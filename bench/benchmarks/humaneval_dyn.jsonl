{"task_id": "HumanEval/0-1", "raw_problem": "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"", "raw_solution": "```python\n\n\n    sorted_numbers = sorted(numbers)\n    for i in range(len(sorted_numbers) - 1):\n        if sorted_numbers[i + 1] - sorted_numbers[i] < threshold:\n            return True\n    return False\n\n\n```", "raw_test_input": ["assert has_close_elements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == True","assert has_close_elements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == False","assert has_close_elements([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == True","assert has_close_elements([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == False","assert has_close_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == True","assert has_close_elements([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == True","assert has_close_elements([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == False"], "new_problem": "In a financial analysis system, you are given multiple datasets representing daily stock price changes for different companies. You need to determine if any two daily changes in each dataset are closer to each other than a given threshold. This can help identify potential anomalies or patterns in stock price movements. Implement a function that takes a list of datasets and a threshold, and returns a list of booleans indicating whether each dataset contains close elements.", "new_solution": "from typing import List\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    sorted_numbers = sorted(numbers)\n    for i in range(len(sorted_numbers) - 1):\n        if sorted_numbers[i + 1] - sorted_numbers[i] < threshold:\n            return True\n    return False\n\ndef analyze_stock_changes(datasets: List[List[float]], threshold: float) -> List[bool]:\n    results = []\n    for dataset in datasets:\n        result = has_close_elements(dataset, threshold)\n        results.append(result)\n    return results\n", "input_format": "A list of lists of floats representing multiple datasets and a float threshold.", "output_format": "A list of booleans indicating whether each dataset contains close elements.", "test_input": ["assert analyze_stock_changes([[1.0, 2.0, 3.0], [1.0, 2.8, 3.0, 4.0, 5.0, 2.0]], 0.5) == [False, True]", "assert analyze_stock_changes([[0.1, 0.2, 0.3], [10.0, 10.5, 11.0]], 0.15) == [True, False]", "assert analyze_stock_changes([[5.0, 5.1, 5.2], [1.0, 1.1, 1.2]], 0.05) == [False, False]", "assert analyze_stock_changes([[100.0, 101.0, 102.0], [50.0, 50.5, 51.0]], 1.0) == [False, True]", "assert analyze_stock_changes([[0.01, 0.02, 0.03], [0.1, 0.2, 0.3]], 0.01) == [True, False]"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "HumanEval/0-2", "raw_problem": "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"", "raw_solution": "```python\n\n\n    sorted_numbers = sorted(numbers)\n    for i in range(len(sorted_numbers) - 1):\n        if sorted_numbers[i + 1] - sorted_numbers[i] < threshold:\n            return True\n    return False\n\n\n```", "raw_test_input": ["assert has_close_elements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == True","assert has_close_elements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == False","assert has_close_elements([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == True","assert has_close_elements([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == False","assert has_close_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == True","assert has_close_elements([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == True","assert has_close_elements([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == False"], "new_problem": "Enhance the function `has_close_elements` to support an optional parameter `inclusive` which determines whether the threshold comparison should be inclusive or exclusive. The function should maintain backward compatibility, meaning it should behave as before when the `inclusive` parameter is not provided. If `inclusive` is set to True, the function should return True if any two numbers are closer than or equal to the threshold.", "new_solution": "from typing import List, Optional\n\ndef has_close_elements(numbers: List[float], threshold: float, inclusive: Optional[bool] = False) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold. If inclusive is True, check if any two numbers are closer than or equal to the threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    >>> has_close_elements([1.0, 2.0, 3.0], 1.0, inclusive=True)\n    True\n    \"\"\"\n    sorted_numbers = sorted(numbers)\n    for i in range(len(sorted_numbers) - 1):\n        if inclusive:\n            if sorted_numbers[i + 1] - sorted_numbers[i] <= threshold:\n                return True\n        else:\n            if sorted_numbers[i + 1] - sorted_numbers[i] < threshold:\n                return True\n    return False\n", "input_format": "List[float], float, Optional[bool]", "output_format": "bool", "test_input": ["assert has_close_elements([1.0, 2.0, 3.0], 0.5) == False", "assert has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3) == True", "assert has_close_elements([1.0, 2.0, 3.0], 1.0, inclusive=True) == True", "assert has_close_elements([1.0, 2.0, 3.0], 1.0, inclusive=False) == False", "assert has_close_elements([1.0, 1.5, 2.0], 0.5, inclusive=True) == True"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "HumanEval/0-3", "raw_problem": "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"", "raw_solution": "```python\n\n\n    sorted_numbers = sorted(numbers)\n    for i in range(len(sorted_numbers) - 1):\n        if sorted_numbers[i + 1] - sorted_numbers[i] < threshold:\n            return True\n    return False\n\n\n```", "raw_test_input": ["assert has_close_elements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == True","assert has_close_elements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == False","assert has_close_elements([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == True","assert has_close_elements([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == False","assert has_close_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == True","assert has_close_elements([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == True","assert has_close_elements([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == False"], "new_problem": "Given a list of tuples where each tuple contains a string identifier and a float number, determine if there are any two numbers associated with different identifiers that are closer to each other than a given threshold. The function should return True if such a pair exists, otherwise False. The solution should utilize a dictionary to map identifiers to their respective numbers and handle cases where the same identifier might appear multiple times with different numbers. Additionally, ensure that the solution can handle up to 10,000 entries efficiently.", "new_solution": "from typing import List, Tuple, Dict\n\ndef has_close_elements_with_identifiers(data: List[Tuple[str, float]], threshold: float) -> bool:\n    \"\"\" Check if in given list of tuples, any two numbers associated with different identifiers are closer to each other than the given threshold. \"\"\"\n    identifier_map: Dict[str, List[float]] = {}\n    for identifier, number in data:\n        if identifier not in identifier_map:\n            identifier_map[identifier] = []\n        identifier_map[identifier].append(number)\n    \n    all_numbers = []\n    for numbers in identifier_map.values():\n        all_numbers.extend(numbers)\n    \n    sorted_numbers = sorted(all_numbers)\n    for i in range(len(sorted_numbers) - 1):\n        if sorted_numbers[i + 1] - sorted_numbers[i] < threshold:\n            return True\n    return False\n", "input_format": "List[Tuple[str, float]], float", "output_format": "bool", "test_input": ["assert has_close_elements_with_identifiers([('a', 1.0), ('b', 2.0), ('c', 3.0)], 0.5) == False", "assert has_close_elements_with_identifiers([('a', 1.0), ('b', 2.8), ('c', 3.0), ('d', 4.0), ('e', 5.0), ('f', 2.0)], 0.3) == True", "assert has_close_elements_with_identifiers([('a', 1.0), ('a', 1.1), ('b', 1.2)], 0.15) == True", "assert has_close_elements_with_identifiers([('a', 1.0), ('b', 1.5), ('c', 2.0)], 0.4) == False", "assert has_close_elements_with_identifiers([('a', 1.0), ('b', 1.05), ('c', 1.1)], 0.1) == True"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "HumanEval/0-4", "raw_problem": "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"", "raw_solution": "```python\n\n\n    sorted_numbers = sorted(numbers)\n    for i in range(len(sorted_numbers) - 1):\n        if sorted_numbers[i + 1] - sorted_numbers[i] < threshold:\n            return True\n    return False\n\n\n```", "raw_test_input": ["assert has_close_elements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == True","assert has_close_elements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == False","assert has_close_elements([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == True","assert has_close_elements([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == False","assert has_close_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == True","assert has_close_elements([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == True","assert has_close_elements([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == False"], "new_problem": "Modify the function `has_close_elements` to handle potential errors in a real-world scenario. The function should raise a `ValueError` if the list of numbers is empty, a `TypeError` if the input is not a list of floats, and a `ThresholdError` (a custom exception) if the threshold is negative. Ensure that the function propagates these errors with meaningful messages.", "new_solution": "from typing import List\n\nclass ThresholdError(Exception):\n    pass\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold. Raises errors for invalid inputs.\n    \"\"\"\n    if not isinstance(numbers, list) or not all(isinstance(n, float) for n in numbers):\n        raise TypeError(\"Input must be a list of floats.\")\n    if len(numbers) == 0:\n        raise ValueError(\"The list of numbers cannot be empty.\")\n    if threshold < 0:\n        raise ThresholdError(\"Threshold must be non-negative.\")\n\n    sorted_numbers = sorted(numbers)\n    for i in range(len(sorted_numbers) - 1):\n        if sorted_numbers[i + 1] - sorted_numbers[i] < threshold:\n            return True\n    return False\n", "input_format": "List[float], float", "output_format": "bool", "test_input": ["assert has_close_elements([1.0, 2.0, 3.0], 0.5) == False", "assert has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3) == True", "try:\n    has_close_elements([], 0.5)\nexcept ValueError as e:\n    assert str(e) == \"The list of numbers cannot be empty.\"", "try:\n    has_close_elements([1.0, 2.0, '3.0'], 0.5)\nexcept TypeError as e:\n    assert str(e) == \"Input must be a list of floats.\"", "try:\n    has_close_elements([1.0, 2.0, 3.0], -0.5)\nexcept ThresholdError as e:\n    assert str(e) == \"Threshold must be non-negative.\""], "requirement_type": "PROMPT_ERROR_HANDLING"}
{"task_id": "HumanEval/1-1","raw_problem": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"","raw_solution": "```python\n\n\n    cnt, group, results = 0, \"\", []\n    for ch in paren_string:\n        if ch == \"(\": cnt += 1\n        if ch == \")\": cnt -= 1\n        if ch != \" \": group += ch\n        if cnt == 0:\n            if group != \"\": results.append(group)\n            group = \"\"\n    return results\n\n\n```", "raw_test_input": ["assert separate_paren_groups('(()()) ((())) () ((())()())') == [\n        '(()())', '((()))', '()', '((())()())'\n    ]","assert separate_paren_groups('() (()) ((())) (((())))') == [\n        '()', '(())', '((()))', '(((())))'\n    ]","assert separate_paren_groups('(()(())((())))') == [\n        '(()(())((())))'\n    ]","assert separate_paren_groups('( ) (( )) (( )( ))') == ['()', '(())', '(()())']"],"new_problem": "In a text processing system for a document management application, you are given a string that contains multiple groups of nested parentheses mixed with other text data. Your task is to separate the parenthesis groups from the text data. The parenthesis groups are balanced and not nested within each other. Ignore any spaces in the input string. Return a dictionary with two keys: 'paren_groups', which contains a list of separated parenthesis groups, and 'text_data', which contains a list of non-parenthesis text segments.","new_solution": "from typing import List, Dict\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    cnt, group, results = 0, '', []\n    for ch in paren_string:\n        if ch == '(': \n            cnt += 1\n            group += ch\n        elif ch == ')': \n            cnt -= 1\n            group += ch\n        elif cnt > 0:  # If we're inside parentheses, add character\n            group += ch\n            \n        if cnt == 0:\n            if group != '': \n                results.append(group)\n            group = ''\n    return results\n\ndef process_document_string(doc_string: str) -> Dict[str, List[str]]:\n    # Initialize result dictionary\n    result = {'paren_groups': [], 'text_data': []}\n    \n    # Get all parenthesis groups first\n    paren_groups = separate_paren_groups(doc_string)\n    result['paren_groups'] = paren_groups\n    \n    # Remove all parenthesis groups from the string to get text data\n    text_string = doc_string\n    for group in paren_groups:\n        text_string = text_string.replace(group, ' ')\n    \n    # Split and clean the remaining text\n    result['text_data'] = [word for word in text_string.split() \n                          if word.strip()]\n    \n    return result\n","input_format": "A string containing multiple groups of nested parentheses and additional text data.","output_format": "A dictionary with keys 'paren_groups' and 'text_data', where 'paren_groups' is a list of separated parenthesis groups and 'text_data' is a list of non-parenthesis text segments.","test_input": [ "assert process_document_string('hello (michael) and (ryan) morning') == {'paren_groups': ['(michael)', '(ryan)'], 'text_data': ['hello', 'and', 'morning']}", "assert process_document_string('hello (world) and (good) morning') == {'paren_groups': ['(world)', '(good)'], 'text_data': ['hello', 'and', 'morning']}", "assert process_document_string('(test) (case) (here)') == {'paren_groups': ['(test)', '(case)', '(here)'], 'text_data': []}", "assert process_document_string('just plain text') == {'paren_groups': [], 'text_data': ['just', 'plain', 'text']}", "assert process_document_string('just my text') == {'paren_groups': [], 'text_data': ['just', 'my', 'text']}" ],"requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "HumanEval/1-2", "raw_problem": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"", "raw_solution": "```python\n\n\n    cnt, group, results = 0, \"\", []\n    for ch in paren_string:\n        if ch == \"(\": cnt += 1\n        if ch == \")\": cnt -= 1\n        if ch != \" \": group += ch\n        if cnt == 0:\n            if group != \"\": results.append(group)\n            group = \"\"\n    return results\n\n\n```", "raw_test_input": ["assert separate_paren_groups('(()()) ((())) () ((())()())') == [\n        '(()())', '((()))', '()', '((())()())'\n    ]","assert separate_paren_groups('() (()) ((())) (((())))') == [\n        '()', '(())', '((()))', '(((())))'\n    ]","assert separate_paren_groups('(()(())((())))') == [\n        '(()(())((())))'\n    ]","assert separate_paren_groups('( ) (( )) (( )( ))') == ['()', '(())', '(()())']"], "new_problem": "Enhance the function to separate groups of nested parentheses from a string. The function should maintain backward compatibility but now include an optional parameter `ignore_spaces` which defaults to True. If `ignore_spaces` is set to False, spaces should be preserved in the output groups. The function should still return a list of strings, each representing a separate group of balanced parentheses.", "new_solution": "from typing import List\n\ndef separate_paren_groups(paren_string: str, ignore_spaces: bool = True) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Optionally ignore spaces in the input string based on the `ignore_spaces` parameter.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    >>> separate_paren_groups('( ) (( )) (( )( ))', ignore_spaces=False)\n    ['( )', '(( ))', '(( )( ))']\n    \"\"\"\n    cnt, group, results = 0, \"\", []\n    for ch in paren_string:\n        if ch == \"(\": cnt += 1\n        if ch == \")\": cnt -= 1\n        if ch != \" \" or not ignore_spaces: group += ch\n        if cnt == 0:\n            if group != \"\": results.append(group)\n            group = \"\"\n    return results\n", "input_format": "paren_string: str, ignore_spaces: bool = True", "output_format": "List[str]", "test_input": ["assert separate_paren_groups('( ) (( )) (( )( ))') == ['()', '(())', '(()())']", "assert separate_paren_groups('(( )) (( )) ((( )( )))') == ['(())', '(())', '((()()))']", "assert separate_paren_groups('((()))((()))()') == ['((()))', '((()))', '()']", "assert separate_paren_groups('((()))((()))()', ignore_spaces=False) == ['((()))', '((()))', '()']", "assert separate_paren_groups('()()() ', ignore_spaces=True) == ['()', '()', '()']"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "HumanEval/1-3", "raw_problem": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"", "raw_solution": "```python\n\n\n    cnt, group, results = 0, \"\", []\n    for ch in paren_string:\n        if ch == \"(\": cnt += 1\n        if ch == \")\": cnt -= 1\n        if ch != \" \": group += ch\n        if cnt == 0:\n            if group != \"\": results.append(group)\n            group = \"\"\n    return results\n\n\n```", "raw_test_input": ["assert separate_paren_groups('(()()) ((())) () ((())()())') == [\n        '(()())', '((()))', '()', '((())()())'\n    ]","assert separate_paren_groups('() (()) ((())) (((())))') == [\n        '()', '(())', '((()))', '(((())))'\n    ]","assert separate_paren_groups('(()(())((())))') == [\n        '(()(())((())))'\n    ]","assert separate_paren_groups('( ) (( )) (( )( ))') == ['()', '(())', '(()())']"], "new_problem": "Given a string containing multiple groups of nested parentheses, your task is to separate these groups into a dictionary where each key is the starting index of the group in the original string, and the value is the group itself. Each group is balanced and not nested within each other. Ignore any spaces in the input string. Additionally, ensure that the input string does not contain any invalid characters other than parentheses and spaces.", "new_solution": "from typing import Dict\n\ndef separate_paren_groups(paren_string: str) -> Dict[int, str]:\n    cnt, group, results, start_index = 0, '', {}, None\n    for i, ch in enumerate(paren_string):\n        if ch == '(': \n            if cnt == 0:\n                start_index = i\n            cnt += 1\n        if ch == ')':\n            cnt -= 1\n        if ch != ' ': \n            group += ch\n        if cnt == 0 and group:\n            if start_index is not None:\n                results[start_index] = group\n            group = ''\n            start_index = None\n    return results\n", "input_format": "A string containing multiple groups of nested parentheses, where each group is separated by spaces.", "output_format": "A dictionary where keys are the starting index of each group in the original string and values are the corresponding balanced parentheses group.", "test_input": ["assert separate_paren_groups('() (()) (()())') == {0: '()', 3: '(())', 8: '(()())'}", "assert separate_paren_groups('(()) ()') == {0: '(())', 5: '()'}", "assert separate_paren_groups('() () ()') == {0: '()', 3: '()', 6: '()'}", "assert separate_paren_groups('(((()))) ((()))') == {0: '(((())))', 9: '((()))'}", "assert separate_paren_groups('') == {}"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "HumanEval/1-4", "raw_problem": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"", "raw_solution": "```python\n\n\n    cnt, group, results = 0, \"\", []\n    for ch in paren_string:\n        if ch == \"(\": cnt += 1\n        if ch == \")\": cnt -= 1\n        if ch != \" \": group += ch\n        if cnt == 0:\n            if group != \"\": results.append(group)\n            group = \"\"\n    return results\n\n\n```", "raw_test_input": ["assert separate_paren_groups('(()()) ((())) () ((())()())') == [\n        '(()())', '((()))', '()', '((())()())'\n    ]","assert separate_paren_groups('() (()) ((())) (((())))') == [\n        '()', '(())', '((()))', '(((())))'\n    ]","assert separate_paren_groups('(()(())((())))') == [\n        '(()(())((())))'\n    ]","assert separate_paren_groups('( ) (( )) (( )( ))') == ['()', '(())', '(()())']"], "new_problem": "Extend the function to handle error scenarios where the input string may contain unbalanced parentheses or invalid characters. The function should raise a custom exception with a meaningful error message if the input is invalid. Specifically, handle the following errors: 1. UnbalancedParenthesesError if the parentheses are not balanced. 2. InvalidCharacterError if the string contains characters other than parentheses and spaces. Ensure that the function propagates these errors with clear messages.", "new_solution": "from typing import List\n\nclass UnbalancedParenthesesError(Exception):\n    pass\n\nclass InvalidCharacterError(Exception):\n    pass\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    Raise UnbalancedParenthesesError if the parentheses are not balanced.\n    Raise InvalidCharacterError if the string contains invalid characters.\n    \"\"\"\n    cnt, group, results = 0, \"\", []\n    for ch in paren_string:\n        if ch not in \"() \":\n            raise InvalidCharacterError(f\"Invalid character '{ch}' found in input.\")\n        if ch == \"(\": cnt += 1\n        if ch == \")\": cnt -= 1\n        if cnt < 0:\n            raise UnbalancedParenthesesError(\"Unbalanced parentheses detected.\")\n        if ch != \" \": group += ch\n        if cnt == 0:\n            if group != \"\": results.append(group)\n            group = \"\"\n    if cnt != 0:\n        raise UnbalancedParenthesesError(\"Unbalanced parentheses detected at the end of input.\")\n    return results\n", "input_format": "A string containing multiple groups of nested parentheses.", "output_format": "A list of strings, each representing a separate group of balanced parentheses.", "test_input": ["assert separate_paren_groups('( ) (( )) (( )( ))') == ['()', '(())', '(()())']", "try:\n    separate_paren_groups('( ) (( )) (( )( )')\nexcept UnbalancedParenthesesError as e:\n    assert str(e) == 'Unbalanced parentheses detected at the end of input.'", "try:\n    separate_paren_groups('( ) (( )) (( )( )))')\nexcept UnbalancedParenthesesError as e:\n    assert str(e) == 'Unbalanced parentheses detected.'", "try:\n    separate_paren_groups('( ) (( )) (( )( ))a')\nexcept InvalidCharacterError as e:\n    assert str(e) == \"Invalid character 'a' found in input.\"", "try:\n    separate_paren_groups('( ) (( )) (( )( ))1')\nexcept InvalidCharacterError as e:\n    assert str(e) == \"Invalid character '1' found in input.\""], "requirement_type": "PROMPT_ERROR_HANDLING"}
{"task_id": "HumanEval/2-1", "raw_problem": "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive floating point number, it can be decomposed into\n    and integer part (largest integer smaller than given number) and decimals\n    (leftover part always smaller than 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"", "raw_solution": "```python\n\n\n    return number - int(number)\n\n\n```", "raw_test_input": ["assert truncate_number(3.5) == 0.5","assert abs(truncate_number(1.33) - 0.33) < 1e-6","assert abs(truncate_number(123.456) - 0.456) < 1e-6"], "new_problem": "In a financial application, you need to calculate the total decimal part of a list of transaction amounts. Each transaction amount is a positive floating point number. The task is to sum up all the decimal parts of these transaction amounts. Implement a function `sum_of_decimals(transactions: List[float]) -> float` that uses the `truncate_number` function to achieve this.", "new_solution": "from typing import List, Dict\n\ndef truncate_number(number: float) -> float:\n    \"\"\" Given a positive floating point number, it can be decomposed into\n    and integer part (largest integer smaller than given number) and decimals\n    (leftover part always smaller than 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\n    return number - int(number)\n\n\ndef sum_of_decimals(transactions: List[float]) -> float:\n    \"\"\" Calculate the sum of the decimal parts of a list of transaction amounts. \"\"\"\n    total_decimal = 0.0\n    for transaction in transactions:\n        total_decimal += truncate_number(transaction)\n    return total_decimal\n", "input_format": "List[float]", "output_format": "float", "test_input":[ "assert abs(sum_of_decimals([3.5, 2.75, 4.1]) - 1.35) < 1e-10", "assert abs(sum_of_decimals([1.99, 2.01, 3.5]) - 1.5) < 1e-10", "assert abs(sum_of_decimals([0.0, 0.0, 0.0]) - 0.0) < 1e-10", "assert abs(sum_of_decimals([10.5, 20.25, 30.75]) - 1.5) < 1e-10", "assert abs(sum_of_decimals([100.99, 200.01, 300.5]) - 1.5) < 1e-10" ], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "HumanEval/2-2", "raw_problem": "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive floating point number, it can be decomposed into\n    and integer part (largest integer smaller than given number) and decimals\n    (leftover part always smaller than 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"", "raw_solution": "```python\n\n\n    return number - int(number)\n\n\n```", "raw_test_input": ["assert truncate_number(3.5) == 0.5","assert abs(truncate_number(1.33) - 0.33) < 1e-6","assert abs(truncate_number(123.456) - 0.456) < 1e-6"], "new_problem": "Enhance the function `truncate_number` to not only return the decimal part of a given positive floating point number but also optionally return the integer part. The function should maintain backward compatibility by defaulting to return the decimal part. Add an optional parameter `return_type` which can be either 'decimal' or 'integer'. If 'decimal' is specified, return the decimal part; if 'integer' is specified, return the integer part.", "new_solution": "from typing import List, Dict\n\ndef truncate_number(number: float, return_type: str = 'decimal') -> float:\n    \"\"\" Given a positive floating point number, it can be decomposed into\n    an integer part (largest integer smaller than given number) and decimals\n    (leftover part always smaller than 1).\n\n    Return the specified part of the number based on the return_type.\n    If return_type is 'decimal', return the decimal part.\n    If return_type is 'integer', return the integer part.\n    >>> truncate_number(3.5)\n    0.5\n    >>> truncate_number(3.5, 'integer')\n    3.0\n    \"\"\"\n    if return_type == 'integer':\n        return float(int(number))\n    return number - int(number)", "input_format": "truncate_number(number: float, return_type: str = 'decimal') -> float", "output_format": "float", "test_input": ["assert truncate_number(3.5) == 0.5", "assert truncate_number(3.5, 'integer') == 3.0", "assert truncate_number(1.999, 'integer') == 1.0", "assert truncate_number(7.9, 'integer') == 7.0", "assert truncate_number(0.0) == 0.0"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "HumanEval/2-3", "raw_problem": "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive floating point number, it can be decomposed into\n    and integer part (largest integer smaller than given number) and decimals\n    (leftover part always smaller than 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"", "raw_solution": "```python\n\n\n    return number - int(number)\n\n\n```", "raw_test_input": ["assert truncate_number(3.5) == 0.5","assert abs(truncate_number(1.33) - 0.33) < 1e-6","assert abs(truncate_number(123.456) - 0.456) < 1e-6"], "new_problem": "Given a list of positive floating point numbers, return a dictionary where each key is the original number and the value is its decimal part. The function should handle lists with up to 1000 elements efficiently.", "new_solution": "from typing import List, Dict\n\ndef truncate_number(number: float) -> float:\n return number - int(number)\n\ndef truncate_numbers(numbers: List[float]) -> Dict[float, float]:\n # Use rounded strings as keys for precision consistency\n return {round(number, 6): round(truncate_number(number), 6) for number in numbers}", "input_format": "List[float]", "output_format": "Dict[float, float]", "test_input": ["assert truncate_numbers([3.5, 4.2, 5.9]) == {3.5: 0.5, 4.2: 0.2, 5.9: 0.9}", "assert truncate_numbers([1.1, 2.2, 3.3, 4.4, 5.5]) == {1.1: 0.1, 2.2: 0.2, 3.3: 0.3, 4.4: 0.4, 5.5: 0.5}", "assert truncate_numbers([0.0, 1.0, 2.0]) == {0.0: 0.0, 1.0: 0.0, 2.0: 0.0}", "assert truncate_numbers([9.99, 8.88, 7.77]) == {9.99: 0.99, 8.88: 0.88, 7.77: 0.77}", "assert truncate_numbers([10.5, 20.25, 30.75]) == {10.5: 0.5, 20.25: 0.25, 30.75: 0.75}"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "HumanEval/2-4", "raw_problem": "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive floating point number, it can be decomposed into\n    and integer part (largest integer smaller than given number) and decimals\n    (leftover part always smaller than 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"", "raw_solution": "```python\n\n\n    return number - int(number)\n\n\n```", "raw_test_input": ["assert truncate_number(3.5) == 0.5","assert abs(truncate_number(1.33) - 0.33) < 1e-6","assert abs(truncate_number(123.456) - 0.456) < 1e-6"], "new_problem": "Create a function `safe_truncate_number` that takes a floating point number and returns its decimal part. The function should handle the following errors: 1) If the input is not a float, raise a `TypeError` with a message 'Input must be a float'. 2) If the input is negative, raise a `ValueError` with a message 'Input must be a positive float'. 3) If the input is NaN or infinity, raise a `ValueError` with a message 'Input must be a finite number'. Implement error propagation by catching these exceptions and re-raising them with additional context.", "new_solution": "class TruncateNumberError(Exception):\n    pass\n\nclass InputTypeError(TruncateNumberError, TypeError):\n    pass\n\nclass InputValueError(TruncateNumberError, ValueError):\n    pass\n\ndef safe_truncate_number(number: float) -> float:\n    \"\"\"\n    Given a positive floating point number, return the decimal part of the number.\n    Handle errors for non-float inputs, negative numbers, and non-finite numbers.\n    \"\"\"\n    try:\n        if not isinstance(number, float):\n            raise InputTypeError('Input must be a float')\n        if number < 0:\n            raise InputValueError('Input must be a positive float')\n        if not (number < float('inf') and number > float('-inf')):\n            raise InputValueError('Input must be a finite number')\n        return number - int(number)\n    except (InputTypeError, InputValueError) as e:\n        raise TruncateNumberError(f'Error in safe_truncate_number: {str(e)}') from e", "input_format": "float", "output_format": "float", "test_input": ["assert safe_truncate_number(3.5) == 0.5", "try:\n    safe_truncate_number('3.5')\nexcept TruncateNumberError as e:\n    assert str(e) == 'Error in safe_truncate_number: Input must be a float'", "try:\n    safe_truncate_number(-3.5)\nexcept TruncateNumberError as e:\n    assert str(e) == 'Error in safe_truncate_number: Input must be a positive float'", "try:\n    safe_truncate_number(float('nan'))\nexcept TruncateNumberError as e:\n    assert str(e) == 'Error in safe_truncate_number: Input must be a finite number'", "try:\n    safe_truncate_number(float('inf'))\nexcept TruncateNumberError as e:\n    assert str(e) == 'Error in safe_truncate_number: Input must be a finite number'"], "requirement_type": "PROMPT_ERROR_HANDLING"}
{"task_id": "HumanEval/3-1", "raw_problem": "from typing import List\n\n\ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" You're given a list of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return True. Otherwise it should return False.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"", "raw_solution": "```python\n\n    account = 0\n    for operation in operations:\n        account += operation\n        if account < 0:\n            return True\n    return False\n\n\n```", "raw_test_input": ["assert below_zero([]) == False","assert below_zero([1, 2, -3, 1, 2, -3]) == False","assert below_zero([1, 2, -4, 5, 6]) == True","assert below_zero([1, -1, 2, -2, 5, -5, 4, -4]) == False","assert below_zero([1, -1, 2, -2, 5, -5, 4, -5]) == True","assert below_zero([1, -2, 2, -2, 5, -5, 4, -4]) == True"], "new_problem": "You are managing a financial system that tracks multiple users' bank accounts. Each user has a list of deposit and withdrawal operations. Your task is to determine for each user if their account balance ever falls below zero. Use the 'below_zero' function to check each user's operations and return a dictionary where each key is a user ID and the value is a boolean indicating if the user's account ever went below zero.", "new_solution": "from typing import List, Tuple, Dict\n\ndef below_zero(operations: List[int]) -> bool:\n    account = 0\n    for operation in operations:\n        account += operation\n        if account < 0:\n            return True\n    return False\n\ndef check_multiple_users(accounts: List[Tuple[str, List[int]]]) -> Dict[str, bool]:\n    result = {}\n    for user_id, operations in accounts:\n        result[user_id] = below_zero(operations)\n    return result\n", "input_format": "List[Tuple[str, List[int]]], where each tuple contains a user ID and a list of operations for that user's account.", "output_format": "Dict[str, bool], where each key is a user ID and the value is a boolean indicating if the user's account ever went below zero.", "test_input": ["assert check_multiple_users([('user1', [1, 2, 3]), ('user2', [1, 2, -4, 5])]) == {'user1': False, 'user2': True}", "assert check_multiple_users([('user1', [-1, 1, -1]), ('user2', [0, 0, 0])]) == {'user1': True, 'user2': False}", "assert check_multiple_users([('user1', [10, -5, -5]), ('user2', [5, -10, 5])]) == {'user1': False, 'user2': True}", "assert check_multiple_users([('user1', [0, 0, 0]), ('user2', [-1, -1, -1])]) == {'user1': False, 'user2': True}", "assert check_multiple_users([('user1', [5, 5, 5]), ('user2', [5, -5, 5, -5, 5])]) == {'user1': False, 'user2': False}"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "HumanEval/3-2", "raw_problem": "from typing import List\n\n\ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" You're given a list of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return True. Otherwise it should return False.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"", "raw_solution": "```python\n\n    account = 0\n    for operation in operations:\n        account += operation\n        if account < 0:\n            return True\n    return False\n\n\n```", "raw_test_input": ["assert below_zero([]) == False","assert below_zero([1, 2, -3, 1, 2, -3]) == False","assert below_zero([1, 2, -4, 5, 6]) == True","assert below_zero([1, -1, 2, -2, 5, -5, 4, -4]) == False","assert below_zero([1, -1, 2, -2, 5, -5, 4, -5]) == True","assert below_zero([1, -2, 2, -2, 5, -5, 4, -4]) == True"], "new_problem": "You're given a list of deposit and withdrawal operations on a bank account that starts with zero balance. Your task is to detect if at any point the balance of the account falls below zero, and at that point, the function should return True. Otherwise, it should return False. Additionally, the function should accept an optional parameter 'initial_balance' which allows setting a starting balance for the account. If 'initial_balance' is not provided, it should default to zero. The function must maintain backward compatibility with the original implementation.", "new_solution": "from typing import List, Optional\n\ndef below_zero(operations: List[int], initial_balance: Optional[int] = 0) -> bool:\n    account = initial_balance\n    for operation in operations:\n        account += operation\n        if account < 0:\n            return True\n    return False", "input_format": "List[int], Optional[int]", "output_format": "bool", "test_input": ["assert below_zero([1, 2, 3]) == False", "assert below_zero([1, 2, -4, 5]) == True", "assert below_zero([1, 2, -3, 1], initial_balance=1) == False", "assert below_zero([-1, -2, -3], initial_balance=5) == True", "assert below_zero([], initial_balance=0) == False"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "HumanEval/3-3", "raw_problem": "from typing import List\n\n\ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" You're given a list of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return True. Otherwise it should return False.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"", "raw_solution": "```python\n\n    account = 0\n    for operation in operations:\n        account += operation\n        if account < 0:\n            return True\n    return False\n\n\n```", "raw_test_input": ["assert below_zero([]) == False","assert below_zero([1, 2, -3, 1, 2, -3]) == False","assert below_zero([1, 2, -4, 5, 6]) == True","assert below_zero([1, -1, 2, -2, 5, -5, 4, -4]) == False","assert below_zero([1, -1, 2, -2, 5, -5, 4, -5]) == True","assert below_zero([1, -2, 2, -2, 5, -5, 4, -4]) == True"], "new_problem": "You are given a list of tuples representing operations on a bank account. Each tuple contains a string indicating the type of operation ('deposit' or 'withdrawal') and an integer representing the amount. The account starts with a zero balance. Your task is to detect if at any point the balance of the account falls below zero, and at that point, the function should return True. Otherwise, it should return False. Additionally, you must keep track of the number of operations performed and return True if the balance falls below zero within the first 10 operations.", "new_solution": "from typing import List, Tuple\n\ndef below_zero(operations: List[Tuple[str, int]]) -> bool:\n    account = 0\n    operation_count = 0\n    for operation_type, amount in operations:\n        if operation_type == 'deposit':\n            account += amount\n        elif operation_type == 'withdrawal':\n            account -= amount\n        operation_count += 1\n        if account < 0 and operation_count <= 10:\n            return True\n    return False", "input_format": "List[Tuple[str, int]]", "output_format": "bool", "test_input": ["assert below_zero([('deposit', 1), ('deposit', 2), ('deposit', 3)]) == False", "assert below_zero([('deposit', 1), ('withdrawal', 4), ('deposit', 5)]) == True", "assert below_zero([('withdrawal', 1), ('deposit', 1), ('withdrawal', 1), ('deposit', 1), ('withdrawal', 1), ('deposit', 1), ('withdrawal', 1), ('deposit', 1), ('withdrawal', 1), ('deposit', 1), ('withdrawal', 1)]) == True", "assert below_zero([('deposit', 10), ('withdrawal', 5), ('withdrawal', 5), ('deposit', 5), ('withdrawal', 5)]) == False", "assert below_zero([('withdrawal', 10), ('deposit', 5), ('withdrawal', 5), ('deposit', 5), ('withdrawal', 5)]) == True"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "HumanEval/3-4", "raw_problem": "from typing import List\n\n\ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" You're given a list of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return True. Otherwise it should return False.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"", "raw_solution": "```python\n\n    account = 0\n    for operation in operations:\n        account += operation\n        if account < 0:\n            return True\n    return False\n\n\n```", "raw_test_input": ["assert below_zero([]) == False","assert below_zero([1, 2, -3, 1, 2, -3]) == False","assert below_zero([1, 2, -4, 5, 6]) == True","assert below_zero([1, -1, 2, -2, 5, -5, 4, -4]) == False","assert below_zero([1, -1, 2, -2, 5, -5, 4, -5]) == True","assert below_zero([1, -2, 2, -2, 5, -5, 4, -4]) == True"], "new_problem": "You are given a list of deposit and withdrawal operations on a bank account that starts with a zero balance. Each operation is represented as an integer, where positive numbers are deposits and negative numbers are withdrawals. Your task is to detect if at any point the balance of the account falls below zero, and at that point, the function should return True. Otherwise, it should return False. Additionally, you must handle the following errors: \n1. If any operation is not an integer, raise a ValueError with a message 'Invalid operation type'. \n2. If the operations list is empty, raise a ValueError with a message 'No operations provided'. \n3. If the operations list is None, raise a TypeError with a message 'Operations list is None'. \nImplement error handling to manage these scenarios and ensure the function propagates meaningful error messages.", "new_solution": "from typing import List, Union\n\nclass BankAccountError(Exception):\n    pass\n\nclass InvalidOperationTypeError(BankAccountError):\n    pass\n\nclass NoOperationsError(BankAccountError):\n    pass\n\ndef below_zero(operations: List[Union[int, str]]) -> bool:\n    if operations is None:\n        raise TypeError('Operations list is None')\n    if not operations:\n        raise NoOperationsError('No operations provided')\n    \n    account = 0\n    for operation in operations:\n        if not isinstance(operation, int):\n            raise InvalidOperationTypeError('Invalid operation type')\n        account += operation\n        if account < 0:\n            return True\n    return False", "input_format": "List[Union[int, str]]", "output_format": "bool", "test_input": ["assert below_zero([1, 2, 3]) == False", "assert below_zero([1, 2, -4, 5]) == True", "try:\n    below_zero(['a', 2, 3])\nexcept InvalidOperationTypeError as e:\n    assert str(e) == 'Invalid operation type'", "try:\n    below_zero([])\nexcept NoOperationsError as e:\n    assert str(e) == 'No operations provided'", "try:\n    below_zero(None)\nexcept TypeError as e:\n    assert str(e) == 'Operations list is None'"], "requirement_type": "PROMPT_ERROR_HANDLING"}
{"task_id": "HumanEval/4-1", "raw_problem": "from typing import List\n\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"", "raw_solution": "```python\n\n    mean = sum(numbers) / len(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)\n\n\n```", "raw_test_input": ["assert abs(mean_absolute_deviation([1.0, 2.0, 3.0]) - 2.0/3.0) < 1e-6","assert abs(mean_absolute_deviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6","assert abs(mean_absolute_deviation([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0/5.0) < 1e-6"], "new_problem": "In a retail company, you are tasked with analyzing the sales performance of different stores. Each store has recorded its daily sales over a month. Your task is to calculate the Mean Absolute Deviation (MAD) of daily sales for each store to understand the variability in their sales performance. Use the provided `mean_absolute_deviation` function to compute the MAD for each store's sales data.", "new_solution": "from typing import List, Dict\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = sum(numbers) / len(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)\n\ndef calculate_sales_mad(stores_sales: List[Dict[str, List[float]]]) -> Dict[str, float]:\n    mad_results = {}\n    for store in stores_sales:\n        name = store['name']\n        sales = store['sales']\n        mad_results[name] = mean_absolute_deviation(sales)\n    return mad_results\n", "input_format": "List of dictionaries, each containing a 'name' (str) and 'sales' (List[float])", "output_format": "Dictionary with 'name' as key and 'MAD' (Mean Absolute Deviation) of sales as value", "test_input": ["assert calculate_sales_mad([{'name': 'Store A', 'sales': [100, 150, 200, 250, 300]}, {'name': 'Store B', 'sales': [80, 85, 90, 95, 100]}]) == {'Store A': 60.0, 'Store B': 6.0}", "assert calculate_sales_mad([{'name': 'Store C', 'sales': [200, 200, 200, 200, 200]}]) == {'Store C': 0.0}", "assert calculate_sales_mad([{'name': 'Store D', 'sales': [50, 60, 70, 80, 90]}, {'name': 'Store E', 'sales': [10, 20, 30, 40, 50]}]) == {'Store D': 12.0, 'Store E': 12.0}", "assert calculate_sales_mad([{'name': 'Store F', 'sales': [300, 400, 500, 600, 700]}]) == {'Store F': 120.0}", "assert calculate_sales_mad([{'name': 'Store G', 'sales': [1000, 1000, 1000, 1000, 1000]}]) == {'Store G': 0.0}"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "HumanEval/4-2", "raw_problem": "from typing import List\n\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"", "raw_solution": "```python\n\n    mean = sum(numbers) / len(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)\n\n\n```", "raw_test_input": ["assert abs(mean_absolute_deviation([1.0, 2.0, 3.0]) - 2.0/3.0) < 1e-6","assert abs(mean_absolute_deviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6","assert abs(mean_absolute_deviation([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0/5.0) < 1e-6"], "new_problem": "Enhance the mean_absolute_deviation function to support an optional parameter 'center'. If 'center' is provided, calculate the Mean Absolute Deviation around this center point instead of the mean of the dataset. The function should maintain backward compatibility, meaning if 'center' is not provided, it should default to using the mean of the dataset as the center point.", "new_solution": "from typing import List, Optional\n\ndef mean_absolute_deviation(numbers: List[float], center: Optional[float] = None) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around a center point. If no center is provided, use the mean of the dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint:\n    MAD = average | x - center |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0], center=2.5)\n    1.0\n    \"\"\"\n    if center is None:\n        center = sum(numbers) / len(numbers)\n    return sum(abs(x - center) for x in numbers) / len(numbers)\n", "input_format": "List[float], Optional[float]", "output_format": "float", "test_input": ["assert mean_absolute_deviation([1.0, 2.0, 3.0, 4.0]) == 1.0", "assert mean_absolute_deviation([1.0, 2.0, 3.0, 4.0], center=2.5) == 1.0", "assert mean_absolute_deviation([1.0, 3.0, 5.0, 7.0], center=3.0) == 2.0", "assert mean_absolute_deviation([10.0, 20.0, 30.0, 40.0]) == 10.0", "assert mean_absolute_deviation([10.0, 20.0, 30.0, 40.0], center=25.0) == 10.0"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "HumanEval/4-3", "raw_problem": "from typing import List\n\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"", "raw_solution": "```python\n\n    mean = sum(numbers) / len(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)\n\n\n```", "raw_test_input": ["assert abs(mean_absolute_deviation([1.0, 2.0, 3.0]) - 2.0/3.0) < 1e-6","assert abs(mean_absolute_deviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6","assert abs(mean_absolute_deviation([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0/5.0) < 1e-6"], "new_problem": "Given a dictionary where each key is a category and the value is a list of numbers representing data points in that category, calculate the Mean Absolute Deviation (MAD) for each category. The result should be a dictionary where each key is the category and the value is the MAD for that category. Additionally, ensure that each category has at least 3 data points; otherwise, return 'NaN' for that category.", "new_solution": "from typing import Dict, List, Union\n\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = sum(numbers) / len(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)\n\n\ndef category_mad(data: Dict[str, List[float]]) -> Dict[str, Union[float, str]]:\n    result = {}\n    for category, numbers in data.items():\n        if len(numbers) < 3:\n            result[category] = 'NaN'\n        else:\n            result[category] = mean_absolute_deviation(numbers)\n    return result\n", "input_format": "Dict[str, List[float]]", "output_format": "Dict[str, float]", "test_input": ["assert category_mad({'A': [1.0, 2.0, 3.0, 4.0], 'B': [5.0, 5.0, 5.0], 'C': [1.0, 2.0]}) == {'A': 1.0, 'B': 0.0, 'C': 'NaN'}", "assert category_mad({'X': [10.0, 20.0, 30.0], 'Y': [15.0, 15.0, 15.0], 'Z': [5.0, 10.0, 15.0, 20.0]}) == {'X': 6.666666666666667, 'Y': 0.0, 'Z': 5.0}", "assert category_mad({'P': [1.0, 1.0, 1.0], 'Q': [2.0, 3.0, 4.0, 5.0], 'R': [0.0, 0.0]}) == {'P': 0.0, 'Q': 1.0, 'R': 'NaN'}", "assert category_mad({'D': [1.0, 2.0, 3.0], 'E': [4.0, 5.0, 6.0, 7.0], 'F': [8.0, 9.0]}) == {'D': 0.6666666666666666, 'E': 1.0, 'F': 'NaN'}", "assert category_mad({'G': [1.0, 2.0, 3.0, 4.0, 5.0], 'H': [10.0, 20.0, 30.0], 'I': [5.0, 5.0, 5.0, 5.0]}) == {'G': 1.2, 'H': 6.666666666666667, 'I': 0.0}"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "HumanEval/4-4", "raw_problem": "from typing import List\n\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"", "raw_solution": "```python\n\n    mean = sum(numbers) / len(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)\n\n\n```", "raw_test_input": ["assert abs(mean_absolute_deviation([1.0, 2.0, 3.0]) - 2.0/3.0) < 1e-6","assert abs(mean_absolute_deviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6","assert abs(mean_absolute_deviation([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0/5.0) < 1e-6"], "new_problem": "Modify the function `mean_absolute_deviation` to handle potential errors that could occur in a real-world scenario. Specifically, handle the following errors: 1) Empty list input, which should raise a `ValueError` with a message 'Input list cannot be empty.' 2) Non-numeric values in the list, which should raise a `TypeError` with a message 'All elements must be numbers.' 3) Propagate any unexpected exceptions with a custom error message 'An unexpected error occurred: {error}'. Ensure that the function maintains type hints and returns the mean absolute deviation for valid inputs.", "new_solution": "```python\nfrom typing import List\n\nclass MeanAbsoluteDeviationError(Exception):\n    pass\n\nclass EmptyListError(MeanAbsoluteDeviationError):\n    pass\n\nclass NonNumericValueError(MeanAbsoluteDeviationError):\n    pass\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \"\"\"\n    try:\n        if not numbers:\n            raise EmptyListError('Input list cannot be empty.')\n        if not all(isinstance(x, (int, float)) for x in numbers):\n            raise NonNumericValueError('All elements must be numbers.')\n        mean = sum(numbers) / len(numbers)\n        return sum(abs(x - mean) for x in numbers) / len(numbers)\n    except MeanAbsoluteDeviationError as e:\n        raise e\n    except Exception as e:\n        raise MeanAbsoluteDeviationError(f'An unexpected error occurred: {e}')\n```", "input_format": "List[float]", "output_format": "float", "test_input": ["assert mean_absolute_deviation([1.0, 2.0, 3.0, 4.0]) == 1.0", "try:\n    mean_absolute_deviation([])\nexcept EmptyListError as e:\n    assert str(e) == 'Input list cannot be empty.'", "try:\n    mean_absolute_deviation([1.0, 'a', 3.0])\nexcept NonNumericValueError as e:\n    assert str(e) == 'All elements must be numbers.'", "try:\n    mean_absolute_deviation([1.0, None, 3.0])\nexcept NonNumericValueError as e:\n    assert str(e) == 'All elements must be numbers.'", "try:\n    mean_absolute_deviation([1.0, 2.0, 3.0, 4.0, float('nan')])\nexcept NonNumericValueError as e:\n    assert str(e) == 'All elements must be numbers.'"], "requirement_type": "PROMPT_ERROR_HANDLING"}
{"task_id": "HumanEval/6-1", "raw_problem": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"", "raw_solution": "```python\n\n    \n    def count_depth(s: str) -> int:\n        max_depth, cnt = 0, 0\n        for ch in s:\n            if ch == \"(\": cnt += 1\n            if ch == \")\": cnt -= 1\n            max_depth = max(max_depth, cnt)\n        return max_depth\n    \n    return [count_depth(s) for s in paren_string.split(\" \") if s != \"\"]\n\n\n```", "raw_test_input": ["assert parse_nested_parens('(()()) ((())) () ((())()())') == [2, 3, 1, 3]","assert parse_nested_parens('() (()) ((())) (((())))') == [1, 2, 3, 4]","assert parse_nested_parens('(()(())((())))') == [4]"], "new_problem": "In a system that processes multiple tasks, each task is represented by a unique identifier followed by a sequence of nested parentheses. The task is to determine the deepest level of nesting for each task and return a dictionary mapping each task identifier to its corresponding nesting depth. This can be useful in scenarios where the complexity of tasks is represented by the nesting of operations, such as in a workflow management system.", "new_solution": "from typing import List, Dict\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    def count_depth(s: str) -> int:\n        max_depth, cnt = 0, 0\n        for ch in s:\n            if ch == '(': cnt += 1\n            if ch == ')': cnt -= 1\n            max_depth = max(max_depth, cnt)\n        return max_depth\n    return [count_depth(s) for s in paren_string.split(' ') if s != '']\n\ndef process_tasks(task_list: List[str]) -> Dict[str, int]:\n    result = {}\n    for task in task_list:\n        identifier, paren_string = task.split(': ')\n        depth = parse_nested_parens(paren_string)[0]\n        result[identifier] = depth\n    return result\n", "input_format": "A list of strings, where each string represents a sequence of nested parentheses and a corresponding identifier separated by a colon. Example: ['id1: (()())', 'id2: ((()))', 'id3: ()', 'id4: ((())()())']", "output_format": "A dictionary where each key is the identifier and the value is the deepest level of nesting of parentheses for that identifier. Example: {'id1': 2, 'id2': 3, 'id3': 1, 'id4': 3}", "test_input": ["assert process_tasks(['id1: (()())', 'id2: ((()))', 'id3: ()', 'id4: ((())()())']) == {'id1': 2, 'id2': 3, 'id3': 1, 'id4': 3}", "assert process_tasks(['task1: (())', 'task2: (((())))', 'task3: ()', 'task4: (()(()))']) == {'task1': 2, 'task2': 4, 'task3': 1, 'task4': 3}", "assert process_tasks(['a: ()', 'b: (())', 'c: ((()))', 'd: (((())))']) == {'a': 1, 'b': 2, 'c': 3, 'd': 4}", "assert process_tasks(['x: ()', 'y: ()()', 'z: (()())']) == {'x': 1, 'y': 1, 'z': 2}", "assert process_tasks(['job1: ((()))', 'job2: ()', 'job3: (())', 'job4: (()(()))']) == {'job1': 3, 'job2': 1, 'job3': 2, 'job4': 3}"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "HumanEval/6-2", "raw_problem": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"", "raw_solution": "```python\n\n    \n    def count_depth(s: str) -> int:\n        max_depth, cnt = 0, 0\n        for ch in s:\n            if ch == \"(\": cnt += 1\n            if ch == \")\": cnt -= 1\n            max_depth = max(max_depth, cnt)\n        return max_depth\n    \n    return [count_depth(s) for s in paren_string.split(\" \") if s != \"\"]\n\n\n```", "raw_test_input": ["assert parse_nested_parens('(()()) ((())) () ((())()())') == [2, 3, 1, 3]","assert parse_nested_parens('() (()) ((())) (((())))') == [1, 2, 3, 4]","assert parse_nested_parens('(()(())((())))') == [4]"], "new_problem": "Enhance the `parse_nested_parens` function to optionally include empty groups in the output. The function should maintain backward compatibility, meaning it should work as before if the new parameter is not provided. The new optional parameter `include_empty` should be a boolean that defaults to `False`. If `include_empty` is `True`, the function should return a depth of 0 for any empty groups.", "new_solution": "from typing import List, Optional\n\ndef parse_nested_parens(paren_string: str, include_empty: Optional[bool] = False) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    If `include_empty` is True, include empty groups with a depth of 0.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    def count_depth(s: str) -> int:\n        max_depth, cnt = 0, 0\n        for ch in s:\n            if ch == \"(\": cnt += 1\n            if ch == \")\": cnt -= 1\n            max_depth = max(max_depth, cnt)\n        return max_depth\n    \n    if paren_string.isspace():\n        groups = paren_string.split(\" \")[1:]\n    else:\n        groups = paren_string.split(\" \")\n    if include_empty:\n        return [count_depth(s) for s in groups]\n    else:\n        return [count_depth(s) for s in groups if s != \"\"]\n", "input_format": "A string of nested parentheses groups separated by spaces, with an optional boolean parameter to include empty groups.", "output_format": "A list of integers representing the deepest level of nesting for each group.", "test_input": ["assert parse_nested_parens('(()()) ((())) () ((())()())') == [2, 3, 1, 3]", "assert parse_nested_parens('(()()) ((())) () ((())()())', include_empty=True) == [2, 3, 1, 3]", "assert parse_nested_parens('(()()) ((())) () ((())()()) ', include_empty=True) == [2, 3, 1, 3, 0]", "assert parse_nested_parens('(()()) ((())) () ((())()()) ', include_empty=False) == [2, 3, 1, 3]", "assert parse_nested_parens(' ', include_empty=True) == [0]"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "HumanEval/6-3", "raw_problem": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"", "raw_solution": "```python\n\n    \n    def count_depth(s: str) -> int:\n        max_depth, cnt = 0, 0\n        for ch in s:\n            if ch == \"(\": cnt += 1\n            if ch == \")\": cnt -= 1\n            max_depth = max(max_depth, cnt)\n        return max_depth\n    \n    return [count_depth(s) for s in paren_string.split(\" \") if s != \"\"]\n\n\n```", "raw_test_input": ["assert parse_nested_parens('(()()) ((())) () ((())()())') == [2, 3, 1, 3]","assert parse_nested_parens('() (()) ((())) (((())))') == [1, 2, 3, 4]","assert parse_nested_parens('(()(())((())))') == [4]"], "new_problem": "Given a dictionary where each key is a unique identifier for a group and each value is a string representing nested parentheses, determine the deepest level of nesting for each group. The solution should use a dictionary to store the results, and the function should handle cases where the input strings may contain invalid parentheses sequences. Additionally, the function should return -1 for any group with an invalid sequence.", "new_solution": "from typing import Dict\n\ndef parse_nested_parens_dict(paren_dict: Dict[str, str]) -> Dict[str, int]:\n    def count_depth(s: str) -> int:\n        max_depth, cnt = 0, 0\n        for ch in s:\n            if ch == \"(\": cnt += 1\n            if ch == \")\": cnt -= 1\n            if cnt < 0:  # More closing than opening\n                return -1\n            max_depth = max(max_depth, cnt)\n        return max_depth if cnt == 0 else -1  # Ensure all opened are closed\n    \n    return {key: count_depth(value) for key, value in paren_dict.items()}\n", "input_format": "A dictionary where keys are group identifiers and values are strings of nested parentheses.", "output_format": "A dictionary where keys are the same group identifiers and values are the deepest level of nesting of parentheses.", "test_input": ["assert parse_nested_parens_dict({'group1': '(()())', 'group2': '((()))', 'group3': '()', 'group4': '((())()())'}) == {'group1': 2, 'group2': 3, 'group3': 1, 'group4': 3}", "assert parse_nested_parens_dict({'group1': '(()', 'group2': '())', 'group3': '((()))', 'group4': '()'}) == {'group1': -1, 'group2': -1, 'group3': 3, 'group4': 1}", "assert parse_nested_parens_dict({'group1': '', 'group2': '()', 'group3': '(((())))', 'group4': '(()())'}) == {'group1': 0, 'group2': 1, 'group3': 4, 'group4': 2}", "assert parse_nested_parens_dict({'group1': '((())', 'group2': '(()))', 'group3': '((()))', 'group4': '((())())'}) == {'group1': -1, 'group2': -1, 'group3': 3, 'group4': 3}", "assert parse_nested_parens_dict({'group1': '()', 'group2': '(((())))', 'group3': '(()(()))', 'group4': '((())()())'}) == {'group1': 1, 'group2': 4, 'group3': 3, 'group4': 3}"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "HumanEval/6-4", "raw_problem": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"", "raw_solution": "```python\n\n    \n    def count_depth(s: str) -> int:\n        max_depth, cnt = 0, 0\n        for ch in s:\n            if ch == \"(\": cnt += 1\n            if ch == \")\": cnt -= 1\n            max_depth = max(max_depth, cnt)\n        return max_depth\n    \n    return [count_depth(s) for s in paren_string.split(\" \") if s != \"\"]\n\n\n```", "raw_test_input": ["assert parse_nested_parens('(()()) ((())) () ((())()())') == [2, 3, 1, 3]","assert parse_nested_parens('() (()) ((())) (((())))') == [1, 2, 3, 4]","assert parse_nested_parens('(()(())((())))') == [4]"], "new_problem": "Extend the function `parse_nested_parens` to handle errors in a real-world scenario where the input string might contain invalid characters or mismatched parentheses. The function should raise specific exceptions for these errors: `InvalidCharacterError` if the string contains characters other than '(' or ')', and `MismatchedParenthesesError` if the parentheses are not properly matched. Additionally, handle empty input strings by raising an `EmptyInputError`. Ensure that the function propagates these errors with meaningful messages.", "new_solution": "```python\nfrom typing import List\n\nclass InvalidCharacterError(Exception):\n    pass\n\nclass MismatchedParenthesesError(Exception):\n    pass\n\nclass EmptyInputError(Exception):\n    pass\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    Raises:\n        InvalidCharacterError: If the string contains characters other than '(' or ')'.\n        MismatchedParenthesesError: If the parentheses are not properly matched.\n        EmptyInputError: If the input string is empty.\n    \"\"\"\n    \n    def count_depth(s: str) -> int:\n        max_depth, cnt = 0, 0\n        for ch in s:\n            if ch not in \"()\":\n                raise InvalidCharacterError(f\"Invalid character '{ch}' found.\")\n            if ch == \"(\": cnt += 1\n            if ch == \")\": cnt -= 1\n            if cnt < 0:\n                raise MismatchedParenthesesError(\"Mismatched parentheses detected.\")\n            max_depth = max(max_depth, cnt)\n        if cnt != 0:\n            raise MismatchedParenthesesError(\"Mismatched parentheses detected.\")\n        return max_depth\n    \n    if not paren_string.strip():\n        raise EmptyInputError(\"Input string is empty.\")\n\n    return [count_depth(s) for s in paren_string.split(\" \") if s != \"\"]\n```", "input_format": "A string with multiple groups of nested parentheses separated by spaces.", "output_format": "A list of integers representing the deepest level of nesting for each group.", "test_input": ["assert parse_nested_parens('(()()) ((())) () ((())()())') == [2, 3, 1, 3]", "try:\n    parse_nested_parens('(()()) ((a)) () ((())()())')\nexcept InvalidCharacterError as e:\n    assert str(e) == \"Invalid character 'a' found.\"", "try:\n    parse_nested_parens('(()()) ((()) (()')\nexcept MismatchedParenthesesError as e:\n    assert str(e) == \"Mismatched parentheses detected.\"", "try:\n    parse_nested_parens('')\nexcept EmptyInputError as e:\n    assert str(e) == \"Input string is empty.\"", "try:\n    parse_nested_parens('(()()) (()))) () ((())()())')\nexcept MismatchedParenthesesError as e:\n    assert str(e) == \"Mismatched parentheses detected.\""], "requirement_type": "PROMPT_ERROR_HANDLING"}
{"task_id": "HumanEval/8-1", "raw_problem": "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\"", "raw_solution": "```python\n\n    s, p = 0, 1\n    for number in numbers:\n        s += number\n        p *= number\n    return s, p\n\n\n```", "raw_test_input": ["assert sum_product([]) == (0, 1)","assert sum_product([1, 1, 1]) == (3, 1)","assert sum_product([100, 0]) == (100, 0)","assert sum_product([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)","assert sum_product([10]) == (10, 10)"], "new_problem": "In an e-commerce platform, you have a list of orders where each order is represented as a tuple containing the order ID and a list of item prices. You need to calculate the total sum and product of item prices for each order. Use the original sum_product function to compute these values for each order and return a dictionary where the keys are order IDs and the values are tuples of the sum and product of item prices.", "new_solution": "from typing import List, Tuple, Dict\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    s, p = 0, 1\n    for number in numbers:\n        s += number\n        p *= number\n    return s, p\n\ndef order_summary(orders: List[Tuple[str, List[int]]]) -> Dict[str, Tuple[int, int]]:\n    summary = {}\n    for order_id, prices in orders:\n        summary[order_id] = sum_product(prices)\n    return summary\n", "input_format": "List[Tuple[str, List[int]]]", "output_format": "Dict[str, Tuple[int, int]]", "test_input": ["assert order_summary([]) == {}", "assert order_summary([('order1', [])]) == {'order1': (0, 1)}", "assert order_summary([('order1', [10, 20, 30])]) == {'order1': (60, 6000)}", "assert order_summary([('order1', [1, 2]), ('order2', [3, 4])]) == {'order1': (3, 2), 'order2': (7, 12)}", "assert order_summary([('order1', [5]), ('order2', [2, 3]), ('order3', [1, 1, 1])]) == {'order1': (5, 5), 'order2': (5, 6), 'order3': (3, 1)}"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "HumanEval/8-2", "raw_problem": "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\"", "raw_solution": "```python\n\n    s, p = 0, 1\n    for number in numbers:\n        s += number\n        p *= number\n    return s, p\n\n\n```", "raw_test_input": ["assert sum_product([]) == (0, 1)","assert sum_product([1, 1, 1]) == (3, 1)","assert sum_product([100, 0]) == (100, 0)","assert sum_product([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)","assert sum_product([10]) == (10, 10)"], "new_problem": "Enhance the sum_product function to optionally return the sum and product as absolute values. The function should maintain backward compatibility, meaning it should still work with the original parameters. Add two optional boolean parameters: 'absolute_sum' and 'absolute_product'. If 'absolute_sum' is True, return the absolute value of the sum. If 'absolute_product' is True, return the absolute value of the product. By default, both parameters should be False.", "new_solution": "from typing import List, Tuple, Optional\n\ndef sum_product(numbers: List[int], absolute_sum: Optional[bool] = False, absolute_product: Optional[bool] = False) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Optionally return the absolute values of the sum and product.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    >>> sum_product([-1, -2, -3, -4], absolute_sum=True)\n    (10, 24)\n    >>> sum_product([-1, -2, -3, -4], absolute_product=True)\n    (-10, 24)\n    \"\"\"\n    s, p = 0, 1\n    for number in numbers:\n        s += number\n        p *= number\n    if absolute_sum:\n        s = abs(s)\n    if absolute_product:\n        p = abs(p)\n    return s, p\n", "input_format": "List[int], Optional[bool], Optional[bool]", "output_format": "Tuple[int, int]", "test_input": ["assert sum_product([]) == (0, 1)", "assert sum_product([1, 2, 3, 4]) == (10, 24)", "assert sum_product([-1, -2, -3, -4], absolute_sum=True) == (10, 24)", "assert sum_product([-1, -2, -3, -4], absolute_product=True) == (-10, 24)", "assert sum_product([-1, -2, -3, -4], absolute_sum=True, absolute_product=True) == (10, 24)"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "HumanEval/8-3", "raw_problem": "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\"", "raw_solution": "```python\n\n    s, p = 0, 1\n    for number in numbers:\n        s += number\n        p *= number\n    return s, p\n\n\n```", "raw_test_input": ["assert sum_product([]) == (0, 1)","assert sum_product([1, 1, 1]) == (3, 1)","assert sum_product([100, 0]) == (100, 0)","assert sum_product([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)","assert sum_product([10]) == (10, 10)"], "new_problem": "Given a dictionary where keys are strings representing categories and values are lists of integers, return a dictionary where each key is associated with a tuple consisting of the sum and product of the integers in the corresponding list. The sum of an empty list should be 0, and the product should be 1. Additionally, ensure that the solution can handle at least 1000 categories efficiently.", "new_solution": "from typing import Dict, List, Tuple\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    s, p = 0, 1\n    for number in numbers:\n        s += number\n        p *= number\n    return s, p\n\ndef category_sum_product(data: Dict[str, List[int]]) -> Dict[str, Tuple[int, int]]:\n    result = {}\n    for category, numbers in data.items():\n        result[category] = sum_product(numbers)\n    return result\n", "input_format": "Dict[str, List[int]]", "output_format": "Dict[str, Tuple[int, int]]", "test_input": ["assert category_sum_product({'fruits': [1, 2, 3], 'vegetables': [4, 5]}) == {'fruits': (6, 6), 'vegetables': (9, 20)}", "assert category_sum_product({'empty': []}) == {'empty': (0, 1)}", "assert category_sum_product({'single': [10]}) == {'single': (10, 10)}", "assert category_sum_product({'mixed': [0, 1, 2, 3]}) == {'mixed': (6, 0)}", "assert category_sum_product({'large': [1]*1000}) == {'large': (1000, 1)}"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "HumanEval/8-4", "raw_problem": "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\"", "raw_solution": "```python\n\n    s, p = 0, 1\n    for number in numbers:\n        s += number\n        p *= number\n    return s, p\n\n\n```", "raw_test_input": ["assert sum_product([]) == (0, 1)","assert sum_product([1, 1, 1]) == (3, 1)","assert sum_product([100, 0]) == (100, 0)","assert sum_product([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)","assert sum_product([10]) == (10, 10)"], "new_problem": "Create a function `safe_sum_product` that calculates the sum and product of a list of integers. The function should handle the following errors: 1) Raise a `TypeError` if any element in the list is not an integer. 2) Raise a `ValueError` if the list contains negative numbers, as they are not allowed in this context. 3) Handle potential overflow errors when calculating the product. The function should return a tuple of the sum and product of the list, with an empty list returning (0, 1).", "new_solution": "from typing import List, Tuple\n\nclass InvalidElementError(Exception):\n    pass\n\nclass NegativeNumberError(Exception):\n    pass\n\ndef safe_sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    Raise TypeError if any element is not an integer.\n    Raise ValueError if any element is negative.\n    Handle overflow errors gracefully.\n    \"\"\"\n    s, p = 0, 1\n    for number in numbers:\n        if not isinstance(number, int):\n            raise InvalidElementError(f\"Invalid element detected: {number} is not an integer.\")\n        if number < 0:\n            raise NegativeNumberError(f\"Negative number detected: {number} is not allowed.\")\n        try:\n            s += number\n            p *= number\n        except OverflowError:\n            raise OverflowError(\"Product calculation overflowed.\")\n    return s, p\n", "input_format": "List[int]", "output_format": "Tuple[int, int]", "test_input": ["assert safe_sum_product([]) == (0, 1)", "assert safe_sum_product([1, 2, 3, 4]) == (10, 24)", "try:\n    safe_sum_product([1, 'a', 3])\nexcept InvalidElementError as e:\n    assert str(e) == \"Invalid element detected: a is not an integer.\"", "try:\n    safe_sum_product([1, -2, 3])\nexcept NegativeNumberError as e:\n    assert str(e) == \"Negative number detected: -2 is not allowed.\"", "try:\n    safe_sum_product([10**100, 10**100])\nexcept OverflowError as e:\n    assert str(e) == \"Product calculation overflowed.\""], "requirement_type": "PROMPT_ERROR_HANDLING"}
{"task_id": "HumanEval/11-1", "raw_problem": "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\"", "raw_solution": "```python\n\n\n    return \"\".join(str(int(a[i]) ^ int(b[i])) for i in range(len(a)))\n\n\n```", "raw_test_input": ["assert string_xor('111000', '101010') == '010010'", "assert string_xor('1', '1') == '0'", "assert string_xor('0101', '0000') == '0101'"], "new_problem": "In a secure communication system, messages are encrypted using a binary XOR operation with a secret key. Given a list of encrypted message pairs and a secret key, decrypt each message by applying the XOR operation twice: first to remove the key and then to combine the two messages. Implement a function that takes a list of encrypted message pairs and a secret key, and returns the decrypted messages.", "new_solution": "```python\nfrom typing import List, Tuple\n\ndef string_xor(a: str, b: str) -> str:\n    return \"\".join(str(int(a[i]) ^ int(b[i])) for i in range(len(a)))\n\ndef decrypt_messages(encrypted_pairs: List[Tuple[str, str]], key: str) -> List[str]:\n    decrypted_messages = []\n    for encrypted_a, encrypted_b in encrypted_pairs:\n        # Remove the key from each encrypted message\n        decrypted_a = string_xor(encrypted_a, key)\n        decrypted_b = string_xor(encrypted_b, key)\n        # Combine the two decrypted messages\n        combined_message = string_xor(decrypted_a, decrypted_b)\n        decrypted_messages.append(combined_message)\n    return decrypted_messages\n```", "input_format": "A list of tuples where each tuple contains two binary strings representing encrypted messages and a binary string representing a key.", "output_format": "A list of decrypted messages as binary strings.", "test_input": ["assert decrypt_messages([('110', '101')], '011') == ['011']", "assert decrypt_messages([('111', '000'), ('101', '110')], '010') == ['111', '011']", "assert decrypt_messages([('1010', '0101')], '1111') == ['1111']", "assert decrypt_messages([('1111', '0000'), ('1100', '0011')], '1010') == ['1111', '1111']", "assert decrypt_messages([('1001', '0110')], '1100') == ['1111']"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "HumanEval/11-2", "raw_problem": "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\"", "raw_solution": "```python\n\n\n    return \"\".join(str(int(a[i]) ^ int(b[i])) for i in range(len(a)))\n\n\n```", "raw_test_input": ["assert string_xor('111000', '101010') == '010010'", "assert string_xor('1', '1') == '0'", "assert string_xor('0101', '0000') == '0101'"], "new_problem": "Enhance the `string_xor` function to support an optional parameter `pad`. This parameter, when set to True, should pad the shorter input string with leading zeros to match the length of the longer string before performing the XOR operation. The function should maintain backward compatibility, meaning it should work as before when the `pad` parameter is not provided or set to False.", "new_solution": "```python\ndef string_xor(a: str, b: str, pad: bool = False) -> str:\n    if pad:\n        max_len = max(len(a), len(b))\n        a = a.zfill(max_len)\n        b = b.zfill(max_len)\n    else:\n        min_len = min(len(a), len(b))\n        a = a[-min_len:]\n        b = b[-min_len:]\n    return \"\".join(str(int(a[i]) ^ int(b[i])) for i in range(len(a)))\n```", "input_format": "string_xor(a: str, b: str, pad: bool = False) -> str", "output_format": "A string representing the XOR result of the two input strings, optionally padded with leading zeros to match the length of the longer input string.", "test_input": ["assert string_xor('010', '110') == '100'", "assert string_xor('010', '110', pad=False) == '100'", "assert string_xor('010', '110', pad=True) == '100'", "assert string_xor('01', '110', pad=True) == '111'", "assert string_xor('01', '1', pad=True) == '00'"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "HumanEval/11-3", "raw_problem": "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\"", "raw_solution": "```python\n\n\n    return \"\".join(str(int(a[i]) ^ int(b[i])) for i in range(len(a)))\n\n\n```", "raw_test_input": ["assert string_xor('111000', '101010') == '010010'", "assert string_xor('1', '1') == '0'", "assert string_xor('0101', '0000') == '0101'"], "new_problem": "Given a list of tuples where each tuple contains two binary strings, perform a binary XOR operation on each pair of strings and return a dictionary. The keys of the dictionary should be the original tuples, and the values should be the resulting XOR strings. Ensure that the input strings are of equal length and consist only of '1's and '0's. Additionally, the function should handle up to 1000 pairs efficiently.", "new_solution": "from typing import List, Tuple, Dict\n\ndef string_xor(a: str, b: str) -> str:\n    return \"\".join(str(int(a[i]) ^ int(b[i])) for i in range(len(a)))\n\ndef batch_string_xor(pairs: List[Tuple[str, str]]) -> Dict[Tuple[str, str], str]:\n    result = {}\n    for a, b in pairs:\n        if len(a) != len(b):\n            raise ValueError(\"Strings must be of equal length\")\n        result[(a, b)] = string_xor(a, b)\n    return result", "input_format": "List[Tuple[str, str]]", "output_format": "Dict[Tuple[str, str], str]", "test_input": ["assert batch_string_xor([('010', '110'), ('111', '000')]) == {('010', '110'): '100', ('111', '000'): '111'}", "assert batch_string_xor([('1010', '0101'), ('0000', '1111')]) == {('1010', '0101'): '1111', ('0000', '1111'): '1111'}", "assert batch_string_xor([('1111', '1111'), ('1010', '1010')]) == {('1111', '1111'): '0000', ('1010', '1010'): '0000'}", "assert batch_string_xor([('1100', '0011'), ('1001', '0110')]) == {('1100', '0011'): '1111', ('1001', '0110'): '1111'}", "assert batch_string_xor([('0001', '0001'), ('1110', '1110')]) == {('0001', '0001'): '0000', ('1110', '1110'): '0000'}"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "HumanEval/11-4", "raw_problem": "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\"", "raw_solution": "```python\n\n\n    return \"\".join(str(int(a[i]) ^ int(b[i])) for i in range(len(a)))\n\n\n```", "raw_test_input": ["assert string_xor('111000', '101010') == '010010'", "assert string_xor('1', '1') == '0'", "assert string_xor('0101', '0000') == '0101'"], "new_problem": "Create a function `safe_string_xor(a: str, b: str) -> str` that performs a binary XOR operation on two input strings consisting only of '1's and '0's. The function should handle the following errors: 1) If the strings are not of equal length, raise a `ValueError` with a message 'Input strings must be of equal length'. 2) If the strings contain characters other than '1' or '0', raise a `ValueError` with a message 'Input strings must contain only binary digits'. 3) If either input is not a string, raise a `TypeError` with a message 'Inputs must be strings'. Ensure that the function propagates these errors appropriately.", "new_solution": "def safe_string_xor(a: str, b: str) -> str:\n    if not isinstance(a, str) or not isinstance(b, str):\n        raise TypeError('Inputs must be strings')\n    if len(a) != len(b):\n        raise ValueError('Input strings must be of equal length')\n    if not all(c in '01' for c in a) or not all(c in '01' for c in b):\n        raise ValueError('Input strings must contain only binary digits')\n    return ''.join(str(int(a[i]) ^ int(b[i])) for i in range(len(a)))", "input_format": "Two binary strings of equal length", "output_format": "A binary string representing the XOR result", "test_input": ["assert safe_string_xor('010', '110') == '100'", "try:\n    safe_string_xor('0101', '110')\nexcept ValueError as e:\n    assert str(e) == 'Input strings must be of equal length'", "try:\n    safe_string_xor('010', '11a')\nexcept ValueError as e:\n    assert str(e) == 'Input strings must contain only binary digits'", "try:\n    safe_string_xor(101, '110')\nexcept TypeError as e:\n    assert str(e) == 'Inputs must be strings'", "try:\n    safe_string_xor('010', 110)\nexcept TypeError as e:\n    assert str(e) == 'Inputs must be strings'"], "requirement_type": "PROMPT_ERROR_HANDLING"}
{"task_id": "HumanEval/12-1", "raw_problem": "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\"", "raw_solution": "```python\n\n    if not strings:\n        return None\n\n    maxlen = max(len(x) for x in strings)\n    for s in strings:\n        if len(s) == maxlen:\n            return s\n\n\n```", "raw_test_input": ["assert longest([]) == None", "assert longest(['x', 'y', 'z']) == 'x'", "assert longest(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) == 'zzzz'"], "new_problem": "In an e-commerce platform, you have a list of product categories, and each category has a list of product names. You need to find the longest product name in each category. If a category has no products, return None for that category. Use the 'longest' function to determine the longest product name in each category.", "new_solution": "```python\nfrom typing import List, Optional, Dict\n\ndef longest(strings: List[str]) -> Optional[str]:\n    if not strings:\n        return None\n    maxlen = max(len(x) for x in strings)\n    for s in strings:\n        if len(s) == maxlen:\n            return s\n\ndef longest_product_names(categories: List[str], strings: Dict[str, List[str]]) -> Dict[str, Optional[str]]:\n    result = {}\n    for category in categories:\n        result[category] = longest(strings.get(category, []))\n    return result\n```", "input_format": "A dictionary with keys 'categories' and 'strings'. 'categories' is a list of category names, and 'strings' is a dictionary where each key is a category name and the value is a list of strings associated with that category.", "output_format": "A dictionary with each category name as a key and the longest string in that category as the value. If a category has no strings, the value should be None.", "test_input": ["assert longest_product_names(['electronics', 'clothing'], {'electronics': ['TV', 'Smartphone', 'Laptop'], 'clothing': ['Shirt', 'Jeans']}) == {'electronics': 'Smartphone', 'clothing': 'Shirt'}", "assert longest_product_names(['books', 'furniture'], {'books': ['Novel', 'Encyclopedia'], 'furniture': ['Chair', 'Table', 'Sofa']}) == {'books': 'Encyclopedia', 'furniture': 'Chair'}", "assert longest_product_names(['toys'], {'toys': ['Car', 'Doll', 'Puzzle']}) == {'toys': 'Puzzle'}", "assert longest_product_names(['groceries'], {'groceries': []}) == {'groceries': None}", "assert longest_product_names(['sports', 'outdoors'], {'sports': ['Football', 'Basketball'], 'outdoors': ['Tent', 'Backpack']}) == {'sports': 'Basketball', 'outdoors': 'Backpack'}"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "HumanEval/12-2", "raw_problem": "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\"", "raw_solution": "```python\n\n    if not strings:\n        return None\n\n    maxlen = max(len(x) for x in strings)\n    for s in strings:\n        if len(s) == maxlen:\n            return s\n\n\n```", "raw_test_input": ["assert longest([]) == None", "assert longest(['x', 'y', 'z']) == 'x'", "assert longest(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) == 'zzzz'"], "new_problem": "Enhance the 'longest' function to optionally return the shortest string instead of the longest. The function should maintain backward compatibility by defaulting to returning the longest string. Add a new optional parameter 'find_shortest' which, when set to True, will return the shortest string instead. If multiple strings have the same length, return the first one. Return None if the input list is empty.", "new_solution": "from typing import List, Optional\n\ndef longest(strings: List[str], find_shortest: Optional[bool] = False) -> Optional[str]:\n    if not strings:\n        return None\n\n    if find_shortest:\n        minlen = min(len(x) for x in strings)\n        for s in strings:\n            if len(s) == minlen:\n                return s\n    else:\n        maxlen = max(len(x) for x in strings)\n        for s in strings:\n            if len(s) == maxlen:\n                return s\n", "input_format": "List[str], Optional[bool]", "output_format": "Optional[str]", "test_input": ["assert longest([]) is None", "assert longest(['a', 'b', 'c']) == 'a'", "assert longest(['a', 'bb', 'ccc']) == 'ccc'", "assert longest(['a', 'bb', 'ccc'], find_shortest=True) == 'a'", "assert longest(['aaa', 'bb', 'c'], find_shortest=True) == 'c'"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "HumanEval/12-3", "raw_problem": "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\"", "raw_solution": "```python\n\n    if not strings:\n        return None\n\n    maxlen = max(len(x) for x in strings)\n    for s in strings:\n        if len(s) == maxlen:\n            return s\n\n\n```", "raw_test_input": ["assert longest([]) == None", "assert longest(['x', 'y', 'z']) == 'x'", "assert longest(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) == 'zzzz'"], "new_problem": "Given a dictionary where keys are categories and values are lists of strings, return the longest string across all categories. If there are multiple strings of the same maximum length, return the first one encountered. Return None if all lists are empty.", "new_solution": "from typing import Dict, List, Optional\n\ndef longest_in_categories(categories: Dict[str, List[str]]) -> Optional[str]:\n    longest_string = None\n    max_length = 0\n    for category, strings in categories.items():\n        for s in strings:\n            if len(s) > max_length:\n                longest_string = s\n                max_length = len(s)\n    return longest_string\n", "input_format": "Dict[str, List[str]]", "output_format": "Optional[str]", "test_input": ["assert longest_in_categories({'fruits': ['apple', 'banana'], 'colors': ['red', 'blue']}) == 'banana'", "assert longest_in_categories({'fruits': ['kiwi', 'pear'], 'colors': ['red', 'blue']}) == 'kiwi'", "assert longest_in_categories({'fruits': [], 'colors': []}) is None", "assert longest_in_categories({'fruits': ['apple'], 'colors': ['red', 'blue', 'yellow']}) == 'yellow'", "assert longest_in_categories({'fruits': ['apple', 'banana'], 'colors': ['red', 'blue', 'green']}) == 'banana'"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "HumanEval/12-4", "raw_problem": "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\"", "raw_solution": "```python\n\n    if not strings:\n        return None\n\n    maxlen = max(len(x) for x in strings)\n    for s in strings:\n        if len(s) == maxlen:\n            return s\n\n\n```", "raw_test_input": ["assert longest([]) == None", "assert longest(['x', 'y', 'z']) == 'x'", "assert longest(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) == 'zzzz'"], "new_problem": "Modify the function to handle errors in a real-world scenario where the input list may contain non-string elements. The function should raise a custom exception if any element in the list is not a string. Additionally, handle the case where the input is not a list at all by raising a different custom exception. Ensure that the function propagates these errors with meaningful messages.", "new_solution": "from typing import List, Optional\n\nclass InvalidElementTypeError(Exception):\n    \"\"\"Raised when an element in the list is not a string.\"\"\"\n    pass\n\nclass InvalidInputTypeError(Exception):\n    \"\"\"Raised when the input is not a list.\"\"\"\n    pass\n\ndef longest(strings: List[str]) -> Optional[str]:\n    if not isinstance(strings, list):\n        raise InvalidInputTypeError(\"Input must be a list.\")\n\n    for element in strings:\n        if not isinstance(element, str):\n            raise InvalidElementTypeError(\"All elements in the list must be strings.\")\n\n    if not strings:\n        return None\n\n    maxlen = max(len(x) for x in strings)\n    for s in strings:\n        if len(s) == maxlen:\n            return s\n", "input_format": "List[str]", "output_format": "Optional[str]", "test_input": ["assert longest(['a', 'b', 'c']) == 'a'", "assert longest(['a', 'bb', 'ccc']) == 'ccc'", "assert longest([]) is None", "try:\n    longest(['a', 2, 'c'])\nexcept InvalidElementTypeError as e:\n    assert str(e) == 'All elements in the list must be strings.'", "try:\n    longest('not a list')\nexcept InvalidInputTypeError as e:\n    assert str(e) == 'Input must be a list.'"], "requirement_type": "PROMPT_ERROR_HANDLING"}
{"task_id": "HumanEval/13-1", "raw_problem": "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\"", "raw_solution": "```python\n\n\n    def query_gcd(a: int, b: int) -> int:\n        return a if b == 0 else query_gcd(b, a % b)\n    return query_gcd(a, b)    \n\n\n```", "raw_test_input": ["assert greatest_common_divisor(3, 7) == 1", "assert greatest_common_divisor(10, 15) == 5", "assert greatest_common_divisor(49, 14) == 7", "assert greatest_common_divisor(144, 60) == 12"], "new_problem": "In a logistics company, you are tasked with optimizing the loading of containers. Each container can hold a certain number of items, and you have multiple types of items with different quantities. To maximize efficiency, you need to find the greatest common divisor (GCD) of the quantities of all item types to determine the largest possible uniform batch size that can be loaded into the containers. Write a function that takes a list of tuples, where each tuple contains two integers representing the quantities of two different item types. The function should return the GCD of all these quantities, which represents the largest uniform batch size that can be loaded into the containers.", "new_solution": "```python\nfrom typing import List, Tuple\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    def query_gcd(a: int, b: int) -> int:\n        return a if b == 0 else query_gcd(b, a % b)\n    return query_gcd(a, b)\n\ndef largest_uniform_batch_size(item_quantities: List[Tuple[int, int]]) -> int:\n    if not item_quantities:\n        return 0\n    current_gcd = greatest_common_divisor(item_quantities[0][0], item_quantities[0][1])\n    for a, b in item_quantities[1:]:\n        current_gcd = greatest_common_divisor(current_gcd, greatest_common_divisor(a, b))\n    return current_gcd\n```", "input_format": "List[Tuple[int, int]]", "output_format": "int", "test_input": ["assert largest_uniform_batch_size([(12, 15), (18, 27), (30, 45)]) == 3", "assert largest_uniform_batch_size([(100, 200), (300, 400), (500, 600)]) == 100", "assert largest_uniform_batch_size([(7, 14), (21, 28), (35, 42)]) == 7", "assert largest_uniform_batch_size([(8, 12), (16, 24), (32, 48)]) == 4", "assert largest_uniform_batch_size([(5, 10), (15, 20), (25, 30)]) == 5"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "HumanEval/13-2", "raw_problem": "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\"", "raw_solution": "```python\n\n\n    def query_gcd(a: int, b: int) -> int:\n        return a if b == 0 else query_gcd(b, a % b)\n    return query_gcd(a, b)    \n\n\n```", "raw_test_input": ["assert greatest_common_divisor(3, 7) == 1", "assert greatest_common_divisor(10, 15) == 5", "assert greatest_common_divisor(49, 14) == 7", "assert greatest_common_divisor(144, 60) == 12"], "new_problem": "Enhance the greatest_common_divisor function to include an optional verbose parameter. When verbose is set to True, the function should print each step of the computation. The function must maintain backward compatibility, meaning it should still work with just the two integer parameters as before.", "new_solution": "def greatest_common_divisor(a: int, b: int, *, verbose: bool = False) -> int:\n    def query_gcd(a: int, b: int) -> int:\n        if verbose:\n            print(f\"Calculating GCD of {a} and {b}\")\n        return a if b == 0 else query_gcd(b, a % b)\n    return query_gcd(a, b)", "input_format": "greatest_common_divisor(a: int, b: int, *, verbose: bool = False) -> int", "output_format": "int", "test_input": ["assert greatest_common_divisor(3, 5) == 1", "assert greatest_common_divisor(25, 15) == 5", "assert greatest_common_divisor(0, 5) == 5", "assert greatest_common_divisor(5, 0) == 5", "assert greatest_common_divisor(48, 18, verbose=True) == 6"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "HumanEval/13-3", "raw_problem": "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\"", "raw_solution": "```python\n\n\n    def query_gcd(a: int, b: int) -> int:\n        return a if b == 0 else query_gcd(b, a % b)\n    return query_gcd(a, b)    \n\n\n```", "raw_test_input": ["assert greatest_common_divisor(3, 7) == 1", "assert greatest_common_divisor(10, 15) == 5", "assert greatest_common_divisor(49, 14) == 7", "assert greatest_common_divisor(144, 60) == 12"], "new_problem": "Given a list of pairs of integers, return a dictionary where each key is a pair of integers and the value is their greatest common divisor. The solution should efficiently handle multiple queries by storing previously computed results to avoid redundant calculations.", "new_solution": "from typing import List, Tuple, Dict\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    def query_gcd(a: int, b: int) -> int:\n        return a if b == 0 else query_gcd(b, a % b)\n    return query_gcd(a, b)\n\ndef gcd_for_pairs(pairs: List[Tuple[int, int]]) -> Dict[Tuple[int, int], int]:\n    gcd_cache: Dict[Tuple[int, int], int] = {}\n    for a, b in pairs:\n        if (a, b) not in gcd_cache:\n            gcd_cache[(a, b)] = greatest_common_divisor(a, b)\n    return gcd_cache", "input_format": "List[Tuple[int, int]]", "output_format": "Dict[Tuple[int, int], int]", "test_input": ["assert gcd_for_pairs([(3, 5), (25, 15), (12, 8), (100, 10), (7, 3)]) == {(3, 5): 1, (25, 15): 5, (12, 8): 4, (100, 10): 10, (7, 3): 1}", "assert gcd_for_pairs([(18, 24), (35, 10), (81, 27), (56, 14), (9, 3)]) == {(18, 24): 6, (35, 10): 5, (81, 27): 27, (56, 14): 14, (9, 3): 3}", "assert gcd_for_pairs([(1, 1), (0, 5), (5, 0), (0, 0), (100, 100)]) == {(1, 1): 1, (0, 5): 5, (5, 0): 5, (0, 0): 0, (100, 100): 100}", "assert gcd_for_pairs([(2, 3), (4, 6), (8, 12), (16, 24), (32, 48)]) == {(2, 3): 1, (4, 6): 2, (8, 12): 4, (16, 24): 8, (32, 48): 16}", "assert gcd_for_pairs([(9, 12), (15, 20), (21, 28), (30, 42), (50, 75)]) == {(9, 12): 3, (15, 20): 5, (21, 28): 7, (30, 42): 6, (50, 75): 25}"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "HumanEval/13-4", "raw_problem": "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\"", "raw_solution": "```python\n\n\n    def query_gcd(a: int, b: int) -> int:\n        return a if b == 0 else query_gcd(b, a % b)\n    return query_gcd(a, b)    \n\n\n```", "raw_test_input": ["assert greatest_common_divisor(3, 7) == 1", "assert greatest_common_divisor(10, 15) == 5", "assert greatest_common_divisor(49, 14) == 7", "assert greatest_common_divisor(144, 60) == 12"], "new_problem": "Create a function that calculates the greatest common divisor (GCD) of two integers a and b. The function should handle the following errors: \n1. If either a or b is not an integer, raise a TypeError with a meaningful message.\n2. If either a or b is negative, raise a ValueError with a message indicating that only non-negative integers are allowed.\n3. If both a and b are zero, raise a ValueError indicating that GCD is undefined for zero inputs.\nThe function should propagate these errors appropriately and maintain type hints.", "new_solution": "class GCDException(Exception):\n    pass\n\nclass GCDTypeError(GCDException):\n    pass\n\nclass GCDValueError(GCDException):\n    pass\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    if not isinstance(a, int) or not isinstance(b, int):\n        raise GCDTypeError('Both a and b must be integers.')\n    if a < 0 or b < 0:\n        raise GCDValueError('Both a and b must be non-negative integers.')\n    if a == 0 and b == 0:\n        raise GCDValueError('GCD is undefined for both a and b being zero.')\n\n    def query_gcd(a: int, b: int) -> int:\n        return a if b == 0 else query_gcd(b, a % b)\n    return query_gcd(a, b)", "input_format": "Two integers a and b", "output_format": "An integer representing the greatest common divisor of a and b", "test_input": ["assert greatest_common_divisor(3, 5) == 1", "assert greatest_common_divisor(25, 15) == 5", "try:\n    greatest_common_divisor(-3, 5)\nexcept GCDValueError as e:\n    assert str(e) == 'Both a and b must be non-negative integers.'", "try:\n    greatest_common_divisor(3, '5')\nexcept GCDTypeError as e:\n    assert str(e) == 'Both a and b must be integers.'", "try:\n    greatest_common_divisor(0, 0)\nexcept GCDValueError as e:\n    assert str(e) == 'GCD is undefined for both a and b being zero.'"], "requirement_type": "PROMPT_ERROR_HANDLING"}
{"task_id": "HumanEval/14-1", "raw_problem": "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\"", "raw_solution": "```python\n\n    return [string[:(i + 1)] for i in range(len(string))]\n\n\n```", "raw_test_input": ["assert all_prefixes('') == []", "assert all_prefixes('asdfgh') == ['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh']", "assert all_prefixes('WWW') == ['W', 'WW', 'WWW']"], "new_problem": "In a text processing application for an e-commerce platform, you need to generate all prefixes of product names that are longer than a specified minimum length. This can help in creating search suggestions for users as they type. Given a list of product names and a minimum prefix length, return a list of lists where each sublist contains all valid prefixes of a product name that meet the minimum length requirement.", "new_solution": "from typing import List\n\ndef all_prefixes(string: str) -> List[str]:\n    return [string[:(i + 1)] for i in range(len(string))]\n\ndef valid_prefixes(strings: List[str], min_length: int) -> List[List[str]]:\n    result = []\n    for string in strings:\n        prefixes = all_prefixes(string)\n        valid = [prefix for prefix in prefixes if len(prefix) >= min_length]\n        result.append(valid)\n    return result", "input_format": "{ 'strings': List[str], 'min_length': int }", "output_format": "List[List[str]]", "test_input": ["assert valid_prefixes(['apple', 'banana', 'cherry'], 3) == [['app', 'appl', 'apple'], ['ban', 'bana', 'banan', 'banana'], ['che', 'cher', 'cherr', 'cherry']]", "assert valid_prefixes(['dog', 'cat', 'fish'], 2) == [['do', 'dog'], ['ca', 'cat'], ['fi', 'fis', 'fish']]", "assert valid_prefixes(['table', 'chair', 'lamp'], 4) == [['tabl', 'table'], ['chai', 'chair'], ['lamp']]", "assert valid_prefixes(['notebook', 'pen', 'eraser'], 5) == [['noteb', 'notebo', 'noteboo', 'notebook'], [], ['erase', 'eraser']]", "assert valid_prefixes(['car', 'bike', 'bus'], 1) == [['c', 'ca', 'car'], ['b', 'bi', 'bik', 'bike'], ['b', 'bu', 'bus']]"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "HumanEval/14-2", "raw_problem": "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\"", "raw_solution": "```python\n\n    return [string[:(i + 1)] for i in range(len(string))]\n\n\n```", "raw_test_input": ["assert all_prefixes('') == []", "assert all_prefixes('asdfgh') == ['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh']", "assert all_prefixes('WWW') == ['W', 'WW', 'WWW']"], "new_problem": "Enhance the function to return all prefixes of a given string, with an optional parameter to include an empty string as the first prefix. The function should maintain backward compatibility, meaning it should work as before when the new parameter is not provided.", "new_solution": "from typing import List\n\ndef all_prefixes(string: str, include_empty: bool = False) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string.\n    Optionally include an empty string as the first prefix if include_empty is True.\n    \"\"\"\n    prefixes = [string[:(i + 1)] for i in range(len(string))]\n    if include_empty:\n        return [''] + prefixes\n    return prefixes", "input_format": "string: str, include_empty: bool = False", "output_format": "List[str]", "test_input": ["assert all_prefixes('abc') == ['a', 'ab', 'abc']", "assert all_prefixes('abc', include_empty=True) == ['', 'a', 'ab', 'abc']", "assert all_prefixes('') == []", "assert all_prefixes('', include_empty=True) == ['']", "assert all_prefixes('a', include_empty=True) == ['', 'a']"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "HumanEval/14-3", "raw_problem": "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\"", "raw_solution": "```python\n\n    return [string[:(i + 1)] for i in range(len(string))]\n\n\n```", "raw_test_input": ["assert all_prefixes('') == []", "assert all_prefixes('asdfgh') == ['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh']", "assert all_prefixes('WWW') == ['W', 'WW', 'WWW']"], "new_problem": "Given a list of strings, return a dictionary where each key is a string from the list and the value is a list of all prefixes of that string from shortest to longest. Ensure that the solution efficiently handles the case where the list contains a large number of strings, and each string can be of considerable length.", "new_solution": "```python\nfrom typing import List, Dict\n\ndef all_prefixes(string: str) -> List[str]:\n    return [string[:(i + 1)] for i in range(len(string))] if string else ['']\n\ndef prefixes_dict(strings: List[str]) -> Dict[str, List[str]]:\n    return {s: all_prefixes(s) for s in strings}\n```", "input_format": "List[str]", "output_format": "Dict[str, List[str]]", "test_input": ["assert prefixes_dict(['abc', 'de']) == {'abc': ['a', 'ab', 'abc'], 'de': ['d', 'de']}", "assert prefixes_dict(['']) == {'': ['']}", "assert prefixes_dict(['a', 'b', 'c']) == {'a': ['a'], 'b': ['b'], 'c': ['c']}", "assert prefixes_dict(['hello', 'world']) == {'hello': ['h', 'he', 'hel', 'hell', 'hello'], 'world': ['w', 'wo', 'wor', 'worl', 'world']}", "assert prefixes_dict(['prefix', 'suffix']) == {'prefix': ['p', 'pr', 'pre', 'pref', 'prefi', 'prefix'], 'suffix': ['s', 'su', 'suf', 'suff', 'suffi', 'suffix']}"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "HumanEval/14-4", "raw_problem": "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\"", "raw_solution": "```python\n\n    return [string[:(i + 1)] for i in range(len(string))]\n\n\n```", "raw_test_input": ["assert all_prefixes('') == []", "assert all_prefixes('asdfgh') == ['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh']", "assert all_prefixes('WWW') == ['W', 'WW', 'WWW']"], "new_problem": "Modify the function to handle errors in a real-world scenario where the input might be invalid. Specifically, handle the following errors: 1) If the input is None, raise a ValueError with a message 'Input cannot be None'. 2) If the input is not a string, raise a TypeError with a message 'Input must be a string'. 3) If the input string is empty, return an empty list. Ensure that these errors are propagated correctly and provide meaningful error messages.", "new_solution": "from typing import List\n\nclass PrefixError(Exception):\n    pass\n\nclass NoneInputError(PrefixError):\n    def __init__(self, message=\"Input cannot be None\"):\n        self.message = message\n        super().__init__(self.message)\n\nclass InvalidTypeError(PrefixError):\n    def __init__(self, message=\"Input must be a string\"):\n        self.message = message\n        super().__init__(self.message)\n\ndef all_prefixes(string: str) -> List[str]:\n    if string is None:\n        raise NoneInputError()\n    if not isinstance(string, str):\n        raise InvalidTypeError()\n    if string == \"\":\n        return []\n    return [string[:(i + 1)] for i in range(len(string))]", "input_format": "A string input that may be empty or None.", "output_format": "A list of string prefixes or an error message.", "test_input": ["assert all_prefixes('abc') == ['a', 'ab', 'abc']", "assert all_prefixes('') == []", "try:\n    all_prefixes(None)\nexcept NoneInputError as e:\n    assert str(e) == 'Input cannot be None'", "try:\n    all_prefixes(123)\nexcept InvalidTypeError as e:\n    assert str(e) == 'Input must be a string'", "try:\n    all_prefixes(['a', 'b', 'c'])\nexcept InvalidTypeError as e:\n    assert str(e) == 'Input must be a string'"], "requirement_type": "PROMPT_ERROR_HANDLING"}
{"task_id": "HumanEval/15-1", "raw_problem": "def string_sequence(n: int) -> str:\n    \"\"\" Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n    >>> string_sequence(0)\n    '0'\n    >>> string_sequence(5)\n    '0 1 2 3 4 5'\n    \"\"\"", "raw_solution": "```python\n\n\n    return \" \".join(map(str, range(n + 1)))\n\n\n```", "raw_test_input": ["assert string_sequence(0) == '0'", "assert string_sequence(3) == '0 1 2 3'", "assert string_sequence(10) == '0 1 2 3 4 5 6 7 8 9 10'"], "new_problem": "Create a function that takes a list of integer ranges and returns a list of space-delimited number sequences for each range. Each range is represented as a tuple (start, end), and the function should use the original string_sequence function to generate the sequence for each range. This can be used in scenarios like generating report sections for different time periods in a financial report.", "new_solution": "```python\ndef string_sequence(n: int) -> str:\n    return \" \".join(map(str, range(n + 1)))\n\ndef generate_sequences(ranges: list) -> list:\n    sequences = []\n    for start, end in ranges:\n        if start > end:\n            sequences.append(\"\")\n        else:\n            sequences.append(\" \".join(map(str, range(start, end + 1))))\n    return sequences\n```", "input_format": "A list of tuples where each tuple contains a start and end integer representing a range.", "output_format": "A list of strings where each string is a space-delimited sequence of numbers for the corresponding range in the input.", "test_input": ["assert generate_sequences([(0, 5), (3, 7), (10, 10)]) == ['0 1 2 3 4 5', '3 4 5 6 7', '10']", "assert generate_sequences([(0, 0), (1, 1), (2, 2)]) == ['0', '1', '2']", "assert generate_sequences([(5, 5), (0, 3), (8, 10)]) == ['5', '0 1 2 3', '8 9 10']", "assert generate_sequences([(0, 2), (2, 5), (5, 8)]) == ['0 1 2', '2 3 4 5', '5 6 7 8']", "assert generate_sequences([(3, 3), (4, 4), (5, 5)]) == ['3', '4', '5']"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "HumanEval/15-2", "raw_problem": "def string_sequence(n: int) -> str:\n    \"\"\" Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n    >>> string_sequence(0)\n    '0'\n    >>> string_sequence(5)\n    '0 1 2 3 4 5'\n    \"\"\"", "raw_solution": "```python\n\n\n    return \" \".join(map(str, range(n + 1)))\n\n\n```", "raw_test_input": ["assert string_sequence(0) == '0'", "assert string_sequence(3) == '0 1 2 3'", "assert string_sequence(10) == '0 1 2 3 4 5 6 7 8 9 10'"], "new_problem": "Enhance the function to allow a custom delimiter for the sequence while maintaining backward compatibility. The function should return a string containing numbers starting from 0 up to n inclusive, separated by the specified delimiter. If no delimiter is provided, it should default to a space.", "new_solution": "def string_sequence(n: int, delimiter: str = ' ') -> str:\n    return delimiter.join(map(str, range(n + 1)))", "input_format": "string_sequence(n: int, delimiter: str = ' ')", "output_format": "str", "test_input": ["assert string_sequence(0) == '0'", "assert string_sequence(5) == '0 1 2 3 4 5'", "assert string_sequence(5, ',') == '0,1,2,3,4,5'", "assert string_sequence(3, '-') == '0-1-2-3'", "assert string_sequence(2, '') == '012'"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "HumanEval/15-3", "raw_problem": "def string_sequence(n: int) -> str:\n    \"\"\" Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n    >>> string_sequence(0)\n    '0'\n    >>> string_sequence(5)\n    '0 1 2 3 4 5'\n    \"\"\"", "raw_solution": "```python\n\n\n    return \" \".join(map(str, range(n + 1)))\n\n\n```", "raw_test_input": ["assert string_sequence(0) == '0'", "assert string_sequence(3) == '0 1 2 3'", "assert string_sequence(10) == '0 1 2 3 4 5 6 7 8 9 10'"], "new_problem": "Given a list of integers, return a dictionary where each key is an integer from the list and the value is a string containing space-delimited numbers starting from 0 up to that integer inclusive. The function should handle lists with up to 1000 integers and each integer should be between 0 and 100. The solution should use a dictionary to store the results.", "new_solution": "```python\nfrom typing import List, Dict\n\ndef string_sequence(n: int) -> str:\n    return \" \".join(map(str, range(n + 1)))\n\ndef generate_sequences(numbers: List[int]) -> Dict[int, str]:\n    return {num: string_sequence(num) for num in numbers}\n```", "input_format": "List[int]", "output_format": "Dict[int, str]", "test_input": ["assert generate_sequences([0]) == {0: '0'}", "assert generate_sequences([5]) == {5: '0 1 2 3 4 5'}", "assert generate_sequences([0, 1, 2]) == {0: '0', 1: '0 1', 2: '0 1 2'}", "assert generate_sequences([3, 4, 5]) == {3: '0 1 2 3', 4: '0 1 2 3 4', 5: '0 1 2 3 4 5'}", "assert generate_sequences([10, 0, 5]) == {10: '0 1 2 3 4 5 6 7 8 9 10', 0: '0', 5: '0 1 2 3 4 5'}"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "HumanEval/15-4", "raw_problem": "def string_sequence(n: int) -> str:\n    \"\"\" Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n    >>> string_sequence(0)\n    '0'\n    >>> string_sequence(5)\n    '0 1 2 3 4 5'\n    \"\"\"", "raw_solution": "```python\n\n\n    return \" \".join(map(str, range(n + 1)))\n\n\n```", "raw_test_input": ["assert string_sequence(0) == '0'", "assert string_sequence(3) == '0 1 2 3'", "assert string_sequence(10) == '0 1 2 3 4 5 6 7 8 9 10'"], "new_problem": "Create a function `safe_string_sequence(n: int) -> str` that returns a string containing space-delimited numbers starting from 0 up to n inclusive. The function should handle the following errors: 1. If `n` is negative, raise a `ValueError` with the message 'Input must be a non-negative integer'. 2. If `n` is not an integer, raise a `TypeError` with the message 'Input must be an integer'. 3. If any other unexpected error occurs, raise a `RuntimeError` with the message 'An unexpected error occurred'.", "new_solution": "def safe_string_sequence(n: int) -> str:\n    try:\n        if not isinstance(n, int):\n            raise TypeError('Input must be an integer')\n        if n < 0:\n            raise ValueError('Input must be a non-negative integer')\n        return \" \".join(map(str, range(n + 1)))\n    except (TypeError, ValueError) as e:\n        raise e\n    except Exception as e:\n        raise RuntimeError('An unexpected error occurred') from e", "input_format": "int", "output_format": "str", "test_input": ["assert safe_string_sequence(0) == '0'", "assert safe_string_sequence(5) == '0 1 2 3 4 5'", "try:\n    safe_string_sequence(-1)\nexcept ValueError as e:\n    assert str(e) == 'Input must be a non-negative integer'", "try:\n    safe_string_sequence('5')\nexcept TypeError as e:\n    assert str(e) == 'Input must be an integer'", "try:\n    safe_string_sequence(None)\nexcept TypeError as e:\n    assert str(e) == 'Input must be an integer'"], "requirement_type": "PROMPT_ERROR_HANDLING"}
{"task_id": "HumanEval/16-1", "raw_problem": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"", "raw_solution": "```python\n\n    return len(set(string.lower()))\n\n\n```", "raw_test_input": ["assert count_distinct_characters('') == 0", "assert count_distinct_characters('abcde') == 5", "assert count_distinct_characters('abcde' + 'cade' + 'CADE') == 5", "assert count_distinct_characters('aaaaAAAAaaaa') == 1", "assert count_distinct_characters('Jerry jERRY JeRRRY') == 5"], "new_problem": "In an e-commerce platform, you are tasked with analyzing customer reviews to determine the diversity of language used in each review. This can help in understanding the richness of vocabulary and the potential need for translation services. Given a list of customer reviews, write a function that returns a dictionary where each review is a key and the value is the number of distinct characters (case-insensitive) used in that review.", "new_solution": "```python\ndef count_distinct_characters(string: str) -> int:\n    return len(set(filter(str.isalnum, string.lower())))\n\ndef analyze_reviews(reviews: list) -> dict:\n    result = {}\n    for review in reviews:\n        result[review] = count_distinct_characters(review)\n    return result\n```", "input_format": "A list of customer reviews, where each review is a string.", "output_format": "A dictionary with each review as a key and the number of distinct characters in that review as the value.", "test_input": ["assert analyze_reviews(['Great product!', 'Not bad', 'Could be better']) == {'Great product!': 10, 'Not bad': 6, 'Could be better': 9}", "assert analyze_reviews(['Amazing!', 'Wow', 'Superb']) == {'Amazing!': 6, 'Wow': 2, 'Superb': 6}", "assert analyze_reviews(['']) == {'': 0}", "assert analyze_reviews(['A', 'B', 'C']) == {'A': 1, 'B': 1, 'C': 1}", "assert analyze_reviews(['Hello World', 'HELLO world', 'hello WORLD']) == {'Hello World': 7, 'HELLO world': 7, 'hello WORLD': 7}"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "HumanEval/16-2", "raw_problem": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"", "raw_solution": "```python\n\n    return len(set(string.lower()))\n\n\n```", "raw_test_input": ["assert count_distinct_characters('') == 0", "assert count_distinct_characters('abcde') == 5", "assert count_distinct_characters('abcde' + 'cade' + 'CADE') == 5", "assert count_distinct_characters('aaaaAAAAaaaa') == 1", "assert count_distinct_characters('Jerry jERRY JeRRRY') == 5"], "new_problem": "Enhance the function to count distinct characters in a string with an optional parameter to consider case sensitivity. The function should maintain backward compatibility, meaning it should default to ignoring case as before. The function should accept a string and an optional boolean parameter 'ignore_case'. If 'ignore_case' is True, the function should count distinct characters regardless of case. If 'ignore_case' is False, it should consider 'A' and 'a' as distinct characters.", "new_solution": "```python\ndef count_distinct_characters(string: str, ignore_case: bool = True) -> int:\n    if ignore_case:\n        string = string.lower()\n    return len(set(string))\n```", "input_format": "string: str, ignore_case: bool = True", "output_format": "int", "test_input": ["assert count_distinct_characters('xyzXYZ') == 3", "assert count_distinct_characters('Jerry') == 4", "assert count_distinct_characters('xyzXYZ', ignore_case=False) == 6", "assert count_distinct_characters('Jerry', ignore_case=False) == 4", "assert count_distinct_characters('aAaAaA') == 1", "assert count_distinct_characters('aAaAaA', ignore_case=False) == 2"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "HumanEval/16-3", "raw_problem": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"", "raw_solution": "```python\n\n    return len(set(string.lower()))\n\n\n```", "raw_test_input": ["assert count_distinct_characters('') == 0", "assert count_distinct_characters('abcde') == 5", "assert count_distinct_characters('abcde' + 'cade' + 'CADE') == 5", "assert count_distinct_characters('aaaaAAAAaaaa') == 1", "assert count_distinct_characters('Jerry jERRY JeRRRY') == 5"], "new_problem": "Given a list of tuples where each tuple contains two strings, find out how many distinct characters (regardless of case) are shared between the two strings in each tuple. Return a dictionary where the keys are the concatenated strings of each tuple and the values are the count of distinct shared characters.", "new_solution": "```python\nfrom typing import List, Tuple, Dict\n\ndef count_shared_distinct_characters(pairs: List[Tuple[str, str]]) -> Dict[str, int]:\n    result = {}\n    for str1, str2 in pairs:\n        shared_chars = set(str1.lower()) & set(str2.lower())\n        result[str1 + str2] = len(shared_chars)\n    return result\n```", "input_format": "List[Tuple[str, str]]", "output_format": "Dict[str, int]", "test_input": ["assert count_shared_distinct_characters([('abc', 'bcd'), ('hello', 'world')]) == {'abcbcd': 2, 'helloworld': 2}", "assert count_shared_distinct_characters([('xyz', 'XYZ'), ('Jerry', 'Berry')]) == {'xyzXYZ': 3, 'JerryBerry': 3}", "assert count_shared_distinct_characters([('apple', 'orange'), ('cat', 'dog')]) == {'appleorange': 2, 'catdog': 0}", "assert count_shared_distinct_characters([('abcd', 'efgh'), ('ijkl', 'mnop')]) == {'abcdefgh': 0, 'ijklmnop': 0}", "assert count_shared_distinct_characters([('same', 'same'), ('different', 'different')]) == {'samesame': 4, 'differentdifferent': 7}"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "HumanEval/16-4", "raw_problem": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"", "raw_solution": "```python\n\n    return len(set(string.lower()))\n\n\n```", "raw_test_input": ["assert count_distinct_characters('') == 0", "assert count_distinct_characters('abcde') == 5", "assert count_distinct_characters('abcde' + 'cade' + 'CADE') == 5", "assert count_distinct_characters('aaaaAAAAaaaa') == 1", "assert count_distinct_characters('Jerry jERRY JeRRRY') == 5"], "new_problem": "Create a function that counts the number of distinct characters in a given string, ignoring case. The function should handle errors such as non-string inputs, None values, and empty strings. Define specific error types and provide meaningful error messages. Ensure that errors are propagated correctly and maintain type hints.", "new_solution": "class InvalidInputError(Exception):\n    \"\"\"Exception raised for invalid input types.\"\"\"\n    def __init__(self, message: str):\n        self.message = message\n        super().__init__(self.message)\n\nclass EmptyStringError(Exception):\n    \"\"\"Exception raised for empty string input.\"\"\"\n    def __init__(self, message: str):\n        self.message = message\n        super().__init__(self.message)\n\ndef count_distinct_characters(string: str) -> int:\n    \"\"\"Given a string, find out how many distinct characters (regardless of case) it consists of.\"\"\"\n    if string is None:\n        raise InvalidInputError(\"Input cannot be None.\")\n    if not isinstance(string, str):\n        raise InvalidInputError(\"Input must be a string.\")\n    if string == '':\n        raise EmptyStringError(\"Input string cannot be empty.\")\n    return len(set(string.lower()))", "input_format": "A string input that may contain non-string types or be None.", "output_format": "An integer representing the number of distinct characters or an error message.", "test_input": ["try:\n    assert count_distinct_characters('xyzXYZ') == 3\nexcept Exception as e:\n    print(e)", "try:\n    assert count_distinct_characters('Jerry') == 4\nexcept Exception as e:\n    print(e)", "try:\n    assert count_distinct_characters(None)\nexcept InvalidInputError as e:\n    assert str(e) == 'Input cannot be None.'", "try:\n    assert count_distinct_characters(123)\nexcept InvalidInputError as e:\n    assert str(e) == 'Input must be a string.'", "try:\n    assert count_distinct_characters('')\nexcept EmptyStringError as e:\n    assert str(e) == 'Input string cannot be empty.'"], "requirement_type": "PROMPT_ERROR_HANDLING"}
{"task_id": "HumanEval/17-1", "raw_problem": "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"", "raw_solution": "```python\n\n\n    def count_beats(note: str) -> int:\n        if note == \"o\": return 4\n        elif note == \"o|\": return 2\n        elif note == \".|\": return 1\n    \n    if music_string == \"\": return []\n    return list(map(count_beats, music_string.split(\" \")))\n\n\n```", "raw_test_input": ["assert parse_music('') == []", "assert parse_music('o o o o') == [4, 4, 4, 4]", "assert parse_music('.| .| .| .|') == [1, 1, 1, 1]", "assert parse_music('o| o| .| .| o o o o') == [2, 2, 1, 1, 4, 4, 4, 4]", "assert parse_music('o| .| o| .| o o| o o|') == [2, 1, 2, 1, 4, 2, 4, 2]"], "new_problem": "You are tasked with developing a system for a music streaming service that analyzes the rhythm complexity of various songs. Each song is represented by a string of musical notes in a special ASCII format. Your task is to parse each song's music string to determine the total number of beats for that song. Use the provided function `parse_music` to parse individual music strings. Then, aggregate the results into a dictionary where each song title maps to its total number of beats.", "new_solution": "```python\nfrom typing import List, Dict\n\ndef parse_music(music_string: str) -> List[int]:\n    def count_beats(note: str) -> int:\n        if note == \"o\": return 4\n        elif note == \"o|\": return 2\n        elif note == \".|\": return 1\n    \n    if music_string == \"\": return []\n    return list(map(count_beats, music_string.split(\" \")))\n\ndef analyze_songs(music_strings: List[str], song_titles: List[str]) -> Dict[str, int]:\n    song_beats = {}\n    for title, music_string in zip(song_titles, music_strings):\n        beats = parse_music(music_string)\n        total_beats = sum(beats)\n        song_beats[title] = total_beats\n    return song_beats\n```", "input_format": "A list of music strings, each representing a sequence of musical notes in a special ASCII format, and a list of corresponding song titles.", "output_format": "A dictionary where each key is a song title and the value is the total number of beats for that song.", "test_input": ["assert analyze_songs(['o o| .| o| o| .| .| .| .| o o', 'o| o| o| o|'], ['Song A', 'Song B']) == {'Song A': 23, 'Song B': 8}", "assert analyze_songs(['o o o o', '.| .| .| .|'], ['Song C', 'Song D']) == {'Song C': 16, 'Song D': 4}", "assert analyze_songs(['o| .| o| .|', 'o o|'], ['Song E', 'Song F']) == {'Song E': 6, 'Song F': 6}", "assert analyze_songs(['', 'o o| o|'], ['Song G', 'Song H']) == {'Song G': 0, 'Song H': 8}", "assert analyze_songs(['o| .| o|', 'o o o'], ['Song I', 'Song J']) == {'Song I': 5, 'Song J': 12}"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "HumanEval/17-2", "raw_problem": "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"", "raw_solution": "```python\n\n\n    def count_beats(note: str) -> int:\n        if note == \"o\": return 4\n        elif note == \"o|\": return 2\n        elif note == \".|\": return 1\n    \n    if music_string == \"\": return []\n    return list(map(count_beats, music_string.split(\" \")))\n\n\n```", "raw_test_input": ["assert parse_music('') == []", "assert parse_music('o o o o') == [4, 4, 4, 4]", "assert parse_music('.| .| .| .|') == [1, 1, 1, 1]", "assert parse_music('o| o| .| .| o o o o') == [2, 2, 1, 1, 4, 4, 4, 4]", "assert parse_music('o| .| o| .| o o| o o|') == [2, 1, 2, 1, 4, 2, 4, 2]"], "new_problem": "Enhance the `parse_music` function to support an optional `tempo` parameter. The `tempo` parameter is a float that adjusts the duration of each note. For example, if the tempo is 2.0, each note's duration is doubled. The function should maintain backward compatibility, meaning it should still work with just the `music_string` parameter as before, defaulting the tempo to 1.0.", "new_solution": "from typing import List\n\ndef parse_music(music_string: str, tempo: float = 1.0) -> List[float]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of floats corresponding to how many beats does each\n    note last, adjusted by the tempo.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quarter note, lasts one beat\n\n    The tempo parameter adjusts the duration of each note.\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o', 1.0)\n    [4.0, 2.0, 1.0, 2.0, 2.0, 1.0, 1.0, 1.0, 1.0, 4.0, 4.0]\n    \"\"\"\n    def count_beats(note: str) -> int:\n        if note == \"o\": return 4\n        elif note == \"o|\": return 2\n        elif note == \".|\": return 1\n\n    if music_string == \"\": return []\n    return [count_beats(note) * tempo for note in music_string.split(\" \")]", "input_format": "parse_music(music_string: str, tempo: float = 1.0) -> List[float]", "output_format": "List of floats representing the duration of each note in beats, adjusted by the tempo.", "test_input": ["assert parse_music('o o| .| o| o| .| .| .| .| o o') == [4.0, 2.0, 1.0, 2.0, 2.0, 1.0, 1.0, 1.0, 1.0, 4.0, 4.0]", "assert parse_music('o o| .| o| o| .| .| .| .| o o', 2.0) == [8.0, 4.0, 2.0, 4.0, 4.0, 2.0, 2.0, 2.0, 2.0, 8.0, 8.0]", "assert parse_music('o o| .|', 0.5) == [2.0, 1.0, 0.5]", "assert parse_music('o| .| o', 1.5) == [3.0, 1.5, 6.0]", "assert parse_music('', 1.0) == []"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "HumanEval/17-3", "raw_problem": "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"", "raw_solution": "```python\n\n\n    def count_beats(note: str) -> int:\n        if note == \"o\": return 4\n        elif note == \"o|\": return 2\n        elif note == \".|\": return 1\n    \n    if music_string == \"\": return []\n    return list(map(count_beats, music_string.split(\" \")))\n\n\n```", "raw_test_input": ["assert parse_music('') == []", "assert parse_music('o o o o') == [4, 4, 4, 4]", "assert parse_music('.| .| .| .|') == [1, 1, 1, 1]", "assert parse_music('o| o| .| .| o o o o') == [2, 2, 1, 1, 4, 4, 4, 4]", "assert parse_music('o| .| o| .| o o| o o|') == [2, 1, 2, 1, 4, 2, 4, 2]"], "new_problem": "You are given a dictionary where each key is a measure number and each value is a list of strings representing musical notes in a special ASCII format. Your task is to parse this dictionary and return a new dictionary where each key is a measure number and each value is a list of integers corresponding to how many beats each note lasts. Additionally, ensure that each measure does not exceed a total of 8 beats. If a measure exceeds 8 beats, raise a ValueError.", "new_solution": "```python\nfrom typing import Dict, List\n\ndef count_beats(note: str) -> int:\n    if note == \"o\": return 4\n    elif note == \"o|\": return 2\n    elif note == \".|\": return 1\n    else: return 0\n\ndef parse_music_dict(music_dict: Dict[int, List[str]]) -> Dict[int, List[int]]:\n    result = {}\n    for measure, notes in music_dict.items():\n        beats = list(map(count_beats, notes))\n        if sum(beats) > 8:\n            raise ValueError(f\"Measure {measure} exceeds 8 beats.\")\n        result[measure] = beats\n    return result\n```", "input_format": "A dictionary where keys are measure numbers and values are lists of strings representing musical notes in a special ASCII format.", "output_format": "A dictionary where keys are measure numbers and values are lists of integers corresponding to how many beats each note lasts.", "test_input": ["assert parse_music_dict({1: ['o', 'o|', '.|'], 2: ['o|', 'o|', '.|', '.|']}) == {1: [4, 2, 1], 2: [2, 2, 1, 1]}", "assert parse_music_dict({1: ['o', 'o'], 2: ['o|', 'o|', 'o|']}) == {1: [4, 4], 2: [2, 2, 2]}", "assert parse_music_dict({1: ['.'], 2: ['o|', '.|', '.|', '.|']}) == {1: [0], 2: [2, 1, 1, 1]}", "assert parse_music_dict({1: ['o|', 'o|', 'o|', 'o|']}) == {1: [2, 2, 2, 2]}", "try:\n    parse_music_dict({1: ['o', 'o', 'o']})\nexcept ValueError as e:\n    assert str(e) == 'Measure 1 exceeds 8 beats.'"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "HumanEval/17-4", "raw_problem": "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"", "raw_solution": "```python\n\n\n    def count_beats(note: str) -> int:\n        if note == \"o\": return 4\n        elif note == \"o|\": return 2\n        elif note == \".|\": return 1\n    \n    if music_string == \"\": return []\n    return list(map(count_beats, music_string.split(\" \")))\n\n\n```", "raw_test_input": ["assert parse_music('') == []", "assert parse_music('o o o o') == [4, 4, 4, 4]", "assert parse_music('.| .| .| .|') == [1, 1, 1, 1]", "assert parse_music('o| o| .| .| o o o o') == [2, 2, 1, 1, 4, 4, 4, 4]", "assert parse_music('o| .| o| .| o o| o o|') == [2, 1, 2, 1, 4, 2, 4, 2]"], "new_problem": "Extend the `parse_music` function to handle errors in a real-world scenario where the input string might contain invalid notes or be improperly formatted. The function should raise a `MusicParseError` if an invalid note is encountered, and a `MusicFormatError` if the input string is improperly formatted (e.g., contains unexpected characters or sequences). Ensure that the function provides meaningful error messages and handles error propagation appropriately.", "new_solution": "from typing import List\n\nclass MusicParseError(Exception):\n    def __init__(self, note: str):\n        super().__init__(f\"Invalid note encountered: '{note}'\")\n\nclass MusicFormatError(Exception):\n    def __init__(self, message: str):\n        super().__init__(message)\n\n\ndef count_beats(note: str) -> int:\n    if note == \"o\":\n        return 4\n    elif note == \"o|\":\n        return 2\n    elif note == \".|\":\n        return 1\n    else:\n        raise MusicParseError(note)\n\n\ndef parse_music(music_string: str) -> List[int]:\n    if not isinstance(music_string, str):\n        raise MusicFormatError(\"Input must be a string.\")\n    if music_string.strip() == \"\":\n        return []\n    try:\n        return list(map(count_beats, music_string.split(\" \")))\n    except MusicParseError as e:\n        raise MusicFormatError(f\"Error parsing music string: {str(e)}\")\n", "input_format": "A string representing musical notes in a special ASCII format.", "output_format": "A list of integers corresponding to how many beats each note lasts.", "test_input": ["assert parse_music('o o| .| o| o| .| .| .| .| o o') == [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]", "try:\n    parse_music('o o| x| o| o| .| .| .| .| o o')\nexcept MusicFormatError as e:\n    assert str(e) == \"Error parsing music string: Invalid note encountered: 'x|'\"", "try:\n    parse_music('o o| .| o| o| .| .| .| .| o o 5')\nexcept MusicFormatError as e:\n    assert str(e) == \"Error parsing music string: Invalid note encountered: '5'\"", "try:\n    parse_music(12345)\nexcept MusicFormatError as e:\n    assert str(e) == \"Input must be a string.\"", "assert parse_music('') == []"], "requirement_type": "PROMPT_ERROR_HANDLING"}
{"task_id": "HumanEval/18-1", "raw_problem": "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"", "raw_solution": "```python\n\n\n    occurences = 0\n    for i in range(len(string)):\n        if string[i:].startswith(substring):\n            occurences += 1\n    return occurences\n\n\n```", "raw_test_input": ["assert how_many_times('', 'x') == 0", "assert how_many_times('xyxyxyx', 'x') == 4", "assert how_many_times('cacacacac', 'cac') == 4", "assert how_many_times('john doe', 'john') == 1"], "new_problem": "In an e-commerce platform, you want to analyze customer reviews to determine how frequently certain keywords appear. This can help in understanding customer sentiment and identifying common themes. Write a function that takes a list of customer reviews and a list of keywords, and returns a dictionary where each keyword is mapped to the total number of times it appears across all reviews, including overlapping occurrences.", "new_solution": "```python\ndef how_many_times(string: str, substring: str) -> int:\n    occurences = 0\n    start = 0\n    while start < len(string):\n        start = string.find(substring, start)\n        if start == -1:\n            break\n        occurences += 1\n        start += 1\n    return occurences\n\ndef keyword_occurrences(reviews: list, keywords: list) -> dict:\n    keyword_count = {keyword: 0 for keyword in keywords}\n    for review in reviews:\n        for keyword in keywords:\n            keyword_count[keyword] += how_many_times(review.lower(), keyword.lower())\n    return keyword_count\n```", "input_format": "A list of customer reviews (strings) and a list of keywords (strings) to search for.", "output_format": "A dictionary where each keyword is a key and its value is the total number of times it appears across all reviews, including overlapping occurrences.", "test_input": ["assert keyword_occurrences(['I love this product', 'This product is great', 'Great product, great service'], ['great', 'product']) == {'great': 3, 'product': 3}", "assert keyword_occurrences(['Amazing service', 'Service was amazing', 'Not amazing at all'], ['amazing', 'service']) == {'amazing': 3, 'service': 2}", "assert keyword_occurrences(['Fast delivery', 'Delivery was fast', 'Very fast delivery'], ['fast', 'delivery']) == {'fast': 3, 'delivery': 3}", "assert keyword_occurrences(['Good quality', 'Quality is good', 'Not good quality'], ['good', 'quality']) == {'good': 3, 'quality': 3}", "assert keyword_occurrences(['Excellent product', 'Product is excellent', 'Excellent service'], ['excellent', 'product']) == {'excellent': 3, 'product': 2}"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "HumanEval/18-2", "raw_problem": "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"", "raw_solution": "```python\n\n\n    occurences = 0\n    for i in range(len(string)):\n        if string[i:].startswith(substring):\n            occurences += 1\n    return occurences\n\n\n```", "raw_test_input": ["assert how_many_times('', 'x') == 0", "assert how_many_times('xyxyxyx', 'x') == 4", "assert how_many_times('cacacacac', 'cac') == 4", "assert how_many_times('john doe', 'john') == 1"], "new_problem": "Enhance the function to count occurrences of a substring in a string, with an option to perform case-insensitive counting. The function should maintain backward compatibility with existing implementations, support original function parameters, and include type hints. Add a new optional parameter 'case_sensitive' which defaults to True. If 'case_sensitive' is False, the function should count occurrences in a case-insensitive manner.", "new_solution": "def how_many_times(string: str, substring: str, case_sensitive: bool = True) -> int:\n    if not case_sensitive:\n        string = string.lower()\n        substring = substring.lower()\n    occurrences = 0\n    for i in range(len(string)):\n        if string[i:].startswith(substring):\n            occurrences += 1\n    return occurrences", "input_format": "how_many_times(string: str, substring: str, case_sensitive: bool = True) -> int", "output_format": "int", "test_input": ["assert how_many_times('', 'a') == 0", "assert how_many_times('aaa', 'a') == 3", "assert how_many_times('aaaa', 'aa') == 3", "assert how_many_times('AaAa', 'aa', case_sensitive=False) == 3", "assert how_many_times('AaAa', 'aa', case_sensitive=True) == 0"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "HumanEval/18-3", "raw_problem": "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"", "raw_solution": "```python\n\n\n    occurences = 0\n    for i in range(len(string)):\n        if string[i:].startswith(substring):\n            occurences += 1\n    return occurences\n\n\n```", "raw_test_input": ["assert how_many_times('', 'x') == 0", "assert how_many_times('xyxyxyx', 'x') == 4", "assert how_many_times('cacacacac', 'cac') == 4", "assert how_many_times('john doe', 'john') == 1"], "new_problem": "Given a list of tuples where each tuple contains a string and a substring, determine how many times each substring can be found in its corresponding string, including overlapping cases. Return the results as a dictionary where the keys are the tuples and the values are the counts. Ensure that the solution is efficient for large datasets and uses a dictionary to store the results.", "new_solution": "from typing import List, Tuple, Dict\n\ndef how_many_times(string: str, substring: str) -> int:\n    occurrences = 0\n    for i in range(len(string)):\n        if string[i:].startswith(substring):\n            occurrences += 1\n    return occurrences\n\ndef count_substring_occurrences(data: List[Tuple[str, str]]) -> Dict[Tuple[str, str], int]:\n    result = {}\n    for string, substring in data:\n        result[(string, substring)] = how_many_times(string, substring)\n    return result", "input_format": "List[Tuple[str, str]]", "output_format": "Dict[Tuple[str, str], int]", "test_input": ["assert count_substring_occurrences([('', 'a')]) == {('', 'a'): 0}", "assert count_substring_occurrences([('aaa', 'a')]) == {('aaa', 'a'): 3}", "assert count_substring_occurrences([('aaaa', 'aa')]) == {('aaaa', 'aa'): 3}", "assert count_substring_occurrences([('abcabcabc', 'abc')]) == {('abcabcabc', 'abc'): 3}", "assert count_substring_occurrences([('abababab', 'aba')]) == {('abababab', 'aba'): 3}"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "HumanEval/18-4", "raw_problem": "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"", "raw_solution": "```python\n\n\n    occurences = 0\n    for i in range(len(string)):\n        if string[i:].startswith(substring):\n            occurences += 1\n    return occurences\n\n\n```", "raw_test_input": ["assert how_many_times('', 'x') == 0", "assert how_many_times('xyxyxyx', 'x') == 4", "assert how_many_times('cacacacac', 'cac') == 4", "assert how_many_times('john doe', 'john') == 1"], "new_problem": "Create a function that counts how many times a given substring can be found in the original string, including overlapping cases. The function should handle the following errors: 1) Raise a ValueError if the substring is empty. 2) Raise a TypeError if either the string or substring is not of type str. 3) Handle any unexpected exceptions gracefully and propagate meaningful error messages.", "new_solution": "class SubstringError(Exception):\n    pass\n\nclass EmptySubstringError(SubstringError):\n    def __init__(self, message=\"The substring cannot be empty.\"):\n        self.message = message\n        super().__init__(self.message)\n\nclass InvalidTypeError(SubstringError):\n    def __init__(self, message=\"Both string and substring must be of type str.\"):\n        self.message = message\n        super().__init__(self.message)\n\ndef how_many_times(string: str, substring: str) -> int:\n    if not isinstance(string, str) or not isinstance(substring, str):\n        raise InvalidTypeError()\n    if substring == '':\n        raise EmptySubstringError()\n    try:\n        occurences = 0\n        for i in range(len(string)):\n            if string[i:].startswith(substring):\n                occurences += 1\n        return occurences\n    except Exception as e:\n        raise SubstringError(f\"An unexpected error occurred: {str(e)}\")", "input_format": "string: str, substring: str", "output_format": "int", "test_input": ["assert how_many_times('aaa', 'a') == 3", "assert how_many_times('aaaa', 'aa') == 3", "try:\n    how_many_times('aaa', '')\nexcept EmptySubstringError as e:\n    assert str(e) == 'The substring cannot be empty.'", "try:\n    how_many_times(123, 'a')\nexcept InvalidTypeError as e:\n    assert str(e) == 'Both string and substring must be of type str.'", "try:\n    how_many_times('aaa', 123)\nexcept InvalidTypeError as e:\n    assert str(e) == 'Both string and substring must be of type str.'"], "requirement_type": "PROMPT_ERROR_HANDLING"}
{"task_id": "HumanEval/19-1", "raw_problem": "from typing import List\n\n\ndef sort_numbers(numbers: str) -> str:\n    \"\"\" Input is a space-delimited string of numberals from 'zero' to 'nine'.\n    Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n    Return the string with numbers sorted from smallest to largest\n    >>> sort_numbers('three one five')\n    'one three five'\n    \"\"\"", "raw_solution": "```python\n\n    \n    to_int = {'zero': 0, 'one': 1, 'two': 2, 'three': 3, 'four': 4, 'five': 5, 'six': 6, 'seven': 7, 'eight': 8, 'nine': 9}\n\n    if numbers == \"\": return \"\"\n    return \" \".join(sorted(numbers.split(\" \"), key=lambda n: to_int[n]))\n\n\n```", "raw_test_input": ["assert sort_numbers('') == ''", "assert sort_numbers('three') == 'three'", "assert sort_numbers('three five nine') == 'three five nine'", "assert sort_numbers('five zero four seven nine eight') == 'zero four five seven eight nine'", "assert sort_numbers('six five four three two one zero') == 'zero one two three four five six'"], "new_problem": "In an e-commerce platform, customer orders are recorded as strings of space-delimited numerals representing item quantities. Each numeral is a word from 'zero' to 'nine'. Develop a function that processes a list of such orders, sorting the numerals in each order from smallest to largest. This will help in standardizing the order records for further processing.", "new_solution": "from typing import List\n\ndef sort_numbers(numbers: str) -> str:\n    to_int = {'zero': 0, 'one': 1, 'two': 2, 'three': 3, 'four': 4, 'five': 5, 'six': 6, 'seven': 7, 'eight': 8, 'nine': 9}\n    if numbers == \"\": return \"\"\n    return \" \".join(sorted(numbers.split(\" \"), key=lambda n: to_int[n]))\n\ndef process_orders(orders: List[str]) -> List[str]:\n    return [sort_numbers(order) for order in orders]", "input_format": "A list of customer orders, where each order is a string of space-delimited numerals from 'zero' to 'nine'.", "output_format": "A list of customer orders with numerals sorted from smallest to largest in each order.", "test_input": ["assert process_orders(['three one five', 'nine zero two', 'four four four']) == ['one three five', 'zero two nine', 'four four four']", "assert process_orders(['seven six five', 'one one one', 'nine eight seven']) == ['five six seven', 'one one one', 'seven eight nine']", "assert process_orders(['', 'zero zero zero', 'two three one']) == ['', 'zero zero zero', 'one two three']", "assert process_orders(['eight nine eight', 'five four three', 'two one zero']) == ['eight eight nine', 'three four five', 'zero one two']", "assert process_orders(['six five four', 'three two one', 'nine eight seven']) == ['four five six', 'one two three', 'seven eight nine']"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "HumanEval/19-2", "raw_problem": "from typing import List\n\n\ndef sort_numbers(numbers: str) -> str:\n    \"\"\" Input is a space-delimited string of numberals from 'zero' to 'nine'.\n    Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n    Return the string with numbers sorted from smallest to largest\n    >>> sort_numbers('three one five')\n    'one three five'\n    \"\"\"", "raw_solution": "```python\n\n    \n    to_int = {'zero': 0, 'one': 1, 'two': 2, 'three': 3, 'four': 4, 'five': 5, 'six': 6, 'seven': 7, 'eight': 8, 'nine': 9}\n\n    if numbers == \"\": return \"\"\n    return \" \".join(sorted(numbers.split(\" \"), key=lambda n: to_int[n]))\n\n\n```", "raw_test_input": ["assert sort_numbers('') == ''", "assert sort_numbers('three') == 'three'", "assert sort_numbers('three five nine') == 'three five nine'", "assert sort_numbers('five zero four seven nine eight') == 'zero four five seven eight nine'", "assert sort_numbers('six five four three two one zero') == 'zero one two three four five six'"], "new_problem": "Enhance the `sort_numbers` function to support an optional parameter `reverse` that allows sorting the numbers in descending order when set to True. The function should maintain backward compatibility, meaning it should still work with the original input format and return type. The function should include type hints.", "new_solution": "```python\nfrom typing import List\n\ndef sort_numbers(numbers: str, reverse: bool = False) -> str:\n    \"\"\" Input is a space-delimited string of numerals from 'zero' to 'nine'.\n    Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n    Return the string with numbers sorted from smallest to largest, or largest to smallest if reverse is True.\n    \"\"\"\n    to_int = {'zero': 0, 'one': 1, 'two': 2, 'three': 3, 'four': 4, 'five': 5, 'six': 6, 'seven': 7, 'eight': 8, 'nine': 9}\n\n    if numbers == \"\": return \"\"\n    return \" \".join(sorted(numbers.split(\" \"), key=lambda n: to_int[n], reverse=reverse))\n```", "input_format": "sort_numbers(numbers: str, reverse: bool = False) -> str", "output_format": "A space-delimited string of sorted numerals", "test_input": ["assert sort_numbers('three one five') == 'one three five'", "assert sort_numbers('three one five', reverse=True) == 'five three one'", "assert sort_numbers('nine eight seven six', reverse=True) == 'nine eight seven six'", "assert sort_numbers('zero nine eight', reverse=False) == 'zero eight nine'", "assert sort_numbers('') == ''"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "HumanEval/19-3", "raw_problem": "from typing import List\n\n\ndef sort_numbers(numbers: str) -> str:\n    \"\"\" Input is a space-delimited string of numberals from 'zero' to 'nine'.\n    Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n    Return the string with numbers sorted from smallest to largest\n    >>> sort_numbers('three one five')\n    'one three five'\n    \"\"\"", "raw_solution": "```python\n\n    \n    to_int = {'zero': 0, 'one': 1, 'two': 2, 'three': 3, 'four': 4, 'five': 5, 'six': 6, 'seven': 7, 'eight': 8, 'nine': 9}\n\n    if numbers == \"\": return \"\"\n    return \" \".join(sorted(numbers.split(\" \"), key=lambda n: to_int[n]))\n\n\n```", "raw_test_input": ["assert sort_numbers('') == ''", "assert sort_numbers('three') == 'three'", "assert sort_numbers('three five nine') == 'three five nine'", "assert sort_numbers('five zero four seven nine eight') == 'zero four five seven eight nine'", "assert sort_numbers('six five four three two one zero') == 'zero one two three four five six'"], "new_problem": "Given a dictionary where each key is a category and each value is a list of space-delimited strings of numerals from 'zero' to 'nine', sort the numbers in each string from smallest to largest. Return a dictionary with the same keys and sorted number strings as values. Ensure that the input dictionary can have up to 100 categories, and each category can have up to 1000 strings.", "new_solution": "```python\nfrom typing import Dict, List\n\ndef sort_numbers(numbers: str) -> str:\n    to_int = {'zero': 0, 'one': 1, 'two': 2, 'three': 3, 'four': 4, 'five': 5, 'six': 6, 'seven': 7, 'eight': 8, 'nine': 9}\n    if numbers == '': return ''\n    return ' '.join(sorted(numbers.split(' '), key=lambda n: to_int[n]))\n\ndef sort_category_numbers(data: Dict[str, List[str]]) -> Dict[str, List[str]]:\n    return {category: [sort_numbers(numbers) for numbers in number_list] for category, number_list in data.items()}\n```", "input_format": "A dictionary where keys are strings representing categories and values are lists of space-delimited strings of numerals from 'zero' to 'nine'.", "output_format": "A dictionary where keys are the same categories and values are lists of strings with numbers sorted from smallest to largest.", "test_input": ["assert sort_category_numbers({'fruits': ['three one five', 'two four'], 'vegetables': ['nine eight', 'seven six']}) == {'fruits': ['one three five', 'two four'], 'vegetables': ['eight nine', 'six seven']}", "assert sort_category_numbers({'animals': ['zero nine', 'one two three'], 'colors': ['four five', 'six seven eight']}) == {'animals': ['zero nine', 'one two three'], 'colors': ['four five', 'six seven eight']}", "assert sort_category_numbers({'empty': ['']}) == {'empty': ['']}", "assert sort_category_numbers({'mixed': ['five four three', 'two one zero']}) == {'mixed': ['three four five', 'zero one two']}", "assert sort_category_numbers({'single': ['nine']}) == {'single': ['nine']}"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "HumanEval/19-4", "raw_problem": "from typing import List\n\n\ndef sort_numbers(numbers: str) -> str:\n    \"\"\" Input is a space-delimited string of numberals from 'zero' to 'nine'.\n    Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n    Return the string with numbers sorted from smallest to largest\n    >>> sort_numbers('three one five')\n    'one three five'\n    \"\"\"", "raw_solution": "```python\n\n    \n    to_int = {'zero': 0, 'one': 1, 'two': 2, 'three': 3, 'four': 4, 'five': 5, 'six': 6, 'seven': 7, 'eight': 8, 'nine': 9}\n\n    if numbers == \"\": return \"\"\n    return \" \".join(sorted(numbers.split(\" \"), key=lambda n: to_int[n]))\n\n\n```", "raw_test_input": ["assert sort_numbers('') == ''", "assert sort_numbers('three') == 'three'", "assert sort_numbers('three five nine') == 'three five nine'", "assert sort_numbers('five zero four seven nine eight') == 'zero four five seven eight nine'", "assert sort_numbers('six five four three two one zero') == 'zero one two three four five six'"], "new_problem": "Extend the `sort_numbers` function to handle errors in a real-world scenario where the input string may contain invalid numerals or be empty. The function should raise a `ValueError` with a meaningful message if an invalid numeral is encountered. If the input is empty, it should return an empty string without error. Additionally, handle any unexpected errors gracefully and propagate them with a custom error message.", "new_solution": "```python\nfrom typing import List\n\nclass InvalidNumeralError(ValueError):\n    pass\n\ndef sort_numbers(numbers: str) -> str:\n    \"\"\" Input is a space-delimited string of numerals from 'zero' to 'nine'.\n    Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n    Return the string with numbers sorted from smallest to largest\n    \"\"\"\n    to_int = {'zero': 0, 'one': 1, 'two': 2, 'three': 3, 'four': 4, 'five': 5, 'six': 6, 'seven': 7, 'eight': 8, 'nine': 9}\n\n    if numbers == \"\":\n        return \"\"\n\n    try:\n        return \" \".join(sorted(numbers.split(\" \"), key=lambda n: to_int[n]))\n    except KeyError as e:\n        raise InvalidNumeralError(f\"Invalid numeral encountered: {e.args[0]}\")\n    except TypeError:\n        raise Exception(\"An unexpected error occurred: Input must be a string\")\n    except Exception as e:\n        raise Exception(f\"An unexpected error occurred: \")\n```", "input_format": "A space-delimited string of numerals from 'zero' to 'nine'.", "output_format": "A space-delimited string of numerals sorted from smallest to largest.", "test_input": ["assert sort_numbers('three one five') == 'one three five'", "assert sort_numbers('') == ''", "try:\n    sort_numbers('three one eleven')\nexcept InvalidNumeralError as e:\n    assert str(e) == 'Invalid numeral encountered: eleven'", "try:\n    sort_numbers('three one 5')\nexcept InvalidNumeralError as e:\n    assert str(e) == 'Invalid numeral encountered: 5'", "try:\n    sort_numbers(None)\nexcept Exception as e:\n    assert str(e) == 'An unexpected error occurred: '"], "requirement_type": "PROMPT_ERROR_HANDLING"}
{"task_id": "HumanEval/20-1", "raw_problem": "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"", "raw_solution": "```python\n\n\n    numbers.sort()\n    min_diff = float(\"inf\")\n    min_pair = None\n    for l, r in zip(numbers[:-1], numbers[1:]):\n        diff = r - l\n        if diff < min_diff:\n            min_diff = diff\n            min_pair = (l, r)\n    return min_pair\n\n\n```", "raw_test_input": ["assert find_closest_elements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0)", "assert find_closest_elements([1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9)", "assert find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2)", "assert find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0)", "assert find_closest_elements([1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1)"], "new_problem": "In the context of stock market analysis, you are given a list of lists, where each sublist contains daily stock prices for a specific company over a period of time. Your task is to identify the two closest stock prices for each company and return them in a dictionary. The keys of the dictionary should be the indices of the sublists (representing different companies), and the values should be tuples containing the closest stock prices for that company. Use the original function 'find_closest_elements' as a core component to solve this problem.", "new_solution": "```python\nfrom typing import List, Tuple, Dict\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    numbers.sort()\n    min_diff = float('inf')\n    min_pair = None\n    for l, r in zip(numbers[:-1], numbers[1:]):\n        diff = r - l\n        if diff < min_diff:\n            min_diff = diff\n            min_pair = (l, r)\n    return min_pair\n\ndef find_closest_stock_prices(stock_data: List[List[float]]) -> Dict[int, Tuple[float, float]]:\n    closest_prices = {}\n    for index, prices in enumerate(stock_data):\n        if len(prices) < 2:\n            closest_prices[index] = (None, None)\n        else:\n            closest_prices[index] = find_closest_elements(prices)\n    return closest_prices\n```", "input_format": "A list of lists, where each sublist contains floating-point numbers representing daily stock prices for different companies.", "output_format": "A dictionary where keys are the indices of the sublists (representing companies) and values are tuples of the closest stock prices for each company.", "test_input": ["assert find_closest_stock_prices([[1.0, 2.0, 3.0, 4.0, 5.0, 2.2], [10.0, 10.5, 11.0, 12.0, 13.0]]) == {0: (2.0, 2.2), 1: (10.0, 10.5)}", "assert find_closest_stock_prices([[1.0, 2.0, 3.0, 4.0, 5.0, 2.0], [5.0, 5.1, 5.2, 5.3, 5.4]]) == {0: (2.0, 2.0), 1: (5.0, 5.1)}", "assert find_closest_stock_prices([[100.0, 101.0, 102.0, 103.0], [200.0, 201.0, 202.0, 203.0]]) == {0: (100.0, 101.0), 1: (200.0, 201.0)}", "assert find_closest_stock_prices([[1.5, 1.6, 1.7, 1.8], [2.5, 2.6, 2.7, 2.8]]) == {0: (1.6, 1.7), 1: (2.7, 2.8)}", "assert find_closest_stock_prices([[0.1, 0.2, 0.3, 0.4], [0.5, 0.6, 0.7, 0.8]]) == {0: (0.2, 0.3), 1: (0.5, 0.6)}"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "HumanEval/20-2", "raw_problem": "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"", "raw_solution": "```python\n\n\n    numbers.sort()\n    min_diff = float(\"inf\")\n    min_pair = None\n    for l, r in zip(numbers[:-1], numbers[1:]):\n        diff = r - l\n        if diff < min_diff:\n            min_diff = diff\n            min_pair = (l, r)\n    return min_pair\n\n\n```", "raw_test_input": ["assert find_closest_elements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0)", "assert find_closest_elements([1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9)", "assert find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2)", "assert find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0)", "assert find_closest_elements([1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1)"], "new_problem": "Enhance the function to optionally return the indices of the closest elements in addition to the elements themselves. The function should maintain backward compatibility, meaning it should still return just the closest elements by default. Add an optional parameter `return_indices` which, when set to True, will make the function return a tuple containing the closest elements and their indices.", "new_solution": "from typing import List, Tuple\n\ndef find_closest_elements(numbers: List[float], return_indices: bool = False) -> Tuple[float, float] or Tuple[Tuple[float, float], Tuple[int, int]]:\n    numbers_with_indices = list(enumerate(numbers))\n    numbers_with_indices.sort(key=lambda x: x[1])\n    min_diff = float('inf')\n    min_pair = None\n    min_indices = None\n    for (i, l), (j, r) in zip(numbers_with_indices[:-1], numbers_with_indices[1:]):\n        diff = r - l\n        if diff < min_diff:\n            min_diff = diff\n            min_pair = (l, r)\n            min_indices = (i, j)\n    if return_indices:\n        return min_pair, min_indices\n    return min_pair", "input_format": "List[float], optional parameter: return_indices: bool = False", "output_format": "Tuple[float, float] or Tuple[Tuple[float, float], Tuple[int, int]]", "test_input": ["assert find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2)", "assert find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0)", "assert find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2], return_indices=True) == ((2.0, 2.2), (1, 5))", "assert find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], return_indices=True) == ((2.0, 2.0), (1, 5))", "assert find_closest_elements([10.0, 20.0, 30.0, 40.0, 50.0, 20.1], return_indices=True) == ((20.0, 20.1), (1, 5))"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "HumanEval/20-3", "raw_problem": "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"", "raw_solution": "```python\n\n\n    numbers.sort()\n    min_diff = float(\"inf\")\n    min_pair = None\n    for l, r in zip(numbers[:-1], numbers[1:]):\n        diff = r - l\n        if diff < min_diff:\n            min_diff = diff\n            min_pair = (l, r)\n    return min_pair\n\n\n```", "raw_test_input": ["assert find_closest_elements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0)", "assert find_closest_elements([1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9)", "assert find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2)", "assert find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0)", "assert find_closest_elements([1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1)"], "new_problem": "Given a dictionary where each key is a category and the value is a list of floating-point numbers, find the two closest numbers in each category and return a dictionary with the same keys, where the values are tuples of the closest numbers in ascending order. The input dictionary will have at least one category with at least two numbers. Additionally, ensure that the solution can handle cases where the lists are very large efficiently.", "new_solution": "```python\nfrom typing import Dict, List, Tuple\n\ndef find_closest_elements_in_categories(data: Dict[str, List[float]]) -> Dict[str, Tuple[float, float]]:\n    def find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n        numbers.sort()\n        min_diff = float('inf')\n        min_pair = None\n        for l, r in zip(numbers[:-1], numbers[1:]):\n            diff = r - l\n            if diff < min_diff:\n                min_diff = diff\n                min_pair = (l, r)\n        return min_pair\n\n    result = {}\n    for category, numbers in data.items():\n        if len(numbers) >= 2:\n            result[category] = find_closest_elements(numbers)\n    return result\n```", "input_format": "Dict[str, List[float]]", "output_format": "Dict[str, Tuple[float, float]]", "test_input": ["assert find_closest_elements_in_categories({'A': [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]}) == {'A': (2.0, 2.2)}", "assert find_closest_elements_in_categories({'A': [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]}) == {'A': (2.0, 2.0)}", "assert find_closest_elements_in_categories({'A': [1.0, 3.0, 5.0], 'B': [2.0, 2.1, 2.2]}) == {'A': (1.0, 3.0), 'B': (2.0, 2.1)}", "assert find_closest_elements_in_categories({'A': [1.0, 1.1, 1.2], 'B': [3.0, 3.1, 3.2]}) == {'A': (1.1, 1.2), 'B': (3.0, 3.1)}", "assert find_closest_elements_in_categories({'A': [10.0, 20.0, 30.0], 'B': [15.0, 25.0, 35.0]}) == {'A': (10.0, 20.0), 'B': (15.0, 25.0)}"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "HumanEval/20-4", "raw_problem": "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"", "raw_solution": "```python\n\n\n    numbers.sort()\n    min_diff = float(\"inf\")\n    min_pair = None\n    for l, r in zip(numbers[:-1], numbers[1:]):\n        diff = r - l\n        if diff < min_diff:\n            min_diff = diff\n            min_pair = (l, r)\n    return min_pair\n\n\n```", "raw_test_input": ["assert find_closest_elements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0)", "assert find_closest_elements([1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9)", "assert find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2)", "assert find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0)", "assert find_closest_elements([1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1)"], "new_problem": "Modify the function `find_closest_elements` to handle errors in a real-world scenario where the input list may not always be valid. The function should raise a `ValueError` if the list contains fewer than two elements, a `TypeError` if the list contains non-numeric values, and a `CustomError` if the list is empty. Implement error handling to ensure that these errors are properly raised and propagated with meaningful error messages.", "new_solution": "from typing import List, Tuple\n\nclass CustomError(Exception):\n    pass\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \"\"\"\n    if not numbers:\n        raise CustomError(\"The list is empty.\")\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two elements.\")\n    if not all(isinstance(n, (int, float)) for n in numbers):\n        raise TypeError(\"All elements in the list must be numbers.\")\n\n    numbers.sort()\n    min_diff = float(\"inf\")\n    min_pair = None\n    for l, r in zip(numbers[:-1], numbers[1:]):\n        diff = r - l\n        if diff < min_diff:\n            min_diff = diff\n            min_pair = (l, r)\n    return min_pair\n", "input_format": "List[float]", "output_format": "Tuple[float, float]", "test_input": ["assert find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2)", "assert find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0)", "try:\n    find_closest_elements([])\nexcept CustomError as e:\n    assert str(e) == \"The list is empty.\"", "try:\n    find_closest_elements([1.0])\nexcept ValueError as e:\n    assert str(e) == \"The list must contain at least two elements.\"", "try:\n    find_closest_elements([1.0, 'a', 3.0])\nexcept TypeError as e:\n    assert str(e) == \"All elements in the list must be numbers.\""], "requirement_type": "PROMPT_ERROR_HANDLING"}
{"task_id": "HumanEval/21-1", "raw_problem": "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"", "raw_solution": "```python\n\n\n    ma, mi = max(numbers), min(numbers)\n    k = 1 / (ma - mi)\n    return list(map(lambda x: (x - mi) * k, numbers))\n\n\n```", "raw_test_input": ["assert rescale_to_unit([2.0, 49.9]) == [0.0, 1.0]", "assert rescale_to_unit([100.0, 49.9]) == [1.0, 0.0]", "assert rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]", "assert rescale_to_unit([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]", "assert rescale_to_unit([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]"], "new_problem": "In an e-commerce platform, you have multiple categories of products, each with a list of prices. You want to normalize the prices within each category to a scale from 0 to 1 to analyze price distribution patterns. Implement a function that takes a list of categories with their respective prices and returns a dictionary where each category is mapped to its list of rescaled prices.", "new_solution": "from typing import List, Dict\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    ma, mi = max(numbers), min(numbers)\n    k = 1 / (ma - mi)\n    return list(map(lambda x: (x - mi) * k, numbers))\n\ndef rescale_prices_by_category(categories: List[Dict[str, List[float]]]) -> Dict[str, List[float]]:\n    rescaled_prices = {}\n    for category in categories:\n        category_name = category['category']\n        prices = category['values']\n        rescaled_prices[category_name] = rescale_to_unit(prices)\n    return rescaled_prices", "input_format": "A list of dictionaries, each containing a 'category' key and a 'values' key which is a list of floats.", "output_format": "A dictionary where each category maps to a list of rescaled values between 0 and 1.", "test_input": ["assert rescale_prices_by_category([{'category': 'electronics', 'values': [100.0, 200.0, 300.0]}, {'category': 'clothing', 'values': [50.0, 75.0, 100.0]}]) == {'electronics': [0.0, 0.5, 1.0], 'clothing': [0.0, 0.5, 1.0]}", "assert rescale_prices_by_category([{'category': 'books', 'values': [10.0, 20.0, 30.0, 40.0]}]) == {'books': [0.0, 0.3333333333333333, 0.6666666666666666, 1.0]}", "assert rescale_prices_by_category([{'category': 'furniture', 'values': [500.0, 1000.0, 1500.0]}]) == {'furniture': [0.0, 0.5, 1.0]}", "assert rescale_prices_by_category([{'category': 'toys', 'values': [5.0, 10.0, 15.0, 20.0, 25.0]}]) == {'toys': [0.0, 0.25, 0.5, 0.75, 1.0]}", "assert rescale_prices_by_category([{'category': 'groceries', 'values': [2.0, 4.0, 6.0, 8.0]}]) == {'groceries': [0.0, 0.3333333333333333, 0.6666666666666666, 1.0]}"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "HumanEval/21-2", "raw_problem": "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"", "raw_solution": "```python\n\n\n    ma, mi = max(numbers), min(numbers)\n    k = 1 / (ma - mi)\n    return list(map(lambda x: (x - mi) * k, numbers))\n\n\n```", "raw_test_input": ["assert rescale_to_unit([2.0, 49.9]) == [0.0, 1.0]", "assert rescale_to_unit([100.0, 49.9]) == [1.0, 0.0]", "assert rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]", "assert rescale_to_unit([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]", "assert rescale_to_unit([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]"], "new_problem": "Enhance the rescale_to_unit function to allow optional parameters min_value and max_value. These parameters should allow the user to specify the desired range for the rescaled values. If not provided, the function should default to rescaling between 0 and 1, maintaining backward compatibility.", "new_solution": "from typing import List, Optional\n\ndef rescale_to_unit(numbers: List[float], min_value: Optional[float] = 0.0, max_value: Optional[float] = 1.0) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become min_value and the largest will become max_value\n    \"\"\"\n    ma, mi = max(numbers), min(numbers)\n    k = (max_value - min_value) / (ma - mi)\n    return list(map(lambda x: (x - mi) * k + min_value, numbers))", "input_format": "List[float], optional float min_value, optional float max_value", "output_format": "List[float]", "test_input": ["assert rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]", "assert rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0], 10.0, 20.0) == [10.0, 12.5, 15.0, 17.5, 20.0]", "assert rescale_to_unit([5.0, 10.0, 15.0], -1.0, 1.0) == [-1.0, 0.0, 1.0]", "assert rescale_to_unit([0.0, 50.0, 100.0], 0.0, 100.0) == [0.0, 50.0, 100.0]", "assert rescale_to_unit([-10.0, 0.0, 10.0], 0.0, 1.0) == [0.0, 0.5, 1.0]"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "HumanEval/21-3", "raw_problem": "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"", "raw_solution": "```python\n\n\n    ma, mi = max(numbers), min(numbers)\n    k = 1 / (ma - mi)\n    return list(map(lambda x: (x - mi) * k, numbers))\n\n\n```", "raw_test_input": ["assert rescale_to_unit([2.0, 49.9]) == [0.0, 1.0]", "assert rescale_to_unit([100.0, 49.9]) == [1.0, 0.0]", "assert rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]", "assert rescale_to_unit([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]", "assert rescale_to_unit([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]"], "new_problem": "Given a dictionary where each key is a category and the value is a list of numbers, apply a linear transform to each list such that the smallest number in each list becomes 0 and the largest becomes 1. Ensure that each list has at least two elements. Additionally, ensure that the transformation is applied only to lists where the difference between the maximum and minimum is greater than a specified threshold.", "new_solution": "from typing import Dict, List\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    ma, mi = max(numbers), min(numbers)\n    k = 1 / (ma - mi)\n    return list(map(lambda x: (x - mi) * k, numbers))\n\ndef rescale_dict(data: Dict[str, List[float]], threshold: float) -> Dict[str, List[float]]:\n    rescaled_data = {}\n    for category, numbers in data.items():\n        if len(numbers) < 2:\n            raise ValueError(\"Each list must contain at least two elements.\")\n        ma, mi = max(numbers), min(numbers)\n        if ma - mi > threshold:\n            rescaled_data[category] = rescale_to_unit(numbers)\n        else:\n            rescaled_data[category] = numbers\n    return rescaled_data", "input_format": "Dict[str, List[float]]", "output_format": "Dict[str, List[float]]", "test_input": ["assert rescale_dict({'a': [1.0, 2.0, 3.0], 'b': [4.0, 5.0, 6.0]}, 0.5) == {'a': [0.0, 0.5, 1.0], 'b': [0.0, 0.5, 1.0]}", "assert rescale_dict({'a': [1.0, 1.1, 1.2], 'b': [4.0, 5.0, 6.0]}, 0.5) == {'a': [1.0, 1.1, 1.2], 'b': [0.0, 0.5, 1.0]}", "assert rescale_dict({'a': [10.0, 20.0], 'b': [30.0, 40.0]}, 5.0) == {'a': [0.0, 1.0], 'b': [0.0, 1.0]}", "assert rescale_dict({'a': [1.0, 2.0], 'b': [2.0, 2.0]}, 0.5) == {'a': [0.0, 1.0], 'b': [2.0, 2.0]}", "assert rescale_dict({'a': [1.0, 3.0, 5.0], 'b': [5.0, 5.0, 5.0]}, 1.0) == {'a': [0.0, 0.5, 1.0], 'b': [5.0, 5.0, 5.0]}"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "HumanEval/21-4", "raw_problem": "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"", "raw_solution": "```python\n\n\n    ma, mi = max(numbers), min(numbers)\n    k = 1 / (ma - mi)\n    return list(map(lambda x: (x - mi) * k, numbers))\n\n\n```", "raw_test_input": ["assert rescale_to_unit([2.0, 49.9]) == [0.0, 1.0]", "assert rescale_to_unit([100.0, 49.9]) == [1.0, 0.0]", "assert rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]", "assert rescale_to_unit([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]", "assert rescale_to_unit([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]"], "new_problem": "Modify the function `rescale_to_unit` to handle errors in a real-world scenario where the input list may not meet the expected conditions. Specifically, handle the following errors: 1) The input list is empty or has only one element, which makes rescaling impossible. 2) The input list contains non-numeric values. 3) All elements in the list are the same, leading to a division by zero. Implement custom exceptions for these cases and ensure meaningful error messages are provided. The function should propagate errors appropriately.", "new_solution": "from typing import List\n\nclass RescaleError(Exception):\n    pass\n\nclass EmptyListError(RescaleError):\n    def __init__(self):\n        super().__init__('The input list must contain at least two elements.')\n\nclass NonNumericValueError(RescaleError):\n    def __init__(self, value):\n        super().__init__(f'Non-numeric value found: {value}')\n\nclass UniformValueError(RescaleError):\n    def __init__(self):\n        super().__init__('All elements in the list are the same, cannot rescale.')\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    if len(numbers) < 2:\n        raise EmptyListError()\n    \n    for num in numbers:\n        if not isinstance(num, (int, float)):\n            raise NonNumericValueError(num)\n\n    ma, mi = max(numbers), min(numbers)\n    if ma == mi:\n        raise UniformValueError()\n\n    k = 1 / (ma - mi)\n    return list(map(lambda x: (x - mi) * k, numbers))", "input_format": "List[float]", "output_format": "List[float]", "test_input": ["try:\n    rescale_to_unit([])\nexcept EmptyListError as e:\n    assert str(e) == 'The input list must contain at least two elements.'", "try:\n    rescale_to_unit([5.0])\nexcept EmptyListError as e:\n    assert str(e) == 'The input list must contain at least two elements.'", "try:\n    rescale_to_unit([1.0, 'a', 3.0])\nexcept NonNumericValueError as e:\n    assert str(e) == 'Non-numeric value found: a'", "try:\n    rescale_to_unit([2.0, 2.0, 2.0])\nexcept UniformValueError as e:\n    assert str(e) == 'All elements in the list are the same, cannot rescale.'", "assert rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]"], "requirement_type": "PROMPT_ERROR_HANDLING"}
{"task_id": "HumanEval/22-1", "raw_problem": "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\"", "raw_solution": "```python\n\n    return list(filter(lambda x: type(x) == int, values))\n\n\n```", "raw_test_input": ["assert filter_integers([]) == []", "assert filter_integers([4, {}, [], 23.2, 9, 'adasd']) == [4, 9]", "assert filter_integers([3, 'c', 3, 3, 'a', 'b']) == [3, 3, 3]"], "new_problem": "In an e-commerce platform, you have a list of transactions where each transaction is represented as a dictionary containing various data types (e.g., strings, floats, integers, lists, etc.). You need to calculate the total sum of all integer values across all transactions and also return a list of filtered integers for each transaction. Use the original function 'filter_integers' to help achieve this.", "new_solution": "```python\nfrom typing import List, Any, Dict\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    return list(filter(lambda x: type(x) == int, values))\n\ndef process_transactions(transactions: List[Dict[str, Any]]) -> Dict[str, Any]:\n    total_sum = 0\n    filtered_integers_per_transaction = []\n    for transaction in transactions:\n        integers = filter_integers(list(transaction.values()))\n        total_sum += sum(integers)\n        filtered_integers_per_transaction.append(integers)\n    return {\n        'total_sum': total_sum,\n        'filtered_integers_per_transaction': filtered_integers_per_transaction\n    }\n```", "input_format": "A list of dictionaries, each representing a transaction with various data types.", "output_format": "A dictionary with the total sum of integer values from all transactions and a list of filtered integers from each transaction.", "test_input": ["assert process_transactions([{'id': 1, 'amount': 100, 'description': 'Book'}, {'id': 2, 'amount': 200, 'description': 'Pen'}]) == {'total_sum': 303, 'filtered_integers_per_transaction': [[1, 100], [2, 200]]}", "assert process_transactions([{'id': 1, 'amount': 50.5, 'description': 'Notebook'}, {'id': 2, 'amount': 150, 'description': 'Pencil', 'extra': 10}]) == {'total_sum': 163, 'filtered_integers_per_transaction': [[1], [2, 150, 10]]}", "assert process_transactions([{'id': 1, 'amount': '100', 'description': 'Eraser'}, {'id': 2, 'amount': 0, 'description': 'Sharpener'}]) == {'total_sum': 3, 'filtered_integers_per_transaction': [[1], [2, 0]]}", "assert process_transactions([{'id': 1, 'amount': 0, 'description': 'Ruler'}, {'id': 2, 'amount': 0, 'description': 'Compass'}]) == {'total_sum': 3, 'filtered_integers_per_transaction': [[1, 0], [2, 0]]}", "assert process_transactions([{'id': 1, 'amount': 100, 'description': 'Bag', 'discount': 5}, {'id': 2, 'amount': 200, 'description': 'Shoes', 'discount': 10}]) == {'total_sum': 318, 'filtered_integers_per_transaction': [[1, 100, 5], [2, 200, 10]]}"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "HumanEval/22-2", "raw_problem": "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\"", "raw_solution": "```python\n\n    return list(filter(lambda x: type(x) == int, values))\n\n\n```", "raw_test_input": ["assert filter_integers([]) == []", "assert filter_integers([4, {}, [], 23.2, 9, 'adasd']) == [4, 9]", "assert filter_integers([3, 'c', 3, 3, 'a', 'b']) == [3, 3, 3]"], "new_problem": "Enhance the function `filter_integers` to optionally filter out negative integers while maintaining backward compatibility. The function should accept an additional optional parameter `exclude_negatives` (defaulting to False). If `exclude_negatives` is set to True, the function should return only non-negative integers from the list.", "new_solution": "from typing import List, Any, Optional\n\ndef filter_integers(values: List[Any], exclude_negatives: Optional[bool] = False) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers, optionally excluding negative integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    >>> filter_integers([1, -2, 3, -4, 5], exclude_negatives=True)\n    [1, 3, 5]\n    \"\"\"\n    if exclude_negatives:\n        return list(filter(lambda x: type(x) == int and x >= 0, values))\n    return list(filter(lambda x: type(x) == int, values))", "input_format": "List[Any], Optional[bool]", "output_format": "List[int]", "test_input": ["assert filter_integers(['a', 3.14, 5]) == [5]", "assert filter_integers([1, 2, 3, 'abc', {}, []]) == [1, 2, 3]", "assert filter_integers([1, -2, 3, -4, 5], exclude_negatives=True) == [1, 3, 5]", "assert filter_integers([1, -2, 3, -4, 5], exclude_negatives=False) == [1, -2, 3, -4, 5]", "assert filter_integers([0, -1, -2, -3], exclude_negatives=True) == [0]"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "HumanEval/22-3", "raw_problem": "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\"", "raw_solution": "```python\n\n    return list(filter(lambda x: type(x) == int, values))\n\n\n```", "raw_test_input": ["assert filter_integers([]) == []", "assert filter_integers([4, {}, [], 23.2, 9, 'adasd']) == [4, 9]", "assert filter_integers([3, 'c', 3, 3, 'a', 'b']) == [3, 3, 3]"], "new_problem": "Given a dictionary where keys are strings and values are lists of any Python values, filter each list to only include integers. Return a new dictionary with the same keys but with lists of integers as values. Additionally, ensure that the lists of integers are sorted in ascending order.", "new_solution": "from typing import Dict, List, Any\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    return list(filter(lambda x: type(x) == int, values))\n\ndef filter_and_sort_integer_dict(data: Dict[str, List[Any]]) -> Dict[str, List[int]]:\n    return {key: sorted(filter_integers(value)) for key, value in data.items()}", "input_format": "Dict[str, Any]", "output_format": "Dict[str, List[int]]", "test_input": ["assert filter_and_sort_integer_dict({'a': ['a', 3.14, 5], 'b': [1, 2, 3, 'abc', {}, []]}) == {'a': [5], 'b': [1, 2, 3]}", "assert filter_and_sort_integer_dict({'x': [10, 'y', 5, 3.14], 'y': [7, 2, 'z', 1]}) == {'x': [5, 10], 'y': [1, 2, 7]}", "assert filter_and_sort_integer_dict({'empty': [], 'mixed': [3, 'a', 2, 1]}) == {'empty': [], 'mixed': [1, 2, 3]}", "assert filter_and_sort_integer_dict({'numbers': [5, 3, 9, 1], 'none': [None, 'none', 0]}) == {'numbers': [1, 3, 5, 9], 'none': [0]}", "assert filter_and_sort_integer_dict({'single': [42], 'no_ints': ['a', 'b', 'c']}) == {'single': [42], 'no_ints': []}"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "HumanEval/22-4", "raw_problem": "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\"", "raw_solution": "```python\n\n    return list(filter(lambda x: type(x) == int, values))\n\n\n```", "raw_test_input": ["assert filter_integers([]) == []", "assert filter_integers([4, {}, [], 23.2, 9, 'adasd']) == [4, 9]", "assert filter_integers([3, 'c', 3, 3, 'a', 'b']) == [3, 3, 3]"], "new_problem": "Create a function `safe_filter_integers` that filters a list of any Python values to only include integers. The function should handle the following errors: 1) Raise a `TypeError` if the input is not a list. 2) Raise a `ValueError` if any element in the list is not a valid Python object (e.g., None or an undefined variable). 3) Propagate any unexpected errors with a meaningful error message. The function should return a list of integers.", "new_solution": "```python\nfrom typing import List, Any\n\nclass InvalidInputError(Exception):\n    pass\n\nclass InvalidElementError(Exception):\n    pass\n\ndef safe_filter_integers(values: List[Any]) -> List[int]:\n    if not isinstance(values, list):\n        raise TypeError('Input must be a list.')\n    try:\n        for value in values:\n            if value is None:\n                raise InvalidElementError('List contains invalid elements.')\n        return list(filter(lambda x: isinstance(x, int), values))\n    except TypeError as e:\n        raise InvalidElementError('List contains invalid elements.') from e\n    except Exception as e:\n        raise InvalidElementError('List contains invalid elements.') from e\n```", "input_format": "List[Any]", "output_format": "List[int]", "test_input": ["assert safe_filter_integers([1, 2, 3, 'abc', {}, []]) == [1, 2, 3]", "assert safe_filter_integers(['a', 3.14, 5]) == [5]", "try:\n    safe_filter_integers('not a list')\nexcept TypeError as e:\n    assert str(e) == 'Input must be a list.'", "try:\n    safe_filter_integers([1, None, 3])\nexcept InvalidElementError as e:\n    assert str(e) == 'List contains invalid elements.'", "try:\n    safe_filter_integers([1, 2, 3, undefined_variable])\nexcept NameError as e:\n    assert str(e) == \"name 'undefined_variable' is not defined\""], "requirement_type": "PROMPT_ERROR_HANDLING"}
{"task_id": "HumanEval/23-1", "raw_problem": "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\"", "raw_solution": "```python\n\n    return len(string)\n\n\n```", "raw_test_input": ["assert strlen('') == 0", "assert strlen('x') == 1", "assert strlen('asdasnakj') == 9"], "new_problem": "In an e-commerce platform, you need to filter product descriptions to ensure they do not exceed a certain length for display purposes. Write a function that takes a list of product descriptions and a maximum length, and returns a list of descriptions that are within the specified length. Use the original strlen function to determine the length of each description.", "new_solution": "```python\ndef strlen(string: str) -> int:\n    return len(string)\n\ndef filter_descriptions(descriptions: list, max_length: int) -> list:\n    ans = [desc for desc in descriptions if strlen(desc) <= max_length]\n    return ans if ans else ['']\n```", "input_format": "List of product descriptions and a maximum length integer", "output_format": "List of product descriptions that are within the maximum length", "test_input": ["assert filter_descriptions(['Short', 'This is a longer description', 'Medium length'], 10) == ['Short']", "assert filter_descriptions(['Apple', 'Banana', 'Cherry'], 6) == ['Apple', 'Banana', 'Cherry']", "assert filter_descriptions(['Tiny', 'Small', 'Moderate', 'Extensive'], 7) == ['Tiny', 'Small']", "assert filter_descriptions(['A', 'AB', 'ABC', 'ABCD'], 3) == ['A', 'AB', 'ABC']", "assert filter_descriptions(['', 'A', 'AB', 'ABC'], 0) == ['']"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "HumanEval/23-2", "raw_problem": "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\"", "raw_solution": "```python\n\n    return len(string)\n\n\n```", "raw_test_input": ["assert strlen('') == 0", "assert strlen('x') == 1", "assert strlen('asdasnakj') == 9"], "new_problem": "Enhance the strlen function to optionally exclude spaces from the length count while maintaining backward compatibility. The function should take an additional optional parameter 'count_spaces' which defaults to True. If 'count_spaces' is set to False, spaces should not be counted in the string length.", "new_solution": "def strlen(string: str, count_spaces: bool = True) -> int:\n    \"\"\" Return length of given string, optionally excluding spaces\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    >>> strlen('a b c', count_spaces=False)\n    3\n    \"\"\"\n    if count_spaces:\n        return len(string)\n    else:\n        return len(string.replace(' ', ''))", "input_format": "strlen(string: str, count_spaces: bool = True) -> int", "output_format": "int", "test_input": ["assert strlen('') == 0", "assert strlen('abc') == 3", "assert strlen('a b c', count_spaces=False) == 3", "assert strlen('a b c', count_spaces=True) == 5", "assert strlen('   ', count_spaces=False) == 0"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "HumanEval/23-3", "raw_problem": "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\"", "raw_solution": "```python\n\n    return len(string)\n\n\n```", "raw_test_input": ["assert strlen('') == 0", "assert strlen('x') == 1", "assert strlen('asdasnakj') == 9"], "new_problem": "Given a list of dictionaries where each dictionary represents a person with a 'name' key, return a dictionary where each key is a person's name and the value is the length of that name. Ensure that the list does not contain duplicate names and handle cases where the list might be empty.", "new_solution": "```python\nfrom typing import List, Dict\n\ndef name_lengths(people: List[Dict[str, str]]) -> Dict[str, int]:\n    \"\"\" Return a dictionary with names as keys and their lengths as values \"\"\"\n    return {person['name']: len(person['name']) for person in people}\n```", "input_format": "List[Dict[str, str]]", "output_format": "Dict[str, int]", "test_input": ["assert name_lengths([]) == {}", "assert name_lengths([{'name': 'Alice'}]) == {'Alice': 5}", "assert name_lengths([{'name': 'Bob'}, {'name': 'Charlie'}]) == {'Bob': 3, 'Charlie': 7}", "assert name_lengths([{'name': 'David'}, {'name': 'Eve'}, {'name': 'Frank'}]) == {'David': 5, 'Eve': 3, 'Frank': 5}", "assert name_lengths([{'name': 'Grace'}, {'name': 'Heidi'}, {'name': 'Ivan'}]) == {'Grace': 5, 'Heidi': 5, 'Ivan': 4}"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "HumanEval/23-4", "raw_problem": "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\"", "raw_solution": "```python\n\n    return len(string)\n\n\n```", "raw_test_input": ["assert strlen('') == 0", "assert strlen('x') == 1", "assert strlen('asdasnakj') == 9"], "new_problem": "Create a function `safe_strlen` that returns the length of a given string. The function should handle the following errors: 1) If the input is not a string, raise a `TypeError` with a meaningful message. 2) If the input string is excessively long (e.g., more than 1000 characters), raise a `ValueError` with a message indicating the string is too long. Implement error propagation to ensure that these errors can be caught and handled by the caller.", "new_solution": "def safe_strlen(string: str) -> int:\n    \"\"\" Return length of given string with error handling for non-string inputs and excessively long strings \"\"\"\n    if not isinstance(string, str):\n        raise TypeError(\"Input must be a string\")\n    if len(string) > 1000:\n        raise ValueError(\"String is too long\")\n    return len(string)", "input_format": "string: str", "output_format": "int", "test_input": ["assert safe_strlen('') == 0", "assert safe_strlen('abc') == 3", "try:\n    safe_strlen(123)\nexcept TypeError as e:\n    assert str(e) == 'Input must be a string'", "try:\n    safe_strlen('a' * 1001)\nexcept ValueError as e:\n    assert str(e) == 'String is too long'", "assert safe_strlen('a' * 1000) == 1000"], "requirement_type": "PROMPT_ERROR_HANDLING"}
{"task_id": "HumanEval/25-1", "raw_problem": "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"", "raw_solution": "```python\n\n    import math\n    fact = []\n    i = 2\n    while i <= int(math.sqrt(n) + 1):\n        if n % i == 0:\n            fact.append(i)\n            n //= i\n        else:\n            i += 1\n\n    if n > 1:\n        fact.append(n)\n    return fact\n\n\n```", "raw_test_input": ["assert factorize(2) == [2]", "assert factorize(4) == [2, 2]", "assert factorize(8) == [2, 2, 2]", "assert factorize(3 * 19) == [3, 19]", "assert factorize(3 * 19 * 3 * 19) == [3, 3, 19, 19]", "assert factorize(3 * 19 * 3 * 19 * 3 * 19) == [3, 3, 3, 19, 19, 19]", "assert factorize(3 * 19 * 19 * 19) == [3, 19, 19, 19]", "assert factorize(3 * 2 * 3) == [2, 3, 3]"], "new_problem": "In the context of a financial analysis tool, you are tasked with analyzing the prime factorization of transaction amounts over a range of days. Given a list of tuples where each tuple represents a range of transaction amounts, return a dictionary where each key is a transaction amount within the range and the value is a list of its prime factors. This can help in understanding the distribution of transaction amounts in terms of their prime components.", "new_solution": "from typing import List, Tuple, Dict\nimport math\n\ndef factorize(n: int) -> List[int]:\n    fact = []\n    i = 2\n    while i <= int(math.sqrt(n) + 1):\n        if n % i == 0:\n            fact.append(i)\n            n //= i\n        else:\n            i += 1\n    if n > 1:\n        fact.append(n)\n    return fact\n\ndef analyze_transaction_ranges(ranges: List[Tuple[int, int]]) -> Dict[int, List[int]]:\n    result = {}\n    for start, end in ranges:\n        for amount in range(start, end + 1):\n            result[amount] = factorize(amount)\n    return result", "input_format": "List[Tuple[int, int]] - A list of tuples where each tuple contains two integers representing the start and end of a range.", "output_format": "Dict[int, List[int]] - A dictionary where each key is an integer from the input ranges and the value is a list of its prime factors.", "test_input": ["assert analyze_transaction_ranges([(8, 10)]) == {8: [2, 2, 2], 9: [3, 3], 10: [2, 5]}", "assert analyze_transaction_ranges([(15, 17)]) == {15: [3, 5], 16: [2, 2, 2, 2], 17: [17]}", "assert analyze_transaction_ranges([(20, 22)]) == {20: [2, 2, 5], 21: [3, 7], 22: [2, 11]}", "assert analyze_transaction_ranges([(25, 27)]) == {25: [5, 5], 26: [2, 13], 27: [3, 3, 3]}", "assert analyze_transaction_ranges([(30, 32)]) == {30: [2, 3, 5], 31: [31], 32: [2, 2, 2, 2, 2]}"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "HumanEval/25-2", "raw_problem": "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"", "raw_solution": "```python\n\n    import math\n    fact = []\n    i = 2\n    while i <= int(math.sqrt(n) + 1):\n        if n % i == 0:\n            fact.append(i)\n            n //= i\n        else:\n            i += 1\n\n    if n > 1:\n        fact.append(n)\n    return fact\n\n\n```", "raw_test_input": ["assert factorize(2) == [2]", "assert factorize(4) == [2, 2]", "assert factorize(8) == [2, 2, 2]", "assert factorize(3 * 19) == [3, 19]", "assert factorize(3 * 19 * 3 * 19) == [3, 3, 19, 19]", "assert factorize(3 * 19 * 3 * 19 * 3 * 19) == [3, 3, 3, 19, 19, 19]", "assert factorize(3 * 19 * 19 * 19) == [3, 19, 19, 19]", "assert factorize(3 * 2 * 3) == [2, 3, 3]"], "new_problem": "Enhance the factorize function to optionally return only unique prime factors of a given integer. The function should maintain backward compatibility, meaning it should still return all prime factors by default. Add an optional parameter 'unique' which, when set to True, returns only the unique prime factors.", "new_solution": "from typing import List\nimport math\n\ndef factorize(n: int, unique: bool = False) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appears in factorization.\n    If 'unique' is True, return only unique prime factors.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    >>> factorize(70, unique=True)\n    [2, 5, 7]\n    \"\"\"\n    fact = []\n    i = 2\n    while i <= int(math.sqrt(n) + 1):\n        if n % i == 0:\n            fact.append(i)\n            n //= i\n        else:\n            i += 1\n\n    if n > 1:\n        fact.append(n)\n\n    return list(set(fact)) if unique else fact\n", "input_format": "factorize(n: int, unique: bool = False) -> List[int]", "output_format": "List of integers representing the prime factors of n, optionally unique", "test_input": ["assert factorize(8) == [2, 2, 2]", "assert factorize(25) == [5, 5]", "assert factorize(70) == [2, 5, 7]", "assert factorize(70, unique=True) == [2, 5, 7]", "assert factorize(100, unique=True) == [2, 5]"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "HumanEval/25-3", "raw_problem": "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"", "raw_solution": "```python\n\n    import math\n    fact = []\n    i = 2\n    while i <= int(math.sqrt(n) + 1):\n        if n % i == 0:\n            fact.append(i)\n            n //= i\n        else:\n            i += 1\n\n    if n > 1:\n        fact.append(n)\n    return fact\n\n\n```", "raw_test_input": ["assert factorize(2) == [2]", "assert factorize(4) == [2, 2]", "assert factorize(8) == [2, 2, 2]", "assert factorize(3 * 19) == [3, 19]", "assert factorize(3 * 19 * 3 * 19) == [3, 3, 19, 19]", "assert factorize(3 * 19 * 3 * 19 * 3 * 19) == [3, 3, 3, 19, 19, 19]", "assert factorize(3 * 19 * 19 * 19) == [3, 19, 19, 19]", "assert factorize(3 * 2 * 3) == [2, 3, 3]"], "new_problem": "Given a list of integers, return a dictionary where the keys are the integers and the values are dictionaries representing the prime factorization of each integer. Each inner dictionary should have prime factors as keys and their counts as values. The input list can contain up to 1000 integers, each ranging from 2 to 10^6.", "new_solution": "from typing import List, Dict\nimport math\n\ndef factorize(n: int) -> Dict[int, int]:\n    fact = {}\n    i = 2\n    while i <= int(math.sqrt(n) + 1):\n        if n % i == 0:\n            if i in fact:\n                fact[i] += 1\n            else:\n                fact[i] = 1\n            n //= i\n        else:\n            i += 1\n    if n > 1:\n        if n in fact:\n            fact[n] += 1\n        else:\n            fact[n] = 1\n    return fact\n\ndef factorize_list(numbers: List[int]) -> Dict[int, Dict[int, int]]:\n    return {num: factorize(num) for num in numbers}", "input_format": "List[int]", "output_format": "Dict[int, int]", "test_input": ["assert factorize_list([8, 25, 70]) == {8: {2: 3}, 25: {5: 2}, 70: {2: 1, 5: 1, 7: 1}}", "assert factorize_list([1, 2, 3, 4, 5]) == {1: {}, 2: {2: 1}, 3: {3: 1}, 4: {2: 2}, 5: {5: 1}}", "assert factorize_list([100, 101, 102]) == {100: {2: 2, 5: 2}, 101: {101: 1}, 102: {2: 1, 3: 1, 17: 1}}", "assert factorize_list([999983, 1000000]) == {999983: {999983: 1}, 1000000: {2: 6, 5: 6}}", "assert factorize_list([6, 10, 15]) == {6: {2: 1, 3: 1}, 10: {2: 1, 5: 1}, 15: {3: 1, 5: 1}}"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "HumanEval/25-4", "raw_problem": "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"", "raw_solution": "```python\n\n    import math\n    fact = []\n    i = 2\n    while i <= int(math.sqrt(n) + 1):\n        if n % i == 0:\n            fact.append(i)\n            n //= i\n        else:\n            i += 1\n\n    if n > 1:\n        fact.append(n)\n    return fact\n\n\n```", "raw_test_input": ["assert factorize(2) == [2]", "assert factorize(4) == [2, 2]", "assert factorize(8) == [2, 2, 2]", "assert factorize(3 * 19) == [3, 19]", "assert factorize(3 * 19 * 3 * 19) == [3, 3, 19, 19]", "assert factorize(3 * 19 * 3 * 19 * 3 * 19) == [3, 3, 3, 19, 19, 19]", "assert factorize(3 * 19 * 19 * 19) == [3, 19, 19, 19]", "assert factorize(3 * 2 * 3) == [2, 3, 3]"], "new_problem": "Extend the factorize function to handle errors in a real-world scenario where the input might not be valid. The function should raise a ValueError if the input is not a positive integer, and a TypeError if the input is not an integer at all. Additionally, handle any unexpected errors gracefully by raising a custom FactorizationError with a meaningful message. Ensure that the function maintains type hints and propagates errors appropriately.", "new_solution": "from typing import List\n\nclass FactorizationError(Exception):\n    pass\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appears in factorization.\n    Input number should be equal to the product of all factors\n    \"\"\"\n    if not isinstance(n, int):\n        raise TypeError(\"Input must be an integer.\")\n    if n <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n\n    try:\n        import math\n        fact = []\n        i = 2\n        while i <= int(math.sqrt(n) + 1):\n            if n % i == 0:\n                fact.append(i)\n                n //= i\n            else:\n                i += 1\n\n        if n > 1:\n            fact.append(n)\n        return fact\n    except Exception as e:\n        raise FactorizationError(f\"An error occurred during factorization: {str(e)}\")", "input_format": "An integer n", "output_format": "A list of integers representing the prime factors of n", "test_input": ["assert factorize(8) == [2, 2, 2]", "assert factorize(25) == [5, 5]", "assert factorize(70) == [2, 5, 7]", "try:\n    factorize(-10)\nexcept ValueError as e:\n    assert str(e) == \"Input must be a positive integer.\"", "try:\n    factorize(\"100\")\nexcept TypeError as e:\n    assert str(e) == \"Input must be an integer.\""], "requirement_type": "PROMPT_ERROR_HANDLING"}
{"task_id": "HumanEval/26-1", "raw_problem": "from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"", "raw_solution": "```python\n\n    num_cnt = dict()\n    for number in numbers:\n        if number not in num_cnt:\n            num_cnt[number] = 0\n        num_cnt[number] += 1\n    return [number for number in numbers if num_cnt[number] == 1]\n\n\n```", "raw_test_input": ["assert remove_duplicates([]) == []", "assert remove_duplicates([1, 2, 3, 4]) == [1, 2, 3, 4]", "assert remove_duplicates([1, 2, 3, 2, 4, 3, 5]) == [1, 4, 5]"], "new_problem": "In an e-commerce platform, each transaction is associated with a list of tags that describe the transaction. However, some tags might be duplicated across different transactions. Write a function that processes a list of transactions and removes any tags that appear more than once across all transactions. The order of transactions and the order of tags within each transaction should be preserved.", "new_solution": "from typing import List, Dict\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    num_cnt = dict()\n    for number in numbers:\n        if number not in num_cnt:\n            num_cnt[number] = 0\n        num_cnt[number] += 1\n    return [number for number in numbers if num_cnt[number] == 1]\n\ndef process_transactions(transactions: List[Dict[str, any]]) -> List[Dict[str, any]]:\n    all_tags = []\n    for transaction in transactions:\n        all_tags.extend(transaction['tags'])\n    unique_tags = remove_duplicates(all_tags)\n    for transaction in transactions:\n        transaction['tags'] = [tag for tag in transaction['tags'] if tag in unique_tags]\n    return transactions\n", "input_format": "A list of transactions, where each transaction is a dictionary with keys 'id', 'amount', and 'tags'.", "output_format": "A list of transactions with duplicate tags removed, maintaining the order of transactions.", "test_input": ["assert process_transactions([{'id': 1, 'amount': 100, 'tags': ['electronics', 'sale']}, {'id': 2, 'amount': 200, 'tags': ['sale', 'new']}, {'id': 3, 'amount': 150, 'tags': ['electronics', 'gift']}]) == [{'id': 1, 'amount': 100, 'tags': []}, {'id': 2, 'amount': 200, 'tags': ['new']}, {'id': 3, 'amount': 150, 'tags': ['gift']}]", "assert process_transactions([{'id': 1, 'amount': 50, 'tags': ['clothing', 'discount']}, {'id': 2, 'amount': 75, 'tags': ['clothing', 'summer']}, {'id': 3, 'amount': 120, 'tags': ['discount', 'clearance']}]) == [{'id': 1, 'amount': 50, 'tags': []}, {'id': 2, 'amount': 75, 'tags': ['summer']}, {'id': 3, 'amount': 120, 'tags': ['clearance']}]", "assert process_transactions([{'id': 1, 'amount': 300, 'tags': ['furniture', 'luxury']}, {'id': 2, 'amount': 400, 'tags': ['luxury', 'home']}, {'id': 3, 'amount': 500, 'tags': ['furniture', 'office']}]) == [{'id': 1, 'amount': 300, 'tags': []}, {'id': 2, 'amount': 400, 'tags': ['home']}, {'id': 3, 'amount': 500, 'tags': ['office']}]", "assert process_transactions([{'id': 1, 'amount': 20, 'tags': ['food', 'organic']}, {'id': 2, 'amount': 30, 'tags': ['organic', 'fresh']}, {'id': 3, 'amount': 25, 'tags': ['food', 'local']}]) == [{'id': 1, 'amount': 20, 'tags': []}, {'id': 2, 'amount': 30, 'tags': ['fresh']}, {'id': 3, 'amount': 25, 'tags': ['local']}]", "assert process_transactions([{'id': 1, 'amount': 60, 'tags': ['books', 'education']}, {'id': 2, 'amount': 80, 'tags': ['education', 'learning']}, {'id': 3, 'amount': 90, 'tags': ['books', 'reading']}]) == [{'id': 1, 'amount': 60, 'tags': []}, {'id': 2, 'amount': 80, 'tags': ['learning']}, {'id': 3, 'amount': 90, 'tags': ['reading']}]"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "HumanEval/26-2", "raw_problem": "from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"", "raw_solution": "```python\n\n    num_cnt = dict()\n    for number in numbers:\n        if number not in num_cnt:\n            num_cnt[number] = 0\n        num_cnt[number] += 1\n    return [number for number in numbers if num_cnt[number] == 1]\n\n\n```", "raw_test_input": ["assert remove_duplicates([]) == []", "assert remove_duplicates([1, 2, 3, 4]) == [1, 2, 3, 4]", "assert remove_duplicates([1, 2, 3, 2, 4, 3, 5]) == [1, 4, 5]"], "new_problem": "Enhance the 'remove_duplicates' function to optionally keep the first occurrence of each duplicate element. The function should maintain backward compatibility, meaning it should work as before if the new parameter is not provided. The new optional parameter 'keep_first_occurrence' should be a boolean that, when set to True, retains the first occurrence of each duplicate element instead of removing all duplicates.", "new_solution": "from typing import List, Optional\n\ndef remove_duplicates(numbers: List[int], keep_first_occurrence: Optional[bool] = False) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Optionally, keep the first occurrence of each duplicate element if 'keep_first_occurrence' is True.\n    Keep order of elements left the same as in the input.\n    \"\"\"\n    num_cnt = dict()\n    for number in numbers:\n        if number not in num_cnt:\n            num_cnt[number] = 0\n        num_cnt[number] += 1\n    if keep_first_occurrence:\n        seen = set()\n        return [number for number in numbers if (num_cnt[number] == 1 or (number not in seen and not seen.add(number)))]\n    else:\n        return [number for number in numbers if num_cnt[number] == 1]", "input_format": "List[int], optional bool parameter 'keep_first_occurrence'", "output_format": "List[int]", "test_input": ["assert remove_duplicates([1, 2, 3, 2, 4]) == [1, 3, 4]", "assert remove_duplicates([1, 2, 3, 2, 4], keep_first_occurrence=True) == [1, 2, 3, 4]", "assert remove_duplicates([5, 5, 5, 6, 7, 8, 8], keep_first_occurrence=True) == [5, 6, 7, 8]", "assert remove_duplicates([9, 10, 10, 11, 12, 12, 12]) == [9, 11]", "assert remove_duplicates([13, 14, 15, 15, 16, 17, 17, 18], keep_first_occurrence=True) == [13, 14, 15, 16, 17, 18]"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "HumanEval/26-3", "raw_problem": "from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"", "raw_solution": "```python\n\n    num_cnt = dict()\n    for number in numbers:\n        if number not in num_cnt:\n            num_cnt[number] = 0\n        num_cnt[number] += 1\n    return [number for number in numbers if num_cnt[number] == 1]\n\n\n```", "raw_test_input": ["assert remove_duplicates([]) == []", "assert remove_duplicates([1, 2, 3, 4]) == [1, 2, 3, 4]", "assert remove_duplicates([1, 2, 3, 2, 4, 3, 5]) == [1, 4, 5]"], "new_problem": "Given a list of tuples where each tuple contains a string identifier and a list of integers, remove all integers that occur more than once across all lists. Return a dictionary where the keys are the string identifiers and the values are the lists of unique integers. Maintain the order of integers within each list as in the input. Additionally, ensure that the solution can handle up to 10,000 integers in total across all lists.", "new_solution": "from typing import List, Tuple, Dict\n\ndef remove_global_duplicates(data: List[Tuple[str, List[int]]]) -> Dict[str, List[int]]:\n    \"\"\" Remove integers that occur more than once across all lists in the input data. \"\"\"\n    num_cnt = dict()\n    for _, numbers in data:\n        for number in numbers:\n            if number not in num_cnt:\n                num_cnt[number] = 0\n            num_cnt[number] += 1\n    result = {}\n    for identifier, numbers in data:\n        result[identifier] = [number for number in numbers if num_cnt[number] == 1]\n    return result\n", "input_format": "List[Tuple[str, List[int]]]", "output_format": "Dict[str, List[int]]", "test_input": ["assert remove_global_duplicates([('a', [1, 2, 3]), ('b', [2, 4, 5]), ('c', [3, 6])]) == {'a': [1], 'b': [4, 5], 'c': [6]}", "assert remove_global_duplicates([('x', [10, 20, 30]), ('y', [20, 40, 50]), ('z', [30, 60, 70])]) == {'x': [10], 'y': [40, 50], 'z': [60, 70]}", "assert remove_global_duplicates([('p', [1, 1, 2]), ('q', [2, 3, 3]), ('r', [4, 5, 6])]) == {'p': [], 'q': [], 'r': [4, 5, 6]}", "assert remove_global_duplicates([('id1', [7, 8, 9]), ('id2', [9, 10, 11]), ('id3', [12, 13, 14])]) == {'id1': [7, 8], 'id2': [10, 11], 'id3': [12, 13, 14]}", "assert remove_global_duplicates([('key1', [100, 200, 300]), ('key2', [400, 500, 600]), ('key3', [700, 800, 900])]) == {'key1': [100, 200, 300], 'key2': [400, 500, 600], 'key3': [700, 800, 900]}"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "HumanEval/26-4", "raw_problem": "from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"", "raw_solution": "```python\n\n    num_cnt = dict()\n    for number in numbers:\n        if number not in num_cnt:\n            num_cnt[number] = 0\n        num_cnt[number] += 1\n    return [number for number in numbers if num_cnt[number] == 1]\n\n\n```", "raw_test_input": ["assert remove_duplicates([]) == []", "assert remove_duplicates([1, 2, 3, 4]) == [1, 2, 3, 4]", "assert remove_duplicates([1, 2, 3, 2, 4, 3, 5]) == [1, 4, 5]"], "new_problem": "Modify the function to remove duplicates from a list of integers, but handle errors for invalid input types. The function should raise a ValueError if any element in the list is not an integer. Additionally, handle the case where the input is not a list by raising a TypeError. Ensure that the function maintains the order of elements that are left after removing duplicates.", "new_solution": "from typing import List, Union\n\nclass InvalidElementTypeError(ValueError):\n    pass\n\nclass InvalidInputTypeError(TypeError):\n    pass\n\ndef remove_duplicates_with_error_handling(numbers: List[Union[int, str, float]]) -> List[int]:\n    \"\"\"\n    From a list of integers, remove all elements that occur more than once.\n    Raise a ValueError if any element is not an integer.\n    Raise a TypeError if the input is not a list.\n    \"\"\"\n    if not isinstance(numbers, list):\n        raise InvalidInputTypeError(\"Input must be a list.\")\n\n    num_cnt = dict()\n    for number in numbers:\n        if not isinstance(number, int):\n            raise InvalidElementTypeError(\"All elements must be integers.\")\n        if number not in num_cnt:\n            num_cnt[number] = 0\n        num_cnt[number] += 1\n    return [number for number in numbers if num_cnt[number] == 1]", "input_format": "List[Union[int, str, float]]", "output_format": "List[int]", "test_input": ["assert remove_duplicates_with_error_handling([1, 2, 3, 2, 4]) == [1, 3, 4]", "try:\n    remove_duplicates_with_error_handling([1, '2', 3])\nexcept InvalidElementTypeError as e:\n    assert str(e) == 'All elements must be integers.'", "try:\n    remove_duplicates_with_error_handling('not a list')\nexcept InvalidInputTypeError as e:\n    assert str(e) == 'Input must be a list.'", "assert remove_duplicates_with_error_handling([1, 1, 2, 2, 3, 3, 4]) == [4]", "try:\n    remove_duplicates_with_error_handling([1, 2.5, 3])\nexcept InvalidElementTypeError as e:\n    assert str(e) == 'All elements must be integers.'"], "requirement_type": "PROMPT_ERROR_HANDLING"}
{"task_id": "HumanEval/27-1", "raw_problem": "def flip_case(string: str) -> str:\n    \"\"\" For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n    >>> flip_case('Hello')\n    'hELLO'\n    \"\"\"", "raw_solution": "```python\n\n    return \"\".join(map(lambda x: x.swapcase(), string))\n\n\n```", "raw_test_input": ["assert flip_case('') == ''", "assert flip_case('Hello!') == 'hELLO!'", "assert flip_case('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'"], "new_problem": "In a customer support system, messages are logged with varying cases. To standardize the logs for analysis, implement a function that processes a list of customer messages by flipping the case of each message. Each message is associated with a customer's name. Use the original flip_case function to transform the messages. The function should return a list of dictionaries with the customer's name and the flipped message.", "new_solution": "def flip_case(string: str) -> str:\n    return \"\".join(map(lambda x: x.swapcase(), string))\n\ndef process_customer_messages(messages):\n    processed_messages = []\n    for entry in messages:\n        name = entry['name']\n        message = entry['message']\n        flipped_message = flip_case(message)\n        processed_messages.append({'name': name, 'flipped_message': flipped_message})\n    return processed_messages", "input_format": "A list of dictionaries, each containing 'name' (str) and 'message' (str) fields.", "output_format": "A list of dictionaries, each containing 'name' (str) and 'flipped_message' (str) fields.", "test_input": ["assert process_customer_messages([{'name': 'Alice', 'message': 'Hello World'}]) == [{'name': 'Alice', 'flipped_message': 'hELLO wORLD'}]", "assert process_customer_messages([{'name': 'Bob', 'message': 'Python3.8'}]) == [{'name': 'Bob', 'flipped_message': 'pYTHON3.8'}]", "assert process_customer_messages([{'name': 'Charlie', 'message': '123abcABC'}]) == [{'name': 'Charlie', 'flipped_message': '123ABCabc'}]", "assert process_customer_messages([{'name': 'Dana', 'message': 'Good Morning!'}]) == [{'name': 'Dana', 'flipped_message': 'gOOD mORNING!'}]", "assert process_customer_messages([{'name': 'Eve', 'message': 'Test123'}]) == [{'name': 'Eve', 'flipped_message': 'tEST123'}]"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "HumanEval/27-2", "raw_problem": "def flip_case(string: str) -> str:\n    \"\"\" For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n    >>> flip_case('Hello')\n    'hELLO'\n    \"\"\"", "raw_solution": "```python\n\n    return \"\".join(map(lambda x: x.swapcase(), string))\n\n\n```", "raw_test_input": ["assert flip_case('') == ''", "assert flip_case('Hello!') == 'hELLO!'", "assert flip_case('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'"], "new_problem": "Enhance the flip_case function to optionally ignore numbers while flipping the case of characters. The function should maintain backward compatibility, meaning it should still work as originally intended if the new parameter is not used.", "new_solution": "def flip_case(string: str, ignore_numbers: bool = False) -> str:\n    def flip_char(c: str) -> str:\n        if ignore_numbers and c.isdigit():\n            return c\n        return c.swapcase()\n    return ''.join(map(flip_char, string))", "input_format": "flip_case(string: str, ignore_numbers: bool = False) -> str", "output_format": "A string with flipped case, optionally ignoring numbers.", "test_input": ["assert flip_case('Hello') == 'hELLO'", "assert flip_case('Hello123') == 'hELLO123'", "assert flip_case('Hello123', ignore_numbers=True) == 'hELLO123'", "assert flip_case('123ABCabc', ignore_numbers=True) == '123abcABC'", "assert flip_case('123ABCabc') == '123abcABC'"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "HumanEval/27-3", "raw_problem": "def flip_case(string: str) -> str:\n    \"\"\" For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n    >>> flip_case('Hello')\n    'hELLO'\n    \"\"\"", "raw_solution": "```python\n\n    return \"\".join(map(lambda x: x.swapcase(), string))\n\n\n```", "raw_test_input": ["assert flip_case('') == ''", "assert flip_case('Hello!') == 'hELLO!'", "assert flip_case('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'"], "new_problem": "Given a list of dictionaries where each dictionary contains a 'text' key with a string value, flip the case of each character in the string. The function should return a new list of dictionaries with the 'text' values having their cases flipped. Additionally, ensure that the input list is not modified, and the output list maintains the order of the input list.", "new_solution": "from typing import List, Dict\n\ndef flip_case(string: str) -> str:\n    return \"\".join(map(lambda x: x.swapcase(), string))\n\ndef flip_case_in_dicts(data: List[Dict[str, str]]) -> List[Dict[str, str]]:\n    return [{key: (flip_case(value) if key == 'text' else value) for key, value in item.items()} for item in data]", "input_format": "List[Dict[str, str]]", "output_format": "List[Dict[str, str]]", "test_input": ["assert flip_case_in_dicts([{'text': 'Hello'}, {'text': 'World'}]) == [{'text': 'hELLO'}, {'text': 'wORLD'}]", "assert flip_case_in_dicts([{'text': 'Python'}, {'text': 'Programming'}]) == [{'text': 'pYTHON'}, {'text': 'pROGRAMMING'}]", "assert flip_case_in_dicts([{'text': '123'}, {'text': 'ABCdef'}]) == [{'text': '123'}, {'text': 'abcDEF'}]", "assert flip_case_in_dicts([{'text': ''}, {'text': 'a'}]) == [{'text': ''}, {'text': 'A'}]", "assert flip_case_in_dicts([{'text': 'MixedCASE'}, {'text': 'AnotherOne'}]) == [{'text': 'mIXEDcase'}, {'text': 'aNOTHERoNE'}]"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "HumanEval/27-4", "raw_problem": "def flip_case(string: str) -> str:\n    \"\"\" For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n    >>> flip_case('Hello')\n    'hELLO'\n    \"\"\"", "raw_solution": "```python\n\n    return \"\".join(map(lambda x: x.swapcase(), string))\n\n\n```", "raw_test_input": ["assert flip_case('') == ''", "assert flip_case('Hello!') == 'hELLO!'", "assert flip_case('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'"], "new_problem": "Create a function `safe_flip_case` that flips the case of alphabetic characters in a given string. The function should handle the following errors: 1) Raise a `TypeError` if the input is not a string. 2) Raise a `ValueError` if the string contains non-alphabetic characters. Implement error propagation and provide meaningful error messages.", "new_solution": "class FlipCaseError(Exception):\n    pass\n\nclass NonAlphabeticCharacterError(FlipCaseError):\n    def __init__(self, message=\"String contains non-alphabetic characters.\"):\n        self.message = message\n        super().__init__(self.message)\n\nclass InvalidTypeError(FlipCaseError):\n    def __init__(self, message=\"Input must be a string.\"):\n        self.message = message\n        super().__init__(self.message)\n\ndef safe_flip_case(string: str) -> str:\n    if not isinstance(string, str):\n        raise InvalidTypeError()\n    if not string.isalpha():\n        raise NonAlphabeticCharacterError()\n    return \"\".join(map(lambda x: x.swapcase(), string))", "input_format": "A string input that may contain non-alphabetic characters or be of incorrect type.", "output_format": "A string with flipped case for alphabetic characters, or an error message for invalid input.", "test_input": ["assert safe_flip_case('Hello') == 'hELLO'", "try:\n    safe_flip_case(123)\nexcept InvalidTypeError as e:\n    assert str(e) == 'Input must be a string.'", "try:\n    safe_flip_case('Hello123')\nexcept NonAlphabeticCharacterError as e:\n    assert str(e) == 'String contains non-alphabetic characters.'", "try:\n    safe_flip_case('')\nexcept NonAlphabeticCharacterError as e:\n    assert str(e) == 'String contains non-alphabetic characters.'", "assert safe_flip_case('WORLD') == 'world'"], "requirement_type": "PROMPT_ERROR_HANDLING"}
{"task_id": "HumanEval/28-1", "raw_problem": "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\"", "raw_solution": "```python\n\n    return \"\".join(strings)\n\n\n```", "raw_test_input": ["assert concatenate([]) == ''", "assert concatenate(['x', 'y', 'z']) == 'xyz'", "assert concatenate(['x', 'y', 'z', 'w', 'k']) == 'xyzwk'"], "new_problem": "In an e-commerce platform, you need to generate a summary of product descriptions for different categories. Each category has a list of product descriptions, and you want to concatenate all descriptions within each category into a single string. Implement a function `generate_category_summaries` that takes a list of dictionaries, where each dictionary represents a category with a key as the category name and a value as a list of product descriptions. The function should return a dictionary with category names as keys and concatenated product descriptions as values.", "new_solution": "from typing import List, Dict\n\ndef concatenate(strings: List[str]) -> str:\n    return \"\".join(strings)\n\ndef generate_category_summaries(categories: List[Dict[str, List[str]]]) -> Dict[str, str]:\n    summaries = {}\n    for category in categories:\n        for category_name, descriptions in category.items():\n            summaries[category_name] = concatenate(descriptions)\n    return summaries", "input_format": "List[Dict[str, List[str]]]", "output_format": "Dict[str, str]", "test_input": ["assert generate_category_summaries([{'Electronics': ['Smartphone', 'Laptop', 'Tablet']}]) == {'Electronics': 'SmartphoneLaptopTablet'}", "assert generate_category_summaries([{'Books': ['Fiction', 'Non-fiction', 'Comics']}]) == {'Books': 'FictionNon-fictionComics'}", "assert generate_category_summaries([{'Clothing': ['Shirt', 'Pants', 'Jacket']}, {'Footwear': ['Sneakers', 'Boots']}]) == {'Clothing': 'ShirtPantsJacket', 'Footwear': 'SneakersBoots'}", "assert generate_category_summaries([{'Toys': []}]) == {'Toys': ''}", "assert generate_category_summaries([{'Groceries': ['Milk', 'Eggs']}, {'Groceries': ['Bread']}]) == {'Groceries': 'Bread'}"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "HumanEval/28-2", "raw_problem": "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\"", "raw_solution": "```python\n\n    return \"\".join(strings)\n\n\n```", "raw_test_input": ["assert concatenate([]) == ''", "assert concatenate(['x', 'y', 'z']) == 'xyz'", "assert concatenate(['x', 'y', 'z', 'w', 'k']) == 'xyzwk'"], "new_problem": "Enhance the concatenate function to allow optional parameters for a separator, prefix, and suffix. The function should still concatenate a list of strings into a single string, but now it can also insert a separator between each string, and add a prefix and suffix to the final result. The function must maintain backward compatibility with the original implementation.", "new_solution": "from typing import List, Optional\n\ndef concatenate(strings: List[str], sep: Optional[str] = '', prefix: Optional[str] = '', suffix: Optional[str] = '') -> str:\n    \"\"\" Concatenate list of strings into a single string with optional separator, prefix, and suffix \"\"\"\n    return f\"{prefix}{sep.join(strings)}{suffix}\"", "input_format": "List[str], sep: Optional[str] = None, prefix: Optional[str] = '', suffix: Optional[str] = ''", "output_format": "str", "test_input": ["assert concatenate([]) == ''", "assert concatenate(['a', 'b', 'c']) == 'abc'", "assert concatenate(['a', 'b', 'c'], sep='-') == 'a-b-c'", "assert concatenate(['a', 'b', 'c'], prefix='(', suffix=')') == '(abc)'", "assert concatenate(['a', 'b', 'c'], sep='-', prefix='(', suffix=')') == '(a-b-c)'"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "HumanEval/28-3", "raw_problem": "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\"", "raw_solution": "```python\n\n    return \"\".join(strings)\n\n\n```", "raw_test_input": ["assert concatenate([]) == ''", "assert concatenate(['x', 'y', 'z']) == 'xyz'", "assert concatenate(['x', 'y', 'z', 'w', 'k']) == 'xyzwk'"], "new_problem": "Given a dictionary where each key is a category and the value is a list of strings, write a function to concatenate the list of strings for each category into a single string. The function should return a new dictionary with the same keys, where each value is the concatenated string. Ensure that the function can handle at least 100 categories, each with up to 1000 strings.", "new_solution": "from typing import Dict, List\n\ndef concatenate(strings: List[str]) -> str:\n    return \"\".join(strings)\n\ndef concatenate_categories(categories: Dict[str, List[str]]) -> Dict[str, str]:\n    return {category: concatenate(strings) for category, strings in categories.items()}", "input_format": "Dict[str, List[str]]", "output_format": "Dict[str, str]", "test_input": ["assert concatenate_categories({}) == {}", "assert concatenate_categories({'fruits': []}) == {'fruits': ''}", "assert concatenate_categories({'fruits': ['apple', 'banana'], 'vegetables': ['carrot']}) == {'fruits': 'applebanana', 'vegetables': 'carrot'}", "assert concatenate_categories({'letters': ['a', 'b', 'c'], 'numbers': ['1', '2', '3']}) == {'letters': 'abc', 'numbers': '123'}", "assert concatenate_categories({'empty': [], 'full': ['full']}) == {'empty': '', 'full': 'full'}"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "HumanEval/28-4", "raw_problem": "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\"", "raw_solution": "```python\n\n    return \"\".join(strings)\n\n\n```", "raw_test_input": ["assert concatenate([]) == ''", "assert concatenate(['x', 'y', 'z']) == 'xyz'", "assert concatenate(['x', 'y', 'z', 'w', 'k']) == 'xyzwk'"], "new_problem": "Create a function that concatenates a list of strings into a single string. The function should handle the following errors: 1) Raise a ValueError if any element in the list is not a string. 2) Raise a TypeError if the input is not a list. 3) Provide meaningful error messages for each exception. Ensure that the function can propagate these errors appropriately.", "new_solution": "from typing import List\n\nclass ConcatenationError(Exception):\n    pass\n\nclass NonStringElementError(ConcatenationError):\n    def __init__(self, element):\n        self.element = element\n        super().__init__(f\"Non-string element found: {element}\")\n\nclass InvalidInputTypeError(ConcatenationError):\n    def __init__(self, input_type):\n        self.input_type = input_type\n        super().__init__(f\"Invalid input type: {input_type}. Expected a list of strings.\")\n\ndef concatenate(strings: List[str]) -> str:\n    if not isinstance(strings, list):\n        raise InvalidInputTypeError(type(strings).__name__)\n    for element in strings:\n        if not isinstance(element, str):\n            raise NonStringElementError(element)\n    return \"\".join(strings)", "input_format": "List[str]", "output_format": "str", "test_input": ["assert concatenate(['hello', 'world']) == 'helloworld'", "assert concatenate([]) == ''", "try:\n    concatenate(['hello', 123])\nexcept NonStringElementError as e:\n    assert str(e) == 'Non-string element found: 123'", "try:\n    concatenate('not a list')\nexcept InvalidInputTypeError as e:\n    assert str(e) == 'Invalid input type: str. Expected a list of strings.'", "try:\n    concatenate(None)\nexcept InvalidInputTypeError as e:\n    assert str(e) == 'Invalid input type: NoneType. Expected a list of strings.'"], "requirement_type": "PROMPT_ERROR_HANDLING"}
{"task_id": "HumanEval/29-1", "raw_problem": "from typing import List\n\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that start with a given prefix.\n    >>> filter_by_prefix([], 'a')\n    []\n    >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ['abc', 'array']\n    \"\"\"", "raw_solution": "```python\n\n    return list(filter(lambda x: x.startswith(prefix), strings))\n\n\n```", "raw_test_input": ["assert filter_by_prefix([], 'john') == []", "assert filter_by_prefix(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']"], "new_problem": "In an e-commerce platform, you have a list of products where each product is represented as a dictionary with keys 'name' and 'category'. You need to filter the products based on a given prefix for their names. Use the original function to filter the product names and return a list of dictionaries containing only the products whose names start with the given prefix.", "new_solution": "from typing import List, Dict\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    return list(filter(lambda x: x.startswith(prefix), strings))\n\ndef filter_products_by_name_prefix(products: List[Dict[str, str]], prefix: str) -> List[Dict[str, str]]:\n    product_names = [product['name'] for product in products]\n    filtered_names = filter_by_prefix(product_names, prefix)\n    return [product for product in products if product['name'] in filtered_names]", "input_format": "{'products': List[Dict[str, str]], 'prefix': str}", "output_format": "List[Dict[str, str]]", "test_input": ["assert filter_products_by_name_prefix([], 'a') == []", "assert filter_products_by_name_prefix([{'name': 'apple', 'category': 'fruit'}, {'name': 'banana', 'category': 'fruit'}], 'a') == [{'name': 'apple', 'category': 'fruit'}]", "assert filter_products_by_name_prefix([{'name': 'apple', 'category': 'fruit'}, {'name': 'apricot', 'category': 'fruit'}, {'name': 'banana', 'category': 'fruit'}], 'ap') == [{'name': 'apple', 'category': 'fruit'}, {'name': 'apricot', 'category': 'fruit'}]", "assert filter_products_by_name_prefix([{'name': 'carrot', 'category': 'vegetable'}, {'name': 'cabbage', 'category': 'vegetable'}, {'name': 'celery', 'category': 'vegetable'}], 'ca') == [{'name': 'carrot', 'category': 'vegetable'}, {'name': 'cabbage', 'category': 'vegetable'}]", "assert filter_products_by_name_prefix([{'name': 'grape', 'category': 'fruit'}, {'name': 'grapefruit', 'category': 'fruit'}, {'name': 'guava', 'category': 'fruit'}], 'gr') == [{'name': 'grape', 'category': 'fruit'}, {'name': 'grapefruit', 'category': 'fruit'}]"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "HumanEval/29-2", "raw_problem": "from typing import List\n\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that start with a given prefix.\n    >>> filter_by_prefix([], 'a')\n    []\n    >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ['abc', 'array']\n    \"\"\"", "raw_solution": "```python\n\n    return list(filter(lambda x: x.startswith(prefix), strings))\n\n\n```", "raw_test_input": ["assert filter_by_prefix([], 'john') == []", "assert filter_by_prefix(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']"], "new_problem": "Enhance the function to filter an input list of strings for ones that start with a given prefix. Additionally, add an optional parameter 'case_sensitive' which defaults to False. If 'case_sensitive' is True, the filtering should be case-sensitive. Maintain backward compatibility with existing implementations.", "new_solution": "from typing import List\n\ndef filter_by_prefix(strings: List[str], prefix: str, case_sensitive: bool = False) -> List[str]:\n    if not case_sensitive:\n        prefix = prefix.lower()\n        strings = [s.lower() for s in strings]\n    return list(filter(lambda x: x.startswith(prefix), strings))", "input_format": "List[str], str, bool = False", "output_format": "List[str]", "test_input": ["assert filter_by_prefix([], 'a') == []", "assert filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a') == ['abc', 'array']", "assert filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'A') == ['abc', 'array']", "assert filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'A', case_sensitive=True) == []", "assert filter_by_prefix(['Abc', 'bcd', 'cde', 'Array'], 'A', case_sensitive=True) == ['Abc', 'Array']"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "HumanEval/29-3", "raw_problem": "from typing import List\n\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that start with a given prefix.\n    >>> filter_by_prefix([], 'a')\n    []\n    >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ['abc', 'array']\n    \"\"\"", "raw_solution": "```python\n\n    return list(filter(lambda x: x.startswith(prefix), strings))\n\n\n```", "raw_test_input": ["assert filter_by_prefix([], 'john') == []", "assert filter_by_prefix(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']"], "new_problem": "Given a dictionary where keys are categories and values are lists of strings, filter each list to only include strings that start with a given prefix. Return a new dictionary with the same keys but only the filtered lists as values. Additionally, ensure that the function can handle nested dictionaries where the values can also be dictionaries with the same structure.", "new_solution": "from typing import Dict, List, Union\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    return list(filter(lambda x: x.startswith(prefix), strings))\n\ndef filter_nested_dict(data: Dict[str, Union[List[str], Dict]], prefix: str) -> Dict[str, Union[List[str], Dict]]:\n    result = {}\n    for key, value in data.items():\n        if isinstance(value, list):\n            result[key] = filter_by_prefix(value, prefix)\n        elif isinstance(value, dict):\n            result[key] = filter_nested_dict(value, prefix)\n    return result", "input_format": "Dict[str, List[str]], str", "output_format": "Dict[str, List[str]]", "test_input": ["assert filter_nested_dict({'fruits': ['apple', 'banana', 'apricot'], 'vegetables': ['asparagus', 'broccoli']}, 'a') == {'fruits': ['apple', 'apricot'], 'vegetables': ['asparagus']}", "assert filter_nested_dict({'fruits': ['apple', 'banana'], 'nested': {'berries': ['blueberry', 'blackberry', 'appleberry']}}, 'b') == {'fruits': ['banana'], 'nested': {'berries': ['blueberry', 'blackberry']}}", "assert filter_nested_dict({'empty': [], 'nested': {'empty': []}}, 'a') == {'empty': [], 'nested': {'empty': []}}", "assert filter_nested_dict({'fruits': ['apple', 'banana'], 'nested': {'berries': ['blueberry', 'blackberry']}}, 'z') == {'fruits': [], 'nested': {'berries': []}}", "assert filter_nested_dict({'fruits': ['apple', 'banana'], 'nested': {'berries': ['blueberry', 'blackberry']}}, '') == {'fruits': ['apple', 'banana'], 'nested': {'berries': ['blueberry', 'blackberry']}}"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "HumanEval/29-4", "raw_problem": "from typing import List\n\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that start with a given prefix.\n    >>> filter_by_prefix([], 'a')\n    []\n    >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ['abc', 'array']\n    \"\"\"", "raw_solution": "```python\n\n    return list(filter(lambda x: x.startswith(prefix), strings))\n\n\n```", "raw_test_input": ["assert filter_by_prefix([], 'john') == []", "assert filter_by_prefix(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']"], "new_problem": "Create a function that filters a list of strings by a given prefix, but includes error handling for invalid inputs. The function should raise a ValueError if the prefix is not a string, and a TypeError if the input list is not a list of strings. Additionally, handle any unexpected errors gracefully and provide meaningful error messages.", "new_solution": "from typing import List\n\nclass InvalidPrefixError(ValueError):\n    pass\n\nclass InvalidStringListError(TypeError):\n    pass\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that start with a given prefix.\n    \"\"\"\n    if not isinstance(prefix, str):\n        raise InvalidPrefixError(\"Prefix must be a string.\")\n    if not isinstance(strings, list) or not all(isinstance(s, str) for s in strings):\n        raise InvalidStringListError(\"Input must be a list of strings.\")\n    try:\n        return list(filter(lambda x: x.startswith(prefix), strings))\n    except Exception as e:\n        raise RuntimeError(f\"An unexpected error occurred: {str(e)}\")\n", "input_format": "List[str], str", "output_format": "List[str]", "test_input": ["assert filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a') == ['abc', 'array']", "assert filter_by_prefix([], 'a') == []", "try:\n    filter_by_prefix(['abc', 123, 'cde'], 'a')\nexcept InvalidStringListError as e:\n    assert str(e) == 'Input must be a list of strings.'", "try:\n    filter_by_prefix(['abc', 'bcd', 'cde'], 123)\nexcept InvalidPrefixError as e:\n    assert str(e) == 'Prefix must be a string.'", "try:\n    filter_by_prefix('not a list', 'a')\nexcept InvalidStringListError as e:\n    assert str(e) == 'Input must be a list of strings.'"], "requirement_type": "PROMPT_ERROR_HANDLING"}
{"task_id": "HumanEval/30-1", "raw_problem": "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"", "raw_solution": "```python\n\n    return list(filter(lambda x: x > 0, l))\n\n\n```", "raw_test_input": ["assert get_positive([-1, -2, 4, 5, 6]) == [4, 5, 6]", "assert get_positive([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]", "assert get_positive([-1, -2]) == []", "assert get_positive([]) == []"], "new_problem": "In a financial application, you need to filter out transactions that are both positive and exceed a certain threshold. Implement a function that takes a list of transaction amounts and a threshold value, and returns a list of transactions that are positive and greater than the threshold. Use the original 'get_positive' function as a helper to first filter out the positive transactions.", "new_solution": "def get_positive(l: list):\n    return list(filter(lambda x: x > 0, l))\n\ndef filter_transactions(transactions: list, threshold: int) -> list:\n    positive_transactions = get_positive(transactions)\n    return [t for t in positive_transactions if t > threshold]", "input_format": "A dictionary with keys 'transactions' (list of transaction amounts) and 'threshold' (positive integer).", "output_format": "A list of positive transactions that exceed the threshold.", "test_input": ["assert filter_transactions([-1, 2, -4, 5, 6], 3) == [5, 6]", "assert filter_transactions([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10], 4) == [5, 9, 123]", "assert filter_transactions([10, 20, 30, -40, -50], 15) == [20, 30]", "assert filter_transactions([-10, -20, -30, 40, 50], 0) == [40, 50]", "assert filter_transactions([100, 200, 300, 400, 500], 250) == [300, 400, 500]"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "HumanEval/30-2", "raw_problem": "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"", "raw_solution": "```python\n\n    return list(filter(lambda x: x > 0, l))\n\n\n```", "raw_test_input": ["assert get_positive([-1, -2, 4, 5, 6]) == [4, 5, 6]", "assert get_positive([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]", "assert get_positive([-1, -2]) == []", "assert get_positive([]) == []"], "new_problem": "Enhance the function to optionally include zero in the returned list while maintaining backward compatibility. The function should still return only positive numbers by default, but if the optional parameter 'include_zero' is set to True, it should also include zeros in the output list.", "new_solution": "from typing import List\n\ndef get_positive(l: List[int], include_zero: bool = False) -> List[int]:\n    if include_zero:\n        return list(filter(lambda x: x >= 0, l))\n    return list(filter(lambda x: x > 0, l))", "input_format": "get_positive(l: List[int], include_zero: bool = False) -> List[int]", "output_format": "List[int]", "test_input": ["assert get_positive([-1, 2, -4, 5, 6]) == [2, 5, 6]", "assert get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 9, 123, 1]", "assert get_positive([-1, 0, 2, -4, 5, 6], include_zero=True) == [0, 2, 5, 6]", "assert get_positive([0, -1, -2, -3], include_zero=True) == [0]", "assert get_positive([0, -1, -2, -3]) == []"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "HumanEval/30-3", "raw_problem": "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"", "raw_solution": "```python\n\n    return list(filter(lambda x: x > 0, l))\n\n\n```", "raw_test_input": ["assert get_positive([-1, -2, 4, 5, 6]) == [4, 5, 6]", "assert get_positive([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]", "assert get_positive([-1, -2]) == []", "assert get_positive([]) == []"], "new_problem": "Given a dictionary where keys are strings representing categories and values are lists of integers, return a new dictionary with the same keys but only containing the positive numbers from each list. Additionally, ensure that each list in the output dictionary is sorted in ascending order.", "new_solution": "```python\nfrom typing import Dict, List\n\ndef get_positive_sorted(data: Dict[str, List[int]]) -> Dict[str, List[int]]:\n    def get_positive(l: List[int]) -> List[int]:\n        return list(filter(lambda x: x > 0, l))\n    return {key: sorted(get_positive(values)) for key, values in data.items()}\n```", "input_format": "Dict[str, List[int]]", "output_format": "Dict[str, List[int]]", "test_input": ["assert get_positive_sorted({'a': [-1, 2, -4, 5, 6], 'b': [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]}) == {'a': [2, 5, 6], 'b': [1, 2, 3, 3, 5, 9, 123]}", "assert get_positive_sorted({'x': [-10, -20, -30], 'y': [0, 0, 0]}) == {'x': [], 'y': []}", "assert get_positive_sorted({'numbers': [10, -1, 3, 5, -6, 7]}) == {'numbers': [3, 5, 7, 10]}", "assert get_positive_sorted({'empty': []}) == {'empty': []}", "assert get_positive_sorted({'mixed': [-1, 0, 1, 2, 3, -2, -3]}) == {'mixed': [1, 2, 3]}"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "HumanEval/30-4", "raw_problem": "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"", "raw_solution": "```python\n\n    return list(filter(lambda x: x > 0, l))\n\n\n```", "raw_test_input": ["assert get_positive([-1, -2, 4, 5, 6]) == [4, 5, 6]", "assert get_positive([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]", "assert get_positive([-1, -2]) == []", "assert get_positive([]) == []"], "new_problem": "Create a function `get_positive_safe(l: list) -> list` that returns only positive numbers from a list. The function should handle the following errors: 1) If the input is not a list, raise a `TypeError` with a meaningful message. 2) If any element in the list is not a number, raise a `ValueError` with a meaningful message. 3) Ensure that errors are propagated correctly and provide meaningful feedback to the user.", "new_solution": "class NonNumericElementError(ValueError):\n    pass\n\nclass NotAListError(TypeError):\n    pass\n\ndef get_positive_safe(l: list) -> list:\n    if not isinstance(l, list):\n        raise NotAListError(\"Input must be a list.\")\n    try:\n        return list(filter(lambda x: isinstance(x, (int, float)) and x > 0, l))\n    except TypeError:\n        raise NonNumericElementError(\"All elements in the list must be numbers.\")", "input_format": "A list of numbers, which may include non-numeric values.", "output_format": "A list of positive numbers extracted from the input list.", "test_input": ["assert get_positive_safe([-1, 2, -4, 5, 6]) == [2, 5, 6]", "assert get_positive_safe([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 9, 123, 1]", "try:\n    get_positive_safe('not a list')\nexcept NotAListError as e:\n    assert str(e) == 'Input must be a list.'", "try:\n    get_positive_safe([1, 'two', 3])\nexcept NonNumericElementError as e:\n    assert str(e) == 'All elements in the list must be numbers.'", "assert get_positive_safe([0, -1, -2, -3]) == []"], "requirement_type": "PROMPT_ERROR_HANDLING"}
{"task_id": "HumanEval/31-1", "raw_problem": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"", "raw_solution": "```python\n\n    if n <= 1: return False\n    n_sqrt = 1\n    while n_sqrt ** 2 < n: n_sqrt += 1\n    for i in range(2, min(n_sqrt + 1, n)):\n        if n % i == 0:\n            return False\n    return True\n\n\n```", "raw_test_input": ["assert is_prime(6) == False", "assert is_prime(101) == True", "assert is_prime(11) == True", "assert is_prime(13441) == True", "assert is_prime(61) == True", "assert is_prime(4) == False", "assert is_prime(1) == False", "assert is_prime(5) == True", "assert is_prime(11) == True", "assert is_prime(17) == True", "assert is_prime(5 * 17) == False", "assert is_prime(11 * 7) == False", "assert is_prime(13441 * 19) == False"], "new_problem": "In a financial application, you are tasked with identifying which transaction amounts are prime numbers. This can help in detecting unusual patterns or anomalies in transaction data. Write a function `identify_prime_transactions(transactions)` that takes a list of transaction amounts and returns a list of booleans indicating whether each transaction amount is a prime number. Use the `is_prime` function as a helper to determine the primality of each transaction amount.", "new_solution": "def is_prime(n):\n    if n <= 1: return False\n    n_sqrt = 1\n    while n_sqrt ** 2 < n: n_sqrt += 1\n    for i in range(2, min(n_sqrt + 1, n)):\n        if n % i == 0:\n            return False\n    return True\n\ndef identify_prime_transactions(transactions):\n    return [is_prime(amount) for amount in transactions]", "input_format": "A list of integers representing transaction amounts.", "output_format": "A list of booleans indicating whether each transaction amount is a prime number.", "test_input": ["assert identify_prime_transactions([6, 101, 11, 13441, 61, 4, 1]) == [False, True, True, True, True, False, False]", "assert identify_prime_transactions([2, 3, 5, 7, 11]) == [True, True, True, True, True]", "assert identify_prime_transactions([10, 15, 20, 25, 30]) == [False, False, False, False, False]", "assert identify_prime_transactions([17, 19, 23, 29, 31]) == [True, True, True, True, True]", "assert identify_prime_transactions([0, -1, -3, 4, 9]) == [False, False, False, False, False]"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "HumanEval/31-2", "raw_problem": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"", "raw_solution": "```python\n\n    if n <= 1: return False\n    n_sqrt = 1\n    while n_sqrt ** 2 < n: n_sqrt += 1\n    for i in range(2, min(n_sqrt + 1, n)):\n        if n % i == 0:\n            return False\n    return True\n\n\n```", "raw_test_input": ["assert is_prime(6) == False", "assert is_prime(101) == True", "assert is_prime(11) == True", "assert is_prime(13441) == True", "assert is_prime(61) == True", "assert is_prime(4) == False", "assert is_prime(1) == False", "assert is_prime(5) == True", "assert is_prime(11) == True", "assert is_prime(17) == True", "assert is_prime(5 * 17) == False", "assert is_prime(11 * 7) == False", "assert is_prime(13441 * 19) == False"], "new_problem": "Enhance the is_prime function to include an optional verbose parameter. This parameter, when set to True, will print the steps taken to determine if a number is prime. The function should maintain backward compatibility, meaning it should work as before when the verbose parameter is not provided.", "new_solution": "def is_prime(n: int, *, verbose: bool = False) -> bool:\n    if n <= 1:\n        if verbose:\n            print(f\"{n} is not prime because it is less than or equal to 1.\")\n        return False\n    n_sqrt = 1\n    while n_sqrt ** 2 < n:\n        n_sqrt += 1\n    if verbose:\n        print(f\"Checking divisibility from 2 to {min(n_sqrt + 1, n)}\")\n    for i in range(2, min(n_sqrt + 1, n)):\n        if n % i == 0:\n            if verbose:\n                print(f\"{n} is divisible by {i}, hence it is not prime.\")\n            return False\n    if verbose:\n        print(f\"{n} is prime.\")\n    return True", "input_format": "is_prime(n: int, *, verbose: bool = False) -> bool", "output_format": "bool", "test_input": ["assert is_prime(6) == False", "assert is_prime(101) == True", "assert is_prime(11, verbose=True) == True", "assert is_prime(13441) == True", "assert is_prime(61, verbose=True) == True", "assert is_prime(4) == False", "assert is_prime(1, verbose=True) == False"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "HumanEval/31-3", "raw_problem": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"", "raw_solution": "```python\n\n    if n <= 1: return False\n    n_sqrt = 1\n    while n_sqrt ** 2 < n: n_sqrt += 1\n    for i in range(2, min(n_sqrt + 1, n)):\n        if n % i == 0:\n            return False\n    return True\n\n\n```", "raw_test_input": ["assert is_prime(6) == False", "assert is_prime(101) == True", "assert is_prime(11) == True", "assert is_prime(13441) == True", "assert is_prime(61) == True", "assert is_prime(4) == False", "assert is_prime(1) == False", "assert is_prime(5) == True", "assert is_prime(11) == True", "assert is_prime(17) == True", "assert is_prime(5 * 17) == False", "assert is_prime(11 * 7) == False", "assert is_prime(13441 * 19) == False"], "new_problem": "Given a dictionary where each key is an integer and the value is a list of integers, determine if each key is a prime number. Return a new dictionary where each key is the original integer and the value is a boolean indicating whether the key is prime. The solution should use a dictionary to store intermediate results for optimization. Additionally, ensure that the function handles up to 10,000 keys efficiently.", "new_solution": "from typing import Dict, List\n\ndef is_prime(n: int) -> bool:\n    if n <= 1: return False\n    n_sqrt = 1\n    while n_sqrt ** 2 < n: n_sqrt += 1\n    for i in range(2, min(n_sqrt + 1, n)):\n        if n % i == 0:\n            return False\n    return True\n\n\ndef check_prime_numbers(data: Dict[int, List[int]]) -> Dict[int, bool]:\n    prime_cache: Dict[int, bool] = {}\n    result: Dict[int, bool] = {}\n    for key in data.keys():\n        if key not in prime_cache:\n            prime_cache[key] = is_prime(key)\n        result[key] = prime_cache[key]\n    return result", "input_format": "A dictionary where keys are integers and values are lists of integers.", "output_format": "A dictionary where keys are integers and values are booleans indicating if the key is prime.", "test_input": ["assert check_prime_numbers({6: [1, 2], 101: [3, 4], 11: [5, 6]}) == {6: False, 101: True, 11: True}", "assert check_prime_numbers({13441: [7, 8], 61: [9, 10], 4: [11, 12]}) == {13441: True, 61: True, 4: False}", "assert check_prime_numbers({1: [13, 14], 2: [15, 16], 3: [17, 18]}) == {1: False, 2: True, 3: True}", "assert check_prime_numbers({17: [19, 20], 19: [21, 22], 20: [23, 24]}) == {17: True, 19: True, 20: False}", "assert check_prime_numbers({23: [25, 26], 24: [27, 28], 25: [29, 30]}) == {23: True, 24: False, 25: False}"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "HumanEval/31-4", "raw_problem": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"", "raw_solution": "```python\n\n    if n <= 1: return False\n    n_sqrt = 1\n    while n_sqrt ** 2 < n: n_sqrt += 1\n    for i in range(2, min(n_sqrt + 1, n)):\n        if n % i == 0:\n            return False\n    return True\n\n\n```", "raw_test_input": ["assert is_prime(6) == False", "assert is_prime(101) == True", "assert is_prime(11) == True", "assert is_prime(13441) == True", "assert is_prime(61) == True", "assert is_prime(4) == False", "assert is_prime(1) == False", "assert is_prime(5) == True", "assert is_prime(11) == True", "assert is_prime(17) == True", "assert is_prime(5 * 17) == False", "assert is_prime(11 * 7) == False", "assert is_prime(13441 * 19) == False"], "new_problem": "Modify the is_prime function to handle errors in a real-world scenario where the input might not be a valid integer. The function should raise a ValueError if the input is not an integer or if it is a negative number. Additionally, handle any unexpected errors gracefully and provide meaningful error messages.", "new_solution": "def is_prime(n: int) -> bool:\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    Raise ValueError if n is not a positive integer.\n    \"\"\"\n    if not isinstance(n, int):\n        raise ValueError(\"Input must be an integer.\")\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n    if n <= 1:\n        return False\n    n_sqrt = 1\n    while n_sqrt ** 2 < n:\n        n_sqrt += 1\n    for i in range(2, min(n_sqrt + 1, n)):\n        if n % i == 0:\n            return False\n    return True", "input_format": "A single integer n", "output_format": "Boolean indicating if n is a prime number", "test_input": ["assert is_prime(6) == False", "assert is_prime(101) == True", "assert is_prime(11) == True", "try:\n    is_prime(-5)\nexcept ValueError as e:\n    assert str(e) == \"Input must be a non-negative integer.\"", "try:\n    is_prime(3.5)\nexcept ValueError as e:\n    assert str(e) == \"Input must be an integer.\""], "requirement_type": "PROMPT_ERROR_HANDLING"}
{"task_id": "HumanEval/33-1", "raw_problem": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"", "raw_solution": "```python\n\n    third = [l[i] for i in range(len(l)) if i % 3 == 0]\n    third.sort()\n    return [third[i // 3] if i % 3 == 0 else l[i] for i in range(len(l))]\n\n\n```", "raw_test_input": ["assert tuple(sort_third([1, 2, 3])) == tuple(sort_third([1, 2, 3]))", "assert tuple(sort_third([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple(sort_third([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]))", "assert tuple(sort_third([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple(sort_third([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]))", "assert tuple(sort_third([5, 6, 3, 4, 8, 9, 2])) == tuple([2, 6, 3, 4, 8, 9, 5])", "assert tuple(sort_third([5, 8, 3, 4, 6, 9, 2])) == tuple([2, 8, 3, 4, 6, 9, 5])", "assert tuple(sort_third([5, 6, 9, 4, 8, 3, 2])) == tuple([2, 6, 9, 4, 8, 3, 5])", "assert tuple(sort_third([5, 6, 3, 4, 8, 9, 2, 1])) == tuple([2, 6, 3, 4, 8, 9, 5, 1])"], "new_problem": "In an e-commerce platform, you have a list of products, each represented by a dictionary containing 'id', 'name', and 'price'. You need to sort the prices of products at indices divisible by three in ascending order, while keeping the rest of the list unchanged. Implement a function that takes this list of product dictionaries and returns a new list with the prices sorted as specified.", "new_solution": "```python\ndef sort_third(l: list):\n    third = [l[i] for i in range(len(l)) if i % 3 == 0]\n    third.sort()\n    return third\n\ndef sort_product_prices(products: list):\n    prices = [product['price'] for product in products]\n    sorted_prices = sort_third(prices)\n    for i in range(len(products)):\n        if i % 3 == 0:\n            products[i]['price'] = sorted_prices[i // 3]\n    return products\n```", "input_format": "A list of dictionaries where each dictionary represents a product with 'id', 'name', and 'price'.", "output_format": "A list of dictionaries with the same structure, but the prices of products at indices divisible by three are sorted in ascending order.", "test_input": ["assert sort_product_prices([{'id': 1, 'name': 'A', 'price': 5}, {'id': 2, 'name': 'B', 'price': 6}, {'id': 3, 'name': 'C', 'price': 3}, {'id': 4, 'name': 'D', 'price': 4}, {'id': 5, 'name': 'E', 'price': 8}, {'id': 6, 'name': 'F', 'price': 9}, {'id': 7, 'name': 'G', 'price': 2}]) == [{'id': 1, 'name': 'A', 'price': 2}, {'id': 2, 'name': 'B', 'price': 6}, {'id': 3, 'name': 'C', 'price': 3}, {'id': 4, 'name': 'D', 'price': 4}, {'id': 5, 'name': 'E', 'price': 8}, {'id': 6, 'name': 'F', 'price': 9}, {'id': 7, 'name': 'G', 'price': 5}]", "assert sort_product_prices([{'id': 1, 'name': 'A', 'price': 10}, {'id': 2, 'name': 'B', 'price': 20}, {'id': 3, 'name': 'C', 'price': 30}, {'id': 4, 'name': 'D', 'price': 40}, {'id': 5, 'name': 'E', 'price': 50}, {'id': 6, 'name': 'F', 'price': 60}, {'id': 7, 'name': 'G', 'price': 70}]) == [{'id': 1, 'name': 'A', 'price': 10}, {'id': 2, 'name': 'B', 'price': 20}, {'id': 3, 'name': 'C', 'price': 30}, {'id': 4, 'name': 'D', 'price': 40}, {'id': 5, 'name': 'E', 'price': 50}, {'id': 6, 'name': 'F', 'price': 60}, {'id': 7, 'name': 'G', 'price': 70}]", "assert sort_product_prices([{'id': 1, 'name': 'A', 'price': 3}, {'id': 2, 'name': 'B', 'price': 2}, {'id': 3, 'name': 'C', 'price': 1}, {'id': 4, 'name': 'D', 'price': 6}, {'id': 5, 'name': 'E', 'price': 5}, {'id': 6, 'name': 'F', 'price': 4}, {'id': 7, 'name': 'G', 'price': 9}]) == [{'id': 1, 'name': 'A', 'price': 3}, {'id': 2, 'name': 'B', 'price': 2}, {'id': 3, 'name': 'C', 'price': 1}, {'id': 4, 'name': 'D', 'price': 6}, {'id': 5, 'name': 'E', 'price': 5}, {'id': 6, 'name': 'F', 'price': 4}, {'id': 7, 'name': 'G', 'price': 9}]", "assert sort_product_prices([{'id': 1, 'name': 'A', 'price': 7}, {'id': 2, 'name': 'B', 'price': 8}, {'id': 3, 'name': 'C', 'price': 9}, {'id': 4, 'name': 'D', 'price': 1}, {'id': 5, 'name': 'E', 'price': 2}, {'id': 6, 'name': 'F', 'price': 3}, {'id': 7, 'name': 'G', 'price': 4}]) == [{'id': 1, 'name': 'A', 'price': 1}, {'id': 2, 'name': 'B', 'price': 8}, {'id': 3, 'name': 'C', 'price': 9}, {'id': 4, 'name': 'D', 'price': 4}, {'id': 5, 'name': 'E', 'price': 2}, {'id': 6, 'name': 'F', 'price': 3}, {'id': 7, 'name': 'G', 'price': 7}]", "assert sort_product_prices([{'id': 1, 'name': 'A', 'price': 15}, {'id': 2, 'name': 'B', 'price': 25}, {'id': 3, 'name': 'C', 'price': 35}, {'id': 4, 'name': 'D', 'price': 45}, {'id': 5, 'name': 'E', 'price': 55}, {'id': 6, 'name': 'F', 'price': 65}, {'id': 7, 'name': 'G', 'price': 75}]) == [{'id': 1, 'name': 'A', 'price': 15}, {'id': 2, 'name': 'B', 'price': 25}, {'id': 3, 'name': 'C', 'price': 35}, {'id': 4, 'name': 'D', 'price': 45}, {'id': 5, 'name': 'E', 'price': 55}, {'id': 6, 'name': 'F', 'price': 65}, {'id': 7, 'name': 'G', 'price': 75}]"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "HumanEval/33-2", "raw_problem": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"", "raw_solution": "```python\n\n    third = [l[i] for i in range(len(l)) if i % 3 == 0]\n    third.sort()\n    return [third[i // 3] if i % 3 == 0 else l[i] for i in range(len(l))]\n\n\n```", "raw_test_input": ["assert tuple(sort_third([1, 2, 3])) == tuple(sort_third([1, 2, 3]))", "assert tuple(sort_third([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple(sort_third([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]))", "assert tuple(sort_third([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple(sort_third([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]))", "assert tuple(sort_third([5, 6, 3, 4, 8, 9, 2])) == tuple([2, 6, 3, 4, 8, 9, 5])", "assert tuple(sort_third([5, 8, 3, 4, 6, 9, 2])) == tuple([2, 8, 3, 4, 6, 9, 5])", "assert tuple(sort_third([5, 6, 9, 4, 8, 3, 2])) == tuple([2, 6, 9, 4, 8, 3, 5])", "assert tuple(sort_third([5, 6, 3, 4, 8, 9, 2, 1])) == tuple([2, 6, 3, 4, 8, 9, 5, 1])"], "new_problem": "Enhance the `sort_third` function to include an optional parameter `reverse` that allows sorting the elements at indices divisible by three in descending order when set to True. The function should maintain backward compatibility, meaning it should still work as originally intended when the `reverse` parameter is not provided.", "new_solution": "```python\nfrom typing import List\n\ndef sort_third(l: List[int], reverse: bool = False) -> List[int]:\n    third = [l[i] for i in range(len(l)) if i % 3 == 0]\n    third.sort(reverse=reverse)\n    return [third[i // 3] if i % 3 == 0 else l[i] for i in range(len(l))]\n```", "input_format": "sort_third(l: List[int], reverse: bool = False) -> List[int]", "output_format": "List[int]", "test_input": ["assert sort_third([1, 2, 3]) == [1, 2, 3]", "assert sort_third([5, 6, 3, 4, 8, 9, 2]) == [2, 6, 3, 4, 8, 9, 5]", "assert sort_third([5, 6, 3, 4, 8, 9, 2], reverse=True) == [5, 6, 3, 4, 8, 9, 2]", "assert sort_third([9, 1, 3, 7, 5, 6, 2, 8, 4]) == [2, 1, 3, 7, 5, 6, 9, 8, 4]", "assert sort_third([9, 1, 3, 7, 5, 6, 2, 8, 4], reverse=True) == [9, 1, 3, 7, 5, 6, 2, 8, 4]"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "HumanEval/33-3", "raw_problem": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"", "raw_solution": "```python\n\n    third = [l[i] for i in range(len(l)) if i % 3 == 0]\n    third.sort()\n    return [third[i // 3] if i % 3 == 0 else l[i] for i in range(len(l))]\n\n\n```", "raw_test_input": ["assert tuple(sort_third([1, 2, 3])) == tuple(sort_third([1, 2, 3]))", "assert tuple(sort_third([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple(sort_third([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]))", "assert tuple(sort_third([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple(sort_third([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]))", "assert tuple(sort_third([5, 6, 3, 4, 8, 9, 2])) == tuple([2, 6, 3, 4, 8, 9, 5])", "assert tuple(sort_third([5, 8, 3, 4, 6, 9, 2])) == tuple([2, 8, 3, 4, 6, 9, 5])", "assert tuple(sort_third([5, 6, 9, 4, 8, 3, 2])) == tuple([2, 6, 9, 4, 8, 3, 5])", "assert tuple(sort_third([5, 6, 3, 4, 8, 9, 2, 1])) == tuple([2, 6, 3, 4, 8, 9, 5, 1])"], "new_problem": "Given a dictionary where keys represent indices and values represent elements of a list, return a new dictionary where the values at keys divisible by three are sorted, while other values remain unchanged. Additionally, ensure that the dictionary can handle up to 10,000 elements efficiently.", "new_solution": "def sort_third_dict(d: dict[int, int]) -> dict[int, int]:\n    third = {k: v for k, v in d.items() if k % 3 == 0}\n    sorted_third_values = sorted(third.values())\n    sorted_third = {k: sorted_third_values[i] for i, k in enumerate(sorted(third.keys()))}\n    return {k: (sorted_third[k] if k in sorted_third else v) for k, v in d.items()}", "input_format": "A dictionary where keys are indices and values are the elements of the list.", "output_format": "A dictionary with the same keys, but values at keys divisible by three are sorted.", "test_input": ["assert sort_third_dict({0: 5, 1: 6, 2: 3, 3: 4, 4: 8, 5: 9, 6: 2}) == {0: 2, 1: 6, 2: 3, 3: 4, 4: 8, 5: 9, 6: 5}", "assert sort_third_dict({0: 1, 1: 2, 2: 3}) == {0: 1, 1: 2, 2: 3}", "assert sort_third_dict({0: 9, 3: 7, 6: 5, 9: 3}) == {0: 3, 3: 5, 6: 7, 9: 9}", "assert sort_third_dict({0: 10, 1: 20, 2: 30, 3: 40, 4: 50, 5: 60, 6: 70, 7: 80, 8: 90, 9: 100}) == {0: 10, 1: 20, 2: 30, 3: 40, 4: 50, 5: 60, 6: 70, 7: 80, 8: 90, 9: 100}", "assert sort_third_dict({0: 3, 3: 1, 6: 2}) == {0: 1, 3: 2, 6: 3}"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "HumanEval/33-4", "raw_problem": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"", "raw_solution": "```python\n\n    third = [l[i] for i in range(len(l)) if i % 3 == 0]\n    third.sort()\n    return [third[i // 3] if i % 3 == 0 else l[i] for i in range(len(l))]\n\n\n```", "raw_test_input": ["assert tuple(sort_third([1, 2, 3])) == tuple(sort_third([1, 2, 3]))", "assert tuple(sort_third([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple(sort_third([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]))", "assert tuple(sort_third([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple(sort_third([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]))", "assert tuple(sort_third([5, 6, 3, 4, 8, 9, 2])) == tuple([2, 6, 3, 4, 8, 9, 5])", "assert tuple(sort_third([5, 8, 3, 4, 6, 9, 2])) == tuple([2, 8, 3, 4, 6, 9, 5])", "assert tuple(sort_third([5, 6, 9, 4, 8, 3, 2])) == tuple([2, 6, 9, 4, 8, 3, 5])", "assert tuple(sort_third([5, 6, 3, 4, 8, 9, 2, 1])) == tuple([2, 6, 3, 4, 8, 9, 5, 1])"], "new_problem": "Modify the function `sort_third` to handle errors in a real-world scenario where the input list may contain non-integer elements or be empty. The function should raise a `ValueError` if the list contains non-integer elements and a `CustomEmptyListError` if the list is empty. Additionally, handle any unexpected errors gracefully and provide meaningful error messages.", "new_solution": "class CustomEmptyListError(Exception):\n    pass\n\ndef sort_third(l: list) -> list:\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    \"\"\"\n    if not l:\n        raise CustomEmptyListError(\"The input list is empty.\")\n    if not all(isinstance(x, int) for x in l):\n        raise ValueError(\"All elements in the list must be integers.\")\n    try:\n        third = [l[i] for i in range(len(l)) if i % 3 == 0]\n        third.sort()\n        return [third[i // 3] if i % 3 == 0 else l[i] for i in range(len(l))]\n    except Exception as e:\n        raise RuntimeError(f\"An unexpected error occurred: {str(e)}\")", "input_format": "A list of integers", "output_format": "A list of integers with elements at indices divisible by three sorted", "test_input": ["assert sort_third([1, 2, 3]) == [1, 2, 3]", "assert sort_third([5, 6, 3, 4, 8, 9, 2]) == [2, 6, 3, 4, 8, 9, 5]", "try:\n    sort_third([])\nexcept CustomEmptyListError as e:\n    assert str(e) == \"The input list is empty.\"", "try:\n    sort_third([1, 'a', 3])\nexcept ValueError as e:\n    assert str(e) == \"All elements in the list must be integers.\"", "try:\n    sort_third([1, 2, 3, None])\nexcept ValueError as e:\n    assert str(e) == \"All elements in the list must be integers.\""], "requirement_type": "PROMPT_ERROR_HANDLING"}
{"task_id": "HumanEval/34-1", "raw_problem": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"", "raw_solution": "```python\n\n    return sorted(set(l))\n\n\n```", "raw_test_input": ["assert unique([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]"], "new_problem": "In an e-commerce platform, you have a list of transactions. Each transaction is represented as a dictionary containing an 'id', 'amount', and a list of 'tags' associated with the transaction. Write a function that calculates the total amount spent for each unique tag across all transactions. Use the 'unique' function to help identify unique tags.", "new_solution": "def unique(l: list):\n    return sorted(set(l))\n\ndef calculate_total_by_tag(transactions: list):\n    tag_totals = {}\n    all_tags = []\n    for transaction in transactions:\n        all_tags.extend(transaction['tags'])\n    unique_tags = unique(all_tags)\n    for tag in unique_tags:\n        total = sum(transaction['amount'] for transaction in transactions if tag in transaction['tags'])\n        tag_totals[tag] = total\n    return tag_totals", "input_format": "A list of transactions where each transaction is a dictionary with 'id', 'amount', and 'tags'.", "output_format": "A dictionary with unique tags as keys and the total amount spent on each tag as values.", "test_input": ["assert calculate_total_by_tag([{'id': 1, 'amount': 100, 'tags': ['electronics', 'sale']}, {'id': 2, 'amount': 200, 'tags': ['clothing', 'sale']}, {'id': 3, 'amount': 150, 'tags': ['electronics', 'new']}]) == {'electronics': 250, 'sale': 300, 'clothing': 200, 'new': 150}", "assert calculate_total_by_tag([{'id': 1, 'amount': 50, 'tags': ['books']}, {'id': 2, 'amount': 75, 'tags': ['books', 'education']}, {'id': 3, 'amount': 25, 'tags': ['education']}]) == {'books': 125, 'education': 100}", "assert calculate_total_by_tag([{'id': 1, 'amount': 300, 'tags': ['furniture']}, {'id': 2, 'amount': 150, 'tags': ['furniture', 'home']}, {'id': 3, 'amount': 200, 'tags': ['home']}]) == {'furniture': 450, 'home': 350}", "assert calculate_total_by_tag([{'id': 1, 'amount': 500, 'tags': ['travel', 'vacation']}, {'id': 2, 'amount': 300, 'tags': ['vacation', 'leisure']}, {'id': 3, 'amount': 200, 'tags': ['leisure']}]) == {'travel': 500, 'vacation': 800, 'leisure': 500}", "assert calculate_total_by_tag([{'id': 1, 'amount': 100, 'tags': ['food']}, {'id': 2, 'amount': 200, 'tags': ['food', 'grocery']}, {'id': 3, 'amount': 150, 'tags': ['grocery']}]) == {'food': 300, 'grocery': 350}"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "HumanEval/34-2", "raw_problem": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"", "raw_solution": "```python\n\n    return sorted(set(l))\n\n\n```", "raw_test_input": ["assert unique([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]"], "new_problem": "Enhance the 'unique' function to maintain backward compatibility while adding an optional parameter 'reverse'. This parameter should allow the user to specify whether the returned list of unique elements should be sorted in reverse order. The function should still accept a list of elements and return a list of sorted unique elements, with the option to reverse the order if 'reverse' is set to True.", "new_solution": "def unique(l: list, reverse: bool = False) -> list:\n    \"\"\"Return sorted unique elements in a list, optionally in reverse order\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123], reverse=True)\n    [123, 9, 5, 3, 2, 0]\n    \"\"\"\n    return sorted(set(l), reverse=reverse)", "input_format": "unique(l: list, reverse: bool = False) -> list", "output_format": "A sorted list of unique elements, optionally in reverse order", "test_input": ["assert unique([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]", "assert unique([5, 3, 5, 2, 3, 3, 9, 0, 123], reverse=True) == [123, 9, 5, 3, 2, 0]", "assert unique([1, 2, 2, 3, 4, 4, 5]) == [1, 2, 3, 4, 5]", "assert unique([1, 2, 2, 3, 4, 4, 5], reverse=True) == [5, 4, 3, 2, 1]", "assert unique([]) == []"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "HumanEval/34-3", "raw_problem": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"", "raw_solution": "```python\n\n    return sorted(set(l))\n\n\n```", "raw_test_input": ["assert unique([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]"], "new_problem": "Given a list of tuples where each tuple contains a string and an integer, return a dictionary where each key is a unique string from the tuples and the value is a sorted list of unique integers associated with that string. The function should handle large datasets efficiently and should include type hints.", "new_solution": "from typing import List, Tuple, Dict\n\ndef unique_dict(data: List[Tuple[str, int]]) -> Dict[str, List[int]]:\n    result = {}\n    for key, value in data:\n        if key not in result:\n            result[key] = set()\n        result[key].add(value)\n    return {k: sorted(v) for k, v in result.items()}", "input_format": "List[Tuple[str, int]]", "output_format": "Dict[str, List[int]]", "test_input": ["assert unique_dict([('a', 5), ('b', 3), ('a', 5), ('a', 2), ('b', 3), ('b', 9), ('c', 0), ('c', 123)]) == {'a': [2, 5], 'b': [3, 9], 'c': [0, 123]}", "assert unique_dict([('x', 1), ('y', 2), ('x', 3), ('y', 2), ('z', 3), ('x', 1)]) == {'x': [1, 3], 'y': [2], 'z': [3]}", "assert unique_dict([('apple', 10), ('banana', 20), ('apple', 10), ('banana', 30), ('apple', 20)]) == {'apple': [10, 20], 'banana': [20, 30]}", "assert unique_dict([('cat', 7), ('dog', 8), ('cat', 7), ('dog', 9), ('cat', 8)]) == {'cat': [7, 8], 'dog': [8, 9]}", "assert unique_dict([('key1', 100), ('key2', 200), ('key1', 300), ('key2', 100), ('key3', 200)]) == {'key1': [100, 300], 'key2': [100, 200], 'key3': [200]}"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "HumanEval/34-4", "raw_problem": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"", "raw_solution": "```python\n\n    return sorted(set(l))\n\n\n```", "raw_test_input": ["assert unique([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]"], "new_problem": "Modify the 'unique' function to handle errors in a real-world scenario where the input list may contain non-integer elements. The function should raise a ValueError if any element in the list is not an integer. Additionally, handle the case where the input is not a list by raising a TypeError. Ensure that meaningful error messages are provided and that error propagation is managed appropriately.", "new_solution": "def unique(l: list) -> list:\n    \"\"\"Return sorted unique integer elements in a list\n    Raises:\n        TypeError: If the input is not a list.\n        ValueError: If any element in the list is not an integer.\n    \"\"\"\n    if not isinstance(l, list):\n        raise TypeError(\"Input must be a list.\")\n    for element in l:\n        if not isinstance(element, int):\n            raise ValueError(f\"All elements must be integers. Found: {element}\")\n    return sorted(set(l))", "input_format": "A list of elements that may include non-integers", "output_format": "A sorted list of unique integers", "test_input": ["assert unique([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]", "try:\n    unique('not a list')\nexcept TypeError as e:\n    assert str(e) == 'Input must be a list.'", "try:\n    unique([5, 3, 'a', 2])\nexcept ValueError as e:\n    assert str(e) == 'All elements must be integers. Found: a'", "try:\n    unique([5, 3, 2.5, 2])\nexcept ValueError as e:\n    assert str(e) == 'All elements must be integers. Found: 2.5'", "assert unique([]) == []"], "requirement_type": "PROMPT_ERROR_HANDLING"}
{"task_id": "HumanEval/35-1", "raw_problem": "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"", "raw_solution": "```python\n\n    return max(l)\n\n\n```", "raw_test_input": ["assert max_element([1, 2, 3]) == 3", "assert max_element([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124"], "new_problem": "In an e-commerce platform, you are tasked with analyzing sales data to determine the best-selling product in each category. You are given a dictionary where each key is a product category and the value is a list of sales figures for products in that category. Your task is to write a function that returns a dictionary with the maximum sales figure for each category. Use the original max_element function to find the maximum sales figure for each category.", "new_solution": "def max_element(l: list):\n    return max(l)\n\ndef max_sales_per_category(sales_data: dict) -> dict:\n    max_sales = {}\n    for category, sales in sales_data.items():\n        max_sales[category] = max_element(sales)\n    return max_sales", "input_format": "A dictionary where keys are product categories and values are lists of sales figures for each product in that category.", "output_format": "A dictionary where keys are product categories and values are the maximum sales figure for that category.", "test_input": ["assert max_sales_per_category({'electronics': [200, 450, 300], 'clothing': [150, 100, 250], 'books': [50, 75, 100]}) == {'electronics': 450, 'clothing': 250, 'books': 100}", "assert max_sales_per_category({'furniture': [500, 700, 600], 'toys': [30, 20, 40], 'groceries': [10, 5, 15]}) == {'furniture': 700, 'toys': 40, 'groceries': 15}", "assert max_sales_per_category({'appliances': [1000, 800, 1200], 'tools': [300, 400, 350]}) == {'appliances': 1200, 'tools': 400}", "assert max_sales_per_category({'sports': [90, 110, 95], 'outdoors': [200, 180, 220]}) == {'sports': 110, 'outdoors': 220}", "assert max_sales_per_category({'beauty': [60, 70, 65], 'health': [80, 85, 75]}) == {'beauty': 70, 'health': 85}"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "HumanEval/35-2", "raw_problem": "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"", "raw_solution": "```python\n\n    return max(l)\n\n\n```", "raw_test_input": ["assert max_element([1, 2, 3]) == 3", "assert max_element([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124"], "new_problem": "Enhance the max_element function to support an optional key parameter, similar to the key parameter in Python's built-in max function. This key parameter should allow users to specify a function that extracts a comparison key from each element in the list. The function should maintain backward compatibility with existing implementations.", "new_solution": "from typing import List, Callable, Any, Optional\n\ndef max_element(l: List[Any], key: Optional[Callable[[Any], Any]] = None) -> Any:\n    \"\"\"Return maximum element in the list, optionally using a key function for comparison.\"\"\"\n    return max(l, key=key)", "input_format": "max_element(l: list, key: Optional[Callable[[Any], Any]] = None) -> Any", "output_format": "Returns the maximum element in the list, optionally using a key function for comparison.", "test_input": ["assert max_element([1, 2, 3]) == 3", "assert max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == 123", "assert max_element(['apple', 'banana', 'cherry'], key=len) == 'banana'", "assert max_element([(1, 2), (3, 4), (5, 0)], key=lambda x: x[1]) == (3, 4)", "assert max_element([{'a': 1}, {'a': 3}, {'a': 2}], key=lambda x: x['a']) == {'a': 3}"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "HumanEval/35-3", "raw_problem": "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"", "raw_solution": "```python\n\n    return max(l)\n\n\n```", "raw_test_input": ["assert max_element([1, 2, 3]) == 3", "assert max_element([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124"], "new_problem": "Given a dictionary where keys are strings representing categories and values are lists of integers, write a function to find the category with the maximum element across all lists. Return a tuple containing the category name and the maximum element. If multiple categories have the same maximum element, return the first one encountered. The function should handle cases where lists can be empty and should include type hints.", "new_solution": "```python\nfrom typing import Dict, List, Tuple\n\ndef max_element_in_categories(data: Dict[str, List[int]]) -> Tuple[str, int]:\n    max_category = None\n    max_value = float('-inf')\n    for category, numbers in data.items():\n        if numbers:  # Check if the list is not empty\n            current_max = max(numbers)\n            if current_max > max_value:\n                max_value = current_max\n                max_category = category\n    if max_category is None:\n        raise ValueError('All lists are empty')\n    return max_category, max_value\n```", "input_format": "Dict[str, List[int]]", "output_format": "Tuple[str, int]", "test_input": ["assert max_element_in_categories({'A': [1, 2, 3], 'B': [4, 5, 6], 'C': [0, -1, -2]}) == ('B', 6)", "assert max_element_in_categories({'X': [10, 20], 'Y': [30, 40], 'Z': [5, 15]}) == ('Y', 40)", "assert max_element_in_categories({'D': [-10, -20], 'E': [-5, -15], 'F': [-1, -2]}) == ('F', -1)", "assert max_element_in_categories({'G': [], 'H': [0], 'I': [0, 0, 0]}) == ('H', 0)", "assert max_element_in_categories({'J': [100], 'K': [100], 'L': [99]}) == ('J', 100)"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "HumanEval/35-4", "raw_problem": "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"", "raw_solution": "```python\n\n    return max(l)\n\n\n```", "raw_test_input": ["assert max_element([1, 2, 3]) == 3", "assert max_element([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124"], "new_problem": "Create a function `max_element_with_error_handling` that returns the maximum element in a list of numbers. The function should handle the following errors: 1) If the input is not a list, raise a `TypeError` with a message 'Input must be a list'. 2) If the list is empty, raise a `ValueError` with a message 'List cannot be empty'. 3) If the list contains non-numeric elements, raise a `TypeError` with a message 'All elements must be numbers'. Ensure that the function propagates these errors with meaningful messages.", "new_solution": "def max_element_with_error_handling(l: list) -> float:\n    \"\"\"Return maximum element in the list with error handling.\"\"\"\n    if not isinstance(l, list):\n        raise TypeError('Input must be a list')\n    if not l:\n        raise ValueError('List cannot be empty')\n    if not all(isinstance(x, (int, float)) for x in l):\n        raise TypeError('All elements must be numbers')\n    return max(l)", "input_format": "A list of numbers", "output_format": "The maximum number in the list or an error message", "test_input": ["assert max_element_with_error_handling([1, 2, 3]) == 3", "assert max_element_with_error_handling([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == 123", "try:\n    max_element_with_error_handling('not a list')\nexcept TypeError as e:\n    assert str(e) == 'Input must be a list'", "try:\n    max_element_with_error_handling([])\nexcept ValueError as e:\n    assert str(e) == 'List cannot be empty'", "try:\n    max_element_with_error_handling([1, 'two', 3])\nexcept TypeError as e:\n    assert str(e) == 'All elements must be numbers'"], "requirement_type": "PROMPT_ERROR_HANDLING"}
{"task_id": "HumanEval/36-1", "raw_problem": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"", "raw_solution": "```python\n\n    cnt = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            cnt += len(list(filter(lambda c: c == \"7\", str(i))))\n    return cnt\n\n\n```", "raw_test_input": ["assert fizz_buzz(50) == 0", "assert fizz_buzz(78) == 2", "assert fizz_buzz(79) == 3", "assert fizz_buzz(100) == 3", "assert fizz_buzz(200) == 6", "assert fizz_buzz(4000) == 192", "assert fizz_buzz(10000) == 639", "assert fizz_buzz(100000) == 8026"], "new_problem": "In a company, different departments have different thresholds for monitoring certain metrics. Each department wants to know how many times the digit '7' appears in numbers less than their threshold, which are divisible by 11 or 13. Write a function `department_fizz_buzz(thresholds: List[int]) -> Dict[str, int]` that takes a list of thresholds for each department and returns a dictionary with department names as keys and the count of digit '7' appearances as values. Assume the departments are named 'Dept1', 'Dept2', etc., in the order of the thresholds provided.", "new_solution": "```python\ndef fizz_buzz(n: int):\n    cnt = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            cnt += str(i).count('7')\n    return cnt\n\ndef department_fizz_buzz(thresholds):\n    results = {}\n    for idx, threshold in enumerate(thresholds):\n        department_name = f'Dept{idx + 1}'\n        results[department_name] = fizz_buzz(threshold)\n    return results\n```", "input_format": "A list of integers representing different thresholds for different departments in a company.", "output_format": "A dictionary where keys are department names and values are the count of digit 7 appearances in numbers less than the threshold, divisible by 11 or 13.", "test_input": ["assert department_fizz_buzz([50, 78, 79]) == {'Dept1': 0, 'Dept2': 2, 'Dept3': 3}", "assert department_fizz_buzz([100, 150]) == {'Dept1': 3, 'Dept2': 4}", "assert department_fizz_buzz([200, 250, 300]) == {'Dept1': 6, 'Dept2': 7, 'Dept3': 10}", "assert department_fizz_buzz([10, 20, 30]) == {'Dept1': 0, 'Dept2': 0, 'Dept3': 0}", "assert department_fizz_buzz([77, 88, 99]) == {'Dept1': 0, 'Dept2': 3, 'Dept3': 3}"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "HumanEval/36-2", "raw_problem": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"", "raw_solution": "```python\n\n    cnt = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            cnt += len(list(filter(lambda c: c == \"7\", str(i))))\n    return cnt\n\n\n```", "raw_test_input": ["assert fizz_buzz(50) == 0", "assert fizz_buzz(78) == 2", "assert fizz_buzz(79) == 3", "assert fizz_buzz(100) == 3", "assert fizz_buzz(200) == 6", "assert fizz_buzz(4000) == 192", "assert fizz_buzz(10000) == 639", "assert fizz_buzz(100000) == 8026"], "new_problem": "Enhance the fizz_buzz function to allow checking for any digit's occurrence in numbers less than n that are divisible by a customizable list of divisors. The function should maintain backward compatibility with the original implementation, which checks for the digit 7 and divisors 11 and 13. The new function should include type hints and support the original function parameters, while adding new optional parameters for the digit to check and the list of divisors.", "new_solution": "```python\nfrom typing import List, Optional\n\ndef fizz_buzz(n: int, include_digit: Optional[int] = 7, divisors: Optional[List[int]] = None) -> int:\n    if divisors is None:\n        divisors = [11, 13]\n    cnt = 0\n    for i in range(n):\n        if any(i % divisor == 0 for divisor in divisors):\n            cnt += str(i).count(str(include_digit))\n    return cnt\n```", "input_format": "fizz_buzz(n: int, include_digit: Optional[int] = 7, divisors: Optional[List[int]] = [11, 13])", "output_format": "int", "test_input": ["assert fizz_buzz(50) == 0", "assert fizz_buzz(78) == 2", "assert fizz_buzz(79) == 3", "assert fizz_buzz(100, include_digit=1) == 4", "assert fizz_buzz(100, include_digit=7, divisors=[7, 14]) == 4", "assert fizz_buzz(100, include_digit=3, divisors=[3, 6]) == 8", "assert fizz_buzz(200, include_digit=5, divisors=[5, 10]) == 24", "assert fizz_buzz(150, include_digit=2, divisors=[2, 4, 8]) == 25"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "HumanEval/36-3", "raw_problem": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"", "raw_solution": "```python\n\n    cnt = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            cnt += len(list(filter(lambda c: c == \"7\", str(i))))\n    return cnt\n\n\n```", "raw_test_input": ["assert fizz_buzz(50) == 0", "assert fizz_buzz(78) == 2", "assert fizz_buzz(79) == 3", "assert fizz_buzz(100) == 3", "assert fizz_buzz(200) == 6", "assert fizz_buzz(4000) == 192", "assert fizz_buzz(10000) == 639", "assert fizz_buzz(100000) == 8026"], "new_problem": "Given a dictionary where keys are integers and values are lists of integers, return the number of times the digit 7 appears in integers from the lists that are divisible by either the key or 13. Additionally, ensure that the sum of all integers in each list does not exceed 1000.", "new_solution": "```python\ndef fizz_buzz_dict(data: dict[int, list[int]]) -> int:\n    cnt = 0\n    for key, values in data.items():\n        if sum(values) > 1000:\n            continue\n        for i in values:\n            if (i % key == 0 or i % 13 == 0) and i <= 1000:\n                cnt += str(i).count('7')\n    return cnt\n```", "input_format": "A dictionary where keys are integers and values are lists of integers.", "output_format": "An integer representing the total count of the digit 7 in the specified conditions.", "test_input": ["assert fizz_buzz_dict({11: [22, 33, 77], 13: [26, 39, 78]}) == 3", "assert fizz_buzz_dict({11: [22, 33, 77], 13: [26, 39, 78, 700]}) == 3", "assert fizz_buzz_dict({11: [22, 33, 77], 13: [26, 39, 78, 700], 5: [5, 10, 15]}) == 3", "assert fizz_buzz_dict({11: [22, 33, 77], 13: [26, 39, 78, 700], 5: [5, 10, 15, 700]}) == 4", "assert fizz_buzz_dict({11: [22, 33, 77], 13: [26, 39, 78, 700], 5: [5, 10, 15, 700, 1000]}) == 3"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "HumanEval/36-4", "raw_problem": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"", "raw_solution": "```python\n\n    cnt = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            cnt += len(list(filter(lambda c: c == \"7\", str(i))))\n    return cnt\n\n\n```", "raw_test_input": ["assert fizz_buzz(50) == 0", "assert fizz_buzz(78) == 2", "assert fizz_buzz(79) == 3", "assert fizz_buzz(100) == 3", "assert fizz_buzz(200) == 6", "assert fizz_buzz(4000) == 192", "assert fizz_buzz(10000) == 639", "assert fizz_buzz(100000) == 8026"], "new_problem": "Modify the fizz_buzz function to handle errors in a real-world scenario where the input might not be a valid integer. The function should raise a ValueError if the input is not a positive integer. Additionally, handle potential overflow errors if the input is too large. Implement custom exceptions for these cases and ensure meaningful error messages are provided.", "new_solution": "class FizzBuzzError(Exception):\n    pass\n\nclass InvalidInputError(FizzBuzzError):\n    def __init__(self, message=\"Input must be a positive integer\"):\n        self.message = message\n        super().__init__(self.message)\n\nclass OverflowError(FizzBuzzError):\n    def __init__(self, message=\"Input is too large to process\"):\n        self.message = message\n        super().__init__(self.message)\n\ndef fizz_buzz(n: int) -> int:\n    if not isinstance(n, int) or n <= 0:\n        raise InvalidInputError()\n    try:\n        cnt = 0\n        for i in range(n):\n            if i % 11 == 0 or i % 13 == 0:\n                cnt += len(list(filter(lambda c: c == \"7\", str(i))))\n        return cnt\n    except OverflowError:\n        raise OverflowError()", "input_format": "An integer n", "output_format": "An integer representing the count of digit '7' in numbers divisible by 11 or 13", "test_input": ["assert fizz_buzz(50) == 0", "assert fizz_buzz(78) == 2", "assert fizz_buzz(79) == 3", "try:\n    fizz_buzz(-10)\nexcept InvalidInputError as e:\n    assert str(e) == \"Input must be a positive integer\"", "try:\n    fizz_buzz(\"100\")\nexcept InvalidInputError as e:\n    assert str(e) == \"Input must be a positive integer\""], "requirement_type": "PROMPT_ERROR_HANDLING"}
{"task_id": "HumanEval/37-1", "raw_problem": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"", "raw_solution": "```python\n\n    even = [l[i] for i in range(len(l)) if i % 2 == 0]\n    even.sort()\n    return [even[i // 2] if i % 2 == 0 else l[i] for i in range(len(l))]\n\n\n```", "raw_test_input": ["assert tuple(sort_even([1, 2, 3])) == tuple([1, 2, 3])", "assert tuple(sort_even([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])", "assert tuple(sort_even([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])"], "new_problem": "In an e-commerce platform, you have a list of transactions. Each transaction is represented as a dictionary containing 'id', 'amount', and 'timestamp'. You need to process this list such that transactions at even indices are sorted by their 'amount', while transactions at odd indices remain in their original order. Implement a function `process_transactions(transactions: list) -> list` that achieves this by utilizing the `sort_even` function to sort the even-indexed transactions by 'amount'.", "new_solution": "```python\ndef sort_even(l: list):\n    even = [l[i] for i in range(len(l)) if i % 2 == 0]\n    even.sort(key=lambda x: x['amount'])\n    even_index = 0\n    result = []\n    for i in range(len(l)):\n        if i % 2 == 0:\n            result.append(even[even_index])\n            even_index += 1\n        else:\n            result.append(l[i])\n    return result\n\ndef process_transactions(transactions: list) -> list:\n    return sort_even(transactions)\n```", "input_format": "A list of transactions where each transaction is a dictionary with 'id', 'amount', and 'timestamp'.", "output_format": "A list of transactions with even-indexed transactions sorted by 'amount', while odd-indexed transactions remain in their original order.", "test_input": ["assert process_transactions([{'id': 1, 'amount': 200, 'timestamp': '2023-10-01'}, {'id': 2, 'amount': 150, 'timestamp': '2023-10-02'}, {'id': 3, 'amount': 100, 'timestamp': '2023-10-03'}]) == [{'id': 3, 'amount': 100, 'timestamp': '2023-10-03'}, {'id': 2, 'amount': 150, 'timestamp': '2023-10-02'}, {'id': 1, 'amount': 200, 'timestamp': '2023-10-01'}]", "assert process_transactions([{'id': 1, 'amount': 300, 'timestamp': '2023-10-01'}, {'id': 2, 'amount': 150, 'timestamp': '2023-10-02'}, {'id': 3, 'amount': 200, 'timestamp': '2023-10-03'}, {'id': 4, 'amount': 100, 'timestamp': '2023-10-04'}]) == [{'id': 3, 'amount': 200, 'timestamp': '2023-10-03'}, {'id': 2, 'amount': 150, 'timestamp': '2023-10-02'}, {'id': 1, 'amount': 300, 'timestamp': '2023-10-01'}, {'id': 4, 'amount': 100, 'timestamp': '2023-10-04'}]", "assert process_transactions([{'id': 1, 'amount': 500, 'timestamp': '2023-10-01'}, {'id': 2, 'amount': 400, 'timestamp': '2023-10-02'}, {'id': 3, 'amount': 300, 'timestamp': '2023-10-03'}, {'id': 4, 'amount': 200, 'timestamp': '2023-10-04'}, {'id': 5, 'amount': 100, 'timestamp': '2023-10-05'}]) == [{'id': 5, 'amount': 100, 'timestamp': '2023-10-05'}, {'id': 2, 'amount': 400, 'timestamp': '2023-10-02'}, {'id': 3, 'amount': 300, 'timestamp': '2023-10-03'}, {'id': 4, 'amount': 200, 'timestamp': '2023-10-04'}, {'id': 1, 'amount': 500, 'timestamp': '2023-10-01'}]", "assert process_transactions([{'id': 1, 'amount': 1000, 'timestamp': '2023-10-01'}, {'id': 2, 'amount': 900, 'timestamp': '2023-10-02'}, {'id': 3, 'amount': 800, 'timestamp': '2023-10-03'}, {'id': 4, 'amount': 700, 'timestamp': '2023-10-04'}, {'id': 5, 'amount': 600, 'timestamp': '2023-10-05'}, {'id': 6, 'amount': 500, 'timestamp': '2023-10-06'}]) == [{'id': 5, 'amount': 600, 'timestamp': '2023-10-05'}, {'id': 2, 'amount': 900, 'timestamp': '2023-10-02'}, {'id': 3, 'amount': 800, 'timestamp': '2023-10-03'}, {'id': 4, 'amount': 700, 'timestamp': '2023-10-04'}, {'id': 1, 'amount': 1000, 'timestamp': '2023-10-01'}, {'id': 6, 'amount': 500, 'timestamp': '2023-10-06'}]", "assert process_transactions([{'id': 1, 'amount': 50, 'timestamp': '2023-10-01'}, {'id': 2, 'amount': 40, 'timestamp': '2023-10-02'}, {'id': 3, 'amount': 30, 'timestamp': '2023-10-03'}, {'id': 4, 'amount': 20, 'timestamp': '2023-10-04'}, {'id': 5, 'amount': 10, 'timestamp': '2023-10-05'}, {'id': 6, 'amount': 0, 'timestamp': '2023-10-06'}]) == [{'id': 5, 'amount': 10, 'timestamp': '2023-10-05'}, {'id': 2, 'amount': 40, 'timestamp': '2023-10-02'}, {'id': 3, 'amount': 30, 'timestamp': '2023-10-03'}, {'id': 4, 'amount': 20, 'timestamp': '2023-10-04'}, {'id': 1, 'amount': 50, 'timestamp': '2023-10-01'}, {'id': 6, 'amount': 0, 'timestamp': '2023-10-06'}]"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "HumanEval/37-2", "raw_problem": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"", "raw_solution": "```python\n\n    even = [l[i] for i in range(len(l)) if i % 2 == 0]\n    even.sort()\n    return [even[i // 2] if i % 2 == 0 else l[i] for i in range(len(l))]\n\n\n```", "raw_test_input": ["assert tuple(sort_even([1, 2, 3])) == tuple([1, 2, 3])", "assert tuple(sort_even([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])", "assert tuple(sort_even([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])"], "new_problem": "Enhance the sort_even function to maintain backward compatibility while adding new optional parameters. The function should now accept an optional boolean parameter 'reverse' to sort the even indices in descending order if set to True. Additionally, include an optional parameter 'index_type' which can be 'even' or 'odd', indicating which indices should be sorted. By default, 'index_type' should be 'even'. The function should still return a list where the specified indices are sorted according to the given parameters.", "new_solution": "def sort_even(l: list[int], reverse: bool = False, index_type: str = 'even') -> list[int]:\n    if index_type == 'even':\n        indices = [i for i in range(len(l)) if i % 2 == 0]\n    elif index_type == 'odd':\n        indices = [i for i in range(len(l)) if i % 2 != 0]\n    else:\n        raise ValueError(\"index_type must be 'even' or 'odd'\")\n    \n    values = [l[i] for i in indices]\n    values.sort(reverse=reverse)\n    \n    result = l[:]\n    for idx, val in zip(indices, values):\n        result[idx] = val\n    return result", "input_format": "A list of integers and optional parameters for sorting order and index type.", "output_format": "A list of integers with even indices sorted based on the optional parameters.", "test_input": ["assert sort_even([1, 2, 3]) == [1, 2, 3]", "assert sort_even([5, 6, 3, 4]) == [3, 6, 5, 4]", "assert sort_even([5, 6, 3, 4], reverse=True) == [5, 6, 3, 4]", "assert sort_even([5, 6, 3, 4], index_type='odd') == [5, 4, 3, 6]", "assert sort_even([5, 6, 3, 4], reverse=True, index_type='odd') == [5, 6, 3, 4]"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "HumanEval/37-3", "raw_problem": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"", "raw_solution": "```python\n\n    even = [l[i] for i in range(len(l)) if i % 2 == 0]\n    even.sort()\n    return [even[i // 2] if i % 2 == 0 else l[i] for i in range(len(l))]\n\n\n```", "raw_test_input": ["assert tuple(sort_even([1, 2, 3])) == tuple([1, 2, 3])", "assert tuple(sort_even([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])", "assert tuple(sort_even([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])"], "new_problem": "Given a dictionary where keys represent indices and values represent elements of a list, return a new dictionary where the values at even indices are sorted, while values at odd indices remain unchanged. The dictionary should maintain the same keys. Additionally, ensure that the function can handle dictionaries with non-sequential keys and values of mixed data types, provided that all values at even indices are comparable.", "new_solution": "def sort_even_dict(d: dict[int, int]) -> dict[int, int]:\n    even_indices = sorted([k for k in d if k % 2 == 0])\n    even_values = sorted([d[k] for k in even_indices])\n    result = {}\n    even_index = 0\n    for k in sorted(d.keys()):\n        if k % 2 == 0:\n            result[k] = even_values[even_index]\n            even_index += 1\n        else:\n            result[k] = d[k]\n    return result", "input_format": "A dictionary where keys are indices and values are the elements of the list.", "output_format": "A dictionary with the same keys, but values at even indices are sorted.", "test_input": ["assert sort_even_dict({0: 5, 1: 6, 2: 3, 3: 4}) == {0: 3, 1: 6, 2: 5, 3: 4}", "assert sort_even_dict({0: 1, 1: 2, 2: 3}) == {0: 1, 1: 2, 2: 3}", "assert sort_even_dict({0: 9, 2: 7, 4: 5, 1: 8, 3: 6}) == {0: 5, 1: 8, 2: 7, 3: 6, 4: 9}", "assert sort_even_dict({0: 10, 1: 20, 2: 30, 3: 40, 4: 50}) == {0: 10, 1: 20, 2: 30, 3: 40, 4: 50}", "assert sort_even_dict({2: 3, 4: 1, 6: 2, 1: 5, 3: 4}) == {2: 1, 4: 2, 6: 3, 1: 5, 3: 4}"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "HumanEval/37-4", "raw_problem": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"", "raw_solution": "```python\n\n    even = [l[i] for i in range(len(l)) if i % 2 == 0]\n    even.sort()\n    return [even[i // 2] if i % 2 == 0 else l[i] for i in range(len(l))]\n\n\n```", "raw_test_input": ["assert tuple(sort_even([1, 2, 3])) == tuple([1, 2, 3])", "assert tuple(sort_even([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])", "assert tuple(sort_even([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])"], "new_problem": "Modify the function sort_even to handle the following errors: 1. Raise a ValueError if the input list contains non-integer elements. 2. Raise a TypeError if the input is not a list. 3. Handle IndexError gracefully if the list is empty. 4. Provide meaningful error messages for each exception.", "new_solution": "def sort_even(l: list) -> list:\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n    \"\"\"\n    if not isinstance(l, list):\n        raise TypeError(\"Input must be a list.\")\n    if not all(isinstance(x, int) for x in l):\n        raise ValueError(\"All elements in the list must be integers.\")\n    try:\n        even = [l[i] for i in range(len(l)) if i % 2 == 0]\n        even.sort()\n        return [even[i // 2] if i % 2 == 0 else l[i] for i in range(len(l))]\n    except IndexError:\n        return []  # Return an empty list if the input list is empty", "input_format": "A list of integers", "output_format": "A list of integers with sorted even indices", "test_input": ["assert sort_even([1, 2, 3]) == [1, 2, 3]", "assert sort_even([5, 6, 3, 4]) == [3, 6, 5, 4]", "try:\n    sort_even('not a list')\nexcept TypeError as e:\n    assert str(e) == 'Input must be a list.'", "try:\n    sort_even([1, 'two', 3])\nexcept ValueError as e:\n    assert str(e) == 'All elements in the list must be integers.'", "assert sort_even([]) == []"], "requirement_type": "PROMPT_ERROR_HANDLING"}
{"task_id": "HumanEval/40-1", "raw_problem": "def triples_sum_to_zero(l: list):\n    \"\"\"\n    triples_sum_to_zero takes a list of integers as an input.\n    it returns True if there are three distinct elements in the list that\n    sum to zero, and False otherwise.\n\n    >>> triples_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> triples_sum_to_zero([1, 3, -2, 1])\n    True\n    >>> triples_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n    True\n    >>> triples_sum_to_zero([1])\n    False\n    \"\"\"", "raw_solution": "```python\n\n    for i in range(len(l)):\n        for j in range(len(l)):\n            for k in range(len(l)):\n                if i != j and i != k and j != k and l[i] + l[j] + l[k] == 0:\n                    return True\n    return False\n\n\n```", "raw_test_input": ["assert triples_sum_to_zero([1, 3, 5, 0]) == False", "assert triples_sum_to_zero([1, 3, 5, -1]) == False", "assert triples_sum_to_zero([1, 3, -2, 1]) == True", "assert triples_sum_to_zero([1, 2, 3, 7]) == False", "assert triples_sum_to_zero([1, 2, 5, 7]) == False", "assert triples_sum_to_zero([2, 4, -5, 3, 9, 7]) == True", "assert triples_sum_to_zero([1]) == False", "assert triples_sum_to_zero([1, 3, 5, -100]) == False", "assert triples_sum_to_zero([100, 3, 5, -100]) == False"], "new_problem": "In a financial auditing system, you are given a list of accounts, where each account contains a list of transaction amounts. Your task is to determine for each account if there are any three distinct transactions that sum to zero. This can help identify potential errors or fraudulent activities where transactions cancel each other out. Implement a function `audit_accounts` that takes a list of accounts (each account is a list of integers) and returns a list of booleans. Each boolean indicates whether the corresponding account contains a zero-sum triplet.", "new_solution": "def triples_sum_to_zero(l):\n    for i in range(len(l)):\n        for j in range(len(l)):\n            for k in range(len(l)):\n                if i != j and i != k and j != k and l[i] + l[j] + l[k] == 0:\n                    return True\n    return False\n\ndef audit_accounts(accounts):\n    return [triples_sum_to_zero(account) for account in accounts]", "input_format": "A list of lists, where each sublist contains integers representing financial transactions for different accounts.", "output_format": "A list of booleans, where each boolean indicates whether there is a zero-sum triplet in the corresponding account's transactions.", "test_input": ["assert audit_accounts([[1, 3, 5, 0], [1, 3, -2, 1], [1, 2, 3, 7], [2, 4, -5, 3, 9, 7], [1]]) == [False, True, False, True, False]", "assert audit_accounts([[0, 0, 0], [1, -1, 0], [10, -10, 0], [5, 5, -10], [100, 200, -300]]) == [True, True, True, True, True]", "assert audit_accounts([[1, 2, 3], [4, 5, 6], [7, 8, 9], [-1, -2, -3], [-4, -5, -6]]) == [False, False, False, False, False]", "assert audit_accounts([[1, 2, -3], [3, -1, -2], [0, 0, 0, 0], [10, 20, -30], [5, -5, 0]]) == [True, True, True, True, True]", "assert audit_accounts([[1, 1, 1], [2, 2, 2], [3, 3, 3], [4, 4, 4], [5, 5, 5]]) == [False, False, False, False, False]"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "HumanEval/40-2", "raw_problem": "def triples_sum_to_zero(l: list):\n    \"\"\"\n    triples_sum_to_zero takes a list of integers as an input.\n    it returns True if there are three distinct elements in the list that\n    sum to zero, and False otherwise.\n\n    >>> triples_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> triples_sum_to_zero([1, 3, -2, 1])\n    True\n    >>> triples_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n    True\n    >>> triples_sum_to_zero([1])\n    False\n    \"\"\"", "raw_solution": "```python\n\n    for i in range(len(l)):\n        for j in range(len(l)):\n            for k in range(len(l)):\n                if i != j and i != k and j != k and l[i] + l[j] + l[k] == 0:\n                    return True\n    return False\n\n\n```", "raw_test_input": ["assert triples_sum_to_zero([1, 3, 5, 0]) == False", "assert triples_sum_to_zero([1, 3, 5, -1]) == False", "assert triples_sum_to_zero([1, 3, -2, 1]) == True", "assert triples_sum_to_zero([1, 2, 3, 7]) == False", "assert triples_sum_to_zero([1, 2, 5, 7]) == False", "assert triples_sum_to_zero([2, 4, -5, 3, 9, 7]) == True", "assert triples_sum_to_zero([1]) == False", "assert triples_sum_to_zero([1, 3, 5, -100]) == False", "assert triples_sum_to_zero([100, 3, 5, -100]) == False"], "new_problem": "Enhance the function `triples_sum_to_zero` to optionally return the indices of the elements that sum to zero. The function should maintain backward compatibility by defaulting to the original behavior of returning a boolean. If the new optional parameter `return_indices` is set to True, the function should return a tuple where the first element is a boolean indicating if such a triplet exists, and the second element is a list of tuples, each containing the indices of the elements that sum to zero.", "new_solution": "```python\nfrom typing import List, Tuple, Union\n\ndef triples_sum_to_zero(l: List[int], return_indices: bool = False) -> Union[bool, Tuple[bool, List[Tuple[int, int, int]]]]:\n    indices = []\n    for i in range(len(l)):\n        for j in range(i + 1, len(l)):\n            for k in range(j + 1, len(l)):\n                if l[i] + l[j] + l[k] == 0:\n                    if return_indices:\n                        indices.append((i, j, k))\n                    else:\n                        return True\n    if return_indices:\n        return (len(indices) > 0, indices)\n    return False\n```", "input_format": "triples_sum_to_zero(l: List[int], return_indices: bool = False) -> Union[bool, Tuple[bool, List[Tuple[int, int, int]]]]", "output_format": "Union[bool, Tuple[bool, List[Tuple[int, int, int]]]]", "test_input": ["assert triples_sum_to_zero([1, 3, 5, 0]) == False", "assert triples_sum_to_zero([1, 3, -2, 1]) == True", "assert triples_sum_to_zero([1, 2, 3, 7]) == False", "assert triples_sum_to_zero([2, 4, -5, 3, 9, 7]) == True", "assert triples_sum_to_zero([1]) == False", "assert triples_sum_to_zero([1, 3, -2, 1], return_indices=True) == (True, [(0, 2, 3)])", "assert triples_sum_to_zero([1, 2, 3, 7], return_indices=True) == (False, [])", "assert triples_sum_to_zero([2, 4, -5, 3, 9, 7], return_indices=True) == (True, [(0, 2, 3)])", "assert triples_sum_to_zero([1, 3, 5, 0], return_indices=True) == (False, [])", "assert triples_sum_to_zero([1], return_indices=True) == (False, [])"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "HumanEval/40-3", "raw_problem": "def triples_sum_to_zero(l: list):\n    \"\"\"\n    triples_sum_to_zero takes a list of integers as an input.\n    it returns True if there are three distinct elements in the list that\n    sum to zero, and False otherwise.\n\n    >>> triples_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> triples_sum_to_zero([1, 3, -2, 1])\n    True\n    >>> triples_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n    True\n    >>> triples_sum_to_zero([1])\n    False\n    \"\"\"", "raw_solution": "```python\n\n    for i in range(len(l)):\n        for j in range(len(l)):\n            for k in range(len(l)):\n                if i != j and i != k and j != k and l[i] + l[j] + l[k] == 0:\n                    return True\n    return False\n\n\n```", "raw_test_input": ["assert triples_sum_to_zero([1, 3, 5, 0]) == False", "assert triples_sum_to_zero([1, 3, 5, -1]) == False", "assert triples_sum_to_zero([1, 3, -2, 1]) == True", "assert triples_sum_to_zero([1, 2, 3, 7]) == False", "assert triples_sum_to_zero([1, 2, 5, 7]) == False", "assert triples_sum_to_zero([2, 4, -5, 3, 9, 7]) == True", "assert triples_sum_to_zero([1]) == False", "assert triples_sum_to_zero([1, 3, 5, -100]) == False", "assert triples_sum_to_zero([100, 3, 5, -100]) == False"], "new_problem": "Given a dictionary where each key is an integer and each value is a list of integers, determine if there are three distinct integers from any of the lists that sum to zero. The integers must be from the same list, and the solution should be optimized using a set data structure to improve performance. Additionally, the function should handle cases where the lists are very large, and it should return False if any list has fewer than three elements.", "new_solution": "def triples_sum_to_zero_dict(d: dict[int, list[int]]) -> bool:\n    for key, lst in d.items():\n        if len(lst) < 3:\n            continue\n        lst.sort()\n        for i in range(len(lst) - 2):\n            if i > 0 and lst[i] == lst[i - 1]:\n                continue\n            left, right = i + 1, len(lst) - 1\n            while left < right:\n                current_sum = lst[i] + lst[left] + lst[right]\n                if current_sum == 0:\n                    return True\n                elif current_sum < 0:\n                    left += 1\n                else:\n                    right -= 1\n    return False", "input_format": "A dictionary where keys are integers and values are lists of integers.", "output_format": "A boolean indicating if there exists a combination of three distinct integers from any of the lists that sum to zero.", "test_input": ["assert triples_sum_to_zero_dict({1: [1, 3, 5, 0], 2: [1, 3, -2, 1]}) == True", "assert triples_sum_to_zero_dict({1: [1, 2, 3, 7], 2: [2, 4, -5, 3, 9, 7]}) == True", "assert triples_sum_to_zero_dict({1: [1], 2: [2, 3]}) == False", "assert triples_sum_to_zero_dict({1: [0, 0, 0], 2: [-1, 1, 0]}) == True", "assert triples_sum_to_zero_dict({1: [10, -10, 0], 2: [5, 5, -10]}) == True"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "HumanEval/40-4", "raw_problem": "def triples_sum_to_zero(l: list):\n    \"\"\"\n    triples_sum_to_zero takes a list of integers as an input.\n    it returns True if there are three distinct elements in the list that\n    sum to zero, and False otherwise.\n\n    >>> triples_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> triples_sum_to_zero([1, 3, -2, 1])\n    True\n    >>> triples_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n    True\n    >>> triples_sum_to_zero([1])\n    False\n    \"\"\"", "raw_solution": "```python\n\n    for i in range(len(l)):\n        for j in range(len(l)):\n            for k in range(len(l)):\n                if i != j and i != k and j != k and l[i] + l[j] + l[k] == 0:\n                    return True\n    return False\n\n\n```", "raw_test_input": ["assert triples_sum_to_zero([1, 3, 5, 0]) == False", "assert triples_sum_to_zero([1, 3, 5, -1]) == False", "assert triples_sum_to_zero([1, 3, -2, 1]) == True", "assert triples_sum_to_zero([1, 2, 3, 7]) == False", "assert triples_sum_to_zero([1, 2, 5, 7]) == False", "assert triples_sum_to_zero([2, 4, -5, 3, 9, 7]) == True", "assert triples_sum_to_zero([1]) == False", "assert triples_sum_to_zero([1, 3, 5, -100]) == False", "assert triples_sum_to_zero([100, 3, 5, -100]) == False"], "new_problem": "Modify the function `triples_sum_to_zero` to handle errors in a real-world scenario where the input list might contain non-integer values, be empty, or be too short to form a triplet. The function should raise a `ValueError` if the list contains non-integer values, an `EmptyListError` if the list is empty, and a `TooShortListError` if the list has fewer than three elements. Implement these custom exceptions and ensure the function handles these errors gracefully.", "new_solution": "class EmptyListError(Exception):\n    pass\n\nclass TooShortListError(Exception):\n    pass\n\ndef triples_sum_to_zero(l: list) -> bool:\n    if not l:\n        raise EmptyListError(\"The list is empty.\")\n    if len(l) < 3:\n        raise TooShortListError(\"The list must contain at least three elements.\")\n    if not all(isinstance(x, int) for x in l):\n        raise ValueError(\"All elements in the list must be integers.\")\n\n    for i in range(len(l)):\n        for j in range(len(l)):\n            for k in range(len(l)):\n                if i != j and i != k and j != k and l[i] + l[j] + l[k] == 0:\n                    return True\n    return False", "input_format": "A list of integers", "output_format": "Boolean indicating if any three distinct integers sum to zero", "test_input": ["try:\n    assert triples_sum_to_zero([1, 3, 5, 0]) == False\nexcept Exception as e:\n    print(e)", "try:\n    assert triples_sum_to_zero([1, 3, -2, 1]) == True\nexcept Exception as e:\n    print(e)", "try:\n    assert triples_sum_to_zero([1, 2, 3, 7]) == False\nexcept Exception as e:\n    print(e)", "try:\n    assert triples_sum_to_zero([2, 4, -5, 3, 9, 7]) == True\nexcept Exception as e:\n    print(e)", "try:\n    assert triples_sum_to_zero([1]) == False\nexcept TooShortListError as e:\n    print(e)", "try:\n    assert triples_sum_to_zero([]) == False\nexcept EmptyListError as e:\n    print(e)", "try:\n    assert triples_sum_to_zero([1, 'a', 3]) == False\nexcept ValueError as e:\n    print(e)"], "requirement_type": "PROMPT_ERROR_HANDLING"}
