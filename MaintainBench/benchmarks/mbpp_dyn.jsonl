{"task_id": "Mbpp/17-1", "raw_problem": "Write a function that returns the perimeter of a square given its side length as input.", "raw_solution": "```python\n\ndef mbpp_run1(a):\n  return 4*a\n\n ```", "raw_test_input": ["assert mbpp_run1(10)==40", "assert mbpp_run1(5)==20", "assert mbpp_run1(4)==16"], "new_problem": "You are tasked with calculating the total fencing required for multiple square-shaped plots of land in a farming project. Each plot has a specified side length and quantity. Write a function that uses the original square_perimeter function to compute the total perimeter for each plot and the overall total perimeter needed for all plots combined.", "new_solution": "def square_perimeter(a):\n    return 4 * a\n\ndef mbpp_run2(plots):\n    total_perimeters = {}\n    overall_total_perimeter = 0\n    for plot in plots:\n        side_length = plot['side_length']\n        quantity = plot['quantity']\n        perimeter = square_perimeter(side_length)\n        total_perimeter = perimeter * quantity\n        total_perimeters[f'plot_{side_length}'] = total_perimeter\n        overall_total_perimeter += total_perimeter\n    total_perimeters['overall_total'] = overall_total_perimeter\n    return total_perimeters", "input_format": "A list of dictionaries, each containing 'side_length' and 'quantity' for different square-shaped plots of land.", "output_format": "A dictionary with the total perimeter for each plot and the overall total perimeter.", "test_input": ["assert mbpp_run2([{'side_length': 5, 'quantity': 2}]) == {'plot_5': 40, 'overall_total': 40}", "assert mbpp_run2([{'side_length': 3, 'quantity': 4}, {'side_length': 2, 'quantity': 3}]) == {'plot_3': 48, 'plot_2': 24, 'overall_total': 72}", "assert mbpp_run2([{'side_length': 10, 'quantity': 1}]) == {'plot_10': 40, 'overall_total': 40}", "assert mbpp_run2([{'side_length': 7, 'quantity': 3}, {'side_length': 4, 'quantity': 2}]) == {'plot_7': 84, 'plot_4': 32, 'overall_total': 116}", "assert mbpp_run2([{'side_length': 6, 'quantity': 5}]) == {'plot_6': 120, 'overall_total': 120}"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "Mbpp/17-2", "raw_problem": "Write a function that returns the perimeter of a square given its side length as input.", "raw_solution": "```python\n\ndef mbpp_run1(a):\n  return 4*a\n\n ```", "raw_test_input": ["assert mbpp_run1(10)==40", "assert mbpp_run1(5)==20", "assert mbpp_run1(4)==16"], "new_problem": "Enhance the function that calculates the perimeter of a square to support an optional parameter for the unit of measurement. The function should maintain backward compatibility with existing implementations that only provide the side length. The function should return the perimeter as a float, and the unit parameter should default to 'm' (meters) if not provided.", "new_solution": "def mbpp_run2(a: float, unit: str = 'm') -> float:\n    return 4 * a", "input_format": "side_length: float, unit: str = 'm'", "output_format": "float", "test_input": ["assert mbpp_run2(5) == 20", "assert mbpp_run2(5, 'cm') == 20", "assert mbpp_run2(0) == 0", "assert mbpp_run2(2.5) == 10.0", "assert mbpp_run2(3.5, 'inches') == 14.0"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "Mbpp/17-3", "raw_problem": "Write a function that returns the perimeter of a square given its side length as input.", "raw_solution": "```python\n\ndef mbpp_run1(a):\n  return 4*a\n\n ```", "raw_test_input": ["assert mbpp_run1(10)==40", "assert mbpp_run1(5)==20", "assert mbpp_run1(4)==16"], "new_problem": "Write a function that takes a list of dictionaries, where each dictionary contains the side length of a square under the key 'side'. The function should return a dictionary where each key is the index of the square in the input list, and the value is the perimeter of the corresponding square. The function should include type hints and handle cases where the side length is not a positive number by ignoring those entries.", "new_solution": "from typing import List, Dict\n\ndef square_perimeter(a: float) -> float:\n    return 4 * a\n\n\ndef mbpp_run2(squares: List[Dict[str, float]]) -> Dict[str, float]:\n    perimeters = {}\n    for index, square in enumerate(squares):\n        side = square.get('side', 0)\n        if side > 0:\n            perimeters[str(index)] = square_perimeter(side)\n    return perimeters\n", "input_format": "List[Dict[str, float]]", "output_format": "Dict[str, float]", "test_input": ["assert mbpp_run2([{'side': 5}, {'side': 3}, {'side': 0}, {'side': -2}, {'side': 7}]) == {'0': 20, '1': 12, '4': 28}", "assert mbpp_run2([{'side': 10}, {'side': 2.5}]) == {'0': 40, '1': 10}", "assert mbpp_run2([{'side': 0}, {'side': -1}]) == {}", "assert mbpp_run2([{'side': 4}, {'side': 4}, {'side': 4}]) == {'0': 16, '1': 16, '2': 16}", "assert mbpp_run2([]) == {}"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "Mbpp/17-4", "raw_problem": "Write a function that returns the perimeter of a square given its side length as input.", "raw_solution": "```python\n\ndef mbpp_run1(a):\n  return 4*a\n\n ```", "raw_test_input": ["assert mbpp_run1(10)==40", "assert mbpp_run1(5)==20", "assert mbpp_run1(4)==16"], "new_problem": "Write a function that returns the perimeter of a square given its side length as input. The function should handle the following errors: \n1. If the input is not a number, raise a TypeError with a message 'Input must be a number'.\n2. If the input is a negative number, raise a ValueError with a message 'Side length cannot be negative'.\n3. If the input is zero, raise a ValueError with a message 'Side length must be greater than zero'.\nEnsure that the function propagates these errors with meaningful messages.", "new_solution": "def mbpp_run2(a: float) -> float:\n    if not isinstance(a, (int, float)):\n        raise TypeError('Input must be a number')\n    if a < 0:\n        raise ValueError('Side length cannot be negative')\n    if a == 0:\n        raise ValueError('Side length must be greater than zero')\n    return 4 * a", "input_format": "A single integer or float representing the side length of a square.", "output_format": "An integer or float representing the perimeter of the square.", "test_input": ["assert mbpp_run2(5) == 20", "assert mbpp_run2(2.5) == 10.0", "try:\n    mbpp_run2(-1)\nexcept ValueError as e:\n    assert str(e) == 'Side length cannot be negative'", "try:\n    mbpp_run2(0)\nexcept ValueError as e:\n    assert str(e) == 'Side length must be greater than zero'", "try:\n    mbpp_run2('a')\nexcept TypeError as e:\n    assert str(e) == 'Input must be a number'"], "requirement_type": "PROMPT_ERROR_HANDLING"}
{"task_id": "Mbpp/18-1", "raw_problem": "Write a function to remove characters from the first string which are present in the second string.", "raw_solution": "```python\n\ndef mbpp_run1(string, second_string): \n\tfor char in second_string:\n\t\tstring = string.replace(char, '')\n\treturn string\n\n ```", "raw_test_input": ["assert mbpp_run1(\"probasscurve\", \"pros\") == 'bacuve'", "assert mbpp_run1(\"digitalindia\", \"talent\") == 'digiidi'", "assert mbpp_run1(\"exoticmiles\", \"toxic\") == 'emles'"], "new_problem": "In an e-commerce platform, customer reviews are essential for product feedback. However, certain words or phrases are prohibited due to policy violations. Write a function that takes a list of customer reviews and a list of prohibited words, and returns a list of cleaned reviews with all prohibited words removed. Use the original function to remove prohibited words from each review.", "new_solution": "import re\n\ndef mbpp_run2(reviews, prohibited_words):\n    cleaned_reviews = []\n    for review in reviews:\n        cleaned_review = review\n        for word in prohibited_words:\n            cleaned_review = cleaned_review.replace(word, '')  # Remove entire word\n        # Use regular expression to handle extra spaces\n        cleaned_review = re.sub(r'\\s+', ' ', cleaned_review).strip()\n        cleaned_reviews.append(cleaned_review)\n    return cleaned_reviews", "input_format": "A list of customer reviews (strings) and a list of prohibited words (strings).", "output_format": "A list of cleaned customer reviews with prohibited words removed.", "test_input": ["assert mbpp_run2(['This product is amazing!', 'Worst purchase ever.'], ['amazing', 'Worst']) == ['This product is !', 'purchase ever.']", "assert mbpp_run2(['Great value for money.', 'Not worth the price.'], ['value', 'price']) == ['Great for money.', 'Not worth the .']", "assert mbpp_run2(['Excellent quality.', 'Terrible service.'], ['Excellent', 'Terrible']) == ['quality.', 'service.']", "assert mbpp_run2(['Fast shipping!', 'Slow delivery.'], ['Fast', 'Slow']) == ['shipping!', 'delivery.']", "assert mbpp_run2(['Highly recommend.', 'Do not recommend.'], ['Highly', 'not']) == ['recommend.', 'Do recommend.']"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "Mbpp/18-2", "raw_problem": "Write a function to remove characters from the first string which are present in the second string.", "raw_solution": "```python\n\ndef mbpp_run1(string, second_string): \n\tfor char in second_string:\n\t\tstring = string.replace(char, '')\n\treturn string\n\n ```", "raw_test_input": ["assert mbpp_run1(\"probasscurve\", \"pros\") == 'bacuve'", "assert mbpp_run1(\"digitalindia\", \"talent\") == 'digiidi'", "assert mbpp_run1(\"exoticmiles\", \"toxic\") == 'emles'"], "new_problem": "Enhance the function to remove characters from the first string which are present in the second string, with an option to ignore case sensitivity. The function should maintain backward compatibility with existing implementations, support original function parameters, include type hints, and add a new optional parameter 'case_sensitive' which defaults to True.", "new_solution": "def mbpp_run2(string: str, second_string: str, case_sensitive: bool = True) -> str:\n    if not case_sensitive:\n        lower_string = string.lower()\n        lower_second_string = second_string.lower()\n        result = \"\"\n        for char in string:\n            if char.lower() not in lower_second_string:\n                result += char\n    else:\n        for char in second_string:\n            string = string.replace(char, '')\n        result = string\n    return result", "input_format": "remove_dirty_chars(string: str, second_string: str, case_sensitive: bool = True) -> str", "output_format": "str", "test_input": ["assert mbpp_run2('hello world', 'lo') == 'he wrd'", "assert mbpp_run2('hello world', 'LO', case_sensitive=False) == 'he wrd'", "assert mbpp_run2('hello world', 'LO', case_sensitive=True) == 'hello world'", "assert mbpp_run2('Python Programming', 'p', case_sensitive=False) == 'ython rogramming'", "assert mbpp_run2('Python Programming', 'p', case_sensitive=True) == 'Python Programming'"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "Mbpp/18-3", "raw_problem": "Write a function to remove characters from the first string which are present in the second string.", "raw_solution": "```python\n\ndef mbpp_run1(string, second_string): \n\tfor char in second_string:\n\t\tstring = string.replace(char, '')\n\treturn string\n\n ```", "raw_test_input": ["assert mbpp_run1(\"probasscurve\", \"pros\") == 'bacuve'", "assert mbpp_run1(\"digitalindia\", \"talent\") == 'digiidi'", "assert mbpp_run1(\"exoticmiles\", \"toxic\") == 'emles'"], "new_problem": "Write a function that takes a dictionary where each key is a string and each value is a list of strings. Remove characters from each string in the lists that are present in a given set of characters. The function should return a new dictionary with the same keys, but with the modified lists. Use a set for the characters to be removed for efficient look-up. Ensure that the function handles large dictionaries efficiently and that the input strings and lists are not modified in place.", "new_solution": "def mbpp_run2(data: dict[str, list[str]], chars_to_remove: set[str]) -> dict[str, list[str]]:\n    def remove_chars(s: str, chars: set[str]) -> str:\n        return ''.join(c for c in s if c not in chars)\n\n    return {key: [remove_chars(s, chars_to_remove) for s in strings] for key, strings in data.items()}", "input_format": "A dictionary where keys are strings and values are lists of strings.", "output_format": "A dictionary with the same keys, but values are lists of strings with certain characters removed.", "test_input": ["assert mbpp_run2({'a': ['apple', 'banana'], 'b': ['berry', 'cherry']}, {'a', 'e'}) == {'a': ['ppl', 'bnn'], 'b': ['brry', 'chrry']}", "assert mbpp_run2({'fruits': ['apple', 'orange'], 'veggies': ['carrot', 'lettuce']}, {'o', 't'}) == {'fruits': ['apple', 'range'], 'veggies': ['carr', 'leuce']}", "assert mbpp_run2({'x': ['xylophone', 'xenon'], 'y': ['yellow', 'yarn']}, {'x', 'y'}) == {'x': ['lophone', 'enon'], 'y': ['ellow', 'arn']}", "assert mbpp_run2({'numbers': ['one', 'two', 'three'], 'letters': ['abc', 'def']}, {'e', 'o'}) == {'numbers': ['n', 'tw', 'thr'], 'letters': ['abc', 'df']}", "assert mbpp_run2({'animals': ['cat', 'dog'], 'birds': ['sparrow', 'eagle']}, {'a', 'g'}) == {'animals': ['ct', 'do'], 'birds': ['sprrow', 'ele']}"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "Mbpp/18-4", "raw_problem": "Write a function to remove characters from the first string which are present in the second string.", "raw_solution": "```python\n\ndef mbpp_run1(string, second_string): \n\tfor char in second_string:\n\t\tstring = string.replace(char, '')\n\treturn string\n\n ```", "raw_test_input": ["assert mbpp_run1(\"probasscurve\", \"pros\") == 'bacuve'", "assert mbpp_run1(\"digitalindia\", \"talent\") == 'digiidi'", "assert mbpp_run1(\"exoticmiles\", \"toxic\") == 'emles'"], "new_problem": "Write a function to remove characters from the first string which are present in the second string. The function should handle the following errors: 1) If either input is not a string, raise a TypeError with a meaningful message. 2) If the first string is empty, raise a ValueError. 3) If the second string is empty, return the first string unchanged. Implement error propagation and ensure that the function has type hints.", "new_solution": "def mbpp_run2(string: str, second_string: str) -> str:\n    if not isinstance(string, str) or not isinstance(second_string, str):\n        raise TypeError('Both inputs must be strings.')\n    if string == '':\n        raise ValueError('The first string must not be empty.')\n    if second_string == '':\n        return string\n    for char in second_string:\n        string = string.replace(char, '')\n    return string", "input_format": "Two strings: the first string from which characters will be removed, and the second string containing characters to be removed.", "output_format": "A string with characters removed from the first string that are present in the second string.", "test_input": ["assert mbpp_run2('hello world', 'lo') == 'he wrd'", "assert mbpp_run2('abcdef', '') == 'abcdef'", "try:\n    mbpp_run2('', 'abc')\nexcept ValueError as e:\n    assert str(e) == 'The first string must not be empty.'", "try:\n    mbpp_run2(123, 'abc')\nexcept TypeError as e:\n    assert str(e) == 'Both inputs must be strings.'", "try:\n    mbpp_run2('hello', 456)\nexcept TypeError as e:\n    assert str(e) == 'Both inputs must be strings.'"], "requirement_type": "PROMPT_ERROR_HANDLING"}
{"task_id": "Mbpp/19-1", "raw_problem": "Write a function to find whether a given array of integers contains any duplicate element.", "raw_solution": "```python\n\ndef mbpp_run1(arraynums):\n    return len(arraynums) != len(set(arraynums))\n\n ```", "raw_test_input": ["assert mbpp_run1(([1,2,3,4,5]))==False", "assert mbpp_run1(([1,2,3,4, 4]))==True", "assert mbpp_run1([1,1,2,2,3,3,4,4,5])==True"], "new_problem": "In an e-commerce platform, you are tasked with processing a list of transactions to identify any duplicate transactions based on 'transaction_id' and calculate the total amount of unique transactions. Use the original function to detect duplicates and extend it to compute the total amount of unique transactions.", "new_solution": "def mbpp_run2(arraynums):\n    return len(arraynums) != len(set(arraynums))\n\ndef mbpp_run2(transactions):\n    transaction_ids = [transaction['transaction_id'] for transaction in transactions]\n    duplicate_transactions = []\n    unique_transactions = []\n    \n    for transaction in transactions:\n        if transaction_ids.count(transaction['transaction_id']) > 1:\n            if transaction['transaction_id'] not in duplicate_transactions:\n                duplicate_transactions.append(transaction['transaction_id'])\n        else:\n            unique_transactions.append(transaction)\n    \n    total_amount = sum(transaction['amount'] for transaction in unique_transactions)\n    \n    return {\n        'duplicate_transactions': duplicate_transactions,\n        'total_amount': total_amount\n    }", "input_format": "A list of dictionaries, each representing a transaction with 'transaction_id', 'user_id', and 'amount'.", "output_format": "A dictionary with 'duplicate_transactions' as a list of transaction IDs that are duplicates and 'total_amount' as the sum of all unique transactions.", "test_input": ["assert mbpp_run2([{'transaction_id': 1, 'user_id': 101, 'amount': 100}, {'transaction_id': 2, 'user_id': 102, 'amount': 200}, {'transaction_id': 1, 'user_id': 101, 'amount': 100}]) == {'duplicate_transactions': [1], 'total_amount': 200}", "assert mbpp_run2([{'transaction_id': 1, 'user_id': 101, 'amount': 100}, {'transaction_id': 2, 'user_id': 102, 'amount': 200}, {'transaction_id': 3, 'user_id': 103, 'amount': 300}]) == {'duplicate_transactions': [], 'total_amount': 600}", "assert mbpp_run2([{'transaction_id': 1, 'user_id': 101, 'amount': 100}, {'transaction_id': 1, 'user_id': 101, 'amount': 100}, {'transaction_id': 1, 'user_id': 101, 'amount': 100}]) == {'duplicate_transactions': [1], 'total_amount': 0}", "assert mbpp_run2([{'transaction_id': 1, 'user_id': 101, 'amount': 100}, {'transaction_id': 2, 'user_id': 102, 'amount': 200}, {'transaction_id': 3, 'user_id': 103, 'amount': 300}, {'transaction_id': 2, 'user_id': 102, 'amount': 200}]) == {'duplicate_transactions': [2], 'total_amount': 400}", "assert mbpp_run2([{'transaction_id': 1, 'user_id': 101, 'amount': 100}]) == {'duplicate_transactions': [], 'total_amount': 100}"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "Mbpp/19-2", "raw_problem": "Write a function to find whether a given array of integers contains any duplicate element.", "raw_solution": "```python\n\ndef mbpp_run1(arraynums):\n    return len(arraynums) != len(set(arraynums))\n\n ```", "raw_test_input": ["assert mbpp_run1(([1,2,3,4,5]))==False", "assert mbpp_run1(([1,2,3,4, 4]))==True", "assert mbpp_run1([1,1,2,2,3,3,4,4,5])==True"], "new_problem": "Enhance the function to find whether a given array of integers contains any duplicate element, with an optional parameter to ignore negative numbers when checking for duplicates. The function should maintain backward compatibility with existing implementations.", "new_solution": "from typing import List, Optional\n\ndef mbpp_run2(arraynums: List[int], ignore_negatives: Optional[bool] = False) -> bool:\n    if ignore_negatives:\n        filtered_nums = [num for num in arraynums if num >= 0]\n    else:\n        filtered_nums = arraynums\n    return len(filtered_nums) != len(set(filtered_nums))", "input_format": "List[int], Optional[bool]", "output_format": "bool", "test_input": ["assert mbpp_run2([1, 2, 3, 4, 5]) == False", "assert mbpp_run2([1, 2, 3, 4, 5, 1]) == True", "assert mbpp_run2([-1, -2, -3, -4, -5, -1], ignore_negatives=True) == False", "assert mbpp_run2([-1, -2, -3, -4, -5, -1], ignore_negatives=False) == True", "assert mbpp_run2([1, 2, 3, -1, -2, 3], ignore_negatives=True) == True"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "Mbpp/19-3", "raw_problem": "Write a function to find whether a given array of integers contains any duplicate element.", "raw_solution": "```python\n\ndef mbpp_run1(arraynums):\n    return len(arraynums) != len(set(arraynums))\n\n ```", "raw_test_input": ["assert mbpp_run1(([1,2,3,4,5]))==False", "assert mbpp_run1(([1,2,3,4, 4]))==True", "assert mbpp_run1([1,1,2,2,3,3,4,4,5])==True"], "new_problem": "Write a function to determine if any user in a given dictionary of user purchases has purchased the same item more than once. Each user is represented by a unique ID, and their purchases are stored in a list. The function should return True if any user has duplicate purchases, otherwise False. Use a set to optimize the check for duplicates within each user's purchase list.", "new_solution": "def mbpp_run2(user_purchases: dict[int, list[int]]) -> bool:\n    for user_id, purchases in user_purchases.items():\n        if len(purchases) != len(set(purchases)):\n            return True\n    return False", "input_format": "A dictionary where keys are user IDs (integers) and values are lists of integers representing items purchased by the user.", "output_format": "A boolean indicating whether any user has purchased the same item more than once.", "test_input": ["assert mbpp_run2({1: [101, 102, 103], 2: [201, 202, 203]}) == False", "assert mbpp_run2({1: [101, 102, 101], 2: [201, 202, 203]}) == True", "assert mbpp_run2({1: [101, 102, 103], 2: [201, 202, 202]}) == True", "assert mbpp_run2({1: [101, 101, 101], 2: [201, 202, 203]}) == True", "assert mbpp_run2({}) == False"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "Mbpp/19-4", "raw_problem": "Write a function to find whether a given array of integers contains any duplicate element.", "raw_solution": "```python\n\ndef mbpp_run1(arraynums):\n    return len(arraynums) != len(set(arraynums))\n\n ```", "raw_test_input": ["assert mbpp_run1(([1,2,3,4,5]))==False", "assert mbpp_run1(([1,2,3,4, 4]))==True", "assert mbpp_run1([1,1,2,2,3,3,4,4,5])==True"], "new_problem": "Write a function to determine if a given list of integers contains any duplicate elements. The function should handle the following errors: 1) The input is not a list. 2) The list contains non-integer elements. 3) The list is too large to process efficiently. Define specific error types for these scenarios and ensure meaningful error messages are provided. Handle error propagation appropriately.", "new_solution": "from typing import List\n\nclass DuplicateCheckError(Exception):\n    pass\n\nclass NotAListError(DuplicateCheckError):\n    def __init__(self, message=\"Input is not a list.\"):\n        self.message = message\n        super().__init__(self.message)\n\nclass NonIntegerElementError(DuplicateCheckError):\n    def __init__(self, message=\"List contains non-integer elements.\"):\n        self.message = message\n        super().__init__(self.message)\n\nclass ListTooLargeError(DuplicateCheckError):\n    def __init__(self, message=\"List is too large to process efficiently.\"):\n        self.message = message\n        super().__init__(self.message)\n\ndef mbpp_run2(arraynums: List[int]) -> bool:\n    if not isinstance(arraynums, list):\n        raise NotAListError()\n    if any(not isinstance(x, int) for x in arraynums):\n        raise NonIntegerElementError()\n    if len(arraynums) > 1000000:  # Arbitrary large size limit\n        raise ListTooLargeError()\n    return len(arraynums) != len(set(arraynums))", "input_format": "A list of integers", "output_format": "Boolean indicating presence of duplicates", "test_input": ["try:\n    assert mbpp_run2([1, 2, 3, 4, 5]) == False\nexcept Exception as e:\n    print(e)", "try:\n    assert mbpp_run2([1, 2, 3, 4, 5, 5]) == True\nexcept Exception as e:\n    print(e)", "try:\n    assert mbpp_run2(\"not a list\")\nexcept NotAListError as e:\n    print(e)", "try:\n    assert mbpp_run2([1, 2, \"three\", 4, 5])\nexcept NonIntegerElementError as e:\n    print(e)", "try:\n    assert mbpp_run2(list(range(1000001)))\nexcept ListTooLargeError as e:\n    print(e)"], "requirement_type": "PROMPT_ERROR_HANDLING"}
{"task_id": "Mbpp/20-1", "raw_problem": "Write a function to check if the given number is woodball or not.", "raw_solution": "```python\n\ndef mbpp_run1(x): \n\tif not isinstance(x, int):\n\t\treturn False\n\tif x <= 0 or x % 2 == 0:\n\t\treturn False\n\tif (x == 1): \n\t\treturn True\n\tx += 1 \n\ti = 0\n\twhile (x % 2 == 0): \n\t\tx /= 2\n\t\ti += 1\n\t\tif (i == x): \n\t\t\treturn True\n\treturn False\n\n ```", "raw_test_input": ["assert mbpp_run1(383) == True", "assert mbpp_run1(254) == False", "assert mbpp_run1(200) == False"], "new_problem": "In a financial system, you are given a list of transaction amounts. You need to categorize these transactions into 'woodall_transactions' and 'non_woodall_transactions' based on whether the transaction amount is a Woodall number. Write a function that takes a list of transaction amounts and returns a dictionary with two keys: 'woodall_transactions' and 'non_woodall_transactions'. Each key should map to a list of transaction amounts that are Woodall numbers and non-Woodall numbers, respectively.", "new_solution": "def is_woodall(x):\n    if not isinstance(x, int):\n        return False\n    if x <= 0 or x % 2 == 0:\n        return False\n    if (x == 1):\n        return True\n    x += 1\n    i = 0\n    while (x % 2 == 0):\n        x /= 2\n        i += 1\n        if (i == x):\n            return True\n    return False\n\ndef mbpp_run2(transactions):\n    woodall_transactions = []\n    non_woodall_transactions = []\n    for amount in transactions:\n        if is_woodall(amount):\n            woodall_transactions.append(amount)\n        else:\n            non_woodall_transactions.append(amount)\n    return {\n        'woodall_transactions': woodall_transactions,\n        'non_woodall_transactions': non_woodall_transactions\n    }", "input_format": "A list of integers representing transaction amounts.", "output_format": "A dictionary with keys 'woodall_transactions' and 'non_woodall_transactions', each containing a list of transaction amounts.", "test_input": ["assert mbpp_run2([1, 2, 3, 7, 23]) == {'woodall_transactions': [1, 7, 23], 'non_woodall_transactions': [2, 3]}", "assert mbpp_run2([0, 4, 8, 15, 21]) == {'woodall_transactions': [], 'non_woodall_transactions': [0, 4, 8, 15, 21]}", "assert mbpp_run2([1, 9, 15, 25, 33]) == {'woodall_transactions': [1], 'non_woodall_transactions': [9, 15, 25, 33]}", "assert mbpp_run2([7, 14, 28, 56, 112]) == {'woodall_transactions': [7], 'non_woodall_transactions': [14, 28, 56, 112]}", "assert mbpp_run2([3, 5, 11, 13, 17]) == {'woodall_transactions': [], 'non_woodall_transactions': [3, 5, 11, 13, 17]}"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "Mbpp/20-2", "raw_problem": "Write a function to check if the given number is woodball or not.", "raw_solution": "```python\n\ndef mbpp_run1(x): \n\tif not isinstance(x, int):\n\t\treturn False\n\tif x <= 0 or x % 2 == 0:\n\t\treturn False\n\tif (x == 1): \n\t\treturn True\n\tx += 1 \n\ti = 0\n\twhile (x % 2 == 0): \n\t\tx /= 2\n\t\ti += 1\n\t\tif (i == x): \n\t\t\treturn True\n\treturn False\n\n ```", "raw_test_input": ["assert mbpp_run1(383) == True", "assert mbpp_run1(254) == False", "assert mbpp_run1(200) == False"], "new_problem": "Enhance the function to check if a given number is a Woodall number, with an optional parameter to also check if the number is prime. The function should maintain backward compatibility, meaning it should still work with the original single integer parameter. If the optional parameter 'check_prime' is set to True, the function should return True only if the number is both a Woodall number and a prime number.", "new_solution": "def mbpp_run2(x: int, check_prime: bool = False) -> bool:\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        if n <= 3:\n            return True\n        if n % 2 == 0 or n % 3 == 0:\n            return False\n        i = 5\n        while i * i <= n:\n            if n % i == 0 or n % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    if not isinstance(x, int):\n        return False\n    if x <= 0 or x % 2 == 0:\n        return False\n    if x == 1:\n        return True\n    x += 1\n    i = 0\n    while x % 2 == 0:\n        x //= 2\n        i += 1\n        if i == x:\n            if check_prime:\n                return is_prime(x)\n            return True\n    return False", "input_format": "is_woodall(x: int, check_prime: bool = False) -> bool", "output_format": "bool", "test_input": ["assert mbpp_run2(1) == True", "assert mbpp_run2(3) == False", "assert mbpp_run2(7) == True", "assert mbpp_run2(7, check_prime=True) == True", "assert mbpp_run2(15, check_prime=True) == False"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "Mbpp/20-3", "raw_problem": "Write a function to check if the given number is woodball or not.", "raw_solution": "```python\n\ndef mbpp_run1(x): \n\tif not isinstance(x, int):\n\t\treturn False\n\tif x <= 0 or x % 2 == 0:\n\t\treturn False\n\tif (x == 1): \n\t\treturn True\n\tx += 1 \n\ti = 0\n\twhile (x % 2 == 0): \n\t\tx /= 2\n\t\ti += 1\n\t\tif (i == x): \n\t\t\treturn True\n\treturn False\n\n ```", "raw_test_input": ["assert mbpp_run1(383) == True", "assert mbpp_run1(254) == False", "assert mbpp_run1(200) == False"], "new_problem": "Write a function that takes a dictionary where keys are integers and values are lists of integers. For each key, determine if it is a Woodall number and return a new dictionary where the keys are the same and the values are booleans indicating whether the key is a Woodall number. A Woodall number is defined as n * 2^n - 1 for some integer n. Additionally, ensure that the function handles only positive integers and ignores any non-integer or negative values in the lists.", "new_solution": "def is_woodall(x: int) -> bool:\n    if not isinstance(x, int):\n        return False\n    if x <= 0 or x % 2 == 0:\n        return False\n    if x == 1:\n        return True\n    x += 1\n    i = 0\n    while x % 2 == 0:\n        x /= 2\n        i += 1\n        if i == x:\n            return True\n    return False\n\ndef mbpp_run2(data: dict[int, list[int]]) -> dict[int, bool]:\n    result = {}\n    for key in data.keys():\n        if isinstance(key, int) and key > 0:\n            result[key] = is_woodall(key)\n        else:\n            result[key] = False\n    return result", "input_format": "A dictionary where keys are integers and values are lists of integers.", "output_format": "A dictionary where keys are integers and values are booleans indicating if the key is a Woodall number.", "test_input": ["assert mbpp_run2({1: [1, 2, 3], 2: [4, 5], 3: [6, 7]}) == {1: True, 2: False, 3: False}", "assert mbpp_run2({5: [10, 15], 7: [14, 21], 9: [18, 27]}) == {5: False, 7: True, 9: False}", "assert mbpp_run2({11: [22, 33], 13: [26, 39], 15: [30, 45]}) == {11: False, 13: False, 15: False}", "assert mbpp_run2({17: [34, 51], 19: [38, 57], 21: [42, 63]}) == {17: False, 19: False, 21: False}", "assert mbpp_run2({23: [46, 69], 25: [50, 75], 27: [54, 81]}) == {23: True, 25: False, 27: False}"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "Mbpp/20-4", "raw_problem": "Write a function to check if the given number is woodball or not.", "raw_solution": "```python\n\ndef mbpp_run1(x): \n\tif not isinstance(x, int):\n\t\treturn False\n\tif x <= 0 or x % 2 == 0:\n\t\treturn False\n\tif (x == 1): \n\t\treturn True\n\tx += 1 \n\ti = 0\n\twhile (x % 2 == 0): \n\t\tx /= 2\n\t\ti += 1\n\t\tif (i == x): \n\t\t\treturn True\n\treturn False\n\n ```", "raw_test_input": ["assert mbpp_run1(383) == True", "assert mbpp_run1(254) == False", "assert mbpp_run1(200) == False"], "new_problem": "Write a function to check if the given number is a Woodall number. The function should handle the following errors: 1) Raise a ValueError if the input is not an integer. 2) Raise a ValueError if the input is negative. 3) Raise a ValueError if the input is zero. 4) Propagate any unexpected errors with a custom error message. The function should return True if the number is a Woodall number, otherwise False.", "new_solution": "class WoodallNumberError(Exception):\n    pass\n\nclass NotAnIntegerError(WoodallNumberError):\n    pass\n\nclass NegativeNumberError(WoodallNumberError):\n    pass\n\nclass ZeroNumberError(WoodallNumberError):\n    pass\n\ndef mbpp_run2(x: int) -> bool:\n    try:\n        if not isinstance(x, int):\n            raise NotAnIntegerError(\"Input must be an integer.\")\n        if x < 0:\n            raise NegativeNumberError(\"Input must be a non-negative integer.\")\n        if x == 0:\n            raise ZeroNumberError(\"Input must be greater than zero.\")\n        if x % 2 == 0:\n            return False\n        if x == 1:\n            return True\n        x += 1\n        i = 0\n        while x % 2 == 0:\n            x /= 2\n            i += 1\n            if i == x:\n                return True\n        return False\n    except WoodallNumberError as e:\n        print(f\"Error: {e}\")\n        return False\n    except Exception as e:\n        print(f\"Unexpected error: {e}\")\n        return False", "input_format": "A single integer input representing the number to be checked.", "output_format": "A boolean value indicating whether the number is a Woodall number or not.", "test_input": ["assert mbpp_run2(1) == True", "assert mbpp_run2(2) == False", "assert mbpp_run2(-1) == False", "assert mbpp_run2(0) == False", "assert mbpp_run2('a') == False"], "requirement_type": "PROMPT_ERROR_HANDLING"}
{"task_id": "Mbpp/56-1", "raw_problem": "Write a python function to check if a given number is one less than twice its reverse.", "raw_solution": "```python\n\ndef mbpp_run1(n):    \n    return n == 2 * int(str(n)[::-1]) - 1\n\n ```", "raw_test_input": ["assert mbpp_run1(70) == False", "assert mbpp_run1(23) == False", "assert mbpp_run1(73) == True"], "new_problem": "In a financial system, transaction IDs are generated in a way that they might have a special property: a transaction ID is considered 'special' if it is one less than twice its reverse. Write a function that takes a list of transaction IDs and returns a list of booleans indicating whether each transaction ID is 'special'. Use the original function to check each transaction ID.", "new_solution": "def check(n):\n    return n == 2 * int(str(n)[::-1]) - 1\n\ndef mbpp_run2(transaction_ids):\n    return [check(transaction_id) for transaction_id in transaction_ids]", "input_format": "A list of integers representing transaction IDs.", "output_format": "A list of booleans indicating whether each transaction ID meets the condition.", "test_input": ["assert mbpp_run2([12, 21, 11, 22, 13]) == [False, False , False, False, False]", "assert mbpp_run2([0, 1, 2, 3, 4]) == [False, True, False, False, False]", "assert mbpp_run2([10, 20, 30, 40, 50]) == [False, False, False, False, False]", "assert mbpp_run2([21, 32, 43, 54, 65]) == [False, False, False, False, False]", "assert mbpp_run2([99, 98, 97, 96, 95]) == [False, False, False, False, False]"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "Mbpp/56-2", "raw_problem": "Write a python function to check if a given number is one less than twice its reverse.", "raw_solution": "```python\n\ndef mbpp_run1(n):    \n    return n == 2 * int(str(n)[::-1]) - 1\n\n ```", "raw_test_input": ["assert mbpp_run1(70) == False", "assert mbpp_run1(23) == False", "assert mbpp_run1(73) == True"], "new_problem": "Write a Python function to check if a given number is one less than a specified multiplier times its reverse, minus an offset. The function should maintain backward compatibility with the original implementation, support the original function parameters, include type hints, and add new optional parameters for the multiplier and offset.", "new_solution": "def mbpp_run2(n: int, multiplier: int = 2, offset: int = 1) -> bool:\n    return n == multiplier * int(str(n)[::-1]) - offset", "input_format": "check(n: int, multiplier: int = 2, offset: int = 1) -> bool", "output_format": "bool", "test_input": ["assert mbpp_run2(21) == False", "assert mbpp_run2(21, multiplier=3, offset=2) == False", "assert mbpp_run2(12, multiplier=2, offset=1) == False", "assert mbpp_run2(0) == False", "assert mbpp_run2(5, multiplier=1, offset=0) == True"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "Mbpp/56-3", "raw_problem": "Write a python function to check if a given number is one less than twice its reverse.", "raw_solution": "```python\n\ndef mbpp_run1(n):    \n    return n == 2 * int(str(n)[::-1]) - 1\n\n ```", "raw_test_input": ["assert mbpp_run1(70) == False", "assert mbpp_run1(23) == False", "assert mbpp_run1(73) == True"], "new_problem": "Write a Python function that takes a dictionary as input, where each key is an integer and its value is a list of integers. The function should return a new dictionary where each key is the same as the input, but the value is a boolean indicating whether the key is one less than twice the reverse of any number in its corresponding list. Use type hints and ensure the solution handles large numbers efficiently.", "new_solution": "from typing import Dict, List\n\ndef check(key: int, num: int) -> bool:\n    return key == 2 * int(str(num)[::-1]) - 1\n\n\ndef mbpp_run2(data: Dict[int, List[int]]) -> Dict[int, bool]:\n    result = {}\n    for key, numbers in data.items():\n        result[key] = all(check(key, num) for num in numbers)\n    return result", "input_format": "A dictionary where keys are integers and values are lists of integers.", "output_format": "A dictionary where keys are integers and values are booleans indicating if the key is one less than twice the reverse of any number in the list.", "test_input": ["assert mbpp_run2({123: [321, 654], 456: [654, 123]}) == {123: False, 456: False}", "assert mbpp_run2({121: [60, 11], 242: [121, 60]}) == {121: False, 242: False}", "assert mbpp_run2({1: [0, 1], 2: [1, 2]}) == {1: False, 2: False}", "assert mbpp_run2({99: [99, 198], 100: [50, 100]}) == {99: False, 100: False}", "assert mbpp_run2({0: [0], 1: [1]}) == {0: False, 1: True}"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "Mbpp/56-4", "raw_problem": "Write a python function to check if a given number is one less than twice its reverse.", "raw_solution": "```python\n\ndef mbpp_run1(n):    \n    return n == 2 * int(str(n)[::-1]) - 1\n\n ```", "raw_test_input": ["assert mbpp_run1(70) == False", "assert mbpp_run1(23) == False", "assert mbpp_run1(73) == True"], "new_problem": "Write a Python function to check if a given number is one less than twice its reverse. The function should handle the following errors: \n1. Input is not an integer (raise a ValueError with a meaningful message).\n2. Input is a negative integer (raise a ValueError with a meaningful message).\n3. Input is too large to handle (raise an OverflowError with a meaningful message).\nThe function should propagate these errors appropriately and provide meaningful error messages.", "new_solution": "class NumberCheckError(Exception):\n    pass\n\nclass NotAnIntegerError(NumberCheckError):\n    pass\n\nclass NegativeNumberError(NumberCheckError):\n    pass\n\nclass NumberTooLargeError(NumberCheckError):\n    pass\n\ndef mbpp_run2(n: int) -> bool:\n    if not isinstance(n, int):\n        raise NotAnIntegerError(\"Input must be an integer.\")\n    if n < 0:\n        raise NegativeNumberError(\"Input must be a non-negative integer.\")\n    try:\n        reversed_number = int(str(n)[::-1])\n    except ValueError:\n        raise NumberTooLargeError(\"Input is too large to handle.\")\n    return n == 2 * reversed_number - 1", "input_format": "A single integer input", "output_format": "Boolean indicating if the number is one less than twice its reverse", "test_input": ["try:\n    assert mbpp_run2(21) == True\nexcept Exception as e:\n    print(e)", "try:\n    assert mbpp_run2(10) == False\nexcept Exception as e:\n    print(e)", "try:\n    assert mbpp_run2(-5) == False\nexcept NegativeNumberError as e:\n    print(e)", "try:\n    assert mbpp_run2('abc') == False\nexcept NotAnIntegerError as e:\n    print(e)", "try:\n    assert mbpp_run2(12345678901234567890) == False\nexcept NumberTooLargeError as e:\n    print(e)"], "requirement_type": "PROMPT_ERROR_HANDLING"}
{"task_id": "Mbpp/57-1", "raw_problem": "Write a python function to find the largest number that can be formed with the given list of digits.", "raw_solution": "```python\n\ndef mbpp_run1(arr) : \n    arr.sort(reverse = True)\n    return int(\"\".join(map(str,arr)))\n\n ```", "raw_test_input": ["assert mbpp_run1([1,2,3]) == 321", "assert mbpp_run1([4,5,6,1]) == 6541", "assert mbpp_run1([1,2,3,9]) == 9321"], "new_problem": "In a financial system, you receive a list of transactions, where each transaction is represented by a list of digits. Write a Python function that uses the original function to determine the largest possible number that can be formed from the digits of each transaction. Return a dictionary where each key is the index of the transaction and the value is the largest number that can be formed from that transaction's digits.", "new_solution": "def find_Max_Num(arr):\n    arr.sort(reverse=True)\n    return int(''.join(map(str, arr)))\n\ndef mbpp_run2(transactions):\n    result = {}\n    for index, transaction in enumerate(transactions):\n        result[index] = find_Max_Num(transaction)\n    return result", "input_format": "A list of lists, where each sublist contains digits representing different financial transactions.", "output_format": "A dictionary with each transaction's index as the key and the largest possible number from its digits as the value.", "test_input": ["assert mbpp_run2([[3, 1, 4], [5, 9, 2], [6, 7, 8]]) == {0: 431, 1: 952, 2: 876}", "assert mbpp_run2([[0, 0, 1], [9, 9, 9], [1, 2, 3]]) == {0: 100, 1: 999, 2: 321}", "assert mbpp_run2([[5, 5, 5], [2, 2, 2], [3, 3, 3]]) == {0: 555, 1: 222, 2: 333}", "assert mbpp_run2([[1, 0, 0], [4, 4, 4], [7, 8, 9]]) == {0: 100, 1: 444, 2: 987}", "assert mbpp_run2([[9, 8, 7], [6, 5, 4], [3, 2, 1]]) == {0: 987, 1: 654, 2: 321}"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "Mbpp/57-2", "raw_problem": "Write a python function to find the largest number that can be formed with the given list of digits.", "raw_solution": "```python\n\ndef mbpp_run1(arr) : \n    arr.sort(reverse = True)\n    return int(\"\".join(map(str,arr)))\n\n ```", "raw_test_input": ["assert mbpp_run1([1,2,3]) == 321", "assert mbpp_run1([4,5,6,1]) == 6541", "assert mbpp_run1([1,2,3,9]) == 9321"], "new_problem": "Enhance the function to find the largest number that can be formed with the given list of digits. The function should maintain backward compatibility and support an optional parameter 'as_string'. If 'as_string' is True, the function should return the result as a string instead of an integer.", "new_solution": "def mbpp_run2(arr: list[int], as_string: bool = False) -> int | str:\n    arr.sort(reverse=True)\n    result = ''.join(map(str, arr))\n    return result if as_string else int(result)", "input_format": "A list of integers representing digits, and an optional boolean parameter 'as_string'.", "output_format": "An integer representing the largest number formed, or a string if 'as_string' is True.", "test_input": ["assert mbpp_run2([3, 1, 4, 1, 5, 9]) == 954311", "assert mbpp_run2([3, 1, 4, 1, 5, 9], as_string=True) == '954311'", "assert mbpp_run2([0, 0, 0]) == 0", "assert mbpp_run2([0, 0, 0], as_string=True) == '000'", "assert mbpp_run2([9, 8, 7, 6, 5, 4, 3, 2, 1, 0]) == 9876543210"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "Mbpp/57-3", "raw_problem": "Write a python function to find the largest number that can be formed with the given list of digits.", "raw_solution": "```python\n\ndef mbpp_run1(arr) : \n    arr.sort(reverse = True)\n    return int(\"\".join(map(str,arr)))\n\n ```", "raw_test_input": ["assert mbpp_run1([1,2,3]) == 321", "assert mbpp_run1([4,5,6,1]) == 6541", "assert mbpp_run1([1,2,3,9]) == 9321"], "new_problem": "Write a Python function that takes a dictionary where each key is a category and each value is a list of digits. The function should return a new dictionary where each key is the same category and each value is the largest number that can be formed from the digits in that category. The function should include type hints and handle cases where the list of digits is empty by returning 0 for that category. Additionally, ensure that the function can handle up to 100 categories, each with up to 1000 digits.", "new_solution": "from typing import Dict, List\n\ndef find_Max_Num(arr: List[int]) -> int:\n    arr.sort(reverse=True)\n    return int(''.join(map(str, arr)))\n\ndef mbpp_run2(digits_by_category: Dict[str, List[int]]) -> Dict[str, int]:\n    result = {}\n    for category, digits in digits_by_category.items():\n        if digits:\n            result[category] = find_Max_Num(digits)\n        else:\n            result[category] = 0\n    return result", "input_format": "A dictionary where keys are strings representing categories and values are lists of integers representing digits.", "output_format": "A dictionary where keys are the same categories and values are the largest numbers that can be formed from the digits in each category.", "test_input": ["assert mbpp_run2({'A': [3, 1, 4, 1, 5], 'B': [9, 2, 6, 5, 3], 'C': []}) == {'A': 54311, 'B': 96532, 'C': 0}", "assert mbpp_run2({'X': [0, 0, 0], 'Y': [1, 2, 3], 'Z': [9, 8, 7]}) == {'X': 0, 'Y': 321, 'Z': 987}", "assert mbpp_run2({'P': [5, 5, 5], 'Q': [1, 0, 0], 'R': [2, 2, 2]}) == {'P': 555, 'Q': 100, 'R': 222}", "assert mbpp_run2({'M': [1], 'N': [2], 'O': [3]}) == {'M': 1, 'N': 2, 'O': 3}", "assert mbpp_run2({'D': [4, 4, 4, 4], 'E': [5, 5, 5, 5], 'F': [6, 6, 6, 6]}) == {'D': 4444, 'E': 5555, 'F': 6666}"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "Mbpp/57-4", "raw_problem": "Write a python function to find the largest number that can be formed with the given list of digits.", "raw_solution": "```python\n\ndef mbpp_run1(arr) : \n    arr.sort(reverse = True)\n    return int(\"\".join(map(str,arr)))\n\n ```", "raw_test_input": ["assert mbpp_run1([1,2,3]) == 321", "assert mbpp_run1([4,5,6,1]) == 6541", "assert mbpp_run1([1,2,3,9]) == 9321"], "new_problem": "Write a Python function to find the largest number that can be formed with the given list of digits. The function should handle the following errors: 1) The list is empty. 2) The list contains non-integer elements. 3) The list contains negative integers. Define specific error types for these scenarios and ensure meaningful error messages are provided. Handle error propagation appropriately.", "new_solution": "from typing import List\n\nclass InvalidElementError(Exception):\n    pass\n\nclass EmptyListError(Exception):\n    pass\n\nclass NegativeIntegerError(Exception):\n    pass\n\ndef mbpp_run2(arr: List[int]) -> int:\n    if not arr:\n        raise EmptyListError(\"The list of digits is empty.\")\n    if any(not isinstance(x, int) for x in arr):\n        raise InvalidElementError(\"The list contains non-integer elements.\")\n    if any(x < 0 for x in arr):\n        raise NegativeIntegerError(\"The list contains negative integers.\")\n    arr.sort(reverse=True)\n    return int(\"\".join(map(str, arr)))", "input_format": "A list of digits (integers) that may include invalid elements or be empty.", "output_format": "The largest number that can be formed from the list of digits, or an appropriate error message.", "test_input": ["try:\n    mbpp_run2([])\nexcept EmptyListError as e:\n    assert str(e) == \"The list of digits is empty.\"", "try:\n    mbpp_run2([1, 'a', 3])\nexcept InvalidElementError as e:\n    assert str(e) == \"The list contains non-integer elements.\"", "try:\n    mbpp_run2([1, -2, 3])\nexcept NegativeIntegerError as e:\n    assert str(e) == \"The list contains negative integers.\"", "assert mbpp_run2([3, 1, 4, 1, 5, 9]) == 954311", "assert mbpp_run2([0, 0, 0]) == 0"], "requirement_type": "PROMPT_ERROR_HANDLING"}
{"task_id": "Mbpp/58-1", "raw_problem": "Write a python function to check whether the given two integers have opposite sign or not.", "raw_solution": "```python\n\ndef mbpp_run1(x,y): \n    return ((x ^ y) < 0) \n\n ```", "raw_test_input": ["assert mbpp_run1(1,-2) == True", "assert mbpp_run1(3,2) == False", "assert mbpp_run1(-10,-10) == False", "assert mbpp_run1(-2,2) == True"], "new_problem": "In a financial application, you are given a list of daily profit and loss values for a series of transactions. Write a Python function that uses the original function to determine if each transaction pair has opposite signs, indicating a profit and a loss. The function should return a list of booleans, where each boolean corresponds to a transaction pair, indicating whether the profit and loss have opposite signs.", "new_solution": "def opposite_Signs(x, y):\n    return ((x ^ y) < 0)\n\ndef mbpp_run2(transactions):\n    results = []\n    for profit, loss in transactions:\n        results.append(opposite_Signs(profit, loss))\n    return results", "input_format": "A list of tuples, where each tuple contains two integers representing daily profit and loss for a series of transactions.", "output_format": "A list of booleans indicating whether each transaction pair has opposite signs.", "test_input": ["assert mbpp_run2([(100, -50), (-200, 300), (0, 0), (50, 50), (-100, -100)]) == [True, True, False, False, False]", "assert mbpp_run2([(10, -10), (-5, 5), (20, -20), (-30, 30), (0, 1)]) == [True, True, True, True, False]", "assert mbpp_run2([(0, -1), (1, 0), (-1, 1), (1, -1), (-1, -1)]) == [True, False, True, True, False]", "assert mbpp_run2([(1000, -1000), (-500, 500), (0, 0), (100, -100), (-200, 200)]) == [True, True, False, True, True]", "assert mbpp_run2([(0, 0), (0, -1), (1, 1), (-1, -1), (1, -1)]) == [False, True, False, False, True]"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "Mbpp/58-2", "raw_problem": "Write a python function to check whether the given two integers have opposite sign or not.", "raw_solution": "```python\n\ndef mbpp_run1(x,y): \n    return ((x ^ y) < 0) \n\n ```", "raw_test_input": ["assert mbpp_run1(1,-2) == True", "assert mbpp_run1(3,2) == False", "assert mbpp_run1(-10,-10) == False", "assert mbpp_run1(-2,2) == True"], "new_problem": "Enhance the existing function to check whether two integers have opposite signs, while maintaining backward compatibility. Add an optional parameter 'verbose' that, when set to True, prints a message indicating whether the numbers have opposite signs or not. The function should still return a boolean indicating the result.", "new_solution": "def mbpp_run2(x: int, y: int, *, verbose: bool = False) -> bool:\n    result = (x ^ y) < 0\n    if verbose:\n        if result:\n            print(f\"The numbers {x} and {y} have opposite signs.\")\n        else:\n            print(f\"The numbers {x} and {y} do not have opposite signs.\")\n    return result", "input_format": "opposite_Signs(x: int, y: int, *, verbose: bool = False) -> bool", "output_format": "bool", "test_input": ["assert mbpp_run2(10, -10) == True", "assert mbpp_run2(-5, 5) == True", "assert mbpp_run2(7, 3) == False", "assert mbpp_run2(-8, -2) == False", "assert mbpp_run2(0, -1) == True"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "Mbpp/58-3", "raw_problem": "Write a python function to check whether the given two integers have opposite sign or not.", "raw_solution": "```python\n\ndef mbpp_run1(x,y): \n    return ((x ^ y) < 0) \n\n ```", "raw_test_input": ["assert mbpp_run1(1,-2) == True", "assert mbpp_run1(3,2) == False", "assert mbpp_run1(-10,-10) == False", "assert mbpp_run1(-2,2) == True"], "new_problem": "Write a Python function that takes a dictionary as input, where each key is a string identifier and each value is a tuple of two integers. The function should return a new dictionary with the same keys, where each value is a boolean indicating whether the two integers in the tuple have opposite signs. Use type hints and ensure the function can handle at least 1000 entries efficiently.", "new_solution": "from typing import Dict, Tuple\n\ndef opposite_Signs(x: int, y: int) -> bool:\n    if x == 0 or y == 0:\n        return False\n    return (x < 0) != (y < 0)\n\ndef mbpp_run2(data: Dict[str, Tuple[int, int]]) -> Dict[str, bool]:\n    return {key: opposite_Signs(x, y) for key, (x, y) in data.items()}", "input_format": "A dictionary where keys are string identifiers and values are tuples of two integers.", "output_format": "A dictionary where keys are the same string identifiers and values are booleans indicating if the integers have opposite signs.", "test_input": ["assert mbpp_run2({'a': (1, -1), 'b': (2, 3)}) == {'a': True, 'b': False}", "assert mbpp_run2({'c': (-5, 5), 'd': (-10, -10)}) == {'c': True, 'd': False}", "assert mbpp_run2({'e': (0, 1), 'f': (0, -1)}) == {'e': False, 'f': False}", "assert mbpp_run2({'g': (100, -100), 'h': (-200, 200)}) == {'g': True, 'h': True}", "assert mbpp_run2({'i': (123456, -654321), 'j': (987654, 123456)}) == {'i': True, 'j': False}"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "Mbpp/58-4", "raw_problem": "Write a python function to check whether the given two integers have opposite sign or not.", "raw_solution": "```python\n\ndef mbpp_run1(x,y): \n    return ((x ^ y) < 0) \n\n ```", "raw_test_input": ["assert mbpp_run1(1,-2) == True", "assert mbpp_run1(3,2) == False", "assert mbpp_run1(-10,-10) == False", "assert mbpp_run1(-2,2) == True"], "new_problem": "Write a Python function to check whether the given two integers have opposite signs or not. The function should handle the following errors: 1) TypeError if the inputs are not integers, 2) ValueError if the inputs are None, and 3) Custom exception 'SameSignError' if both numbers have the same sign. The function should propagate errors with meaningful messages.", "new_solution": "class SameSignError(Exception):\n    def __init__(self, message=\"Both numbers have the same sign\"):\n        self.message = message\n        super().__init__(self.message)\n\ndef mbpp_run2(x: int, y: int) -> bool:\n    if x is None or y is None:\n        raise ValueError(\"Input values cannot be None\")\n    if not isinstance(x, int) or not isinstance(y, int):\n        raise TypeError(\"Both inputs must be integers\")\n    if (x ^ y) >= 0:\n        raise SameSignError()\n    return True", "input_format": "Two integers", "output_format": "Boolean indicating if the integers have opposite signs", "test_input": ["assert mbpp_run2(10, -5) == True", "try:\n    mbpp_run2(10, 5)\nexcept SameSignError as e:\n    assert str(e) == \"Both numbers have the same sign\"", "try:\n    mbpp_run2(None, 5)\nexcept ValueError as e:\n    assert str(e) == \"Input values cannot be None\"", "try:\n    mbpp_run2(10, None)\nexcept ValueError as e:\n    assert str(e) == \"Input values cannot be None\"", "try:\n    mbpp_run2(10, \"5\")\nexcept TypeError as e:\n    assert str(e) == \"Both inputs must be integers\""], "requirement_type": "PROMPT_ERROR_HANDLING"}
{"task_id": "Mbpp/59-1", "raw_problem": "Write a function to find the nth octagonal number.", "raw_solution": "```python\n\ndef mbpp_run1(n): \n\treturn 3 * n * n - 2 * n \n\n ```", "raw_test_input": ["assert mbpp_run1(5) == 65", "assert mbpp_run1(10) == 280", "assert mbpp_run1(15) == 645"], "new_problem": "In a warehouse, items are stored in octagonal-shaped containers. Each category of items has a different number of containers, and each container can hold an octagonal number of items. Given a list of integers representing the number of containers for each category and a list of integers representing the cost per item in each category, write a function to calculate the total cost of purchasing all items in the warehouse. Use the function to find the nth octagonal number as a helper function.", "new_solution": "def is_octagonal(n):\n    return 3 * n * n - 2 * n\n\ndef mbpp_run2(containers, cost_per_item):\n    total_cost = 0\n    for i in range(len(containers)):\n        num_items = containers[i]\n        total_cost += num_items * cost_per_item[i]\n    return total_cost", "input_format": "A list of integers representing the number of items in each category and a list of integers representing the cost per item in each category.", "output_format": "A single integer representing the total cost of purchasing octagonal numbers of items in each category.", "test_input": ["assert mbpp_run2([1, 2, 3], [10, 20, 30]) == 140", "assert mbpp_run2([4, 5, 6], [5, 10, 15]) == 160", "assert mbpp_run2([7, 8, 9], [2, 4, 6]) == 100", "assert mbpp_run2([10, 11, 12], [1, 2, 3]) == 68", "assert mbpp_run2([13, 14, 15], [3, 6, 9]) == 258"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "Mbpp/59-2", "raw_problem": "Write a function to find the nth octagonal number.", "raw_solution": "```python\n\ndef mbpp_run1(n): \n\treturn 3 * n * n - 2 * n \n\n ```", "raw_test_input": ["assert mbpp_run1(5) == 65", "assert mbpp_run1(10) == 280", "assert mbpp_run1(15) == 645"], "new_problem": "Enhance the function to find the nth octagonal number by adding an optional parameter that allows the function to return a list of all octagonal numbers up to the nth number. The function should maintain backward compatibility, meaning it should still return a single octagonal number when the new parameter is not used.", "new_solution": "def mbpp_run2(n: int, *, return_as_list: bool = False) -> int or list:\n    def octagonal_number(k: int) -> int:\n        return 3 * k * k - 2 * k\n    \n    if return_as_list:\n        return [octagonal_number(i) for i in range(1, n + 1)]\n    else:\n        return octagonal_number(n)", "input_format": "n: int, *, return_as_list: bool = False", "output_format": "int or List[int]", "test_input": ["assert mbpp_run2(1) == 1", "assert mbpp_run2(2) == 8", "assert mbpp_run2(3) == 21", "assert mbpp_run2(4, return_as_list=True) == [1, 8, 21, 40]", "assert mbpp_run2(5, return_as_list=True) == [1, 8, 21, 40, 65]"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "Mbpp/59-3", "raw_problem": "Write a function to find the nth octagonal number.", "raw_solution": "```python\n\ndef mbpp_run1(n): \n\treturn 3 * n * n - 2 * n \n\n ```", "raw_test_input": ["assert mbpp_run1(5) == 65", "assert mbpp_run1(10) == 280", "assert mbpp_run1(15) == 645"], "new_problem": "Given a list of tuples where each tuple contains an index and a number, write a function to compute the nth octagonal number for each number in the list and return a dictionary where the keys are the indices and the values are the corresponding octagonal numbers. Ensure that the function handles up to 10,000 tuples efficiently.", "new_solution": "from typing import List, Tuple, Dict\n\ndef is_octagonal(n: int) -> int:\n    return 3 * n * n - 2 * n\n\ndef mbpp_run2(data: List[Tuple[int, int]]) -> Dict[int, int]:\n    result = {}\n    for index, number in data:\n        result[index] = is_octagonal(number)\n    return result", "input_format": "List[Tuple[int, int]]", "output_format": "Dict[int, int]", "test_input": ["assert mbpp_run2([(0, 1), (1, 2), (2, 3), (3, 4), (4, 5)]) == {0: 1, 1: 8, 2: 21, 3: 40, 4: 65}", "assert mbpp_run2([(10, 6), (11, 7), (12, 8)]) == {10: 96, 11: 133, 12: 176}", "assert mbpp_run2([(20, 9), (21, 10), (22, 11)]) == {20: 225, 21: 280, 22: 341}", "assert mbpp_run2([(30, 12), (31, 13), (32, 14)]) == {30: 408, 31: 481, 32: 560}", "assert mbpp_run2([(40, 15), (41, 16), (42, 17)]) == {40: 645, 41: 736, 42: 833}"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "Mbpp/59-4", "raw_problem": "Write a function to find the nth octagonal number.", "raw_solution": "```python\n\ndef mbpp_run1(n): \n\treturn 3 * n * n - 2 * n \n\n ```", "raw_test_input": ["assert mbpp_run1(5) == 65", "assert mbpp_run1(10) == 280", "assert mbpp_run1(15) == 645"], "new_problem": "Write a function to find the nth octagonal number with error handling. The function should handle the following errors: \n1. If n is not an integer, raise a TypeError with the message 'Input must be an integer'.\n2. If n is less than 1, raise a ValueError with the message 'Input must be a positive integer'.\n3. If n is too large and causes an overflow, handle the OverflowError and return a message 'Result too large'.\nEnsure that the function propagates errors appropriately and provides meaningful error messages.", "new_solution": "class OctagonalNumberError(Exception):\n    pass\n\nclass OctagonalNumberTypeError(OctagonalNumberError):\n    pass\n\nclass OctagonalNumberValueError(OctagonalNumberError):\n    pass\n\nclass OctagonalNumberOverflowError(OctagonalNumberError):\n    pass\n\ndef mbpp_run2(n: int) -> int:\n    if not isinstance(n, int):\n        raise OctagonalNumberTypeError('Input must be an integer')\n    if n < 1:\n        raise OctagonalNumberValueError('Input must be a positive integer')\n    try:\n        result = 3 * n * n - 2 * n\n        return result\n    except OverflowError:\n        raise OctagonalNumberOverflowError('Result too large')", "input_format": "An integer n representing the position of the octagonal number to find.", "output_format": "The nth octagonal number as an integer.", "test_input": ["try:\n    mbpp_run2('a')\nexcept OctagonalNumberTypeError as e:\n    assert str(e) == 'Input must be an integer'", "try:\n    mbpp_run2(-5)\nexcept OctagonalNumberValueError as e:\n    assert str(e) == 'Input must be a positive integer'", "try:\n    mbpp_run2(0)\nexcept OctagonalNumberValueError as e:\n    assert str(e) == 'Input must be a positive integer'", "try:\n    mbpp_run2(1)\nexcept Exception:\n    assert False, 'Unexpected exception for valid input'\nelse:\n    assert mbpp_run2(1) == 1", "try:\n    mbpp_run2(10**18)\nexcept OctagonalNumberOverflowError as e:\n    assert str(e) == 'Result too large'"], "requirement_type": "PROMPT_ERROR_HANDLING"}
{"task_id": "Mbpp/61-1", "raw_problem": "Write a python function to count the number of substrings with the sum of digits equal to their length.", "raw_solution": "```python\n\nfrom collections import defaultdict\ndef mbpp_run1(s):\n    n, count, sum = len(s), 0, 0\n    mp = defaultdict(lambda : 0)\n    mp[0] += 1\n    for i in range(n):\n        sum += ord(s[i]) - ord('0')\n        count += mp[sum - i - 1]\n        mp[sum - i - 1] += 1\n    return count\n\n ```", "raw_test_input": ["assert mbpp_run1('112112') == 6", "assert mbpp_run1('111') == 6", "assert mbpp_run1('1101112') == 12"], "new_problem": "In a financial system, each transaction is assigned a unique numeric ID. We need to analyze these transaction IDs to find patterns. Specifically, for each transaction ID, count the number of substrings where the sum of the digits equals the length of the substring. This can help in identifying certain types of transactions that follow specific patterns. Implement a function that takes a list of transaction IDs and returns a dictionary with each transaction ID as a key and the count of such substrings as the value.", "new_solution": "from collections import defaultdict\n\ndef count_Substrings(s):\n    n, count, sum = len(s), 0, 0\n    mp = defaultdict(lambda : 0)\n    mp[0] += 1\n    for i in range(n):\n        sum += ord(s[i]) - ord('0')\n        count += mp[sum - i - 1]\n        mp[sum - i - 1] += 1\n    return count\n\n\ndef mbpp_run2(transaction_ids):\n    result = {}\n    for transaction_id in transaction_ids:\n        result[transaction_id] = count_Substrings(transaction_id)\n    return result", "input_format": "A list of strings representing transaction IDs, where each ID is a numeric string.", "output_format": "A dictionary where keys are transaction IDs and values are the count of substrings with the sum of digits equal to their length.", "test_input": ["assert mbpp_run2(['123', '111', '222']) == {'123': 1, '111': 6, '222': 0}", "assert mbpp_run2(['000', '999', '101']) == {'000': 0, '999': 0, '101': 2}", "assert mbpp_run2(['12', '34', '56']) == {'12': 1, '34': 0, '56': 0}", "assert mbpp_run2(['9876543210']) == {'9876543210': 2}", "assert mbpp_run2(['1111', '2222', '3333']) == {'1111': 10, '2222': 0, '3333': 0}"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "Mbpp/61-2", "raw_problem": "Write a python function to count the number of substrings with the sum of digits equal to their length.", "raw_solution": "```python\n\nfrom collections import defaultdict\ndef mbpp_run1(s):\n    n, count, sum = len(s), 0, 0\n    mp = defaultdict(lambda : 0)\n    mp[0] += 1\n    for i in range(n):\n        sum += ord(s[i]) - ord('0')\n        count += mp[sum - i - 1]\n        mp[sum - i - 1] += 1\n    return count\n\n ```", "raw_test_input": ["assert mbpp_run1('112112') == 6", "assert mbpp_run1('111') == 6", "assert mbpp_run1('1101112') == 12"], "new_problem": "Write a Python function to count the number of substrings with the sum of digits equal to their length. The function should maintain backward compatibility with existing implementations. Additionally, it should support an optional parameter 'ignore_non_digit' which, when set to True, will ignore non-digit characters in the string while calculating the sum of digits.", "new_solution": "from collections import defaultdict\nfrom typing import Optional\n\ndef mbpp_run2(s: str, ignore_non_digit: Optional[bool] = False) -> int:\n    n, count, sum = len(s), 0, 0\n    mp = defaultdict(lambda: 0)\n    mp[0] += 1\n    for start in range(n):\n        digit_sum = 0\n        length = 0\n        for end in range(start, n):\n            if ignore_non_digit and not s[end].isdigit():\n                 continue\n            if s[end].isdigit():\n                 digit_sum += int(s[end])\n            length += 1\n            if digit_sum == length:\n                 count += 1\n    return count\n", "input_format": "A string s and an optional boolean parameter ignore_non_digit", "output_format": "An integer representing the count of substrings", "test_input": ["assert mbpp_run2('123') == 1", "assert mbpp_run2('123', ignore_non_digit=True) == 1", "assert mbpp_run2('1a2b3', ignore_non_digit=True) == 1", "assert mbpp_run2('1a2b3') == 4", "assert mbpp_run2('111') == 6"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "Mbpp/61-3", "raw_problem": "Write a python function to count the number of substrings with the sum of digits equal to their length.", "raw_solution": "```python\n\nfrom collections import defaultdict\ndef mbpp_run1(s):\n    n, count, sum = len(s), 0, 0\n    mp = defaultdict(lambda : 0)\n    mp[0] += 1\n    for i in range(n):\n        sum += ord(s[i]) - ord('0')\n        count += mp[sum - i - 1]\n        mp[sum - i - 1] += 1\n    return count\n\n ```", "raw_test_input": ["assert mbpp_run1('112112') == 6", "assert mbpp_run1('111') == 6", "assert mbpp_run1('1101112') == 12"], "new_problem": "Write a Python function that takes a list of strings, where each string is a sequence of digits. For each string, count the number of substrings where the sum of the digits is equal to the length of the substring. Return the results in a dictionary, where each key is the original string and the value is the count of such substrings. Use a tree data structure to efficiently manage and query the substrings. Include type hints in your function and ensure that the solution can handle up to 10,000 strings, each with a length of up to 1,000 characters.", "new_solution": "from collections import defaultdict\nfrom typing import List, Dict\n\nclass SubstringTree:\n    def __init__(self):\n        self.children = defaultdict(SubstringTree)\n        self.count = 0\n\n    def insert(self, sum_diff: int):\n        node = self\n        node.count += 1\n        for char in str(sum_diff):\n            node = node.children[char]\n            node.count += 1\n\n    def query(self, sum_diff: int) -> int:\n        node = self\n        for char in str(sum_diff):\n            if char in node.children:\n                node = node.children[char]\n            else:\n                return 0\n        return node.count\n\n\ndef mbpp_run2(strings: List[str]) -> Dict[str, int]:\n    results = {}\n    for s in strings:\n        n = len(s)\n        count = 0\n        sum_digits = 0\n        tree = SubstringTree()\n        tree.insert(0)\n        for i in range(n):\n            sum_digits += ord(s[i]) - ord('0')\n            count += tree.query(sum_digits - i - 1)\n            tree.insert(sum_digits - i - 1)\n        results[s] = count\n    return results\n", "input_format": "A list of strings, where each string represents a sequence of digits.", "output_format": "A dictionary where keys are the input strings and values are the counts of substrings with the sum of digits equal to their length.", "test_input": ["assert mbpp_run2(['123', '111', '222']) == {'123': 1, '111': 6, '222': 0}", "assert mbpp_run2(['000', '999', '101']) == {'000': 0, '999': 0, '101': 2}", "assert mbpp_run2(['12', '34', '56']) == {'12': 1, '34': 0, '56': 0}", "assert mbpp_run2(['9876543210']) == {'9876543210': 2}", "assert mbpp_run2(['1111', '2222', '3333']) == {'1111': 10, '2222': 0, '3333': 0}"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "Mbpp/61-4", "raw_problem": "Write a python function to count the number of substrings with the sum of digits equal to their length.", "raw_solution": "```python\n\nfrom collections import defaultdict\ndef mbpp_run1(s):\n    n, count, sum = len(s), 0, 0\n    mp = defaultdict(lambda : 0)\n    mp[0] += 1\n    for i in range(n):\n        sum += ord(s[i]) - ord('0')\n        count += mp[sum - i - 1]\n        mp[sum - i - 1] += 1\n    return count\n\n ```", "raw_test_input": ["assert mbpp_run1('112112') == 6", "assert mbpp_run1('111') == 6", "assert mbpp_run1('1101112') == 12"], "new_problem": "Write a Python function to count the number of substrings with the sum of digits equal to their length. The function should handle the following errors: 1. Input is not a string of digits (raise ValueError). 2. Input is an empty string (raise ValueError). 3. Input contains non-digit characters (raise ValueError). Implement error propagation and provide meaningful error messages.", "new_solution": "from collections import defaultdict\n\ndef mbpp_run2(s: str) -> int:\n    if not isinstance(s, str):\n        raise ValueError(\"Input must be a string.\")\n    if not s:\n        raise ValueError(\"Input string cannot be empty.\")\n    if not s.isdigit():\n        raise ValueError(\"Input string must contain only digits.\")\n\n    n, count, sum = len(s), 0, 0\n    mp = defaultdict(lambda: 0)\n    mp[0] += 1\n    for i in range(n):\n        sum += ord(s[i]) - ord('0')\n        count += mp[sum - i - 1]\n        mp[sum - i - 1] += 1\n    return count", "input_format": "A string of digits", "output_format": "An integer representing the count of substrings", "test_input": ["assert mbpp_run2('123') == 1", "assert mbpp_run2('111') == 6", "try:\n    mbpp_run2('12a3')\nexcept ValueError as e:\n    assert str(e) == 'Input string must contain only digits.'", "try:\n    mbpp_run2('')\nexcept ValueError as e:\n    assert str(e) == 'Input string cannot be empty.'", "try:\n    mbpp_run2(123)\nexcept ValueError as e:\n    assert str(e) == 'Input must be a string.'"], "requirement_type": "PROMPT_ERROR_HANDLING"}
{"task_id": "Mbpp/62-1", "raw_problem": "Write a python function to find smallest number in a list.", "raw_solution": "```python\n\ndef mbpp_run1(xs):\n  assert len(xs) > 0, \"invalid inputs\"\n  return min(xs)\n\n ```", "raw_test_input": ["assert mbpp_run1([10, 20, 1, 45, 99]) == 1", "assert mbpp_run1([1, 2, 3]) == 1", "assert mbpp_run1([45, 46, 50, 60]) == 45"], "new_problem": "In an e-commerce platform, you are tasked with analyzing the sales data for various products over a month. You need to identify the day with the lowest sales for each product to understand the worst-performing days. Write a Python function that takes a dictionary where each key is a product ID and the value is a list of daily sales figures for that product over a month. The function should return a dictionary where each key is a product ID and the value is the smallest daily sales figure for that product.", "new_solution": "def smallest_num(xs):\n    assert len(xs) > 0, \"invalid inputs\"\n    return min(xs)\n\ndef mbpp_run2(sales_data):\n    lowest_sales = {}\n    for product_id, sales in sales_data.items():\n        lowest_sales[product_id] = smallest_num(sales)\n    return lowest_sales", "input_format": "A dictionary where keys are product IDs and values are lists of daily sales figures for a month.", "output_format": "A dictionary where keys are product IDs and values are the smallest daily sales figure for that product.", "test_input": ["assert mbpp_run2({'A': [10, 20, 5, 15], 'B': [7, 8, 9, 6], 'C': [12, 11, 13, 14]}) == {'A': 5, 'B': 6, 'C': 11}", "assert mbpp_run2({'X': [100, 200, 150], 'Y': [50, 60, 40], 'Z': [300, 250, 400]}) == {'X': 100, 'Y': 40, 'Z': 250}", "assert mbpp_run2({'P': [1, 2, 3], 'Q': [4, 5, 6], 'R': [7, 8, 9]}) == {'P': 1, 'Q': 4, 'R': 7}", "assert mbpp_run2({'D': [0, 0, 0], 'E': [1, 1, 1], 'F': [2, 2, 2]}) == {'D': 0, 'E': 1, 'F': 2}", "assert mbpp_run2({'G': [5], 'H': [10], 'I': [15]}) == {'G': 5, 'H': 10, 'I': 15}"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "Mbpp/62-2", "raw_problem": "Write a python function to find smallest number in a list.", "raw_solution": "```python\n\ndef mbpp_run1(xs):\n  assert len(xs) > 0, \"invalid inputs\"\n  return min(xs)\n\n ```", "raw_test_input": ["assert mbpp_run1([10, 20, 1, 45, 99]) == 1", "assert mbpp_run1([1, 2, 3]) == 1", "assert mbpp_run1([45, 46, 50, 60]) == 45"], "new_problem": "Enhance the existing function to find the smallest number in a list, with an optional parameter to ignore negative numbers. The function should maintain backward compatibility, support the original function parameters, include type hints, and add the new optional parameter.", "new_solution": "def mbpp_run2(xs: list[float], ignore_negatives: bool = False) -> float:\n    assert len(xs) > 0, \"invalid inputs\"\n    if ignore_negatives:\n        xs = [x for x in xs if x >= 0]\n        assert len(xs) > 0, \"no non-negative numbers available\"\n    return min(xs)", "input_format": "A list of numbers and an optional parameter 'ignore_negatives' (boolean)", "output_format": "The smallest number in the list, optionally ignoring negative numbers", "test_input": ["assert mbpp_run2([3, 1, 4, 1, 5, 9]) == 1", "assert mbpp_run2([-3, -1, -4, -1, -5, -9]) == -9", "assert mbpp_run2([3, 1, 4, 1, 5, 9], ignore_negatives=True) == 1", "assert mbpp_run2([-3, -1, 4, 1, 5, 9], ignore_negatives=True) == 1", "assert mbpp_run2([0, -1, -2, -3], ignore_negatives=True) == 0"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "Mbpp/62-3", "raw_problem": "Write a python function to find smallest number in a list.", "raw_solution": "```python\n\ndef mbpp_run1(xs):\n  assert len(xs) > 0, \"invalid inputs\"\n  return min(xs)\n\n ```", "raw_test_input": ["assert mbpp_run1([10, 20, 1, 45, 99]) == 1", "assert mbpp_run1([1, 2, 3]) == 1", "assert mbpp_run1([45, 46, 50, 60]) == 45"], "new_problem": "Write a Python function that takes a dictionary where each key is a category and each value is a list of integers. The function should return a new dictionary where each key is the same category and the value is the smallest integer from the corresponding list. Use type hints and ensure that each list contains at least one integer. Additionally, the function should handle cases where the input dictionary is empty by returning an empty dictionary.", "new_solution": "def smallest_num(xs: list[int]) -> int:\n    assert len(xs) > 0, \"invalid inputs\"\n    return min(xs)\n\ndef mbpp_run2(data: dict[str, list[int]]) -> dict[str, int]:\n    result = {}\n    for category, numbers in data.items():\n        if numbers:  # Ensure the list is not empty\n            result[category] = smallest_num(numbers)\n    return result", "input_format": "A dictionary where keys are strings representing categories and values are lists of integers.", "output_format": "A dictionary where keys are the same categories and values are the smallest integer in each list.", "test_input": ["assert mbpp_run2({'fruits': [3, 1, 4], 'vegetables': [10, 5, 2]}) == {'fruits': 1, 'vegetables': 2}", "assert mbpp_run2({'electronics': [100, 200, 50], 'furniture': [300, 150, 400]}) == {'electronics': 50, 'furniture': 150}", "assert mbpp_run2({'books': [7], 'magazines': [9, 3, 6]}) == {'books': 7, 'magazines': 3}", "assert mbpp_run2({'clothes': [20, 30, 10], 'shoes': [40, 25, 35]}) == {'clothes': 10, 'shoes': 25}", "assert mbpp_run2({}) == {}"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "Mbpp/62-4", "raw_problem": "Write a python function to find smallest number in a list.", "raw_solution": "```python\n\ndef mbpp_run1(xs):\n  assert len(xs) > 0, \"invalid inputs\"\n  return min(xs)\n\n ```", "raw_test_input": ["assert mbpp_run1([10, 20, 1, 45, 99]) == 1", "assert mbpp_run1([1, 2, 3]) == 1", "assert mbpp_run1([45, 46, 50, 60]) == 45"], "new_problem": "Write a Python function to find the smallest number in a list. The function should handle the following errors: 1) The input is not a list. 2) The list is empty. 3) The list contains non-numeric elements. Define specific error types for these scenarios and ensure meaningful error messages are provided. The function should propagate errors appropriately and maintain type hints.", "new_solution": "from typing import List, Union\n\nclass NotAListError(Exception):\n    pass\n\nclass EmptyListError(Exception):\n    pass\n\nclass NonNumericElementError(Exception):\n    pass\n\ndef mbpp_run2(xs: Union[List[Union[int, float]], None]) -> Union[int, float]:\n    if not isinstance(xs, list):\n        raise NotAListError(\"Input must be a list.\")\n    if len(xs) == 0:\n        raise EmptyListError(\"List cannot be empty.\")\n    if not all(isinstance(x, (int, float)) for x in xs):\n        raise NonNumericElementError(\"All elements must be numeric.\")\n    return min(xs)", "input_format": "A list of numbers", "output_format": "The smallest number in the list or an error message", "test_input": ["try:\n    mbpp_run2(None)\nexcept NotAListError as e:\n    assert str(e) == \"Input must be a list.\"\n", "try:\n    mbpp_run2([])\nexcept EmptyListError as e:\n    assert str(e) == \"List cannot be empty.\"\n", "try:\n    mbpp_run2([1, 'a', 3])\nexcept NonNumericElementError as e:\n    assert str(e) == \"All elements must be numeric.\"\n", "assert mbpp_run2([3, 1, 2]) == 1", "assert mbpp_run2([5.5, 2.2, 3.3]) == 2.2"], "requirement_type": "PROMPT_ERROR_HANDLING"}
{"task_id": "Mbpp/63-1", "raw_problem": "Write a function to find the maximum difference between available pairs in the given tuple list.", "raw_solution": "```python\n\ndef mbpp_run1(test_list):\n  return max(abs(a - b) for a, b in test_list)\n\n ```", "raw_test_input": ["assert mbpp_run1([(3, 5), (1, 7), (10, 3), (1, 2)]) == 7", "assert mbpp_run1([(4, 6), (2, 17), (9, 13), (11, 12)]) == 15", "assert mbpp_run1([(12, 35), (21, 27), (13, 23), (41, 22)]) == 23"], "new_problem": "In the context of stock trading, you are given a list of stocks, where each stock is represented by a dictionary containing the stock's name and a list of tuples. Each tuple represents the price change of the stock on a particular day, with the first element being the opening price and the second element being the closing price. Write a function that calculates the maximum price change difference for each stock and returns a dictionary with the stock names as keys and their maximum price change difference as values.", "new_solution": "def max_difference(test_list):\n    return max(abs(a - b) for a, b in test_list)\n\n\ndef mbpp_run2(stocks):\n    result = {}\n    for stock in stocks:\n        name = stock['name']\n        price_changes = stock['price_changes']\n        result[name] = max_difference(price_changes)\n    return result", "input_format": "A list of dictionaries, each containing a 'name' key with a string value and a 'price_changes' key with a list of tuples representing daily price changes.", "output_format": "A dictionary with stock names as keys and their maximum price change difference as values.", "test_input": ["assert mbpp_run2([{'name': 'StockA', 'price_changes': [(100, 105), (102, 110), (108, 107)]}, {'name': 'StockB', 'price_changes': [(200, 195), (210, 215), (220, 210)]}]) == {'StockA': 8, 'StockB': 10}", "assert mbpp_run2([{'name': 'StockC', 'price_changes': [(300, 310), (305, 300), (310, 320)]}]) == {'StockC': 10}", "assert mbpp_run2([{'name': 'StockD', 'price_changes': [(150, 145), (155, 160), (160, 150)]}, {'name': 'StockE', 'price_changes': [(100, 90), (95, 105), (110, 100)]}]) == {'StockD': 10, 'StockE': 10}", "assert mbpp_run2([{'name': 'StockF', 'price_changes': [(500, 505), (505, 500), (510, 515)]}]) == {'StockF': 5}", "assert mbpp_run2([{'name': 'StockG', 'price_changes': [(50, 55), (55, 50), (60, 65)]}, {'name': 'StockH', 'price_changes': [(70, 75), (75, 70), (80, 85)]}]) == {'StockG': 5, 'StockH': 5}"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "Mbpp/63-2", "raw_problem": "Write a function to find the maximum difference between available pairs in the given tuple list.", "raw_solution": "```python\n\ndef mbpp_run1(test_list):\n  return max(abs(a - b) for a, b in test_list)\n\n ```", "raw_test_input": ["assert mbpp_run1([(3, 5), (1, 7), (10, 3), (1, 2)]) == 7", "assert mbpp_run1([(4, 6), (2, 17), (9, 13), (11, 12)]) == 15", "assert mbpp_run1([(12, 35), (21, 27), (13, 23), (41, 22)]) == 23"], "new_problem": "Enhance the function to find the maximum difference between available pairs in the given tuple list. The function should maintain backward compatibility but also include an optional parameter 'absolute' that, when set to False, considers the signed difference instead of the absolute difference.", "new_solution": "def mbpp_run2(test_list: list[tuple[int, int]], absolute: bool = True) -> int:\n    if absolute:\n        return max(abs(a - b) for a, b in test_list)\n    else:\n        return max(a - b for a, b in test_list)", "input_format": "A list of tuples, where each tuple contains two integers, and an optional boolean parameter 'absolute'.", "output_format": "An integer representing the maximum difference between pairs, optionally considering the sign of the difference.", "test_input": ["assert mbpp_run2([(1, 2), (3, 5), (6, 1)]) == 5", "assert mbpp_run2([(1, 2), (3, 5), (6, 1)], absolute=True) == 5", "assert mbpp_run2([(1, 2), (3, 5), (6, 1)], absolute=False) == 5", "assert mbpp_run2([(10, 2), (3, 5), (6, 1)], absolute=False) == 8", "assert mbpp_run2([(1, 2), (3, 5), (6, 1)], absolute=True) == 5"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "Mbpp/63-3", "raw_problem": "Write a function to find the maximum difference between available pairs in the given tuple list.", "raw_solution": "```python\n\ndef mbpp_run1(test_list):\n    if not test_list:\n        return 0\n    differences = [abs(a - b) for a, b in test_list]\n    return max(differences)\n\n ```", "raw_test_input": ["assert mbpp_run1([(3, 5), (1, 7), (10, 3), (1, 2)]) == 7", "assert mbpp_run1([(4, 6), (2, 17), (9, 13), (11, 12)]) == 15", "assert mbpp_run1([(12, 35), (21, 27), (13, 23), (41, 22)]) == 23"], "new_problem": "Write a function to find the maximum difference between available pairs in a dictionary where each key is associated with a list of tuples. Each tuple contains two integers. The function should return a dictionary with the same keys, where each value is the maximum difference found in the corresponding list of tuples. Ensure that the function handles cases where the list of tuples is empty by returning a difference of 0 for that key. Use type hints in your function definition.", "new_solution": "from typing import Dict, List, Tuple\n\ndef max_difference(test_list: List[Tuple[int, int]]) -> int:\n    if not test_list:\n        return 0\n    differences = [abs(a - b) for a, b in test_list]\n    return max(differences)\n\n\ndef mbpp_run2(data: Dict[str, List[Tuple[int, int]]]) -> Dict[str, int]:\n    return {key: max_difference(tuples) for key, tuples in data.items()}", "input_format": "A dictionary where keys are strings representing item names and values are lists of tuples, each tuple containing two integers.", "output_format": "A dictionary where keys are the same item names and values are the maximum differences found in the corresponding list of tuples.", "test_input": ["assert mbpp_run2({'item1': [(1, 2), (3, 5)], 'item2': [(10, 20), (30, 40)]}) == {'item1': 2, 'item2': 10}", "assert mbpp_run2({'item1': [(1, 10), (5, 3)], 'item2': [(100, 50), (30, 10)]}) == {'item1': 9, 'item2': 50}", "assert mbpp_run2({'item1': [], 'item2': [(1, 1), (2, 2)]}) == {'item1': 0, 'item2': 0}", "assert mbpp_run2({'item1': [(0, 0)], 'item2': [(5, 5), (10, 10)]}) == {'item1': 0, 'item2': 0}", "assert mbpp_run2({'item1': [(1, 100), (50, 25)], 'item2': [(0, 0), (100, 100)]}) == {'item1': 99, 'item2': 0}"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "Mbpp/63-4", "raw_problem": "Write a function to find the maximum difference between available pairs in the given tuple list.", "raw_solution": "```python\n\ndef mbpp_run1(test_list):\n  return max(abs(a - b) for a, b in test_list)\n\n ```", "raw_test_input": ["assert mbpp_run1([(3, 5), (1, 7), (10, 3), (1, 2)]) == 7", "assert mbpp_run1([(4, 6), (2, 17), (9, 13), (11, 12)]) == 15", "assert mbpp_run1([(12, 35), (21, 27), (13, 23), (41, 22)]) == 23"], "new_problem": "Write a function to find the maximum difference between available pairs in the given list of tuples. The function should handle the following errors: 1) If the input is not a list, raise a TypeError with a meaningful message. 2) If any element in the list is not a tuple, raise a ValueError. 3) If any tuple does not contain exactly two integers, raise a ValueError. 4) If the list is empty, raise a ValueError. Implement error propagation and ensure that the function has type hints.", "new_solution": "from typing import List, Tuple\n\nclass MaxDifferenceError(Exception):\n    pass\n\nclass NotAListError(MaxDifferenceError):\n    pass\n\nclass NotATupleError(MaxDifferenceError):\n    pass\n\nclass InvalidTupleError(MaxDifferenceError):\n    pass\n\nclass EmptyListError(MaxDifferenceError):\n    pass\n\ndef mbpp_run2(test_list: List[Tuple[int, int]]) -> int:\n    if not isinstance(test_list, list):\n        raise NotAListError(\"Input must be a list.\")\n    if not test_list:\n        raise EmptyListError(\"Input list cannot be empty.\")\n    for item in test_list:\n        if not isinstance(item, tuple):\n            raise NotATupleError(\"All elements in the list must be tuples.\")\n        if len(item) != 2 or not all(isinstance(i, int) for i in item):\n            raise InvalidTupleError(\"Each tuple must contain exactly two integers.\")\n    return max(abs(a - b) for a, b in test_list)", "input_format": "A list of tuples, where each tuple contains two integers.", "output_format": "An integer representing the maximum difference between any pair of integers in the list of tuples.", "test_input": ["assert mbpp_run2([(1, 2), (3, 5), (10, 4)]) == 6", "try:\n    mbpp_run2(\"not a list\")\nexcept NotAListError as e:\n    assert str(e) == \"Input must be a list.\"", "try:\n    mbpp_run2([])\nexcept EmptyListError as e:\n    assert str(e) == \"Input list cannot be empty.\"", "try:\n    mbpp_run2([(1, 2), [3, 5]])\nexcept NotATupleError as e:\n    assert str(e) == \"All elements in the list must be tuples.\"", "try:\n    mbpp_run2([(1, 2), (3, 5, 7)])\nexcept InvalidTupleError as e:\n    assert str(e) == \"Each tuple must contain exactly two integers.\""], "requirement_type": "PROMPT_ERROR_HANDLING"}
{"task_id": "Mbpp/64-1", "raw_problem": "Write a function to sort a list of tuples using the second value of each tuple.", "raw_solution": "```python\n\ndef mbpp_run1(subjectmarks):\n#mbpp_run1 = [('English', 88), ('Science', 90), ('Maths', 97), ('Social sciences', 82)])\n subjectmarks.sort(key = lambda x: x[1])\n return subjectmarks\n\n ```", "raw_test_input": ["assert mbpp_run1([('English', 88), ('Science', 90), ('Maths', 97), ('Social sciences', 82)])==[('Social sciences', 82), ('English', 88), ('Science', 90), ('Maths', 97)]", "assert mbpp_run1([('Telugu',49),('Hindhi',54),('Social',33)])==([('Social',33),('Telugu',49),('Hindhi',54)])", "assert mbpp_run1([('Physics',96),('Chemistry',97),('Biology',45)])==([('Biology',45),('Physics',96),('Chemistry',97)])"], "new_problem": "In a school, each student has a report card that lists their subjects and corresponding marks. Write a function that takes a dictionary of student report cards and returns a new dictionary where each student's subjects are sorted by their marks in ascending order. Use the original function to sort the subjects for each student.", "new_solution": "def subject_marks(subjectmarks):\n    subjectmarks.sort(key=lambda x: x[1])\n    return subjectmarks\n\ndef mbpp_run2(report_cards):\n    sorted_report_cards = {}\n    for student, subjects in report_cards.items():\n        sorted_subjects = subject_marks(subjects)\n        sorted_report_cards[student] = [subject for subject, mark in sorted_subjects]\n    return sorted_report_cards", "input_format": "A dictionary where keys are student names and values are lists of tuples, each tuple containing a subject and its corresponding mark.", "output_format": "A dictionary where keys are student names and values are lists of subjects sorted by marks in ascending order.", "test_input": ["assert mbpp_run2({'Alice': [('English', 88), ('Science', 90), ('Maths', 97), ('Social sciences', 82)]}) == {'Alice': ['Social sciences', 'English', 'Science', 'Maths']}", "assert mbpp_run2({'Bob': [('History', 75), ('Maths', 85), ('Science', 80)]}) == {'Bob': ['History', 'Science', 'Maths']}", "assert mbpp_run2({'Charlie': [('Art', 95), ('Maths', 90), ('Science', 85)]}) == {'Charlie': ['Science', 'Maths', 'Art']}", "assert mbpp_run2({'David': [('Biology', 70), ('Chemistry', 60), ('Physics', 80)]}) == {'David': ['Chemistry', 'Biology', 'Physics']}", "assert mbpp_run2({'Eve': [('Geography', 88), ('History', 92), ('Maths', 85), ('Science', 90)]}) == {'Eve': ['Maths', 'Geography', 'Science', 'History']}"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "Mbpp/64-2", "raw_problem": "Write a function to sort a list of tuples using the second value of each tuple.", "raw_solution": "```python\n\ndef mbpp_run1(subjectmarks):\n#mbpp_run1 = [('English', 88), ('Science', 90), ('Maths', 97), ('Social sciences', 82)])\n subjectmarks.sort(key = lambda x: x[1])\n return subjectmarks\n\n ```", "raw_test_input": ["assert mbpp_run1([('English', 88), ('Science', 90), ('Maths', 97), ('Social sciences', 82)])==[('Social sciences', 82), ('English', 88), ('Science', 90), ('Maths', 97)]", "assert mbpp_run1([('Telugu',49),('Hindhi',54),('Social',33)])==([('Social',33),('Telugu',49),('Hindhi',54)])", "assert mbpp_run1([('Physics',96),('Chemistry',97),('Biology',45)])==([('Biology',45),('Physics',96),('Chemistry',97)])"], "new_problem": "Enhance the function to sort a list of tuples using the second value of each tuple, with an optional parameter to sort in descending order. The function should maintain backward compatibility, support original function parameters, and include type hints.", "new_solution": "from typing import List, Tuple, Optional\n\ndef mbpp_run2(subjectmarks: List[Tuple[str, int]], descending: Optional[bool] = False) -> List[Tuple[str, int]]:\n    subjectmarks.sort(key=lambda x: x[1], reverse=descending)\n    return subjectmarks\n", "input_format": "List[Tuple[str, int]], Optional[bool]", "output_format": "List[Tuple[str, int]]", "test_input": ["assert mbpp_run2([('English', 88), ('Science', 90), ('Maths', 97), ('Social sciences', 82)]) == [('Social sciences', 82), ('English', 88), ('Science', 90), ('Maths', 97)]", "assert mbpp_run2([('English', 88), ('Science', 90), ('Maths', 97), ('Social sciences', 82)], descending=True) == [('Maths', 97), ('Science', 90), ('English', 88), ('Social sciences', 82)]", "assert mbpp_run2([('History', 75), ('Geography', 85), ('Biology', 80)]) == [('History', 75), ('Biology', 80), ('Geography', 85)]", "assert mbpp_run2([('History', 75), ('Geography', 85), ('Biology', 80)], descending=True) == [('Geography', 85), ('Biology', 80), ('History', 75)]", "assert mbpp_run2([]) == []"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "Mbpp/64-3", "raw_problem": "Write a function to sort a list of tuples using the second value of each tuple.", "raw_solution": "```python\n\ndef mbpp_run1(subjectmarks):\n#mbpp_run1 = [('English', 88), ('Science', 90), ('Maths', 97), ('Social sciences', 82)])\n subjectmarks.sort(key = lambda x: x[1])\n return subjectmarks\n\n ```", "raw_test_input": ["assert mbpp_run1([('English', 88), ('Science', 90), ('Maths', 97), ('Social sciences', 82)])==[('Social sciences', 82), ('English', 88), ('Science', 90), ('Maths', 97)]", "assert mbpp_run1([('Telugu',49),('Hindhi',54),('Social',33)])==([('Social',33),('Telugu',49),('Hindhi',54)])", "assert mbpp_run1([('Physics',96),('Chemistry',97),('Biology',45)])==([('Biology',45),('Physics',96),('Chemistry',97)])"], "new_problem": "Write a function to sort subjects based on their marks from a dictionary where each subject is a key and the value is another dictionary containing 'marks' and 'teacher'. The function should return a list of subject names sorted by their marks. Use type hints and ensure the function can handle at least 10 subjects.", "new_solution": "from typing import Dict, List\n\ndef mbpp_run2(subjects: Dict[str, Dict[str, int]]) -> List[str]:\n    return sorted(subjects.keys(), key=lambda subject: subjects[subject]['marks'])", "input_format": "A dictionary where keys are subject names and values are dictionaries with 'marks' and 'teacher' as keys.", "output_format": "A list of subject names sorted by their marks.", "test_input": ["assert mbpp_run2({'English': {'marks': 88, 'teacher': 'Mr. Smith'}, 'Science': {'marks': 90, 'teacher': 'Ms. Johnson'}, 'Maths': {'marks': 97, 'teacher': 'Mr. Brown'}, 'Social sciences': {'marks': 82, 'teacher': 'Ms. Davis'}}) == ['Social sciences', 'English', 'Science', 'Maths']", "assert mbpp_run2({'History': {'marks': 75, 'teacher': 'Mr. White'}, 'Geography': {'marks': 85, 'teacher': 'Ms. Green'}, 'Physics': {'marks': 95, 'teacher': 'Mr. Black'}, 'Chemistry': {'marks': 65, 'teacher': 'Ms. Blue'}}) == ['Chemistry', 'History', 'Geography', 'Physics']", "assert mbpp_run2({'Biology': {'marks': 78, 'teacher': 'Mr. Red'}, 'Art': {'marks': 88, 'teacher': 'Ms. Yellow'}, 'Music': {'marks': 98, 'teacher': 'Mr. Purple'}, 'Drama': {'marks': 68, 'teacher': 'Ms. Orange'}}) == ['Drama', 'Biology', 'Art', 'Music']", "assert mbpp_run2({'PE': {'marks': 55, 'teacher': 'Mr. Gray'}, 'IT': {'marks': 95, 'teacher': 'Ms. Pink'}, 'Economics': {'marks': 85, 'teacher': 'Mr. Cyan'}, 'Business': {'marks': 75, 'teacher': 'Ms. Magenta'}}) == ['PE', 'Business', 'Economics', 'IT']", "assert mbpp_run2({'Philosophy': {'marks': 92, 'teacher': 'Mr. Gold'}, 'Psychology': {'marks': 82, 'teacher': 'Ms. Silver'}, 'Sociology': {'marks': 72, 'teacher': 'Mr. Bronze'}, 'Anthropology': {'marks': 62, 'teacher': 'Ms. Platinum'}}) == ['Anthropology', 'Sociology', 'Psychology', 'Philosophy']"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "Mbpp/64-4", "raw_problem": "Write a function to sort a list of tuples using the second value of each tuple.", "raw_solution": "```python\n\ndef mbpp_run1(subjectmarks):\n#mbpp_run1 = [('English', 88), ('Science', 90), ('Maths', 97), ('Social sciences', 82)])\n subjectmarks.sort(key = lambda x: x[1])\n return subjectmarks\n\n ```", "raw_test_input": ["assert mbpp_run1([('English', 88), ('Science', 90), ('Maths', 97), ('Social sciences', 82)])==[('Social sciences', 82), ('English', 88), ('Science', 90), ('Maths', 97)]", "assert mbpp_run1([('Telugu',49),('Hindhi',54),('Social',33)])==([('Social',33),('Telugu',49),('Hindhi',54)])", "assert mbpp_run1([('Physics',96),('Chemistry',97),('Biology',45)])==([('Biology',45),('Physics',96),('Chemistry',97)])"], "new_problem": "Write a function to sort a list of tuples using the second value of each tuple. The function should handle the following errors: 1) If the input is not a list, raise a TypeError with a meaningful message. 2) If any element in the list is not a tuple, raise a ValueError. 3) If any tuple does not contain exactly two elements, raise a ValueError. 4) If the second element of any tuple is not an integer, raise a ValueError. Ensure that the function propagates errors with meaningful messages.", "new_solution": "from typing import List, Tuple\n\nclass SortingError(Exception):\n    pass\n\nclass NotAListError(SortingError):\n    pass\n\nclass InvalidTupleError(SortingError):\n    pass\n\nclass InvalidTupleLengthError(SortingError):\n    pass\n\nclass InvalidSecondElementError(SortingError):\n    pass\n\ndef mbpp_run2(subjectmarks: List[Tuple[str, int]]) -> List[Tuple[str, int]]:\n    if not isinstance(subjectmarks, list):\n        raise NotAListError(\"Input must be a list.\")\n    for item in subjectmarks:\n        if not isinstance(item, tuple):\n            raise InvalidTupleError(\"All elements must be tuples.\")\n        if len(item) != 2:\n            raise InvalidTupleLengthError(\"Each tuple must contain exactly two elements.\")\n        if not isinstance(item[1], int):\n            raise InvalidSecondElementError(\"The second element of each tuple must be an integer.\")\n    subjectmarks.sort(key=lambda x: x[1])\n    return subjectmarks\n", "input_format": "A list of tuples where each tuple contains a string and an integer.", "output_format": "A sorted list of tuples based on the second value of each tuple.", "test_input": ["assert mbpp_run2([('English', 88), ('Science', 90), ('Maths', 97), ('Social sciences', 82)]) == [('Social sciences', 82), ('English', 88), ('Science', 90), ('Maths', 97)]", "try:\n    mbpp_run2('Not a list')\nexcept NotAListError as e:\n    assert str(e) == 'Input must be a list.'", "try:\n    mbpp_run2([('English', 88), 'Not a tuple'])\nexcept InvalidTupleError as e:\n    assert str(e) == 'All elements must be tuples.'", "try:\n    mbpp_run2([('English', 88, 'Extra')])\nexcept InvalidTupleLengthError as e:\n    assert str(e) == 'Each tuple must contain exactly two elements.'", "try:\n    mbpp_run2([('English', 'Eighty-eight')])\nexcept InvalidSecondElementError as e:\n    assert str(e) == 'The second element of each tuple must be an integer.'"], "requirement_type": "PROMPT_ERROR_HANDLING"}
{"task_id": "Mbpp/65-1", "raw_problem": "Write a function to flatten a list and sum all of its elements.", "raw_solution": "```python\n\ndef mbpp_run1(data_list):\n\ttotal = 0\n\tfor element in data_list:\n\t\tif type(element) == type([]):\n\t\t\ttotal = total + mbpp_run1(element)\n\t\telse:\n\t\t\ttotal = total + element\n\treturn total\n\n ```", "raw_test_input": ["assert mbpp_run1(([1, 2, [3,4],[5,6]]))==21", "assert mbpp_run1(([7, 10, [15,14],[19,41]]))==106", "assert mbpp_run1(([10, 20, [30,40],[50,60]]))==210"], "new_problem": "In a company, each department tracks its monthly expenses in a nested list format. Write a function that calculates the total annual expenses for each department using the provided function to flatten and sum the expenses. The input is a dictionary where keys are department names and values are lists of lists representing monthly expenses for each department. The output should be a dictionary where keys are department names and values are the total annual expenses for each department.", "new_solution": "def recursive_list_sum(data_list):\n    total = 0\n    for element in data_list:\n        if type(element) == type([]):\n            total = total + recursive_list_sum(element)\n        else:\n            total = total + element\n    return total\n\n\ndef mbpp_run2(expenses_dict):\n    annual_expenses = {}\n    for department, expenses in expenses_dict.items():\n        annual_expenses[department] = recursive_list_sum(expenses)\n    return annual_expenses", "input_format": "A dictionary where keys are department names and values are lists of lists representing monthly expenses for each department.", "output_format": "A dictionary where keys are department names and values are the total annual expenses for each department.", "test_input": ["assert mbpp_run2({'HR': [[100, 200], [300, 400]], 'IT': [[500, 600], [700, 800]]}) == {'HR': 1000, 'IT': 2600}", "assert mbpp_run2({'Sales': [[150, 250], [350, 450]], 'Marketing': [[550, 650], [750, 850]]}) == {'Sales': 1200, 'Marketing': 2800}", "assert mbpp_run2({'Finance': [[1000, 2000], [3000, 4000]], 'Operations': [[5000, 6000], [7000, 8000]]}) == {'Finance': 10000, 'Operations': 26000}", "assert mbpp_run2({'R&D': [[110, 210], [310, 410]], 'Support': [[510, 610], [710, 810]]}) == {'R&D': 1040, 'Support': 2640}", "assert mbpp_run2({'Admin': [[120, 220], [320, 420]], 'Logistics': [[520, 620], [720, 820]]}) == {'Admin': 1080, 'Logistics': 2680}"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "Mbpp/65-2", "raw_problem": "Write a function to flatten a list and sum all of its elements.", "raw_solution": "```python\n\ndef mbpp_run1(data_list):\n\ttotal = 0\n\tfor element in data_list:\n\t\tif type(element) == type([]):\n\t\t\ttotal = total + mbpp_run1(element)\n\t\telse:\n\t\t\ttotal = total + element\n\treturn total\n\n ```", "raw_test_input": ["assert mbpp_run1(([1, 2, [3,4],[5,6]]))==21", "assert mbpp_run1(([7, 10, [15,14],[19,41]]))==106", "assert mbpp_run1(([10, 20, [30,40],[50,60]]))==210"], "new_problem": "Enhance the function to flatten a list and sum all of its elements by adding optional parameters: a multiplier to scale the sum and a filter function to include only certain elements in the sum. The function should maintain backward compatibility with existing implementations.", "new_solution": "def mbpp_run2(data_list: list, multiplier: int = 1, filter_func: callable = None) -> int:\n    total = 0\n    for element in data_list:\n        if isinstance(element, list):\n            total += mbpp_run2(element, multiplier, filter_func)\n        else:\n            if filter_func is None or filter_func(element):\n                total += element * multiplier\n    return total", "input_format": "A list of integers and/or nested lists of integers, with optional parameters for a multiplier and a filter function.", "output_format": "An integer representing the sum of all elements in the list, potentially modified by the multiplier and filter function.", "test_input": ["assert mbpp_run2([1, 2, [3, 4], 5]) == 15", "assert mbpp_run2([1, 2, [3, 4], 5], multiplier=2) == 30", "assert mbpp_run2([1, 2, [3, 4], 5], filter_func=lambda x: x > 2) == 12", "assert mbpp_run2([1, 2, [3, 4], 5], multiplier=3, filter_func=lambda x: x % 2 == 0) == 18", "assert mbpp_run2([1, [2, [3, [4, 5]]]], filter_func=lambda x: x < 4) == 6"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "Mbpp/65-3", "raw_problem": "Write a function to flatten a list and sum all of its elements.", "raw_solution": "```python\n\ndef mbpp_run1(data_list):\n\ttotal = 0\n\tfor element in data_list:\n\t\tif type(element) == type([]):\n\t\t\ttotal = total + mbpp_run1(element)\n\t\telse:\n\t\t\ttotal = total + element\n\treturn total\n\n ```", "raw_test_input": ["assert mbpp_run1(([1, 2, [3,4],[5,6]]))==21", "assert mbpp_run1(([7, 10, [15,14],[19,41]]))==106", "assert mbpp_run1(([10, 20, [30,40],[50,60]]))==210"], "new_problem": "Write a function to flatten a dictionary and sum all of its integer values. The dictionary can have nested dictionaries as values. Use type hints and ensure the function can handle deeply nested structures. Additionally, the function should ignore any non-integer values.", "new_solution": "from typing import Union, Dict\n\ndef mbpp_run2(data_dict: Dict[str, Union[int, dict]]) -> int:\n    total = 0\n    for value in data_dict.values():\n        if isinstance(value, dict):\n            total += mbpp_run2(value)\n        elif isinstance(value, int):\n            total += value\n    return total\n", "input_format": "A dictionary where keys are strings and values are either integers or nested dictionaries with similar structure.", "output_format": "An integer representing the sum of all integer values in the dictionary.", "test_input": ["assert mbpp_run2({'a': 1, 'b': {'c': 2, 'd': {'e': 3}}, 'f': 4}) == 10", "assert mbpp_run2({'x': {'y': {'z': 5}}, 'w': 6}) == 11", "assert mbpp_run2({'key1': 10, 'key2': {'key3': 20, 'key4': {'key5': 30}}, 'key6': 40}) == 100", "assert mbpp_run2({'outer': {'inner': {'innermost': 7}}, 'another': 8}) == 15", "assert mbpp_run2({'a': 1, 'b': {'c': 'not an int', 'd': {'e': 3}}, 'f': 4}) == 8"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "Mbpp/65-4", "raw_problem": "Write a function to flatten a list and sum all of its elements.", "raw_solution": "```python\n\ndef mbpp_run1(data_list):\n\ttotal = 0\n\tfor element in data_list:\n\t\tif type(element) == type([]):\n\t\t\ttotal = total + mbpp_run1(element)\n\t\telse:\n\t\t\ttotal = total + element\n\treturn total\n\n ```", "raw_test_input": ["assert mbpp_run1(([1, 2, [3,4],[5,6]]))==21", "assert mbpp_run1(([7, 10, [15,14],[19,41]]))==106", "assert mbpp_run1(([10, 20, [30,40],[50,60]]))==210"], "new_problem": "Write a function to flatten a list and sum all of its elements, handling errors appropriately. The function should raise a ValueError if any element in the list is not an integer or float. Additionally, handle TypeError if the input is not a list. Ensure that the error messages are meaningful and propagate errors correctly.", "new_solution": "from typing import List, Union\n\nclass InvalidElementError(Exception):\n    pass\n\nclass NotAListError(Exception):\n    pass\n\ndef mbpp_run2(data_list: Union[List[Union[int, float]], int, float]) -> Union[int, float]:\n    if not isinstance(data_list, list):\n        raise NotAListError(\"Input must be a list.\")\n    total = 0\n    for element in data_list:\n        if isinstance(element, list):\n            total += mbpp_run2(element)\n        elif isinstance(element, (int, float)):\n            total += element\n        else:\n            raise InvalidElementError(f\"Invalid element found: {element}. Only integers and floats are allowed.\")\n    return total\n", "input_format": "A nested list of integers and/or floats, potentially containing invalid elements.", "output_format": "An integer or float representing the sum of all valid elements in the list.", "test_input": ["assert mbpp_run2([1, 2, [3, 4], 5]) == 15", "assert mbpp_run2([1.5, 2.5, [3.0, 4.0], 5.0]) == 16.0", "try:\n    mbpp_run2([1, 2, 'a', 4])\nexcept InvalidElementError as e:\n    assert str(e) == 'Invalid element found: a. Only integers and floats are allowed.'", "try:\n    mbpp_run2('not a list')\nexcept NotAListError as e:\n    assert str(e) == 'Input must be a list.'", "try:\n    mbpp_run2([1, 2, [3, 'b'], 5])\nexcept InvalidElementError as e:\n    assert str(e) == 'Invalid element found: b. Only integers and floats are allowed.'"], "requirement_type": "PROMPT_ERROR_HANDLING"}
{"task_id": "Mbpp/66-1", "raw_problem": "Write a python function to count the number of positive numbers in a list.", "raw_solution": "```python\n\ndef mbpp_run1(l):\n  return len([x for x in l if x > 0])\n\n ```", "raw_test_input": ["assert mbpp_run1([1,-2,3,-4]) == 2", "assert mbpp_run1([3,4,5,-1]) == 3", "assert mbpp_run1([1,2,3,4]) == 4"], "new_problem": "In a financial application, you need to analyze a list of transaction amounts to determine the number of positive transactions and check if the number of positive transactions exceeds a given threshold. Write a Python function that takes a dictionary with a list of transaction amounts and a threshold value, and returns a dictionary with the total number of positive transactions and a boolean indicating if this number exceeds the threshold.", "new_solution": "def pos_count(l):\n    return len([x for x in l if x > 0])\n\n\ndef mbpp_run2(data):\n    transactions = data['transactions']\n    threshold = data['threshold']\n    total_positive_transactions = pos_count(transactions)\n    above_threshold = total_positive_transactions > threshold\n    return {\n        'total_positive_transactions': total_positive_transactions,\n        'above_threshold': above_threshold\n    }", "input_format": "A dictionary with keys 'transactions' (list of transaction amounts) and 'threshold' (positive integer)", "output_format": "A dictionary with keys 'total_positive_transactions' (integer) and 'above_threshold' (boolean)", "test_input": ["assert mbpp_run2({'transactions': [100, -50, 200, -300, 400], 'threshold': 2}) == {'total_positive_transactions': 3, 'above_threshold': True}", "assert mbpp_run2({'transactions': [-100, -50, -200, -300, -400], 'threshold': 0}) == {'total_positive_transactions': 0, 'above_threshold': False}", "assert mbpp_run2({'transactions': [10, 20, 30, 40, 50], 'threshold': 5}) == {'total_positive_transactions': 5, 'above_threshold': False}", "assert mbpp_run2({'transactions': [1, 2, 3, 4, 5], 'threshold': 3}) == {'total_positive_transactions': 5, 'above_threshold': True}", "assert mbpp_run2({'transactions': [0, 0, 0, 0, 0], 'threshold': 0}) == {'total_positive_transactions': 0, 'above_threshold': False}"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "Mbpp/66-2", "raw_problem": "Write a python function to count the number of positive numbers in a list.", "raw_solution": "```python\n\ndef mbpp_run1(l):\n  return len([x for x in l if x > 0])\n\n ```", "raw_test_input": ["assert mbpp_run1([1,-2,3,-4]) == 2", "assert mbpp_run1([3,4,5,-1]) == 3", "assert mbpp_run1([1,2,3,4]) == 4"], "new_problem": "Enhance the existing function to count the number of positive numbers in a list. The function should maintain backward compatibility and support the original function parameters. Additionally, include an optional parameter 'include_zero' that, when set to True, counts zeros as positive numbers.", "new_solution": "def mbpp_run2(l: list[int], include_zero: bool = False) -> int:\n    if include_zero:\n        return len([x for x in l if x >= 0])\n    return len([x for x in l if x > 0])", "input_format": "List[int], optional bool", "output_format": "int", "test_input": ["assert mbpp_run2([1, -2, 3, 0, -5]) == 2", "assert mbpp_run2([1, -2, 3, 0, -5], include_zero=True) == 3", "assert mbpp_run2([-1, -2, -3, -4]) == 0", "assert mbpp_run2([0, 0, 0], include_zero=True) == 3", "assert mbpp_run2([0, 0, 0]) == 0"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "Mbpp/66-3", "raw_problem": "Write a python function to count the number of positive numbers in a list.", "raw_solution": "```python\n\ndef mbpp_run1(l):\n  return len([x for x in l if x > 0])\n\n ```", "raw_test_input": ["assert mbpp_run1([1,-2,3,-4]) == 2", "assert mbpp_run1([3,4,5,-1]) == 3", "assert mbpp_run1([1,2,3,4]) == 4"], "new_problem": "Write a Python function that takes a dictionary where each key is a category and each value is a list of integers. The function should return a new dictionary with the same keys, but the values should be the count of positive numbers in each list. Use type hints and ensure the function can handle dictionaries with up to 100 categories, each containing up to 1000 integers.", "new_solution": "def pos_count(l: list[int]) -> int:\n    return len([x for x in l if x > 0])\n\ndef mbpp_run2(data: dict[str, list[int]]) -> dict[str, int]:\n    return {category: pos_count(numbers) for category, numbers in data.items()}", "input_format": "A dictionary where keys are strings representing categories and values are lists of integers.", "output_format": "A dictionary where keys are the same categories and values are the counts of positive numbers in each list.", "test_input": ["assert mbpp_run2({'fruits': [1, -2, 3], 'vegetables': [-1, -2, -3]}) == {'fruits': 2, 'vegetables': 0}", "assert mbpp_run2({'numbers': [0, 0, 0], 'more_numbers': [1, 2, 3]}) == {'numbers': 0, 'more_numbers': 3}", "assert mbpp_run2({'mixed': [-1, 0, 1, 2, -3]}) == {'mixed': 2}", "assert mbpp_run2({'empty': [], 'single_positive': [5]}) == {'empty': 0, 'single_positive': 1}", "assert mbpp_run2({'all_negative': [-5, -10, -15], 'all_positive': [5, 10, 15]}) == {'all_negative': 0, 'all_positive': 3}"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "Mbpp/66-4", "raw_problem": "Write a python function to count the number of positive numbers in a list.", "raw_solution": "```python\n\ndef mbpp_run1(l):\n  return len([x for x in l if x > 0])\n\n ```", "raw_test_input": ["assert mbpp_run1([1,-2,3,-4]) == 2", "assert mbpp_run1([3,4,5,-1]) == 3", "assert mbpp_run1([1,2,3,4]) == 4"], "new_problem": "Write a Python function to count the number of positive numbers in a list. The function should handle the following errors: 1) Raise a ValueError if any element in the list is not a number. 2) Raise a TypeError if the input is not a list. 3) Propagate errors with meaningful messages. Use type hints in your function definition.", "new_solution": "from typing import List, Union\n\nclass NonNumericValueError(ValueError):\n    pass\n\nclass NotAListError(TypeError):\n    pass\n\ndef mbpp_run2(l: Union[List[Union[int, float]], None]) -> int:\n    if not isinstance(l, list):\n        raise NotAListError('Input must be a list.')\n    for item in l:\n        if not isinstance(item, (int, float)):\n            raise NonNumericValueError(f'List contains non-numeric value: {item}')\n    return len([x for x in l if x > 0])", "input_format": "A list of numbers, which may include non-numeric values.", "output_format": "An integer representing the count of positive numbers in the list.", "test_input": ["assert mbpp_run2([1, 2, 3, -1, -2, 0]) == 3", "assert mbpp_run2([-1, -2, -3, 0]) == 0", "try:\n    mbpp_run2('not a list')\nexcept NotAListError as e:\n    assert str(e) == 'Input must be a list.'", "try:\n    mbpp_run2([1, 'two', 3])\nexcept NonNumericValueError as e:\n    assert str(e) == 'List contains non-numeric value: two'", "try:\n    mbpp_run2(None)\nexcept NotAListError as e:\n    assert str(e) == 'Input must be a list.'"], "requirement_type": "PROMPT_ERROR_HANDLING"}
{"task_id": "Mbpp/67-1", "raw_problem": "Write a function to find the number of ways to partition a set of Bell numbers.", "raw_solution": "```python\n\ndef mbpp_run1(n):   \n    bell = [[0 for i in range(n+1)] for j in range(n+1)] \n    bell[0][0] = 1\n    for i in range(1, n+1): \n        bell[i][0] = bell[i-1][i-1]  \n        for j in range(1, i+1): \n            bell[i][j] = bell[i-1][j-1] + bell[i][j-1]   \n    return bell[n][0] \n\n ```", "raw_test_input": ["assert mbpp_run1(2)==2", "assert mbpp_run1(10)==115975", "assert mbpp_run1(56)==6775685320645824322581483068371419745979053216268760300"], "new_problem": "In an e-commerce platform, you have different categories of products, each with a certain number of items. You want to determine the total number of ways to partition all items across these categories into non-empty subsets. Use the Bell number to calculate the number of ways to partition each category and then find the total number of ways to partition all items across all categories.", "new_solution": "def bell_number(n):\n    bell = [[0 for i in range(n+1)] for j in range(n+1)]\n    bell[0][0] = 1\n    for i in range(1, n+1):\n        bell[i][0] = bell[i-1][i-1]\n        for j in range(1, i+1):\n            bell[i][j] = bell[i-1][j-1] + bell[i][j-1]\n    return bell[n][0]\n\ndef mbpp_run2(categories):\n    total_ways = 1\n    for items in categories:\n        total_ways *= bell_number(items)\n    return total_ways\n", "input_format": "A list of integers representing the number of items in different categories.", "output_format": "An integer representing the total number of ways to partition all items across categories.", "test_input": ["assert mbpp_run2([1, 2, 3]) == 10", "assert mbpp_run2([0, 0, 0]) == 1", "assert mbpp_run2([4, 5]) == 780", "assert mbpp_run2([3, 3, 3]) == 125", "assert mbpp_run2([2, 2, 2, 2]) == 16"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "Mbpp/67-2", "raw_problem": "Write a function to find the number of ways to partition a set of Bell numbers.", "raw_solution": "```python\n\ndef mbpp_run1(n):   \n    bell = [[0 for i in range(n+1)] for j in range(n+1)] \n    bell[0][0] = 1\n    for i in range(1, n+1): \n        bell[i][0] = bell[i-1][i-1]  \n        for j in range(1, i+1): \n            bell[i][j] = bell[i-1][j-1] + bell[i][j-1]   \n    return bell[n][0] \n\n ```", "raw_test_input": ["assert mbpp_run1(2)==2", "assert mbpp_run1(10)==115975", "assert mbpp_run1(56)==6775685320645824322581483068371419745979053216268760300"], "new_problem": "Enhance the function to find the number of ways to partition a set of Bell numbers by adding an optional parameter to enable memoization for performance improvement. The function should maintain backward compatibility, support the original function parameters, and include type hints.", "new_solution": "from typing import Dict\n\ndef mbpp_run2(n: int, *, memoize: bool = False) -> int:\n    if memoize:\n        memo: Dict[int, int] = {}\n        def mbpp_run2_memo(n: int) -> int:\n            if n in memo:\n                return memo[n]\n            bell = [[0 for _ in range(n+1)] for _ in range(n+1)]\n            bell[0][0] = 1\n            for i in range(1, n+1):\n                bell[i][0] = bell[i-1][i-1]\n                for j in range(1, i+1):\n                    bell[i][j] = bell[i-1][j-1] + bell[i][j-1]\n            memo[n] = bell[n][0]\n            return memo[n]\n        return mbpp_run2_memo(n)\n    else:\n        bell = [[0 for _ in range(n+1)] for _ in range(n+1)]\n        bell[0][0] = 1\n        for i in range(1, n+1):\n            bell[i][0] = bell[i-1][i-1]\n            for j in range(1, i+1):\n                bell[i][j] = bell[i-1][j-1] + bell[i][j-1]\n        return bell[n][0]", "input_format": "bell_number(n: int, *, memoize: bool = False) -> int", "output_format": "int", "test_input": ["assert mbpp_run2(0) == 1", "assert mbpp_run2(1) == 1", "assert mbpp_run2(2) == 2", "assert mbpp_run2(3) == 5", "assert mbpp_run2(4, memoize=True) == 15", "assert mbpp_run2(5, memoize=True) == 52"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "Mbpp/67-3", "raw_problem": "Write a function to find the number of ways to partition a set of Bell numbers.", "raw_solution": "```python\n\ndef mbpp_run1(n):   \n    bell = [[0 for i in range(n+1)] for j in range(n+1)] \n    bell[0][0] = 1\n    for i in range(1, n+1): \n        bell[i][0] = bell[i-1][i-1]  \n        for j in range(1, i+1): \n            bell[i][j] = bell[i-1][j-1] + bell[i][j-1]   \n    return bell[n][0] \n\n ```", "raw_test_input": ["assert mbpp_run1(2)==2", "assert mbpp_run1(10)==115975", "assert mbpp_run1(56)==6775685320645824322581483068371419745979053216268760300"], "new_problem": "Write a function to find the number of ways to partition a set of Bell numbers using a dictionary to store intermediate results. The function should also handle the case where the input is a list of integers, each representing a different set size, and return a dictionary mapping each set size to its corresponding Bell number. Additionally, ensure that the function can handle inputs up to 1000 efficiently.", "new_solution": "from typing import List, Dict\n\ndef bell_number(n: int) -> int:\n    bell = [[0 for i in range(n+1)] for j in range(n+1)]\n    bell[0][0] = 1\n    for i in range(1, n+1):\n        bell[i][0] = bell[i-1][i-1]\n        for j in range(1, i+1):\n            bell[i][j] = bell[i-1][j-1] + bell[i][j-1]\n    return bell[n][0]\n\ndef mbpp_run2(sizes: List[int]) -> Dict[int, int]:\n    max_size = max(sizes)\n    bell_dict = {}\n    for size in sizes:\n        if size not in bell_dict:\n            bell_dict[size] = bell_number(size)\n    return bell_dict", "input_format": "A positive integer n representing the number of elements in the set.", "output_format": "An integer representing the number of ways to partition the set using Bell numbers.", "test_input": ["assert mbpp_run2([1, 2, 3]) == {1: 1, 2: 2, 3: 5}", "assert mbpp_run2([4, 5]) == {4: 15, 5: 52}", "assert mbpp_run2([6, 7, 8]) == {6: 203, 7: 877, 8: 4140}", "assert mbpp_run2([0, 1, 2]) == {0: 1, 1: 1, 2: 2}", "assert mbpp_run2([10, 20]) == {10: 115975, 20: 51724158235372}"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "Mbpp/67-4", "raw_problem": "Write a function to find the number of ways to partition a set of Bell numbers.", "raw_solution": "```python\n\ndef mbpp_run1(n):   \n    bell = [[0 for i in range(n+1)] for j in range(n+1)] \n    bell[0][0] = 1\n    for i in range(1, n+1): \n        bell[i][0] = bell[i-1][i-1]  \n        for j in range(1, i+1): \n            bell[i][j] = bell[i-1][j-1] + bell[i][j-1]   \n    return bell[n][0] \n\n ```", "raw_test_input": ["assert mbpp_run1(2)==2", "assert mbpp_run1(10)==115975", "assert mbpp_run1(56)==6775685320645824322581483068371419745979053216268760300"], "new_problem": "Write a function to find the number of ways to partition a set of Bell numbers, with error handling. The function should handle the following errors: \n1. Input is not an integer (TypeError).\n2. Input is a negative integer (ValueError).\n3. Input is too large, causing performance issues (Custom exception: PerformanceError). \nThe function should propagate errors with meaningful messages.", "new_solution": "class PerformanceError(Exception):\n    pass\n\ndef mbpp_run2(n: int) -> int:\n    if not isinstance(n, int):\n        raise TypeError(\"Input must be an integer.\")\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n    if n > 1000:  # Arbitrary limit for performance concerns\n        raise PerformanceError(\"Input is too large and may cause performance issues.\")\n    \n    bell = [[0 for _ in range(n+1)] for _ in range(n+1)]\n    bell[0][0] = 1\n    for i in range(1, n+1):\n        bell[i][0] = bell[i-1][i-1]\n        for j in range(1, i+1):\n            bell[i][j] = bell[i-1][j-1] + bell[i][j-1]\n    return bell[n][0]", "input_format": "An integer n representing the number of elements in the set.", "output_format": "An integer representing the number of ways to partition the set of Bell numbers.", "test_input": ["assert mbpp_run2(0) == 1", "assert mbpp_run2(1) == 1", "assert mbpp_run2(2) == 2", "try:\n    mbpp_run2(-1)\nexcept ValueError as e:\n    assert str(e) == \"Input must be a non-negative integer.\"", "try:\n    mbpp_run2(1001)\nexcept PerformanceError as e:\n    assert str(e) == \"Input is too large and may cause performance issues.\"", "try:\n    mbpp_run2('a')\nexcept TypeError as e:\n    assert str(e) == \"Input must be an integer.\""], "requirement_type": "PROMPT_ERROR_HANDLING"}
{"task_id": "Mbpp/68-1", "raw_problem": "Write a python function to check whether the given array is monotonic or not.", "raw_solution": "```python\n\ndef mbpp_run1(A): \n    return all(a <= b for a, b in zip(A, A[1:])) or all(a >= b for a, b in zip(A, A[1:]))\n\n ```", "raw_test_input": ["assert mbpp_run1([6, 5, 4, 4]) == True", "assert mbpp_run1([1, 2, 2, 3]) == True", "assert mbpp_run1([1, 3, 2]) == False"], "new_problem": "In the context of stock market analysis, you are given a dictionary where each key is a company name and the corresponding value is a list of stock prices over a period of time. Write a Python function that uses the original monotonic check function to determine if the stock prices for each company are monotonic. A company's stock prices are considered monotonic if they are either entirely non-increasing or non-decreasing. The function should return a dictionary where each key is a company name and the value is a boolean indicating whether the stock prices for that company are monotonic.", "new_solution": "def is_Monotonic(A):\n    return all(a <= b for a, b in zip(A, A[1:])) or all(a >= b for a, b in zip(A, A[1:]))\n\ndef mbpp_run2(stock_data):\n    result = {}\n    for company, prices in stock_data.items():\n        result[company] = is_Monotonic(prices)\n    return result", "input_format": "A list of stock prices (floats) for multiple companies over a period of time, represented as a dictionary where keys are company names and values are lists of prices.", "output_format": "A dictionary where keys are company names and values are booleans indicating whether the stock prices for that company are monotonic.", "test_input": ["assert mbpp_run2({'CompanyA': [1, 2, 3, 4], 'CompanyB': [4, 3, 2, 1], 'CompanyC': [1, 3, 2, 4]}) == {'CompanyA': True, 'CompanyB': True, 'CompanyC': False}", "assert mbpp_run2({'CompanyD': [5, 5, 5, 5], 'CompanyE': [10, 9, 8, 7], 'CompanyF': [1, 2, 2, 3]}) == {'CompanyD': True, 'CompanyE': True, 'CompanyF': True}", "assert mbpp_run2({'CompanyG': [1, 1, 1, 2], 'CompanyH': [3, 3, 3, 3], 'CompanyI': [2, 1, 0, -1]}) == {'CompanyG': True, 'CompanyH': True, 'CompanyI': True}", "assert mbpp_run2({'CompanyJ': [1, 2, 1, 2], 'CompanyK': [4, 5, 6, 7], 'CompanyL': [7, 6, 5, 4]}) == {'CompanyJ': False, 'CompanyK': True, 'CompanyL': True}", "assert mbpp_run2({'CompanyM': [3, 2, 1, 0], 'CompanyN': [0, 1, 2, 3], 'CompanyO': [1, 2, 3, 2]}) == {'CompanyM': True, 'CompanyN': True, 'CompanyO': False}"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "Mbpp/68-2", "raw_problem": "Write a python function to check whether the given array is monotonic or not.", "raw_solution": "```python\n\ndef mbpp_run1(A): \n    return all(a <= b for a, b in zip(A, A[1:])) or all(a >= b for a, b in zip(A, A[1:]))\n\n ```", "raw_test_input": ["assert mbpp_run1([6, 5, 4, 4]) == True", "assert mbpp_run1([1, 2, 2, 3]) == True", "assert mbpp_run1([1, 3, 2]) == False"], "new_problem": "Enhance the function to check whether the given array is monotonic or not, with an optional parameter 'strict'. If 'strict' is True, the function should check for strictly increasing or decreasing sequences. Maintain backward compatibility with the original function.", "new_solution": "def mbpp_run2(A: list[int], strict: bool = False) -> bool:\n    if strict:\n        return all(a < b for a, b in zip(A, A[1:])) or all(a > b for a, b in zip(A, A[1:]))\n    else:\n        return all(a <= b for a, b in zip(A, A[1:])) or all(a >= b for a, b in zip(A, A[1:]))", "input_format": "List[int], optional bool parameter 'strict' (default is False)", "output_format": "bool", "test_input": ["assert mbpp_run2([1, 2, 2, 3]) == True", "assert mbpp_run2([3, 2, 2, 1]) == True", "assert mbpp_run2([1, 2, 3, 4], strict=True) == True", "assert mbpp_run2([1, 2, 2, 3], strict=True) == False", "assert mbpp_run2([4, 3, 2, 1], strict=True) == True"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "Mbpp/68-3", "raw_problem": "Write a python function to check whether the given array is monotonic or not.", "raw_solution": "```python\n\ndef mbpp_run1(A): \n    return all(a <= b for a, b in zip(A, A[1:])) or all(a >= b for a, b in zip(A, A[1:]))\n\n ```", "raw_test_input": ["assert mbpp_run1([6, 5, 4, 4]) == True", "assert mbpp_run1([1, 2, 2, 3]) == True", "assert mbpp_run1([1, 3, 2]) == False"], "new_problem": "Write a Python function to check whether the given sequence represented as a dictionary is monotonic or not. The dictionary keys represent the indices of the sequence, and the values are the elements. The function should handle sequences with missing indices by assuming missing values are zero. Additionally, the function should include type hints and handle sequences of up to 10,000 elements efficiently.", "new_solution": "from typing import Dict\n\ndef mbpp_run2(seq: Dict[int, int]) -> bool:\n    # Fill missing indices with zero\n    max_index = max(seq.keys())\n    filled_seq = [seq.get(i, 0) for i in range(max_index + 1)]\n    return all(a <= b for a, b in zip(filled_seq, filled_seq[1:])) or all(a >= b for a, b in zip(filled_seq, filled_seq[1:]))", "input_format": "A dictionary where keys are indices and values are the elements of the sequence.", "output_format": "A boolean indicating whether the sequence is monotonic.", "test_input": ["assert mbpp_run2({0: 1, 1: 2, 2: 3, 3: 4}) == True", "assert mbpp_run2({0: 4, 1: 3, 2: 2, 3: 1}) == True", "assert mbpp_run2({0: 1, 2: 2, 3: 3, 4: 4}) == False", "assert mbpp_run2({0: 1, 1: 3, 2: 2, 3: 4}) == False", "assert mbpp_run2({0: 1, 1: 2, 3: 3, 4: 2}) == False"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "Mbpp/68-4", "raw_problem": "Write a python function to check whether the given array is monotonic or not.", "raw_solution": "```python\n\ndef mbpp_run1(A): \n    return all(a <= b for a, b in zip(A, A[1:])) or all(a >= b for a, b in zip(A, A[1:]))\n\n ```", "raw_test_input": ["assert mbpp_run1([6, 5, 4, 4]) == True", "assert mbpp_run1([1, 2, 2, 3]) == True", "assert mbpp_run1([1, 3, 2]) == False"], "new_problem": "Write a Python function to check whether the given array is monotonic or not. The function should handle the following errors: 1. Raise a ValueError if the input is not a list. 2. Raise a TypeError if the list contains non-numeric elements. 3. Raise a ValueError if the list is empty. Implement error propagation and provide meaningful error messages.", "new_solution": "class MonotonicError(Exception):\n    pass\n\nclass NotAListError(MonotonicError):\n    def __init__(self, message=\"Input must be a list.\"):\n        self.message = message\n        super().__init__(self.message)\n\nclass NonNumericElementError(MonotonicError):\n    def __init__(self, message=\"All elements in the list must be numbers.\"):\n        self.message = message\n        super().__init__(self.message)\n\nclass EmptyListError(MonotonicError):\n    def __init__(self, message=\"List cannot be empty.\"):\n        self.message = message\n        super().__init__(self.message)\n\n\ndef mbpp_run2(A: list) -> bool:\n    if not isinstance(A, list):\n        raise NotAListError()\n    if not A:\n        raise EmptyListError()\n    if not all(isinstance(x, (int, float)) for x in A):\n        raise NonNumericElementError()\n    return all(a <= b for a, b in zip(A, A[1:])) or all(a >= b for a, b in zip(A, A[1:]))", "input_format": "A list of numbers", "output_format": "Boolean indicating if the list is monotonic", "test_input": ["try:\n    assert mbpp_run2([1, 2, 2, 3]) == True\nexcept Exception as e:\n    print(e)", "try:\n    assert mbpp_run2([3, 2, 2, 1]) == True\nexcept Exception as e:\n    print(e)", "try:\n    assert mbpp_run2([1, 3, 2]) == False\nexcept Exception as e:\n    print(e)", "try:\n    assert mbpp_run2([]) == False\nexcept EmptyListError as e:\n    print(e)", "try:\n    assert mbpp_run2('not a list') == False\nexcept NotAListError as e:\n    print(e)", "try:\n    assert mbpp_run2([1, 'a', 3]) == False\nexcept NonNumericElementError as e:\n    print(e)"], "requirement_type": "PROMPT_ERROR_HANDLING"}
{"task_id": "Mbpp/69-1", "raw_problem": "Write a function to check whether a list contains the given sublist or not.", "raw_solution": "```python\n\ndef mbpp_run1(l, s):\n\tif len(l) < len(s):\n\t\treturn False\n\treturn any(l[i:i+len(s)] == s for i in range(len(l)-len(s)+1))\n\n ```", "raw_test_input": ["assert mbpp_run1([2,4,3,5,7],[3,7])==False", "assert mbpp_run1([2,4,3,5,7],[4,3])==True", "assert mbpp_run1([2,4,3,5,7],[1,6])==False"], "new_problem": "In an e-commerce platform, you are tasked with identifying transactions that contain a specific promotional bundle of items. Write a function that takes a list of transactions and a promotional bundle (both represented as lists of items) and returns a list of indices of transactions where the promotional bundle appears as a sublist. Use the original function to check for the presence of the sublist within each transaction.", "new_solution": "def is_sublist(l, s):\n    if len(l) < len(s):\n        return False\n    return any(l[i:i+len(s)] == s for i in range(len(l)-len(s)+1))\n\ndef mbpp_run2(transactions, bundle):\n    indices = []\n    for index, transaction in enumerate(transactions):\n        if is_sublist(transaction, bundle):\n            indices.append(index)\n    return indices", "input_format": "A list of transactions (each transaction is a list of items) and a list of items representing a promotional bundle.", "output_format": "A list of transaction indices where the promotional bundle is found as a sublist.", "test_input": ["assert mbpp_run2([[\"apple\", \"banana\", \"cherry\"], [\"banana\", \"cherry\", \"date\"], [\"cherry\", \"date\", \"apple\"]], [\"banana\", \"cherry\"]) == [0, 1]", "assert mbpp_run2([[\"milk\", \"bread\", \"butter\"], [\"bread\", \"butter\", \"jam\"], [\"butter\", \"jam\", \"milk\"]], [\"bread\", \"butter\"]) == [0, 1]", "assert mbpp_run2([[\"pen\", \"pencil\", \"eraser\"], [\"pencil\", \"eraser\", \"sharpener\"], [\"eraser\", \"sharpener\", \"pen\"]], [\"pencil\", \"eraser\"]) == [0, 1]", "assert mbpp_run2([[\"shirt\", \"tie\", \"jacket\"], [\"tie\", \"jacket\", \"hat\"], [\"jacket\", \"hat\", \"shirt\"]], [\"tie\", \"jacket\"]) == [0, 1]", "assert mbpp_run2([[\"book\", \"notebook\", \"pen\"], [\"notebook\", \"pen\", \"pencil\"], [\"pen\", \"pencil\", \"book\"]], [\"notebook\", \"pen\"]) == [0, 1]"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "Mbpp/69-2", "raw_problem": "Write a function to check whether a list contains the given sublist or not.", "raw_solution": "```python\n\ndef mbpp_run1(l, s):\n\tif len(l) < len(s):\n\t\treturn False\n\treturn any(l[i:i+len(s)] == s for i in range(len(l)-len(s)+1))\n\n ```", "raw_test_input": ["assert mbpp_run1([2,4,3,5,7],[3,7])==False", "assert mbpp_run1([2,4,3,5,7],[4,3])==True", "assert mbpp_run1([2,4,3,5,7],[1,6])==False"], "new_problem": "Enhance the function to check whether a list contains the given sublist or not by adding support for case sensitivity and a custom comparison function. The function should maintain backward compatibility with existing implementations, support original function parameters, include type hints, and add new optional parameters for case sensitivity and a custom comparison function.", "new_solution": "from typing import List, Callable, Any\n\ndef mbpp_run2(l: List[Any], s: List[Any], case_sensitive: bool = True, compare_func: Callable[[Any, Any], bool] = lambda x, y: x == y) -> bool:\n    if len(l) < len(s):\n        return False\n    if not case_sensitive:\n        l = [str(item).lower() for item in l]\n        s = [str(item).lower() for item in s]\n    return any(all(compare_func(l[i+j], s[j]) for j in range(len(s))) for i in range(len(l) - len(s) + 1))", "input_format": "A list of integers and a sublist of integers, with optional parameters for case sensitivity and a custom comparison function.", "output_format": "A boolean indicating whether the sublist is present in the list.", "test_input": ["assert mbpp_run2([1, 2, 3, 4, 5], [2, 3]) == True", "assert mbpp_run2([1, 2, 3, 4, 5], [3, 5]) == False", "assert mbpp_run2(['a', 'b', 'c'], ['B', 'C'], case_sensitive=False) == True", "assert mbpp_run2(['a', 'b', 'c'], ['B', 'C'], case_sensitive=True) == False", "assert mbpp_run2(['apple', 'banana', 'cherry'], ['Banana'], case_sensitive=False) == True"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "Mbpp/69-3", "raw_problem": "Write a function to check whether a list contains the given sublist or not.", "raw_solution": "```python\n\ndef mbpp_run1(l, s):\n\tif len(l) < len(s):\n\t\treturn False\n\treturn any(l[i:i+len(s)] == s for i in range(len(l)-len(s)+1))\n\n ```", "raw_test_input": ["assert mbpp_run1([2,4,3,5,7],[3,7])==False", "assert mbpp_run1([2,4,3,5,7],[4,3])==True", "assert mbpp_run1([2,4,3,5,7],[1,6])==False"], "new_problem": "Write a function to check whether a given sublist is present in the lists associated with each key in a dictionary. The function should return a dictionary with the same keys, where each value is a boolean indicating whether the sublist is present in the corresponding list. The function should handle cases where the lists are large, and the sublist is small. Use type hints for the function signature.", "new_solution": "def mbpp_run2(data: dict[str, list[int]], sublist: list[int]) -> dict[str, bool]:\n    def is_sublist(l: list[int], s: list[int]) -> bool:\n        if len(l) < len(s):\n            return False\n        return any(l[i:i+len(s)] == s for i in range(len(l)-len(s)+1))\n\n    result = {}\n    for key, lst in data.items():\n        result[key] = is_sublist(lst, sublist)\n    return result", "input_format": "A dictionary where keys are strings and values are lists of integers, and a sublist to check.", "output_format": "A dictionary where keys are the original keys and values are booleans indicating if the sublist is present.", "test_input": ["assert mbpp_run2({'a': [1, 2, 3, 4], 'b': [5, 6, 7, 8]}, [2, 3]) == {'a': True, 'b': False}", "assert mbpp_run2({'x': [10, 20, 30], 'y': [30, 40, 50]}, [30, 40]) == {'x': False, 'y': True}", "assert mbpp_run2({'p': [1, 2, 3], 'q': [4, 5, 6]}, [7, 8]) == {'p': False, 'q': False}", "assert mbpp_run2({'m': [1, 2, 3, 4, 5], 'n': [5, 4, 3, 2, 1]}, [3, 4]) == {'m': True, 'n': False}", "assert mbpp_run2({'k': [1, 1, 1, 1], 'l': [1, 2, 1, 2]}, [1, 2]) == {'k': False, 'l': True}"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "Mbpp/69-4", "raw_problem": "Write a function to check whether a list contains the given sublist or not.", "raw_solution": "```python\n\ndef mbpp_run1(l, s):\n\tif len(l) < len(s):\n\t\treturn False\n\treturn any(l[i:i+len(s)] == s for i in range(len(l)-len(s)+1))\n\n ```", "raw_test_input": ["assert mbpp_run1([2,4,3,5,7],[3,7])==False", "assert mbpp_run1([2,4,3,5,7],[4,3])==True", "assert mbpp_run1([2,4,3,5,7],[1,6])==False"], "new_problem": "Write a function to check whether a list contains the given sublist or not. The function should handle the following errors: 1) TypeError if either the main list or the sublist is not a list. 2) ValueError if the sublist is empty. 3) Custom exception SublistNotFoundError if the sublist is not found in the main list. The function should propagate errors with meaningful messages.", "new_solution": "from typing import List\n\nclass SublistNotFoundError(Exception):\n    def __init__(self, message=\"Sublist not found in the main list\"):\n        self.message = message\n        super().__init__(self.message)\n\ndef mbpp_run2(l: List, s: List) -> bool:\n    if not isinstance(l, list) or not isinstance(s, list):\n        raise TypeError(\"Both arguments must be of type list.\")\n    if len(s) == 0:\n        raise ValueError(\"Sublist cannot be empty.\")\n    if len(l) < len(s):\n        raise SublistNotFoundError()\n    if any(l[i:i+len(s)] == s for i in range(len(l)-len(s)+1)):\n        return True\n    else:\n        raise SublistNotFoundError()", "input_format": "A list and a sublist to check for, both of which should be lists.", "output_format": "Boolean indicating whether the sublist is present in the list.", "test_input": ["assert mbpp_run2([1, 2, 3, 4], [2, 3]) == True", "try:\n    mbpp_run2([1, 2, 3, 4], [])\nexcept ValueError as e:\n    assert str(e) == \"Sublist cannot be empty.\"", "try:\n    mbpp_run2(\"not a list\", [1, 2])\nexcept TypeError as e:\n    assert str(e) == \"Both arguments must be of type list.\"", "try:\n    mbpp_run2([1, 2, 3, 4], [5, 6])\nexcept SublistNotFoundError as e:\n    assert str(e) == \"Sublist not found in the main list\"", "try:\n    mbpp_run2([1, 2, 3, 4], \"not a list\")\nexcept TypeError as e:\n    assert str(e) == \"Both arguments must be of type list.\""], "requirement_type": "PROMPT_ERROR_HANDLING"}
{"task_id": "Mbpp/70-1", "raw_problem": "Write a function to find whether all the given tuples have equal length or not.", "raw_solution": "```python\n\ndef mbpp_run1(Input):\n  return len(set(len(item) for item in Input)) == 1\n\n ```", "raw_test_input": ["assert mbpp_run1([(11, 22, 33), (44, 55, 66)]) == True", "assert mbpp_run1([(1, 2, 3), (4, 5, 6, 7)]) == False", "assert mbpp_run1([(1, 2), (3, 4)]) == True"], "new_problem": "In a data processing system for an e-commerce platform, you need to verify that all records (represented as tuples) in a batch have the same number of fields and that the average number of fields per record exceeds a given threshold. Write a function that takes a dictionary with a list of tuples and a threshold integer, and returns True if all tuples have equal length and the average length is above the threshold, otherwise returns False.", "new_solution": "def get_equal(Input):\n    return len(set(len(item) for item in Input)) == 1\n\n\ndef mbpp_run2(data_dict):\n    data = data_dict['data']\n    threshold = data_dict['threshold']\n    if not data:\n        return False\n    if get_equal(data):\n        average_length = sum(len(item) for item in data) / len(data)\n        return average_length > threshold\n    return False", "input_format": "A dictionary with keys 'data' (a list of tuples) and 'threshold' (an integer).", "output_format": "A boolean indicating if all tuples have equal length and if the average length is above the threshold.", "test_input": ["assert mbpp_run2({'data': [(1, 2), (3, 4), (5, 6)], 'threshold': 1}) == True", "assert mbpp_run2({'data': [(1, 2, 3), (4, 5, 6), (7, 8, 9)], 'threshold': 2}) == True", "assert mbpp_run2({'data': [(1, 2), (3, 4, 5), (6, 7)], 'threshold': 2}) == False", "assert mbpp_run2({'data': [(1, 2), (3, 4)], 'threshold': 3}) == False", "assert mbpp_run2({'data': [], 'threshold': 1}) == False"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "Mbpp/70-2", "raw_problem": "Write a function to find whether all the given tuples have equal length or not.", "raw_solution": "```python\n\ndef mbpp_run1(Input):\n  return len(set(len(item) for item in Input)) == 1\n\n ```", "raw_test_input": ["assert mbpp_run1([(11, 22, 33), (44, 55, 66)]) == True", "assert mbpp_run1([(1, 2, 3), (4, 5, 6, 7)]) == False", "assert mbpp_run1([(1, 2), (3, 4)]) == True"], "new_problem": "Enhance the function to determine if all given tuples have equal length, with an optional parameter to specify a minimum length that all tuples must meet. The function should maintain backward compatibility with existing implementations.", "new_solution": "from typing import List, Tuple, Optional\n\ndef mbpp_run2(input: List[Tuple], min_length: Optional[int] = None) -> bool:\n    if min_length is not None:\n        if any(len(item) < min_length for item in input):\n            return False\n    return len(set(len(item) for item in input)) == 1", "input_format": "List[Tuple]", "output_format": "bool", "test_input": ["assert mbpp_run2([(1, 2), (3, 4)]) == True", "assert mbpp_run2([(1, 2), (3, 4, 5)]) == False", "assert mbpp_run2([(1, 2), (3, 4)], min_length=2) == True", "assert mbpp_run2([(1, 2), (3, 4)], min_length=3) == False", "assert mbpp_run2([(1, 2, 3), (4, 5, 6)], min_length=3) == True"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "Mbpp/70-3", "raw_problem": "Write a function to find whether all the given tuples have equal length or not.", "raw_solution": "```python\n\ndef mbpp_run1(Input):\n  return len(set(len(item) for item in Input)) == 1\n\n ```", "raw_test_input": ["assert mbpp_run1([(11, 22, 33), (44, 55, 66)]) == True", "assert mbpp_run1([(1, 2, 3), (4, 5, 6, 7)]) == False", "assert mbpp_run1([(1, 2), (3, 4)]) == True"], "new_problem": "Write a function to determine if all tuples across different categories in a dictionary have the same length. Each key in the dictionary represents a category, and its value is a list of tuples. The function should return True if all tuples in all categories have the same length, and False otherwise. Additionally, ensure that the function handles cases where some categories might be empty or contain no tuples.", "new_solution": "def mbpp_run2(data: dict[str, list[tuple]]) -> bool:\n    lengths = set()\n    for category, tuples in data.items():\n        for item in tuples:\n            lengths.add(len(item))\n    return len(lengths) == 1 if lengths else False", "input_format": "A dictionary where keys are strings representing categories and values are lists of tuples.", "output_format": "A boolean indicating whether all tuples across all categories have the same length.", "test_input": ["assert mbpp_run2({'fruits': [(1, 2), (3, 4)], 'vegetables': [(5, 6), (7, 8)]}) == True", "assert mbpp_run2({'fruits': [(1, 2), (3, 4, 5)], 'vegetables': [(5, 6), (7, 8)]}) == False", "assert mbpp_run2({'fruits': [], 'vegetables': [(5, 6), (7, 8)]}) == True", "assert mbpp_run2({'fruits': [(1, 2)], 'vegetables': []}) == True", "assert mbpp_run2({'fruits': [(1, 2)], 'vegetables': [(3, 4)], 'grains': [(5, 6)]}) == True"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "Mbpp/70-4", "raw_problem": "Write a function to find whether all the given tuples have equal length or not.", "raw_solution": "```python\n\ndef mbpp_run1(Input):\n  return len(set(len(item) for item in Input)) == 1\n\n ```", "raw_test_input": ["assert mbpp_run1([(11, 22, 33), (44, 55, 66)]) == True", "assert mbpp_run1([(1, 2, 3), (4, 5, 6, 7)]) == False", "assert mbpp_run1([(1, 2), (3, 4)]) == True"], "new_problem": "Write a function to determine if all given tuples have equal length. The function should handle the following errors: 1) Raise a ValueError if the input is not a list. 2) Raise a TypeError if any element in the list is not a tuple. 3) Raise a ValueError if the list is empty. 4) Provide meaningful error messages for each exception. Ensure that the function propagates errors appropriately.", "new_solution": "from typing import List, Tuple\n\nclass TupleLengthError(Exception):\n    pass\n\nclass NotAListError(TupleLengthError):\n    def __init__(self, message=\"Input must be a list.\"):\n        self.message = message\n        super().__init__(self.message)\n\nclass NotATupleError(TupleLengthError):\n    def __init__(self, message=\"All elements in the list must be tuples.\"):\n        self.message = message\n        super().__init__(self.message)\n\nclass EmptyListError(TupleLengthError):\n    def __init__(self, message=\"Input list cannot be empty.\"):\n        self.message = message\n        super().__init__(self.message)\n\ndef mbpp_run2(input_data: List[Tuple]) -> bool:\n    if not isinstance(input_data, list):\n        raise NotAListError()\n    if len(input_data) == 0:\n        raise EmptyListError()\n    for item in input_data:\n        if not isinstance(item, tuple):\n            raise NotATupleError()\n    return len(set(len(item) for item in input_data)) == 1\n", "input_format": "A list of tuples", "output_format": "Boolean indicating if all tuples have equal length", "test_input": ["assert mbpp_run2([(1, 2), (3, 4)]) == True", "assert mbpp_run2([(1, 2), (3, 4, 5)]) == False", "try:\n    mbpp_run2(\"not a list\")\nexcept NotAListError as e:\n    assert str(e) == \"Input must be a list.\"", "try:\n    mbpp_run2([])\nexcept EmptyListError as e:\n    assert str(e) == \"Input list cannot be empty.\"", "try:\n    mbpp_run2([(1, 2), [3, 4]])\nexcept NotATupleError as e:\n    assert str(e) == \"All elements in the list must be tuples.\""], "requirement_type": "PROMPT_ERROR_HANDLING"}
{"task_id": "Mbpp/71-1", "raw_problem": "Write a function to sort a list of elements.", "raw_solution": "```python\n\ndef mbpp_run1(nums):\n    n = len(nums)\n    gap = n\n    shrink = 1.3\n    swapped = True\n    while gap > 1 or swapped:\n        gap = int(gap / shrink)\n        if gap < 1:\n            gap = 1\n        swapped = False\n        for i in range(n - gap):\n            if nums[i] > nums[i + gap]:\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                swapped = True\n    return nums\n\n ```", "raw_test_input": ["assert mbpp_run1([5, 15, 37, 25, 79]) == [5, 15, 25, 37, 79]", "assert mbpp_run1([41, 32, 15, 19, 22]) == [15, 19, 22, 32, 41]", "assert mbpp_run1([99, 15, 13, 47]) == [13, 15, 47, 99]"], "new_problem": "You are tasked with developing a system for an e-commerce platform that sorts products based on their price and rating. The system should first sort the products by price in ascending order. If two products have the same price, they should be sorted by their rating in descending order. Use the provided comb_sort function to implement this sorting system.", "new_solution": "def comb_sort(nums, key_func=None, reverse=False):\n    n = len(nums)\n    gap = n\n    shrink = 1.3\n    swapped = True\n    while gap > 1 or swapped:\n        gap = int(gap / shrink)\n        if gap < 1:\n            gap = 1\n        swapped = False\n        for i in range(n - gap):\n            if key_func:\n                first = key_func(nums[i])\n                second = key_func(nums[i + gap])\n            else:\n                first = nums[i]\n                second = nums[i + gap]\n            if (first > second and not reverse) or (first < second and reverse):\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                swapped = True\n    return nums\n\ndef mbpp_run2(products):\n    # Sort by rating in descending order\n    products = comb_sort(products, key_func=lambda x: x['rating'], reverse=True)\n    # Sort by price in ascending order\n    products = comb_sort(products, key_func=lambda x: x['price'])\n    return [product['name'] for product in products]", "input_format": "A list of dictionaries, each representing a product with 'name', 'price', and 'rating'.", "output_format": "A list of product names sorted by price and then by rating.", "test_input": ["assert mbpp_run2([{'name': 'Product A', 'price': 10, 'rating': 4.5}, {'name': 'Product B', 'price': 20, 'rating': 4.7}, {'name': 'Product C', 'price': 10, 'rating': 4.8}]) == ['Product C', 'Product A', 'Product B']", "assert mbpp_run2([{'name': 'Product A', 'price': 15, 'rating': 4.5}, {'name': 'Product B', 'price': 15, 'rating': 4.6}, {'name': 'Product C', 'price': 10, 'rating': 4.8}]) == ['Product C', 'Product B', 'Product A']", "assert mbpp_run2([{'name': 'Product A', 'price': 5, 'rating': 4.5}, {'name': 'Product B', 'price': 5, 'rating': 4.5}, {'name': 'Product C', 'price': 5, 'rating': 4.5}]) == ['Product A', 'Product B', 'Product C']", "assert mbpp_run2([{'name': 'Product A', 'price': 20, 'rating': 4.0}, {'name': 'Product B', 'price': 10, 'rating': 4.0}, {'name': 'Product C', 'price': 15, 'rating': 4.0}]) == ['Product B', 'Product C', 'Product A']", "assert mbpp_run2([{'name': 'Product A', 'price': 10, 'rating': 5.0}, {'name': 'Product B', 'price': 10, 'rating': 4.0}, {'name': 'Product C', 'price': 10, 'rating': 3.0}]) == ['Product A', 'Product B', 'Product C']"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "Mbpp/71-2", "raw_problem": "Write a function to sort a list of elements.", "raw_solution": "```python\n\ndef mbpp_run1(nums):\n    n = len(nums)\n    gap = n\n    shrink = 1.3\n    swapped = True\n    while gap > 1 or swapped:\n        gap = int(gap / shrink)\n        if gap < 1:\n            gap = 1\n        swapped = False\n        for i in range(n - gap):\n            if nums[i] > nums[i + gap]:\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                swapped = True\n    return nums\n\n ```", "raw_test_input": ["assert mbpp_run1([5, 15, 37, 25, 79]) == [5, 15, 25, 37, 79]", "assert mbpp_run1([41, 32, 15, 19, 22]) == [15, 19, 22, 32, 41]", "assert mbpp_run1([99, 15, 13, 47]) == [13, 15, 47, 99]"], "new_problem": "Enhance the existing comb_sort function to support sorting in both ascending and descending order, and allow a custom comparison function. The function should maintain backward compatibility with existing implementations.", "new_solution": "def mbpp_run2(nums: list[int], ascending: bool = True, compare_func: callable = None) -> list[int]:\n    def default_compare(x, y):\n        return x > y if ascending else x < y\n\n    compare = compare_func if compare_func else default_compare\n\n    n = len(nums)\n    gap = n\n    shrink = 1.3\n    swapped = True\n    while gap > 1 or swapped:\n        gap = int(gap / shrink)\n        if gap < 1:\n            gap = 1\n        swapped = False\n        for i in range(n - gap):\n            if compare(nums[i], nums[i + gap]):\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                swapped = True\n    return nums", "input_format": "A list of numbers and optional parameters for sorting order and a custom comparison function.", "output_format": "A sorted list of numbers.", "test_input": ["assert mbpp_run2([4, 3, 2, 1]) == [1, 2, 3, 4]", "assert mbpp_run2([4, 3, 2, 1], ascending=False) == [4, 3, 2, 1]", "assert mbpp_run2([1, 2, 3, 4], ascending=False) == [4, 3, 2, 1]", "assert mbpp_run2([4, 3, 2, 1], compare_func=lambda x, y: x < y) == [4, 3, 2, 1]", "assert mbpp_run2([1, 3, 2, 4], compare_func=lambda x, y: x > y) == [1, 2, 3, 4]"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "Mbpp/71-3", "raw_problem": "Write a function to sort a list of elements.", "raw_solution": "```python\n\ndef mbpp_run1(nums):\n    n = len(nums)\n    gap = n\n    shrink = 1.3\n    swapped = True\n    while gap > 1 or swapped:\n        gap = int(gap / shrink)\n        if gap < 1:\n            gap = 1\n        swapped = False\n        for i in range(n - gap):\n            if nums[i] > nums[i + gap]:\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                swapped = True\n    return nums\n\n ```", "raw_test_input": ["assert mbpp_run1([5, 15, 37, 25, 79]) == [5, 15, 25, 37, 79]", "assert mbpp_run1([41, 32, 15, 19, 22]) == [15, 19, 22, 32, 41]", "assert mbpp_run1([99, 15, 13, 47]) == [13, 15, 47, 99]"], "new_problem": "Write a function to sort the items within each category of a dictionary. Each category is represented by a key, and the items are stored in a list as values. The function should return a new dictionary with the same keys, but with each list of items sorted. Use the comb sort algorithm for sorting. Additionally, ensure that the function can handle dictionaries with up to 100 categories, each containing up to 1000 items.", "new_solution": "def comb_sort(nums: list[int]) -> list[int]:\n    n = len(nums)\n    gap = n\n    shrink = 1.3\n    swapped = True\n    while gap > 1 or swapped:\n        gap = int(gap / shrink)\n        if gap < 1:\n            gap = 1\n        swapped = False\n        for i in range(n - gap):\n            if nums[i] > nums[i + gap]:\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                swapped = True\n    return nums\n\ndef mbpp_run2(data: dict[str, list[int]]) -> dict[str, list[int]]:\n    sorted_data = {}\n    for category, items in data.items():\n        sorted_data[category] = comb_sort(items)\n    return sorted_data", "input_format": "A dictionary where keys are strings representing categories and values are lists of integers representing items in those categories.", "output_format": "A dictionary with the same keys, but each list of integers is sorted.", "test_input": ["assert mbpp_run2({'fruits': [5, 3, 8, 6], 'vegetables': [2, 9, 1, 4]}) == {'fruits': [3, 5, 6, 8], 'vegetables': [1, 2, 4, 9]}", "assert mbpp_run2({'numbers': [10, 7, 2, 5, 3]}) == {'numbers': [2, 3, 5, 7, 10]}", "assert mbpp_run2({'empty': []}) == {'empty': []}", "assert mbpp_run2({'single': [1]}) == {'single': [1]}", "assert mbpp_run2({'mixed': [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]}) == {'mixed': [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9]}"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "Mbpp/71-4", "raw_problem": "Write a function to sort a list of elements.", "raw_solution": "```python\n\ndef mbpp_run1(nums):\n    n = len(nums)\n    gap = n\n    shrink = 1.3\n    swapped = True\n    while gap > 1 or swapped:\n        gap = int(gap / shrink)\n        if gap < 1:\n            gap = 1\n        swapped = False\n        for i in range(n - gap):\n            if nums[i] > nums[i + gap]:\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                swapped = True\n    return nums\n\n ```", "raw_test_input": ["assert mbpp_run1([5, 15, 37, 25, 79]) == [5, 15, 25, 37, 79]", "assert mbpp_run1([41, 32, 15, 19, 22]) == [15, 19, 22, 32, 41]", "assert mbpp_run1([99, 15, 13, 47]) == [13, 15, 47, 99]"], "new_problem": "Write a function to sort a list of elements using comb sort. The function should handle the following errors: 1) TypeError if the input is not a list, 2) ValueError if the list contains non-numeric elements, 3) ValueError if the list is None. The function should propagate these errors with meaningful messages.", "new_solution": "class SortingError(Exception):\n    pass\n\nclass TypeError(SortingError):\n    pass\n\nclass ValueError(SortingError):\n    pass\n\ndef mbpp_run2(nums: list) -> list:\n    if nums is None:\n        raise ValueError('Input list cannot be None.')\n    if not isinstance(nums, list):\n        raise TypeError('Input must be a list.')\n    if not all(isinstance(x, (int, float)) for x in nums):\n        raise ValueError('All elements must be numeric.')\n\n    n = len(nums)\n    gap = n\n    shrink = 1.3\n    swapped = True\n    while gap > 1 or swapped:\n        gap = int(gap / shrink)\n        if gap < 1:\n            gap = 1\n        swapped = False\n        for i in range(n - gap):\n            if nums[i] > nums[i + gap]:\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                swapped = True\n    return nums\n", "input_format": "A list of elements to be sorted, which may include non-numeric types or be None.", "output_format": "A sorted list of elements or an appropriate error message.", "test_input": ["try:\n    mbpp_run2(None)\nexcept ValueError as e:\n    assert str(e) == 'Input list cannot be None.'", "try:\n    mbpp_run2('not a list')\nexcept TypeError as e:\n    assert str(e) == 'Input must be a list.'", "try:\n    mbpp_run2([1, 2, 'three', 4])\nexcept ValueError as e:\n    assert str(e) == 'All elements must be numeric.'", "assert mbpp_run2([3, 1, 2]) == [1, 2, 3]", "assert mbpp_run2([5.5, 2.2, 3.3, 1.1]) == [1.1, 2.2, 3.3, 5.5]"], "requirement_type": "PROMPT_ERROR_HANDLING"}
{"task_id": "Mbpp/72-1", "raw_problem": "Write a python function to check whether the given number can be represented as the difference of two squares or not.", "raw_solution": "```python\n\ndef mbpp_run1(n): \n    # see https://www.quora.com/Which-numbers-can-be-expressed-as-the-difference-of-two-squares\n    return n % 4 != 2\n\n ```", "raw_test_input": ["assert mbpp_run1(5) == True", "assert mbpp_run1(10) == False", "assert mbpp_run1(15) == True"], "new_problem": "In a financial system, transactions are considered valid if the transaction amount can be represented as the difference of two squares. Write a Python function that takes a list of transaction amounts and categorizes them into 'valid_transactions' and 'invalid_transactions' based on this criterion.", "new_solution": "def dif_Square(n):\n    return n % 4 != 2\n\ndef mbpp_run2(transactions):\n    valid_transactions = []\n    invalid_transactions = []\n    for amount in transactions:\n        if dif_Square(amount):\n            valid_transactions.append(amount)\n        else:\n            invalid_transactions.append(amount)\n    return {\n        'valid_transactions': valid_transactions,\n        'invalid_transactions': invalid_transactions\n    }", "input_format": "A list of integers representing transaction amounts.", "output_format": "A dictionary with keys 'valid_transactions' and 'invalid_transactions', each containing a list of transaction amounts.", "test_input": ["assert mbpp_run2([1, 2, 3, 4, 5]) == {'valid_transactions': [1, 3, 4, 5], 'invalid_transactions': [2]}", "assert mbpp_run2([10, 15, 20, 25, 30]) == {'valid_transactions': [15, 20, 25], 'invalid_transactions': [10, 30]}", "assert mbpp_run2([0, 8, 9, 12]) == {'valid_transactions': [0, 8, 9,12], 'invalid_transactions': []}", "assert mbpp_run2([7, 11, 13, 17, 19]) == {'valid_transactions': [7, 11, 13, 17, 19], 'invalid_transactions': []}", "assert mbpp_run2([2, 6, 10, 14, 18]) == {'valid_transactions': [], 'invalid_transactions': [2, 6, 10,14, 18]}"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "Mbpp/72-2", "raw_problem": "Write a python function to check whether the given number can be represented as the difference of two squares or not.", "raw_solution": "```python\n\ndef mbpp_run1(n): \n    # see https://www.quora.com/Which-numbers-can-be-expressed-as-the-difference-of-two-squares\n    return n % 4 != 2\n\n ```", "raw_test_input": ["assert mbpp_run1(5) == True", "assert mbpp_run1(10) == False", "assert mbpp_run1(15) == True"], "new_problem": "Enhance the existing function to check whether a given number can be represented as the difference of two squares, while maintaining backward compatibility. The function should now include an optional parameter 'verbose' that, when set to True, prints a message explaining the result. The function should still return a boolean indicating whether the number can be represented as the difference of two squares.", "new_solution": "def mbpp_run2(n: int, verbose: bool = False) -> bool:\n    result = n % 4 != 2\n    if verbose:\n        if result:\n            print(f\"{n} can be represented as the difference of two squares.\")\n        else:\n            print(f\"{n} cannot be represented as the difference of two squares.\")\n    return result", "input_format": "dif_Square(n: int, verbose: bool = False) -> bool", "output_format": "bool", "test_input": ["assert mbpp_run2(5) == True", "assert mbpp_run2(8) == True", "assert mbpp_run2(9, verbose=True) == True", "assert mbpp_run2(14, verbose=True) == False", "assert mbpp_run2(0) == True"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "Mbpp/72-3", "raw_problem": "Write a python function to check whether the given number can be represented as the difference of two squares or not.", "raw_solution": "```python\n\ndef mbpp_run1(n): \n    # see https://www.quora.com/Which-numbers-can-be-expressed-as-the-difference-of-two-squares\n    return n % 4 != 2\n\n ```", "raw_test_input": ["assert mbpp_run1(5) == True", "assert mbpp_run1(10) == False", "assert mbpp_run1(15) == True"], "new_problem": "Write a Python function that takes a list of tuples, where each tuple contains two integers. The function should return a dictionary where each key is the sum of the two integers in a tuple, and the value is a boolean indicating whether that sum can be represented as the difference of two squares. Use the original function to determine the boolean value, and ensure the solution handles the data using dictionaries.", "new_solution": "from typing import List, Tuple, Dict\n\ndef dif_Square(n: int) -> bool:\n    return n % 4 != 2\n\n\ndef mbpp_run2(pairs: List[Tuple[int, int]]) -> Dict[int, bool]:\n    result = {}\n    for a, b in pairs:\n        sum_ab = a + b\n        result[sum_ab] = dif_Square(sum_ab)\n    return result", "input_format": "List[Tuple[int, int]]", "output_format": "Dict[int, bool]", "test_input": ["assert mbpp_run2([(3, 5), (10, 2), (7, 1)]) == {8: True, 12: True, 8: True}", "assert mbpp_run2([(4, 4), (6, 6), (2, 2)]) == {8: True, 12: True, 4: True}", "assert mbpp_run2([(1, 1), (2, 3), (5, 5)]) == {2: False, 5: True, 10: False}", "assert mbpp_run2([(0, 0), (1, 0), (2, 0)]) == {0: True, 1: True, 2: False}", "assert mbpp_run2([(9, 1), (8, 2), (7, 3)]) == {10: False}"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "Mbpp/72-4", "raw_problem": "Write a python function to check whether the given number can be represented as the difference of two squares or not.", "raw_solution": "```python\n\ndef mbpp_run1(n): \n    # see https://www.quora.com/Which-numbers-can-be-expressed-as-the-difference-of-two-squares\n    return n % 4 != 2\n\n ```", "raw_test_input": ["assert mbpp_run1(5) == True", "assert mbpp_run1(10) == False", "assert mbpp_run1(15) == True"], "new_problem": "Write a Python function to check whether the given number can be represented as the difference of two squares or not. The function should handle the following errors: \n1. TypeError if the input is not an integer.\n2. ValueError if the input is a negative integer.\n3. Propagate any unexpected errors with a meaningful message.", "new_solution": "class DifferenceOfSquaresError(Exception):\n    pass\n\nclass InvalidTypeError(DifferenceOfSquaresError):\n    def __init__(self, message=\"Input must be an integer\"):\n        self.message = message\n        super().__init__(self.message)\n\nclass NegativeValueError(DifferenceOfSquaresError):\n    def __init__(self, message=\"Input must be a non-negative integer\"):\n        self.message = message\n        super().__init__(self.message)\n\ndef mbpp_run2(n: int) -> bool:\n    if not isinstance(n, int):\n        raise InvalidTypeError()\n    if n < 0:\n        raise NegativeValueError()\n    try:\n        return n % 4 != 2\n    except Exception as e:\n        raise DifferenceOfSquaresError(f\"An unexpected error occurred: {str(e)}\")", "input_format": "A single integer n", "output_format": "Boolean indicating if n can be represented as the difference of two squares", "test_input": ["assert mbpp_run2(5) == True", "assert mbpp_run2(2) == False", "try:\n    mbpp_run2(-1)\nexcept NegativeValueError as e:\n    assert str(e) == \"Input must be a non-negative integer\"", "try:\n    mbpp_run2(3.5)\nexcept InvalidTypeError as e:\n    assert str(e) == \"Input must be an integer\"", "try:\n    mbpp_run2(\"string\")\nexcept InvalidTypeError as e:\n    assert str(e) == \"Input must be an integer\""], "requirement_type": "PROMPT_ERROR_HANDLING"}
{"task_id": "Mbpp/74-1", "raw_problem": "Write a function to check whether it follows the sequence given in the patterns array.", "raw_solution": "```python\n\ndef mbpp_run1(colors, patterns):    \n    if len(colors) != len(patterns):\n        return False    \n    pattern_color_dict = {pattern: set() for pattern in patterns}\n    for color, pattern in zip(colors, patterns):\n        pattern_color_dict[pattern].add(color)\n    return all(len(pattern_color_dict[pattern]) == 1 for pattern in patterns)\n\n ```", "raw_test_input": ["assert mbpp_run1([\"red\",\"green\",\"green\"], [\"a\", \"b\", \"b\"])==True", "assert mbpp_run1([\"red\",\"green\",\"greenn\"], [\"a\",\"b\",\"b\"])==False", "assert mbpp_run1([\"red\",\"green\",\"greenn\"], [\"a\",\"b\"])==False"], "new_problem": "In an e-commerce platform, you are tasked with verifying if the items bought in each transaction follow a specific pattern. Each transaction consists of a list of items and a corresponding list of patterns. Write a function that uses the original pattern-checking function to determine if each transaction follows its respective pattern. Return a list of booleans where each boolean indicates whether the corresponding transaction follows the pattern.", "new_solution": "def is_samepatterns(colors, patterns):\n    if len(colors) != len(patterns):\n        return False\n    pattern_color_dict = {pattern: set() for pattern in patterns}\n    for color, pattern in zip(colors, patterns):\n        pattern_color_dict[pattern].add(color)\n    return all(len(pattern_color_dict[pattern]) == 1 for pattern in patterns)\n\ndef mbpp_run2(transactions):\n    results = []\n    for transaction in transactions:\n        items = transaction['items']\n        patterns = transaction['patterns']\n        result = is_samepatterns(items, patterns)\n        results.append(result)\n    return results", "input_format": "A list of transactions, where each transaction is a dictionary with 'items' (list of items bought) and 'patterns' (list of expected patterns).", "output_format": "A list of booleans indicating whether each transaction follows the expected patterns.", "test_input": ["assert mbpp_run2([{'items': ['apple', 'banana', 'apple'], 'patterns': ['A', 'B', 'A']}, {'items': ['apple', 'banana', 'banana'], 'patterns': ['A', 'B', 'A']}]) == [True, False]", "assert mbpp_run2([{'items': ['shirt', 'pants', 'shirt'], 'patterns': ['X', 'Y', 'X']}, {'items': ['shirt', 'pants', 'hat'], 'patterns': ['X', 'Y', 'Z']}]) == [True, True]", "assert mbpp_run2([{'items': ['pen', 'pencil', 'pen'], 'patterns': ['P', 'Q', 'P']}, {'items': ['pen', 'pencil', 'pencil'], 'patterns': ['P', 'Q', 'Q']}]) == [True, True]", "assert mbpp_run2([{'items': ['book', 'notebook', 'book'], 'patterns': ['B', 'N', 'B']}, {'items': ['book', 'notebook', 'notebook'], 'patterns': ['B', 'N', 'B']}]) == [True, False]", "assert mbpp_run2([{'items': ['car', 'bike', 'car'], 'patterns': ['C', 'B', 'C']}, {'items': ['car', 'bike', 'bike'], 'patterns': ['C', 'B', 'B']}]) == [True, True]"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "Mbpp/74-2", "raw_problem": "Write a function to check whether it follows the sequence given in the patterns array.", "raw_solution": "```python\n\ndef mbpp_run1(colors, patterns):    \n    if len(colors) != len(patterns):\n        return False    \n    pattern_color_dict = {pattern: set() for pattern in patterns}\n    for color, pattern in zip(colors, patterns):\n        pattern_color_dict[pattern].add(color)\n    return all(len(pattern_color_dict[pattern]) == 1 for pattern in patterns)\n\n ```", "raw_test_input": ["assert mbpp_run1([\"red\",\"green\",\"green\"], [\"a\", \"b\", \"b\"])==True", "assert mbpp_run1([\"red\",\"green\",\"greenn\"], [\"a\",\"b\",\"b\"])==False", "assert mbpp_run1([\"red\",\"green\",\"greenn\"], [\"a\",\"b\"])==False"], "new_problem": "Enhance the function to check whether a sequence of colors follows the sequence given in the patterns array, with additional options to ignore case sensitivity and allow pattern repetition. The function should maintain backward compatibility with existing implementations, support original function parameters, include type hints, and add new optional parameters.", "new_solution": "def mbpp_run2(colors: list[str], patterns: list[str], ignore_case: bool = False, allow_repetition: bool = False) -> bool:\n    if len(colors) != len(patterns):\n        return False\n    if ignore_case:\n        colors = [color.lower() for color in colors]\n        patterns = [pattern.lower() for pattern in patterns]\n    pattern_color_dict = {pattern: set() for pattern in patterns}\n    for color, pattern in zip(colors, patterns):\n        pattern_color_dict[pattern].add(color)\n    return all(len(pattern_color_dict[pattern]) == 1 for pattern in patterns)", "input_format": "A list of colors and a list of patterns, with optional parameters for case sensitivity and pattern repetition.", "output_format": "A boolean indicating whether the colors follow the sequence given in the patterns array.", "test_input": ["assert mbpp_run2(['red', 'blue', 'red'], ['a', 'b', 'a']) == True", "assert mbpp_run2(['red', 'blue', 'green'], ['a', 'b', 'a']) == False", "assert mbpp_run2(['Red', 'Blue', 'Red'], ['a', 'b', 'a'], ignore_case=True) == True", "assert mbpp_run2(['red', 'blue', 'red'], ['a', 'b', 'a'], allow_repetition=True) == True", "assert mbpp_run2(['red', 'blue', 'green'], ['a', 'b', 'a'], allow_repetition=True) == False"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "Mbpp/74-3", "raw_problem": "Write a function to check whether it follows the sequence given in the patterns array.", "raw_solution": "```python\n\ndef mbpp_run1(colors, patterns):    \n    if len(colors) != len(patterns):\n        return False    \n    pattern_color_dict = {pattern: set() for pattern in patterns}\n    for color, pattern in zip(colors, patterns):\n        pattern_color_dict[pattern].add(color)\n    return all(len(pattern_color_dict[pattern]) == 1 for pattern in patterns)\n\n ```", "raw_test_input": ["assert mbpp_run1([\"red\",\"green\",\"green\"], [\"a\", \"b\", \"b\"])==True", "assert mbpp_run1([\"red\",\"green\",\"greenn\"], [\"a\",\"b\",\"b\"])==False", "assert mbpp_run1([\"red\",\"green\",\"greenn\"], [\"a\",\"b\"])==False"], "new_problem": "Write a function to check whether each pattern in a given dictionary is associated with exactly one unique color. The input is a dictionary where keys are pattern names and values are lists of colors associated with each pattern. Ensure that the function uses a set to track unique colors for each pattern. Additionally, the function should handle cases where patterns have no associated colors and should return False if any pattern is associated with more than one unique color.", "new_solution": "def mbpp_run2(patterns: dict[str, list[str]]) -> bool:\n    for pattern, colors in patterns.items():\n        unique_colors = set(colors)\n        if len(unique_colors) != 1:\n            return False\n    return True", "input_format": "A dictionary where keys are pattern names and values are lists of colors associated with each pattern.", "output_format": "A boolean indicating whether each pattern is associated with exactly one unique color.", "test_input": ["assert mbpp_run2({'striped': ['red'], 'dotted': ['blue'], 'plain': ['green']}) == True", "assert mbpp_run2({'striped': ['red', 'red'], 'dotted': ['blue'], 'plain': ['green', 'green']}) == True", "assert mbpp_run2({'striped': ['red', 'blue'], 'dotted': ['blue'], 'plain': ['green']}) == False", "assert mbpp_run2({'striped': [], 'dotted': ['blue'], 'plain': ['green']}) == False", "assert mbpp_run2({'striped': ['red'], 'dotted': ['blue', 'blue'], 'plain': ['green', 'green', 'green']}) == True"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "Mbpp/74-4", "raw_problem": "Write a function to check whether it follows the sequence given in the patterns array.", "raw_solution": "```python\n\ndef mbpp_run1(colors, patterns):    \n    if len(colors) != len(patterns):\n        return False    \n    pattern_color_dict = {pattern: set() for pattern in patterns}\n    for color, pattern in zip(colors, patterns):\n        pattern_color_dict[pattern].add(color)\n    return all(len(pattern_color_dict[pattern]) == 1 for pattern in patterns)\n\n ```", "raw_test_input": ["assert mbpp_run1([\"red\",\"green\",\"green\"], [\"a\", \"b\", \"b\"])==True", "assert mbpp_run1([\"red\",\"green\",\"greenn\"], [\"a\",\"b\",\"b\"])==False", "assert mbpp_run1([\"red\",\"green\",\"greenn\"], [\"a\",\"b\"])==False"], "new_problem": "Write a function that checks if a list of colors follows a sequence given in a patterns array. The function should handle the following errors: 1) Raise a ValueError if the input lists are not of the same length. 2) Raise a TypeError if the inputs are not lists. 3) Raise a ValueError if any element in the lists is not a string. 4) Propagate errors with meaningful messages.", "new_solution": "from typing import List\n\nclass PatternError(Exception):\n    pass\n\nclass LengthMismatchError(PatternError):\n    def __init__(self, message=\"Colors and patterns must be of the same length.\"):\n        self.message = message\n        super().__init__(self.message)\n\nclass InvalidTypeError(PatternError):\n    def __init__(self, message=\"Both colors and patterns must be lists.\"):\n        self.message = message\n        super().__init__(self.message)\n\nclass InvalidElementError(PatternError):\n    def __init__(self, message=\"All elements in colors and patterns must be strings.\"):\n        self.message = message\n        super().__init__(self.message)\n\ndef mbpp_run2(colors: List[str], patterns: List[str]) -> bool:\n    if not isinstance(colors, list) or not isinstance(patterns, list):\n        raise InvalidTypeError()\n    if len(colors) != len(patterns):\n        raise LengthMismatchError()\n    if not all(isinstance(color, str) for color in colors) or not all(isinstance(pattern, str) for pattern in patterns):\n        raise InvalidElementError()\n    pattern_color_dict = {pattern: set() for pattern in patterns}\n    for color, pattern in zip(colors, patterns):\n        pattern_color_dict[pattern].add(color)\n    return all(len(pattern_color_dict[pattern]) == 1 for pattern in patterns)", "input_format": "A list of colors and a list of patterns", "output_format": "Boolean indicating if the colors follow the pattern sequence", "test_input": ["assert mbpp_run2(['red', 'blue', 'red'], ['a', 'b', 'a']) == True", "assert mbpp_run2(['red', 'blue', 'green'], ['a', 'b', 'a']) == False", "try:\n    mbpp_run2(['red', 'blue'], ['a', 'b', 'a'])\nexcept LengthMismatchError as e:\n    assert str(e) == 'Colors and patterns must be of the same length.'", "try:\n    mbpp_run2('red, blue', ['a', 'b'])\nexcept InvalidTypeError as e:\n    assert str(e) == 'Both colors and patterns must be lists.'", "try:\n    mbpp_run2(['red', 2, 'blue'], ['a', 'b', 'c'])\nexcept InvalidElementError as e:\n    assert str(e) == 'All elements in colors and patterns must be strings.'"], "requirement_type": "PROMPT_ERROR_HANDLING"}
{"task_id": "Mbpp/75-1", "raw_problem": "Write a function to find tuples which have all elements divisible by k from the given list of tuples.", "raw_solution": "```python\n\ndef mbpp_run1(test_list, K):\n  res = [sub for sub in test_list if all(ele % K == 0 for ele in sub)]\n  return res\n\n ```", "raw_test_input": ["assert mbpp_run1([(6, 24, 12), (7, 9, 6), (12, 18, 21)], 6) == [(6, 24, 12)]", "assert mbpp_run1([(5, 25, 30), (4, 2, 3), (7, 8, 9)], 5) == [(5, 25, 30)]", "assert mbpp_run1([(7, 9, 16), (8, 16, 4), (19, 17, 18)], 4) == [(8, 16, 4)]"], "new_problem": "In a financial application, you are given a list of transactions where each transaction is represented as a tuple of amounts in different currencies. You need to filter out transactions where all amounts are divisible by a given currency conversion factor k. Use the original function to identify such transactions and return them. This can help in identifying transactions that are cleanly divisible by a standard conversion rate, which might be useful for auditing or reporting purposes.", "new_solution": "def find_tuples(test_list, K):\n    res = [sub for sub in test_list if all(ele % K == 0 for ele in sub)]\n    return res\n\ndef mbpp_run2(transactions, conversion_factor):\n    return find_tuples(transactions, conversion_factor)\n", "input_format": "A list of transactions where each transaction is a tuple of integers representing amounts in different currencies, and an integer k representing a currency conversion factor.", "output_format": "A list of transactions where all amounts are divisible by the conversion factor k.", "test_input": ["assert mbpp_run2([(100, 200, 300), (150, 250, 350), (120, 240, 360)], 100) == [(100, 200, 300)]", "assert mbpp_run2([(50, 100, 150), (60, 120, 180), (70, 140, 210)], 50) == [(50, 100, 150)]", "assert mbpp_run2([(10, 20, 30), (15, 25, 35), (20, 40, 60)], 10) == [(10, 20, 30), (20, 40, 60)]", "assert mbpp_run2([(5, 10, 15), (6, 12, 18), (7, 14, 21)], 5) == [(5, 10, 15)]", "assert mbpp_run2([(200, 400, 600), (300, 600, 900), (250, 500, 750)], 200) == [(200, 400, 600)]"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "Mbpp/75-2", "raw_problem": "Write a function to find tuples which have all elements divisible by k from the given list of tuples.", "raw_solution": "```python\n\ndef mbpp_run1(test_list, K):\n  res = [sub for sub in test_list if all(ele % K == 0 for ele in sub)]\n  return res\n\n ```", "raw_test_input": ["assert mbpp_run1([(6, 24, 12), (7, 9, 6), (12, 18, 21)], 6) == [(6, 24, 12)]", "assert mbpp_run1([(5, 25, 30), (4, 2, 3), (7, 8, 9)], 5) == [(5, 25, 30)]", "assert mbpp_run1([(7, 9, 16), (8, 16, 4), (19, 17, 18)], 4) == [(8, 16, 4)]"], "new_problem": "Enhance the function to find tuples with all elements divisible by K from a given list of tuples. The function should maintain backward compatibility but also support new optional parameters: 'strict', a boolean that when set to True, requires all elements to be strictly greater than K, and 'exclude', a list of tuples to be excluded from the result.", "new_solution": "def mbpp_run2(test_list: list[tuple], K: int, strict: bool = False, exclude: list[tuple] = None) -> list[tuple]:\n    if exclude is None:\n        exclude = []\n    res = [sub for sub in test_list if sub not in exclude and all(ele % K == 0 and (not strict or ele > K) for ele in sub)]\n    return res", "input_format": "A list of tuples and an integer K, with optional parameters: a boolean 'strict' and a list 'exclude'.", "output_format": "A list of tuples where each tuple's elements are divisible by K, optionally excluding certain tuples or applying strict divisibility.", "test_input": ["assert mbpp_run2([(6, 12), (5, 10), (15, 30)], 3) == [(6, 12), (15, 30)]", "assert mbpp_run2([(6, 12), (5, 10), (15, 30)], 3, strict=True) == [(6, 12),(15, 30)]", "assert mbpp_run2([(6, 12), (5, 10), (15, 30)], 5, exclude=[(5, 10)]) == [(15, 30)]", "assert mbpp_run2([(6, 12), (5, 10), (15, 30)], 5, strict=True, exclude=[(15, 30)]) == []", "assert mbpp_run2([(6, 12), (5, 10), (15, 30)], 1) == [(6, 12), (5, 10), (15, 30)]"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "Mbpp/75-3", "raw_problem": "Write a function to find tuples which have all elements divisible by k from the given list of tuples.", "raw_solution": "```python\n\ndef mbpp_run1(test_list, K):\n  res = [sub for sub in test_list if all(ele % K == 0 for ele in sub)]\n  return res\n\n ```", "raw_test_input": ["assert mbpp_run1([(6, 24, 12), (7, 9, 6), (12, 18, 21)], 6) == [(6, 24, 12)]", "assert mbpp_run1([(5, 25, 30), (4, 2, 3), (7, 8, 9)], 5) == [(5, 25, 30)]", "assert mbpp_run1([(7, 9, 16), (8, 16, 4), (19, 17, 18)], 4) == [(8, 16, 4)]"], "new_problem": "Write a function to filter tuples from a dictionary where each key maps to a list of tuples. Each tuple should have all elements divisible by a given integer K. The function should return a new dictionary with the same keys, but only include tuples that meet the divisibility condition. Additionally, ensure that the function can handle cases where some categories might not have any tuples that meet the condition.", "new_solution": "from typing import Dict, List, Tuple\n\ndef mbpp_run2(test_dict: Dict[str, List[Tuple[int, ...]]], K: int) -> Dict[str, List[Tuple[int, ...]]]:\n    res = {}\n    for key, tuples in test_dict.items():\n        filtered_tuples = [sub for sub in tuples if all(ele % K == 0 for ele in sub)]\n        if filtered_tuples:\n            res[key] = filtered_tuples\n    return res\n", "input_format": "A dictionary where keys are strings representing categories and values are lists of tuples. Each tuple contains integers.", "output_format": "A dictionary with the same keys, but values are lists of tuples where all elements are divisible by a given integer K.", "test_input": ["assert mbpp_run2({'category1': [(6, 12), (8, 16)], 'category2': [(10, 20), (15, 25)]}, 2) == {'category1': [(6, 12), (8, 16)], 'category2': [(10, 20)]}", "assert mbpp_run2({'category1': [(3, 6), (9, 12)], 'category2': [(5, 10), (15, 20)]}, 3) == {'category1': [(3, 6), (9, 12)]}", "assert mbpp_run2({'category1': [(4, 8), (12, 16)], 'category2': [(7, 14), (21, 28)]}, 4) == {'category1': [(4, 8), (12, 16)]}", "assert mbpp_run2({'category1': [(2, 4), (6, 8)], 'category2': [(3, 6), (9, 12)]}, 5) == {}", "assert mbpp_run2({'category1': [(10, 20), (30, 40)], 'category2': [(50, 60), (70, 80)]}, 10) == {'category1': [(10, 20), (30, 40)], 'category2': [(50, 60), (70, 80)]}"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "Mbpp/75-4", "raw_problem": "Write a function to find tuples which have all elements divisible by k from the given list of tuples.", "raw_solution": "```python\n\ndef mbpp_run1(test_list, K):\n  res = [sub for sub in test_list if all(ele % K == 0 for ele in sub)]\n  return res\n\n ```", "raw_test_input": ["assert mbpp_run1([(6, 24, 12), (7, 9, 6), (12, 18, 21)], 6) == [(6, 24, 12)]", "assert mbpp_run1([(5, 25, 30), (4, 2, 3), (7, 8, 9)], 5) == [(5, 25, 30)]", "assert mbpp_run1([(7, 9, 16), (8, 16, 4), (19, 17, 18)], 4) == [(8, 16, 4)]"], "new_problem": "Write a function to find tuples which have all elements divisible by K from the given list of tuples. The function should handle the following errors: 1) TypeError if the input is not a list of tuples or if K is not an integer. 2) ValueError if any tuple contains non-integer elements. 3) ZeroDivisionError if K is zero. The function should propagate meaningful error messages.", "new_solution": "from typing import List, Tuple\n\nclass InvalidInputError(Exception):\n    pass\n\nclass NonIntegerElementError(Exception):\n    pass\n\ndef mbpp_run2(test_list: List[Tuple[int, ...]], K: int) -> List[Tuple[int, ...]]:\n    if not isinstance(test_list, list) or not all(isinstance(t, tuple) for t in test_list):\n        raise InvalidInputError('Input must be a list of tuples.')\n    if not isinstance(K, int):\n        raise InvalidInputError('K must be an integer.')\n    if K == 0:\n        raise ZeroDivisionError('K cannot be zero.')\n    for t in test_list:\n        if not all(isinstance(ele, int) for ele in t):\n            raise NonIntegerElementError('All elements in tuples must be integers.')\n    res = [sub for sub in test_list if all(ele % K == 0 for ele in sub)]\n    return res", "input_format": "A list of tuples and an integer K", "output_format": "A list of tuples where all elements are divisible by K", "test_input": ["assert mbpp_run2([(6, 12), (15, 30), (10, 20)], 3) == [(6, 12), (15, 30)]", "try:\n    mbpp_run2([(6, 12), (15, '30'), (10, 20)], 3)\nexcept NonIntegerElementError as e:\n    assert str(e) == 'All elements in tuples must be integers.'", "try:\n    mbpp_run2('not a list', 3)\nexcept InvalidInputError as e:\n    assert str(e) == 'Input must be a list of tuples.'", "try:\n    mbpp_run2([(6, 12), (15, 30)], '3')\nexcept InvalidInputError as e:\n    assert str(e) == 'K must be an integer.'", "try:\n    mbpp_run2([(6, 12), (15, 30)], 0)\nexcept ZeroDivisionError as e:\n    assert str(e) == 'K cannot be zero.'"], "requirement_type": "PROMPT_ERROR_HANDLING"}
{"task_id": "Mbpp/77-1", "raw_problem": "Write a python function to find whether a number is divisible by 11.", "raw_solution": "```python\n\ndef mbpp_run1(n): \n    return n % 11 == 0 \n\n ```", "raw_test_input": ["assert mbpp_run1 (12345) == False", "assert mbpp_run1(1212112) == True", "assert mbpp_run1(1212) == False"], "new_problem": "In a financial application, you are given a list of transactions. Each transaction is represented as a dictionary with 'amount' and 'description' keys. Write a Python function that filters out transactions where the 'amount' is divisible by 11. Use the original function to determine divisibility.", "new_solution": "def is_Diff(n):\n    return n % 11 == 0\n\ndef mbpp_run2(transactions):\n    return [transaction for transaction in transactions if is_Diff(transaction['amount'])]", "input_format": "A list of transactions where each transaction is a dictionary with 'amount' and 'description' keys.", "output_format": "A list of transactions that are divisible by 11.", "test_input": ["assert mbpp_run2([{'amount': 22, 'description': 'Payment A'}, {'amount': 33, 'description': 'Payment B'}, {'amount': 10, 'description': 'Payment C'}]) == [{'amount': 22, 'description': 'Payment A'}, {'amount': 33, 'description': 'Payment B'}]", "assert mbpp_run2([{'amount': 11, 'description': 'Payment D'}, {'amount': 44, 'description': 'Payment E'}, {'amount': 55, 'description': 'Payment F'}]) == [{'amount': 11, 'description': 'Payment D'}, {'amount': 44, 'description': 'Payment E'}, {'amount': 55, 'description': 'Payment F'}]", "assert mbpp_run2([{'amount': 1, 'description': 'Payment G'}, {'amount': 2, 'description': 'Payment H'}, {'amount': 3, 'description': 'Payment I'}]) == []", "assert mbpp_run2([{'amount': 121, 'description': 'Payment J'}, {'amount': 132, 'description': 'Payment K'}, {'amount': 143, 'description': 'Payment L'}]) == [{'amount': 121, 'description': 'Payment J'}, {'amount': 132, 'description': 'Payment K'},{'amount': 143, 'description': 'Payment L'}]", "assert mbpp_run2([{'amount': 0, 'description': 'Payment M'}, {'amount': 11, 'description': 'Payment N'}, {'amount': 22, 'description': 'Payment O'}]) == [{'amount': 0, 'description': 'Payment M'}, {'amount': 11, 'description': 'Payment N'}, {'amount': 22, 'description': 'Payment O'}]"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "Mbpp/77-2", "raw_problem": "Write a python function to find whether a number is divisible by 11.", "raw_solution": "```python\n\ndef mbpp_run1(n): \n    return n % 11 == 0 \n\n ```", "raw_test_input": ["assert mbpp_run1 (12345) == False", "assert mbpp_run1(1212112) == True", "assert mbpp_run1(1212) == False"], "new_problem": "Enhance the function to determine if a number is divisible by 11 by adding an optional parameter 'verbose'. If 'verbose' is set to True, the function should print a message indicating whether the number is divisible by 11. Ensure the function maintains backward compatibility with existing implementations.", "new_solution": "def is_Diff(n: int) -> bool:\n    return n % 11 == 0\n\ndef mbpp_run2(n: int, verbose: bool = False) -> bool:\n    result = is_Diff(n)\n    if verbose:\n        if result:\n            print(f\"{n} is divisible by 11.\")\n        else:\n            print(f\"{n} is not divisible by 11.\")\n    return result", "input_format": "is_divisible_by_11(n: int, verbose: bool = False) -> bool", "output_format": "bool", "test_input": ["assert mbpp_run2(22) == True", "assert mbpp_run2(23) == False", "assert mbpp_run2(33, verbose=True) == True", "assert mbpp_run2(44, verbose=False) == True", "assert mbpp_run2(45, verbose=True) == False"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "Mbpp/77-3", "raw_problem": "Write a python function to find whether a number is divisible by 11.", "raw_solution": "```python\n\ndef mbpp_run1(n): \n    return n % 11 == 0 \n\n ```", "raw_test_input": ["assert mbpp_run1 (12345) == False", "assert mbpp_run1(1212112) == True", "assert mbpp_run1(1212) == False"], "new_problem": "Write a Python function that takes a dictionary where keys are item names and values are their quantities. The function should return a list of item names whose quantities are divisible by 11. Use type hints and ensure the function can handle large dictionaries efficiently.", "new_solution": "def is_Diff(n: int) -> bool:\n    return n % 11 == 0\n\ndef mbpp_run2(items: dict[str, int]) -> list[str]:\n    return [item for item, quantity in items.items() if is_Diff(quantity)]", "input_format": "A dictionary where keys are strings representing item names and values are integers representing quantities.", "output_format": "A list of item names that have quantities divisible by 11.", "test_input": ["assert mbpp_run2({'apple': 22, 'banana': 33, 'cherry': 10}) == ['apple', 'banana']", "assert mbpp_run2({'notebook': 11, 'pen': 5, 'eraser': 44}) == ['notebook', 'eraser']", "assert mbpp_run2({'shirt': 21, 'pants': 32, 'hat': 55}) == ['hat']", "assert mbpp_run2({'book': 0, 'lamp': 11, 'table': 23}) == ['book', 'lamp']", "assert mbpp_run2({'car': 110, 'bike': 99, 'scooter': 88}) == ['car', 'bike','scooter']"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "Mbpp/77-4", "raw_problem": "Write a python function to find whether a number is divisible by 11.", "raw_solution": "```python\n\ndef mbpp_run1(n): \n    return n % 11 == 0 \n\n ```", "raw_test_input": ["assert mbpp_run1 (12345) == False", "assert mbpp_run1(1212112) == True", "assert mbpp_run1(1212) == False"], "new_problem": "Write a Python function to determine if a given input is divisible by 11. The function should handle the following errors: 1) Input is not a number (raise a ValueError with a meaningful message). 2) Input is a negative number (raise a ValueError with a meaningful message). 3) Input is None (raise a TypeError with a meaningful message). Ensure that the function propagates errors appropriately and uses type hints.", "new_solution": "def mbpp_run2(n: int) -> bool:\n    if n is None:\n        raise TypeError('Input cannot be None')\n    if not isinstance(n, (int, str)):\n        raise ValueError('Input must be an integer or a string representing a number')\n    try:\n        number = int(n)\n    except ValueError:\n        raise ValueError('Input string must be convertible to an integer')\n    if number < 0:\n        raise ValueError('Input must be a non-negative integer')\n    return number % 11 == 0", "input_format": "A single integer or a string representing a number", "output_format": "Boolean indicating if the number is divisible by 11", "test_input": ["assert mbpp_run2(22) == True", "assert mbpp_run2('33') == True", "try:\n    mbpp_run2(-11)\nexcept ValueError as e:\n    assert str(e) == 'Input must be a non-negative integer'", "try:\n    mbpp_run2('abc')\nexcept ValueError as e:\n    assert str(e) == 'Input string must be convertible to an integer'", "try:\n    mbpp_run2(None)\nexcept TypeError as e:\n    assert str(e) == 'Input cannot be None'"], "requirement_type": "PROMPT_ERROR_HANDLING"}
{"task_id": "Mbpp/79-1", "raw_problem": "Write a python function to check whether the length of the word is odd or not.", "raw_solution": "```python\n\ndef mbpp_run1(s): \n    return len(s) % 2 == 1\n\n ```", "raw_test_input": ["assert mbpp_run1(\"Hadoop\") == False", "assert mbpp_run1(\"great\") == True", "assert mbpp_run1(\"structure\") == True"], "new_problem": "In an e-commerce platform, you are tasked with analyzing product descriptions to determine if their lengths are odd. Write a Python function that takes a dictionary where keys are product names and values are their descriptions. Use the original function to check if the length of each description is odd, and return a new dictionary with product names as keys and a boolean indicating if the description length is odd as values.", "new_solution": "def word_len(s):\n    return len(s) % 2 == 1\n\ndef mbpp_run2(products):\n    result = {}\n    for product, description in products.items():\n        result[product] = word_len(description)\n    return result", "input_format": "A list of product names and their descriptions in a dictionary format.", "output_format": "A dictionary with product names as keys and a boolean indicating if the description length is odd as values.", "test_input": ["assert mbpp_run2({'Laptop': 'A high-performance laptop', 'Phone': 'Latest model smartphone'}) == {'Laptop': True, 'Phone': True}", "assert mbpp_run2({'Book': 'A thrilling mystery novel', 'Pen': 'Smooth writing pen'}) == {'Book': True, 'Pen': False}", "assert mbpp_run2({'Table': 'Wooden dining table', 'Chair': 'Comfortable office chair'}) == {'Table': True, 'Chair': False}", "assert mbpp_run2({'Watch': 'Luxury wristwatch', 'Shoes': 'Running shoes'}) == {'Watch': True, 'Shoes': True}", "assert mbpp_run2({'Bag': 'Leather backpack', 'Bottle': 'Insulated water bottle'}) == {'Bag': False, 'Bottle': False}"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "Mbpp/79-2", "raw_problem": "Write a python function to check whether the length of the word is odd or not.", "raw_solution": "```python\n\ndef mbpp_run1(s): \n    return len(s) % 2 == 1\n\n ```", "raw_test_input": ["assert mbpp_run1(\"Hadoop\") == False", "assert mbpp_run1(\"great\") == True", "assert mbpp_run1(\"structure\") == True"], "new_problem": "Enhance the existing function to check whether the length of the word is odd or not, with an additional optional parameter 'min_length'. If 'min_length' is provided, the function should also check if the word's length is greater than or equal to 'min_length'. The function should maintain backward compatibility with the original implementation.", "new_solution": "from typing import Optional\n\ndef mbpp_run2(s: str, min_length: Optional[int] = None) -> bool:\n    if min_length is not None:\n        return len(s) % 2 == 1 and len(s) >= min_length\n    return len(s) % 2 == 1", "input_format": "word_len(s: str, min_length: Optional[int] = None) -> bool", "output_format": "bool", "test_input": ["assert mbpp_run2('hello') == True", "assert mbpp_run2('hello', min_length=5) == True", "assert mbpp_run2('hello', min_length=6) == False", "assert mbpp_run2('world') == True", "assert mbpp_run2('world', min_length=4) == True"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "Mbpp/79-3", "raw_problem": "Write a python function to check whether the length of the word is odd or not.", "raw_solution": "```python\n\ndef mbpp_run1(s): \n    return len(s) % 2 == 1\n\n ```", "raw_test_input": ["assert mbpp_run1(\"Hadoop\") == False", "assert mbpp_run1(\"great\") == True", "assert mbpp_run1(\"structure\") == True"], "new_problem": "Write a Python function that takes a list of dictionaries, where each dictionary contains a single key-value pair representing a word. The function should return a dictionary where each key is the word and the value is a boolean indicating whether the length of the word is odd. Use type hints and ensure the function can handle a list of up to 1000 words.", "new_solution": "from typing import List, Dict\n\ndef word_len(s: str) -> bool:\n    return len(s) % 2 == 1\n\n\ndef mbpp_run2(words: List[Dict[str, str]]) -> Dict[str, bool]:\n    result = {}\n    for word_dict in words:\n        for word in word_dict.values():\n            result[word] = word_len(word)\n    return result\n", "input_format": "List[Dict[str, str]]", "output_format": "Dict[str, bool]", "test_input": ["assert mbpp_run2([{ 'word1': 'hello' }, { 'word2': 'world' }]) == {'hello': True, 'world': True}", "assert mbpp_run2([{ 'word1': 'python' }, { 'word2': 'java' }]) == {'python': False, 'java': False}", "assert mbpp_run2([{ 'word1': 'odd' }, { 'word2': 'even' }]) == {'odd': True, 'even': False}", "assert mbpp_run2([{ 'word1': 'test' }, { 'word2': 'case' }]) == {'test': False, 'case': False}", "assert mbpp_run2([{ 'word1': 'single' }]) == {'single': False}"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "Mbpp/79-4", "raw_problem": "Write a python function to check whether the length of the word is odd or not.", "raw_solution": "```python\n\ndef mbpp_run1(s): \n    return len(s) % 2 == 1\n\n ```", "raw_test_input": ["assert mbpp_run1(\"Hadoop\") == False", "assert mbpp_run1(\"great\") == True", "assert mbpp_run1(\"structure\") == True"], "new_problem": "Write a Python function to check whether the length of a word is odd. The function should handle the following errors: 1) If the input is not a string, raise a TypeError with a meaningful message. 2) If the input string is empty, raise a ValueError with a message indicating that the word cannot be empty. 3) Propagate any unexpected exceptions with a custom error message.", "new_solution": "class WordLengthError(Exception):\n    pass\n\nclass EmptyWordError(WordLengthError):\n    pass\n\nclass InvalidTypeError(WordLengthError):\n    pass\n\ndef mbpp_run2(s: str) -> bool:\n    try:\n        if not isinstance(s, str):\n            raise InvalidTypeError('Input must be a string.')\n        if len(s) == 0:\n            raise EmptyWordError('Word cannot be empty.')\n        return len(s) % 2 == 1\n    except (InvalidTypeError, EmptyWordError) as e:\n        raise e\n    except Exception as e:\n        raise WordLengthError('An unexpected error occurred.') from e", "input_format": "A string input representing a word.", "output_format": "A boolean indicating whether the length of the word is odd.", "test_input": ["assert mbpp_run2('hello') == True", "assert mbpp_run2('world') == True", "try:\n    mbpp_run2(123)\nexcept InvalidTypeError as e:\n    assert str(e) == 'Input must be a string.'", "try:\n    mbpp_run2('')\nexcept EmptyWordError as e:\n    assert str(e) == 'Word cannot be empty.'", "try:\n    mbpp_run2(None)\nexcept InvalidTypeError as e:\n    assert str(e) == 'Input must be a string.'"], "requirement_type": "PROMPT_ERROR_HANDLING"}
{"task_id": "Mbpp/80-1", "raw_problem": "Write a function to find the nth tetrahedral number.", "raw_solution": "```python\n\ndef mbpp_run1(n): \n\treturn (n * (n + 1) * (n + 2)) / 6\n\n ```", "raw_test_input": ["assert mbpp_run1(5) == 35", "assert mbpp_run1(6) == 56", "assert mbpp_run1(7) == 84"], "new_problem": "In a supply chain management system, each product category has a different number of levels in its supply chain. Each level requires a certain number of items, which can be represented by a tetrahedral number. Write a function that calculates the total number of items needed for each product category based on its supply chain levels. Use the tetrahedral number function to determine the number of items required at each level.", "new_solution": "def tetrahedral_number(n):\n    return (n * (n + 1) * (n + 2)) // 6\n\ndef mbpp_run2(categories):\n    total_items = {}\n    for category, levels in categories:\n        total_items[category] = sum(tetrahedral_number(level) for level in range(1, levels + 1))\n    return total_items", "input_format": "A list of tuples where each tuple contains a string representing a product category and an integer representing the number of levels in the supply chain.", "output_format": "A dictionary where keys are product categories and values are the total number of items needed to fulfill the supply chain requirements for each category.", "test_input": ["assert mbpp_run2([('Electronics', 3), ('Furniture', 2)]) == {'Electronics': 15, 'Furniture': 5}", "assert mbpp_run2([('Toys', 4)]) == {'Toys': 35}", "assert mbpp_run2([('Books', 1), ('Clothing', 5)]) == {'Books': 1, 'Clothing': 70}", "assert mbpp_run2([('Groceries', 0)]) == {'Groceries': 0}", "assert mbpp_run2([('Appliances', 6)]) == {'Appliances': 126}"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "Mbpp/80-2", "raw_problem": "Write a function to find the nth tetrahedral number.", "raw_solution": "```python\n\ndef mbpp_run1(n): \n\treturn (n * (n + 1) * (n + 2)) / 6\n\n ```", "raw_test_input": ["assert mbpp_run1(5) == 35", "assert mbpp_run1(6) == 56", "assert mbpp_run1(7) == 84"], "new_problem": "Enhance the function to find the nth tetrahedral number by adding an optional parameter 'detailed'. If 'detailed' is set to True, the function should return a tuple containing the tetrahedral number and a string explaining the calculation. Ensure the function maintains backward compatibility with existing implementations.", "new_solution": "from typing import Union, Tuple\n\ndef mbpp_run2(n: int, detailed: bool = False) -> Union[int, Tuple[int, str]]:\n    result = (n * (n + 1) * (n + 2)) // 6\n    if detailed:\n        explanation = f'The {n}th tetrahedral number is calculated as (n * (n + 1) * (n + 2)) / 6 = {result}'\n        return result, explanation\n    return result", "input_format": "tetrahedral_number(n: int, detailed: bool = False) -> Union[int, Tuple[int, str]]", "output_format": "int if detailed is False, otherwise Tuple[int, str]", "test_input": ["assert mbpp_run2(1) == 1", "assert mbpp_run2(2) == 4", "assert mbpp_run2(3) == 10", "assert mbpp_run2(4, detailed=True) == (20, 'The 4th tetrahedral number is calculated as (n * (n + 1) * (n + 2)) / 6 = 20')", "assert mbpp_run2(5, detailed=True) == (35, 'The 5th tetrahedral number is calculated as (n * (n + 1) * (n + 2)) / 6 = 35')"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "Mbpp/80-3", "raw_problem": "Write a function to find the nth tetrahedral number.", "raw_solution": "```python\n\ndef mbpp_run1(n): \n\treturn (n * (n + 1) * (n + 2)) / 6\n\n ```", "raw_test_input": ["assert mbpp_run1(5) == 35", "assert mbpp_run1(6) == 56", "assert mbpp_run1(7) == 84"], "new_problem": "Given a list of tuples where each tuple contains two integers (n, m), write a function to compute the nth tetrahedral number for each tuple and store the result in a dictionary where the key is n and the value is the nth tetrahedral number. Ensure that the function uses dictionaries to store intermediate results for efficient computation. The function should include type hints and handle up to 1000 tuples efficiently.", "new_solution": "from typing import List, Tuple, Dict\n\ndef tetrahedral_number(n: int) -> int:\n    return (n * (n + 1) * (n + 2)) // 6\n\n\ndef mbpp_run2(pairs: List[Tuple[int, int]]) -> Dict[int, int]:\n    results = {}\n    for n, _ in pairs:\n        if n not in results:\n            results[n] = tetrahedral_number(n)\n    return results\n", "input_format": "List[Tuple[int, int]]", "output_format": "Dict[int, int]", "test_input": ["assert mbpp_run2([(1, 0), (2, 0), (3, 0)]) == {1: 1, 2: 4, 3: 10}", "assert mbpp_run2([(4, 0), (5, 0), (6, 0)]) == {4: 20, 5: 35, 6: 56}", "assert mbpp_run2([(7, 0), (8, 0), (9, 0)]) == {7: 84, 8: 120, 9: 165}", "assert mbpp_run2([(10, 0), (11, 0), (12, 0)]) == {10: 220, 11: 286, 12: 364}", "assert mbpp_run2([(13, 0), (14, 0), (15, 0)]) == {13: 455, 14: 560, 15: 680}"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "Mbpp/80-4", "raw_problem": "Write a function to find the nth tetrahedral number.", "raw_solution": "```python\n\ndef mbpp_run1(n): \n\treturn (n * (n + 1) * (n + 2)) / 6\n\n ```", "raw_test_input": ["assert mbpp_run1(5) == 35", "assert mbpp_run1(6) == 56", "assert mbpp_run1(7) == 84"], "new_problem": "Write a function to find the nth tetrahedral number, but include error handling for the following scenarios: \n1. The input is not an integer. \n2. The input is a negative integer. \n3. The input is too large and causes overflow. \nDefine specific error types for these scenarios and ensure meaningful error messages are provided. Handle error propagation appropriately.", "new_solution": "class TetrahedralNumberError(Exception):\n    pass\n\nclass InvalidInputError(TetrahedralNumberError):\n    def __init__(self, message=\"Input must be a non-negative integer.\"):\n        self.message = message\n        super().__init__(self.message)\n\nclass OverflowError(TetrahedralNumberError):\n    def __init__(self, message=\"Input is too large and causes overflow.\"):\n        self.message = message\n        super().__init__(self.message)\n\n\ndef mbpp_run2(n: int) -> float:\n    if not isinstance(n, int):\n        raise InvalidInputError(\"Input must be an integer.\")\n    if n < 0:\n        raise InvalidInputError(\"Input must be a non-negative integer.\")\n    try:\n        result = (n * (n + 1) * (n + 2)) / 6\n    except OverflowError:\n        raise OverflowError(\"Input is too large and causes overflow.\")\n    return result\n", "input_format": "An integer n representing the position of the tetrahedral number to find.", "output_format": "The nth tetrahedral number as a float.", "test_input": ["assert mbpp_run2(0) == 0.0", "assert mbpp_run2(1) == 1.0", "try:\n    mbpp_run2(-1)\nexcept InvalidInputError as e:\n    assert str(e) == \"Input must be a non-negative integer.\"", "try:\n    mbpp_run2(1.5)\nexcept InvalidInputError as e:\n    assert str(e) == \"Input must be an integer.\"", "try:\n    mbpp_run2(10**6)\nexcept OverflowError as e:\n    assert str(e) == \"Input is too large and causes overflow.\""], "requirement_type": "PROMPT_ERROR_HANDLING"}
{"task_id": "Mbpp/82-1", "raw_problem": "Write a function to find the volume of a sphere.", "raw_solution": "```python\n\nimport math\ndef mbpp_run1(r):\n  return (4./3.) * math.pi * (r**3)\n\n ```", "raw_test_input": ["assert math.isclose(mbpp_run1(10), 4188.790204786391, rel_tol=0.001)", "assert math.isclose(mbpp_run1(25), 65449.84694978735, rel_tol=0.001)", "assert math.isclose(mbpp_run1(20), 33510.32163829113, rel_tol=0.001)"], "new_problem": "In a manufacturing company, you need to calculate the mass of spherical objects made from different materials. Each object is defined by its radius and the material's density. Write a function that takes a list of tuples, where each tuple contains the radius of a sphere and its material density, and returns a list of tuples with the radius, density, and calculated mass of each sphere. Use the volume of the sphere to determine its mass.", "new_solution": "import math\n\ndef volume_sphere(r):\n    return (4./3.) * math.pi * (r**3)\n\n\ndef mbpp_run2(spheres):\n    results = []\n    for radius, density in spheres:\n        volume = volume_sphere(radius)\n        mass = volume * density\n        results.append((radius, density, mass))\n    return results", "input_format": "A list of tuples, each containing the radius of a sphere and its material density.", "output_format": "A list of tuples, each containing the radius, density, and calculated mass of the sphere.", "test_input": ["assert mbpp_run2([(1, 1)]) == [(1, 1, 4.1887902047863905)]", "assert mbpp_run2([(2, 2)]) == [(2, 2, 67.02064327658225)]", "assert mbpp_run2([(3, 3)]) == [(3, 3, 339.29200658769764)]", "assert mbpp_run2([(1, 0.5), (2, 1.5)]) == [(1, 0.5, 2.0943951023931953), (2, 1.5, 50.26548245743669)]", "assert mbpp_run2([(0.5, 8)]) == [(0.5, 8, 4.1887902047863905)]"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "Mbpp/82-2", "raw_problem": "Write a function to find the volume of a sphere.", "raw_solution": "```python\n\nimport math\ndef mbpp_run1(r):\n  return (4./3.) * math.pi * (r**3)\n\n ```", "raw_test_input": ["assert math.isclose(mbpp_run1(10), 4188.790204786391, rel_tol=0.001)", "assert math.isclose(mbpp_run1(25), 65449.84694978735, rel_tol=0.001)", "assert math.isclose(mbpp_run1(20), 33510.32163829113, rel_tol=0.001)"], "new_problem": "Enhance the function to calculate the volume of a sphere by adding an optional parameter to specify the unit of measurement for the radius. The function should maintain backward compatibility with existing implementations, support the original function parameters, include type hints, and add new optional parameters.", "new_solution": "import math\ndef mbpp_run2(r: float, unit: str = 'cm') -> float:\n    volume = (4./3.) * math.pi * (r**3)\n    if unit == 'm':\n        return volume / 1e6  # Convert cubic centimeters to cubic meters\n    return volume", "input_format": "radius: float, unit: str = 'cm'", "output_format": "volume: float", "test_input": ["assert mbpp_run2(1) == (4./3.) * math.pi", "assert mbpp_run2(1, 'cm') == (4./3.) * math.pi", "assert mbpp_run2(100) == (4./3.) * math.pi * (100**3)", "assert mbpp_run2(1, 'm') == (4./3.) * math.pi / 1e6", "assert mbpp_run2(100, 'm') == (4./3.) * math.pi * (100**3) / 1e6"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "Mbpp/82-3", "raw_problem": "Write a function to find the volume of a sphere.", "raw_solution": "```python\n\nimport math\ndef mbpp_run1(r):\n  return (4./3.) * math.pi * (r**3)\n\n ```", "raw_test_input": ["assert math.isclose(mbpp_run1(10), 4188.790204786391, rel_tol=0.001)", "assert math.isclose(mbpp_run1(25), 65449.84694978735, rel_tol=0.001)", "assert math.isclose(mbpp_run1(20), 33510.32163829113, rel_tol=0.001)"], "new_problem": "Write a function that takes a list of tuples, where each tuple contains a name and the radius of a sphere. The function should return a dictionary where the keys are the names and the values are the volumes of the corresponding spheres. Use type hints and ensure that the function can handle an empty list. Additionally, the function should raise a ValueError if any radius is negative.", "new_solution": "import math\nfrom typing import List, Tuple, Dict\n\ndef volume_sphere(r: float) -> float:\n    return (4./3.) * math.pi * (r**3)\n\ndef mbpp_run2(spheres: List[Tuple[str, float]]) -> Dict[str, float]:\n    volumes = {}\n    for name, radius in spheres:\n        if radius < 0:\n            raise ValueError(f\"Radius cannot be negative: {radius}\")\n        volumes[name] = volume_sphere(radius)\n    return volumes", "input_format": "List[Tuple[str, float]]", "output_format": "Dict[str, float]", "test_input": ["assert mbpp_run2([]) == {}", "assert mbpp_run2([('Sphere1', 1)]) == {'Sphere1': 4.1887902047863905}", "assert mbpp_run2([('Sphere1', 1), ('Sphere2', 2)]) == {'Sphere1': 4.1887902047863905, 'Sphere2': 33.510321638291124}", "assert mbpp_run2([('Small', 0.5), ('Large', 3)]) == {'Small': 0.5235987755982988, 'Large': 113.09733552923254}", "try:\n    mbpp_run2([('Invalid', -1)])\nexcept ValueError as e:\n    assert str(e) == 'Radius cannot be negative: -1'"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "Mbpp/82-4", "raw_problem": "Write a function to find the volume of a sphere.", "raw_solution": "```python\n\nimport math\ndef mbpp_run1(r):\n  return (4./3.) * math.pi * (r**3)\n\n ```", "raw_test_input": ["assert math.isclose(mbpp_run1(10), 4188.790204786391, rel_tol=0.001)", "assert math.isclose(mbpp_run1(25), 65449.84694978735, rel_tol=0.001)", "assert math.isclose(mbpp_run1(20), 33510.32163829113, rel_tol=0.001)"], "new_problem": "Write a function to find the volume of a sphere, but include error handling for invalid inputs. The function should raise a ValueError if the radius is negative, a TypeError if the input is not a number, and a custom exception InvalidRadiusError if the radius is not a finite number. Ensure that the function propagates errors with meaningful messages.", "new_solution": "import math\n\nclass InvalidRadiusError(Exception):\n    pass\n\ndef mbpp_run2(r: float) -> float:\n    if not isinstance(r, (int, float)):\n        raise TypeError(\"The radius must be a number.\")\n    if r < 0:\n        raise ValueError(\"The radius cannot be negative.\")\n    if not math.isfinite(r):\n        raise InvalidRadiusError(\"The radius must be a finite number.\")\n    return (4./3.) * math.pi * (r**3)", "input_format": "A single float or integer representing the radius of a sphere.", "output_format": "A float representing the volume of the sphere, or an error message if the input is invalid.", "test_input": ["assert mbpp_run2(3) == 113.09733552923254", "try:\n    mbpp_run2(-1)\nexcept ValueError as e:\n    assert str(e) == \"The radius cannot be negative.\"", "try:\n    mbpp_run2('a')\nexcept TypeError as e:\n    assert str(e) == \"The radius must be a number.\"", "try:\n    mbpp_run2(float('inf'))\nexcept InvalidRadiusError as e:\n    assert str(e) == \"The radius must be a finite number.\"", "try:\n    mbpp_run2(None)\nexcept TypeError as e:\n    assert str(e) == \"The radius must be a number.\""], "requirement_type": "PROMPT_ERROR_HANDLING"}
{"task_id": "Mbpp/84-1", "raw_problem": "Write a function to find the nth number in the newman conway sequence.", "raw_solution": "```python\n\ndef mbpp_run1(n): \n\tif n == 1 or n == 2: \n\t\treturn 1\n\tseq = [0] * (n + 1)\n\tseq[1] = seq[2] = 1\n\tfor i in range(3, n + 1):\n\t\tseq[i] = seq[seq[i - 1]] + seq[i - seq[i - 1]]\n\treturn seq[n]\n\n ```", "raw_test_input": ["assert mbpp_run1(10) == 6", "assert mbpp_run1(2) == 1", "assert mbpp_run1(3) == 2"], "new_problem": "In a financial forecasting scenario, a company wants to predict the cumulative growth of a new product's user base over several months. The growth pattern follows the Newman-Conway sequence, where the nth month's growth is determined by the nth number in the sequence. Write a function that takes a list of integers, each representing a month, and returns a list of cumulative user base growth for each month. Use the original Newman-Conway sequence function as a core component.", "new_solution": "def sequence(n):\n    if n == 1 or n == 2:\n        return 1\n    seq = [0] * (n + 1)\n    seq[1] = seq[2] = 1\n    for i in range(3, n + 1):\n        seq[i] = seq[seq[i - 1]] + seq[i - seq[i - 1]]\n    return seq[n]\n\ndef mbpp_run2(months):\n    cumulative_values = []\n    total_growth = 0\n    for month in months:\n        total_growth += sequence(month)\n        cumulative_values.append(total_growth)\n    return cumulative_values", "input_format": "A list of integers representing the number of months for which to calculate the cumulative Newman-Conway sequence values.", "output_format": "A list of integers representing the cumulative sum of the Newman-Conway sequence values for each month.", "test_input": ["assert mbpp_run2([1, 2, 3, 4, 5]) == [1, 2, 4, 6, 9]", "assert mbpp_run2([6, 7, 8]) == [4, 8, 12]", "assert mbpp_run2([10, 11, 12]) == [6, 13, 20]", "assert mbpp_run2([15, 16, 17]) == [8, 16, 25]", "assert mbpp_run2([20, 21, 22]) == [12, 24, 37]"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "Mbpp/84-2", "raw_problem": "Write a function to find the nth number in the newman conway sequence.", "raw_solution": "```python\n\ndef mbpp_run1(n): \n\tif n == 1 or n == 2: \n\t\treturn 1\n\tseq = [0] * (n + 1)\n\tseq[1] = seq[2] = 1\n\tfor i in range(3, n + 1):\n\t\tseq[i] = seq[seq[i - 1]] + seq[i - seq[i - 1]]\n\treturn seq[n]\n\n ```", "raw_test_input": ["assert mbpp_run1(10) == 6", "assert mbpp_run1(2) == 1", "assert mbpp_run1(3) == 2"], "new_problem": "Enhance the function to find the nth number in the Newman-Conway sequence by adding an optional parameter that allows the user to retrieve the entire sequence up to the nth number. The function should maintain backward compatibility, meaning it should still return the nth number by default if the new parameter is not used.", "new_solution": "from typing import List, Union\n\ndef mbpp_run2(n: int, *, return_list: bool = False) -> Union[int, List[int]]:\n    if n == 1 or n == 2:\n        return 1 if not return_list else [1] * n\n    seq = [0] * (n + 1)\n    seq[1] = seq[2] = 1\n    for i in range(3, n + 1):\n        seq[i] = seq[seq[i - 1]] + seq[i - seq[i - 1]]\n    return seq[n] if not return_list else seq[1:]", "input_format": "sequence(n: int, *, return_list: bool = False) -> Union[int, List[int]]", "output_format": "If return_list is False, return the nth number in the sequence as an integer. If return_list is True, return the entire sequence up to the nth number as a list.", "test_input": ["assert mbpp_run2(1) == 1", "assert mbpp_run2(2) == 1", "assert mbpp_run2(3) == 2", "assert mbpp_run2(4) == 2", "assert mbpp_run2(5) == 3", "assert mbpp_run2(5, return_list=True) == [1, 1, 2, 2, 3]", "assert mbpp_run2(6, return_list=True) == [1, 1, 2, 2, 3, 4]"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "Mbpp/84-3", "raw_problem": "Write a function to find the nth number in the newman conway sequence.", "raw_solution": "```python\n\ndef mbpp_run1(n): \n\tif n == 1 or n == 2: \n\t\treturn 1\n\tseq = [0] * (n + 1)\n\tseq[1] = seq[2] = 1\n\tfor i in range(3, n + 1):\n\t\tseq[i] = seq[seq[i - 1]] + seq[i - seq[i - 1]]\n\treturn seq[n]\n\n ```", "raw_test_input": ["assert mbpp_run1(10) == 6", "assert mbpp_run1(2) == 1", "assert mbpp_run1(3) == 2"], "new_problem": "Write a function to compute multiple values of the Newman-Conway sequence for given indices. The function should return a dictionary where each key is an index from the input list and the value is the corresponding number in the Newman-Conway sequence. Use a dictionary to store intermediate results to optimize repeated calculations. Include type hints in your function. Additionally, ensure that the function can handle up to 10,000 indices efficiently.", "new_solution": "from typing import List, Dict\n\ndef sequence(n: int, memo: Dict[int, int]) -> int:\n    if n in memo:\n        return memo[n]\n    if n == 1 or n == 2:\n        return 1\n    memo[n] = sequence(sequence(n - 1, memo), memo) + sequence(n - sequence(n - 1, memo), memo)\n    return memo[n]\n\n\ndef mbpp_run2(indices: List[int]) -> Dict[int, int]:\n    memo = {1: 1, 2: 1}\n    result = {}\n    for index in indices:\n        result[index] = sequence(index, memo)\n    return result", "input_format": "A list of integers representing the sequence indices to be calculated.", "output_format": "A dictionary where keys are the sequence indices and values are the corresponding Newman-Conway sequence numbers.", "test_input": ["assert mbpp_run2([1, 2, 3, 4, 5]) == {1: 1, 2: 1, 3: 2, 4: 2, 5: 3}", "assert mbpp_run2([6, 7, 8, 9, 10]) == {6: 4, 7: 4, 8: 4, 9: 5, 10: 6}", "assert mbpp_run2([11, 12, 13, 14, 15]) == {11: 7, 12: 7, 13: 8, 14: 8, 15: 8}", "assert mbpp_run2([16, 17, 18, 19, 20]) == {16: 8, 17: 9, 18: 10, 19: 11, 20: 12}", "assert mbpp_run2([21, 22, 23, 24, 25]) == {21: 12, 22: 13, 23: 14, 24: 14, 25: 15}"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "Mbpp/84-4", "raw_problem": "Write a function to find the nth number in the newman conway sequence.", "raw_solution": "```python\n\ndef mbpp_run1(n): \n\tif n == 1 or n == 2: \n\t\treturn 1\n\tseq = [0] * (n + 1)\n\tseq[1] = seq[2] = 1\n\tfor i in range(3, n + 1):\n\t\tseq[i] = seq[seq[i - 1]] + seq[i - seq[i - 1]]\n\treturn seq[n]\n\n ```", "raw_test_input": ["assert mbpp_run1(10) == 6", "assert mbpp_run1(2) == 1", "assert mbpp_run1(3) == 2"], "new_problem": "Write a function to find the nth number in the Newman-Conway sequence with error handling. The function should handle the following errors: \n1. If n is not an integer, raise a TypeError with a message 'Input must be an integer.'.\n2. If n is less than 1, raise a ValueError with a message 'Input must be a positive integer.'.\n3. If n is excessively large (e.g., greater than 10,000), raise a ValueError with a message 'Input is too large.'.\nThe function should propagate these errors with meaningful messages.", "new_solution": "def mbpp_run2(n: int) -> int:\n    if not isinstance(n, int):\n        raise TypeError('Input must be an integer.')\n    if n < 1:\n        raise ValueError('Input must be a positive integer.')\n    if n > 10000:\n        raise ValueError('Input is too large.')\n    if n == 1 or n == 2:\n        return 1\n    seq = [0] * (n + 1)\n    seq[1] = seq[2] = 1\n    for i in range(3, n + 1):\n        seq[i] = seq[seq[i - 1]] + seq[i - seq[i - 1]]\n    return seq[n]", "input_format": "An integer n representing the position in the Newman-Conway sequence.", "output_format": "An integer representing the nth number in the Newman-Conway sequence.", "test_input": ["try:\n    assert mbpp_run2(1) == 1\nexcept Exception as e:\n    print(e)", "try:\n    assert mbpp_run2(2) == 1\nexcept Exception as e:\n    print(e)", "try:\n    assert mbpp_run2(5) == 3\nexcept Exception as e:\n    print(e)", "try:\n    assert mbpp_run2(0)\nexcept ValueError as e:\n    assert str(e) == 'Input must be a positive integer.'", "try:\n    assert mbpp_run2('a')\nexcept TypeError as e:\n    assert str(e) == 'Input must be an integer.'", "try:\n    assert mbpp_run2(10001)\nexcept ValueError as e:\n    assert str(e) == 'Input is too large.'"], "requirement_type": "PROMPT_ERROR_HANDLING"}
{"task_id": "Mbpp/85-1", "raw_problem": "Write a function to find the surface area of a sphere.", "raw_solution": "```python\n\nimport math\ndef mbpp_run1(r):\n  return 4 * math.pi * (r**2)\n\n ```", "raw_test_input": ["assert math.isclose(mbpp_run1(10), 1256.6370614359173, rel_tol=0.001)", "assert math.isclose(mbpp_run1(15), 2827.4333882308138, rel_tol=0.001)", "assert math.isclose(mbpp_run1(20), 5026.548245743669, rel_tol=0.001)"], "new_problem": "In a manufacturing company, spherical tanks are painted for protection against corrosion. The cost of painting is determined by the surface area of the sphere and the cost per unit area. Write a function that calculates the total cost of painting multiple spherical tanks given their radii and the cost per unit area. Use the original function to calculate the surface area of each sphere.", "new_solution": "import math\n\ndef surfacearea_sphere(r):\n    return 4 * math.pi * (r**2)\n\n\ndef mbpp_run2(spheres):\n    total_costs = []\n    for radius, cost_per_unit_area in spheres:\n        surface_area = surfacearea_sphere(radius)\n        total_cost = surface_area * cost_per_unit_area\n        total_costs.append(total_cost)\n    return total_costs", "input_format": "A list of tuples, each containing the radius of a sphere and the cost per unit area for painting the sphere.", "output_format": "A list of total costs for painting each sphere.", "test_input": ["assert mbpp_run2([(1, 10)]) == [125.66370614359172]", "assert mbpp_run2([(2, 5), (3, 7)]) == [251.32741228718345, 791.6813487046279]", "assert mbpp_run2([(0.5, 20)]) == [62.83185307179586]", "assert mbpp_run2([(1, 0), (2, 0)]) == [0.0, 0.0]", "assert mbpp_run2([(1, 10), (2, 15), (3, 20)]) == [125.66370614359172, 753.9822368615503, 2261.946710584651]"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "Mbpp/85-2", "raw_problem": "Write a function to find the surface area of a sphere.", "raw_solution": "```python\n\nimport math\ndef mbpp_run1(r):\n  return 4 * math.pi * (r**2)\n\n ```", "raw_test_input": ["assert math.isclose(mbpp_run1(10), 1256.6370614359173, rel_tol=0.001)", "assert math.isclose(mbpp_run1(15), 2827.4333882308138, rel_tol=0.001)", "assert math.isclose(mbpp_run1(20), 5026.548245743669, rel_tol=0.001)"], "new_problem": "Enhance the function to calculate the surface area of a sphere by adding an optional parameter to specify the unit of measurement for the radius. The function should maintain backward compatibility with existing implementations, support the original function parameters, include type hints, and add new optional parameters.", "new_solution": "import math\ndef mbpp_run2(r: float, unit: str = 'meters') -> float:\n    return 4 * math.pi * (r**2)", "input_format": "radius: float, unit: str = 'meters'", "output_format": "float", "test_input": ["assert mbpp_run2(1) == 4 * math.pi", "assert mbpp_run2(1, 'meters') == 4 * math.pi", "assert mbpp_run2(2) == 16 * math.pi", "assert mbpp_run2(2, 'centimeters') == 16 * math.pi", "assert mbpp_run2(0) == 0"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "Mbpp/85-3", "raw_problem": "Write a function to find the surface area of a sphere.", "raw_solution": "```python\n\nimport math\ndef mbpp_run1(r):\n  return 4 * math.pi * (r**2)\n\n ```", "raw_test_input": ["assert math.isclose(mbpp_run1(10), 1256.6370614359173, rel_tol=0.001)", "assert math.isclose(mbpp_run1(15), 2827.4333882308138, rel_tol=0.001)", "assert math.isclose(mbpp_run1(20), 5026.548245743669, rel_tol=0.001)"], "new_problem": "Write a function that takes a dictionary of spheres, where each key is a unique identifier for a sphere and the value is the radius of that sphere. The function should return a new dictionary where each key is the same unique identifier and the value is the surface area of the corresponding sphere. Ensure that the function uses type hints and handles cases where the radius is zero or negative by returning a surface area of zero for those spheres.", "new_solution": "import math\nfrom typing import Dict\n\ndef surfacearea_sphere(r: float) -> float:\n    return 4 * math.pi * (r**2) if r > 0 else 0\n\ndef mbpp_run2(spheres: Dict[str, float]) -> Dict[str, float]:\n    return {identifier: surfacearea_sphere(radius) for identifier, radius in spheres.items()}", "input_format": "A dictionary where keys are sphere identifiers and values are their radii.", "output_format": "A dictionary where keys are sphere identifiers and values are their surface areas.", "test_input": ["assert mbpp_run2({'sphere1': 3, 'sphere2': 0, 'sphere3': -5}) == {'sphere1': 113.09733552923255, 'sphere2': 0, 'sphere3': 0}", "assert mbpp_run2({'a': 1, 'b': 2, 'c': 3}) == {'a': 12.566370614359172, 'b': 50.26548245743669, 'c': 113.09733552923255}", "assert mbpp_run2({'x': 0}) == {'x': 0}", "assert mbpp_run2({'y': -1}) == {'y': 0}", "assert mbpp_run2({'z': 4.5}) == {'z': 254.46900494077323}"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "Mbpp/85-4", "raw_problem": "Write a function to find the surface area of a sphere.", "raw_solution": "```python\n\nimport math\ndef mbpp_run1(r):\n  return 4 * math.pi * (r**2)\n\n ```", "raw_test_input": ["assert math.isclose(mbpp_run1(10), 1256.6370614359173, rel_tol=0.001)", "assert math.isclose(mbpp_run1(15), 2827.4333882308138, rel_tol=0.001)", "assert math.isclose(mbpp_run1(20), 5026.548245743669, rel_tol=0.001)"], "new_problem": "Write a function to find the surface area of a sphere, but include error handling for the following scenarios: 1) The radius must be a non-negative number. 2) The input must be a number (either integer or float). 3) Handle any unexpected errors gracefully with a meaningful error message.", "new_solution": "import math\n\nclass SphereError(Exception):\n    pass\n\nclass NegativeRadiusError(SphereError):\n    def __init__(self, radius):\n        self.radius = radius\n        self.message = f\"Radius cannot be negative: {radius}\"\n        super().__init__(self.message)\n\nclass InvalidTypeError(SphereError):\n    def __init__(self, radius):\n        self.radius = radius\n        self.message = f\"Radius must be a number, got {type(radius).__name__} instead.\"\n        super().__init__(self.message)\n\ndef mbpp_run2(r: float) -> float:\n    if not isinstance(r, (int, float)):\n        raise InvalidTypeError(r)\n    if r < 0:\n        raise NegativeRadiusError(r)\n    try:\n        return 4 * math.pi * (r**2)\n    except Exception as e:\n        raise SphereError(f\"An unexpected error occurred: {str(e)}\")\n", "input_format": "A single float or integer representing the radius of a sphere.", "output_format": "A float representing the surface area of the sphere.", "test_input": ["assert mbpp_run2(3) == 4 * math.pi * 9", "try:\n    mbpp_run2(-5)\nexcept NegativeRadiusError as e:\n    assert str(e) == \"Radius cannot be negative: -5\"", "try:\n    mbpp_run2('a')\nexcept InvalidTypeError as e:\n    assert str(e) == \"Radius must be a number, got str instead.\"", "try:\n    mbpp_run2(None)\nexcept InvalidTypeError as e:\n    assert str(e) == \"Radius must be a number, got NoneType instead.\"", "try:\n    mbpp_run2([1, 2, 3])\nexcept InvalidTypeError as e:\n    assert str(e) == \"Radius must be a number, got list instead.\""], "requirement_type": "PROMPT_ERROR_HANDLING"}
{"task_id": "Mbpp/86-1", "raw_problem": "Write a function to find nth centered hexagonal number.", "raw_solution": "```python\n\ndef mbpp_run1(n):\n  return 3 * n * (n - 1) + 1\n\n ```", "raw_test_input": ["assert mbpp_run1(10) == 271", "assert mbpp_run1(2) == 7", "assert mbpp_run1(9) == 217"], "new_problem": "In an e-commerce warehouse, items are stored in hexagonal bins. Each bin can hold a number of items based on the centered hexagonal number formula. Write a function that calculates the total number of items that can be stored in each category of bins, given the number of bins in each category. Use the centered hexagonal number formula to determine the capacity of each bin. The function should return a list of total capacities for each category.", "new_solution": "def centered_hexagonal_number(n):\n    return 3 * n * (n - 1) + 1\n\n\ndef mbpp_run2(bins_per_category):\n    total_items = []\n    for bins in bins_per_category:\n        total_capacity = 0\n        for i in range(1, bins + 1):\n            total_capacity = centered_hexagonal_number(i)\n        total_items.append(total_capacity)\n    return total_items", "input_format": "A list of integers representing the number of items in each category and a list of integers representing the number of categories.", "output_format": "A list of integers representing the total number of items in each category after applying the centered hexagonal number formula.", "test_input": ["assert mbpp_run2([1, 2, 3]) == [1, 7, 19]", "assert mbpp_run2([4, 5]) == [37, 61]", "assert mbpp_run2([6]) == [91]", "assert mbpp_run2([0]) == [0]", "assert mbpp_run2([1, 1, 1]) == [1, 1, 1]"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "Mbpp/86-2", "raw_problem": "Write a function to find nth centered hexagonal number.", "raw_solution": "```python\n\ndef mbpp_run1(n):\n  return 3 * n * (n - 1) + 1\n\n ```", "raw_test_input": ["assert mbpp_run1(10) == 271", "assert mbpp_run1(2) == 7", "assert mbpp_run1(9) == 217"], "new_problem": "Enhance the function to find the nth centered hexagonal number by adding an optional multiplier parameter. The function should maintain backward compatibility, meaning it should still return the nth centered hexagonal number when the multiplier is not provided. If the multiplier is provided, the function should return the nth centered hexagonal number multiplied by this value. Include type hints for the function parameters and return type.", "new_solution": "from typing import Optional\n\ndef mbpp_run2(n: int, multiplier: Optional[int] = None) -> int:\n    result = 3 * n * (n - 1) + 1\n    if multiplier is not None:\n        result *= multiplier\n    return result", "input_format": "n: int, multiplier: Optional[int] = None", "output_format": "int", "test_input": ["assert mbpp_run2(1) == 1", "assert mbpp_run2(2) == 7", "assert mbpp_run2(3) == 19", "assert mbpp_run2(2, 2) == 14", "assert mbpp_run2(3, 3) == 57"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "Mbpp/86-3", "raw_problem": "Write a function to find nth centered hexagonal number.", "raw_solution": "```python\n\ndef mbpp_run1(n):\n  return 3 * n * (n - 1) + 1\n\n ```", "raw_test_input": ["assert mbpp_run1(10) == 271", "assert mbpp_run1(2) == 7", "assert mbpp_run1(9) == 217"], "new_problem": "Write a function that takes a list of tuples, where each tuple contains an integer n and a count. The function should return a dictionary where the keys are the integers n and the values are the sum of the nth centered hexagonal numbers for the given count. Use a dictionary to store intermediate results to optimize repeated calculations.", "new_solution": "from typing import List, Tuple, Dict\n\ndef centered_hexagonal_number(n: int) -> int:\n    return 3 * n * (n - 1) + 1\n\n\ndef mbpp_run2(data: List[Tuple[int, int]]) -> Dict[int, int]:\n    result = {}\n    hexagonal_cache = {}\n    for n, count in data:\n        if n not in hexagonal_cache:\n            hexagonal_cache[n] = centered_hexagonal_number(n)\n        if n not in result:\n            result[n] = 0\n        result[n] += hexagonal_cache[n] * count\n    return result", "input_format": "List[Tuple[int, int]]", "output_format": "Dict[int, int]", "test_input": ["assert mbpp_run2([(1, 1), (2, 2), (3, 1)]) == {1: 1, 2: 14, 3: 19}", "assert mbpp_run2([(4, 3), (5, 1)]) == {4: 111, 5: 61}", "assert mbpp_run2([(6, 2), (7, 1), (6, 1)]) == {6: 273, 7: 127}", "assert mbpp_run2([(8, 1), (9, 2)]) == {8: 169, 9: 434}", "assert mbpp_run2([(10, 1), (10, 1)]) == {10: 542}"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "Mbpp/86-4", "raw_problem": "Write a function to find nth centered hexagonal number.", "raw_solution": "```python\n\ndef mbpp_run1(n):\n  return 3 * n * (n - 1) + 1\n\n ```", "raw_test_input": ["assert mbpp_run1(10) == 271", "assert mbpp_run1(2) == 7", "assert mbpp_run1(9) == 217"], "new_problem": "Write a function to find the nth centered hexagonal number with error handling. The function should handle the following errors: \n1. If n is not an integer, raise a TypeError with a message 'Input must be an integer'.\n2. If n is less than 1, raise a ValueError with a message 'Input must be a positive integer'.\n3. If n is too large and causes an overflow, handle the OverflowError and return a message 'Result too large to compute'.\nThe function should propagate errors appropriately and maintain type hints.", "new_solution": "def mbpp_run2(n: int) -> int:\n    if not isinstance(n, int):\n        raise TypeError('Input must be an integer')\n    if n < 1:\n        raise ValueError('Input must be a positive integer')\n    try:\n        return 3 * n * (n - 1) + 1\n    except OverflowError:\n        raise OverflowError('Result too large to compute')", "input_format": "An integer n representing the position of the centered hexagonal number.", "output_format": "An integer representing the nth centered hexagonal number or an error message if input is invalid.", "test_input": ["assert mbpp_run2(1) == 1", "assert mbpp_run2(2) == 7", "try:\n    mbpp_run2(0)\nexcept ValueError as e:\n    assert str(e) == 'Input must be a positive integer'", "try:\n    mbpp_run2('a')\nexcept TypeError as e:\n    assert str(e) == 'Input must be an integer'", "try:\n    mbpp_run2(10**18)\nexcept OverflowError as e:\n    assert str(e) == 'Result too large to compute'"], "requirement_type": "PROMPT_ERROR_HANDLING"}
{"task_id": "Mbpp/87-1", "raw_problem": "Write a function to merge three dictionaries into a single dictionary.", "raw_solution": "```python\n\nimport collections as ct\ndef mbpp_run1(dict1,dict2, dict3):\n    merged_dict = dict(ct.ChainMap({},dict1,dict2,dict3))\n    return merged_dict\n\n ```", "raw_test_input": ["assert mbpp_run1({ \"R\": \"Red\", \"B\": \"Black\", \"P\": \"Pink\" }, { \"G\": \"Green\", \"W\": \"White\" },{ \"O\": \"Orange\", \"W\": \"White\", \"B\": \"Black\" })=={'B': 'Black', 'R': 'Red', 'P': 'Pink', 'G': 'Green', 'W': 'White', 'O': 'Orange'}", "assert mbpp_run1({ \"R\": \"Red\", \"B\": \"Black\", \"P\": \"Pink\" }, { \"G\": \"Green\", \"W\": \"White\" },{\"L\":\"lavender\",\"B\":\"Blue\"})=={'W': 'White', 'P': 'Pink', 'B': 'Black', 'R': 'Red', 'G': 'Green', 'L': 'lavender'}", "assert mbpp_run1({ \"R\": \"Red\", \"B\": \"Black\", \"P\": \"Pink\" },{\"L\":\"lavender\",\"B\":\"Blue\"},{ \"G\": \"Green\", \"W\": \"White\" })=={'B': 'Black', 'P': 'Pink', 'R': 'Red', 'G': 'Green', 'L': 'lavender', 'W': 'White'}"], "new_problem": "In an e-commerce company, sales data is collected from three different regions, each represented as a dictionary. Each region's sales data is in its local currency. You are given a dictionary of exchange rates to convert all sales data to USD and a dictionary of tax rates to adjust the sales figures. Write a function that merges the sales data from the three regions into a single dictionary, converts all sales figures to USD using the provided exchange rates, and adjusts the figures for tax using the provided tax rates. Use the original function to merge the dictionaries.", "new_solution": "import collections as ct\n\ndef merge_dictionaries_three(dict1, dict2, dict3):\n    merged_dict = dict(ct.ChainMap({}, dict1, dict2, dict3))\n    return merged_dict\n\ndef mbpp_run2(sales_data_list, exchange_rates, tax_rates):\n    # Merge sales data from different regions\n    merged_sales_data = merge_dictionaries_three(*sales_data_list)\n    # Convert and adjust sales data\n    for region, sales in merged_sales_data.items():\n        if region in exchange_rates and region in tax_rates:\n            # Convert to USD\n            sales_in_usd = sales * exchange_rates[region]\n            # Adjust for tax\n            adjusted_sales = sales_in_usd * (1 - tax_rates[region])\n            merged_sales_data[region] = adjusted_sales\n    return merged_sales_data", "input_format": "A list of dictionaries representing sales data from different regions, a dictionary of exchange rates, and a dictionary of tax rates.", "output_format": "A single dictionary with merged sales data, converted to a common currency, and adjusted for tax rates.", "test_input": ["assert mbpp_run2([{'US': 1000}, {'EU': 2000}, {'ASIA': 3000}], {'US': 1, 'EU': 1.1, 'ASIA': 0.9}, {'US': 0.1, 'EU': 0.2, 'ASIA': 0.15}) == {'US': 900.0, 'EU': 1760.0, 'ASIA': 2295.0}", "assert mbpp_run2([{'US': 500}, {'EU': 1500}, {'ASIA': 2500}], {'US': 1, 'EU': 1.2, 'ASIA': 0.8}, {'US': 0.05, 'EU': 0.15, 'ASIA': 0.1}) == {'US': 475.0, 'EU': 1530.0, 'ASIA': 1800.0}", "assert mbpp_run2([{'US': 0}, {'EU': 0}, {'ASIA': 0}], {'US': 1, 'EU': 1.1, 'ASIA': 0.9}, {'US': 0.1, 'EU': 0.2, 'ASIA': 0.15}) == {'US': 0.0, 'EU': 0.0, 'ASIA': 0.0}", "assert mbpp_run2([{'US': 100}, {'EU': 200}, {'ASIA': 300}], {'US': 1, 'EU': 1.3, 'ASIA': 0.7}, {'US': 0.2, 'EU': 0.1, 'ASIA': 0.05}) == {'US': 80.0, 'EU': 234.0, 'ASIA': 199.5}", "assert mbpp_run2([{'US': 1000}, {'EU': 0}, {'ASIA': 0}], {'US': 1, 'EU': 1.1, 'ASIA': 0.9}, {'US': 0.1, 'EU': 0.2, 'ASIA': 0.15}) == {'US': 900.0, 'EU': 0.0, 'ASIA': 0.0}"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "Mbpp/87-2", "raw_problem": "Write a function to merge three dictionaries into a single dictionary.", "raw_solution": "```python\n\nimport collections as ct\ndef mbpp_run1(dict1,dict2, dict3):\n    merged_dict = dict(ct.ChainMap({},dict1,dict2,dict3))\n    return merged_dict\n\n ```", "raw_test_input": ["assert mbpp_run1({ \"R\": \"Red\", \"B\": \"Black\", \"P\": \"Pink\" }, { \"G\": \"Green\", \"W\": \"White\" },{ \"O\": \"Orange\", \"W\": \"White\", \"B\": \"Black\" })=={'B': 'Black', 'R': 'Red', 'P': 'Pink', 'G': 'Green', 'W': 'White', 'O': 'Orange'}", "assert mbpp_run1({ \"R\": \"Red\", \"B\": \"Black\", \"P\": \"Pink\" }, { \"G\": \"Green\", \"W\": \"White\" },{\"L\":\"lavender\",\"B\":\"Blue\"})=={'W': 'White', 'P': 'Pink', 'B': 'Black', 'R': 'Red', 'G': 'Green', 'L': 'lavender'}", "assert mbpp_run1({ \"R\": \"Red\", \"B\": \"Black\", \"P\": \"Pink\" },{\"L\":\"lavender\",\"B\":\"Blue\"},{ \"G\": \"Green\", \"W\": \"White\" })=={'B': 'Black', 'P': 'Pink', 'R': 'Red', 'G': 'Green', 'L': 'lavender', 'W': 'White'}"], "new_problem": "Enhance the function to merge three dictionaries into a single dictionary by adding an optional parameter 'overwrite'. This parameter should determine whether values from later dictionaries should overwrite those from earlier ones. The function should maintain backward compatibility with existing implementations, support original function parameters, and include type hints.", "new_solution": "from typing import Dict, Any\nimport collections as ct\n\ndef mbpp_run2(dict1: Dict[str, Any], dict2: Dict[str, Any], dict3: Dict[str, Any], *, overwrite: bool = True) -> Dict[str, Any]:\n    if overwrite:\n        merged_dict = dict(ct.ChainMap({}, dict3, dict2, dict1))\n    else:\n        merged_dict = dict(ct.ChainMap({}, dict1, dict2, dict3))\n    return merged_dict", "input_format": "merge_dictionaries_three(dict1: Dict[str, Any], dict2: Dict[str, Any], dict3: Dict[str, Any], *, overwrite: bool = True) -> Dict[str, Any]", "output_format": "A single merged dictionary with optional overwrite behavior", "test_input": ["assert mbpp_run2({'a': 1}, {'b': 2}, {'c': 3}) == {'a': 1, 'b': 2, 'c': 3}", "assert mbpp_run2({'a': 1}, {'a': 2}, {'a': 3}) == {'a': 3}", "assert mbpp_run2({'a': 1}, {'a': 2}, {'a': 3}, overwrite=False) == {'a': 1}", "assert mbpp_run2({'a': 1, 'b': 2}, {'b': 3}, {'c': 4}) == {'a': 1, 'b': 3, 'c': 4}", "assert mbpp_run2({'x': 10}, {'y': 20}, {'z': 30}, overwrite=False) == {'x': 10, 'y': 20, 'z': 30}"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "Mbpp/87-3", "raw_problem": "Write a function to merge three dictionaries into a single dictionary.", "raw_solution": "```python\n\nimport collections as ct\ndef mbpp_run1(dict1,dict2, dict3):\n    merged_dict = dict(ct.ChainMap({},dict1,dict2,dict3))\n    return merged_dict\n\n ```", "raw_test_input": ["assert mbpp_run1({ \"R\": \"Red\", \"B\": \"Black\", \"P\": \"Pink\" }, { \"G\": \"Green\", \"W\": \"White\" },{ \"O\": \"Orange\", \"W\": \"White\", \"B\": \"Black\" })=={'B': 'Black', 'R': 'Red', 'P': 'Pink', 'G': 'Green', 'W': 'White', 'O': 'Orange'}", "assert mbpp_run1({ \"R\": \"Red\", \"B\": \"Black\", \"P\": \"Pink\" }, { \"G\": \"Green\", \"W\": \"White\" },{\"L\":\"lavender\",\"B\":\"Blue\"})=={'W': 'White', 'P': 'Pink', 'B': 'Black', 'R': 'Red', 'G': 'Green', 'L': 'lavender'}", "assert mbpp_run1({ \"R\": \"Red\", \"B\": \"Black\", \"P\": \"Pink\" },{\"L\":\"lavender\",\"B\":\"Blue\"},{ \"G\": \"Green\", \"W\": \"White\" })=={'B': 'Black', 'P': 'Pink', 'R': 'Red', 'G': 'Green', 'L': 'lavender', 'W': 'White'}"], "new_problem": "Write a function to merge a list of dictionaries into a single dictionary, where each key in the resulting dictionary maps to a list of all values associated with that key in the input dictionaries. Use a defaultdict to handle the merging process. Ensure that the function can handle at least 5 dictionaries and that each dictionary can have up to 1000 key-value pairs.", "new_solution": "from collections import defaultdict\nfrom typing import List, Dict, Tuple\n\ndef mbpp_run2(dicts: List[Dict[str, List[Tuple[str, int]]]]) -> Dict[str, List[int]]:\n    merged_dict = defaultdict(list)\n    for d in dicts:\n        for key, value_list in d.items():\n            for _, value in value_list:\n                merged_dict[key].append(value)\n    return dict(merged_dict)\n\n# Original function for reference\nimport collections as ct\n\ndef merge_dictionaries_three(dict1, dict2, dict3):\n    merged_dict = dict(ct.ChainMap({}, dict1, dict2, dict3))\n    return merged_dict", "input_format": "A list of dictionaries, where each dictionary contains a list of tuples representing key-value pairs.", "output_format": "A dictionary where each key maps to a list of values from the input dictionaries.", "test_input": ["assert mbpp_run2([{'a': [('x', 1), ('y', 2)]}, {'b': [('z', 3)]}, {'a': [('w', 4)]}]) == {'a': [1, 2, 4], 'b': [3]}", "assert mbpp_run2([{'key1': [('a', 10)]}, {'key2': [('b', 20)]}, {'key1': [('c', 30)]}, {'key3': [('d', 40)]}]) == {'key1': [10, 30], 'key2': [20], 'key3': [40]}", "assert mbpp_run2([{'x': [('a', 5)]}, {'x': [('b', 15)]}, {'y': [('c', 25)]}, {'z': [('d', 35)]}, {'x': [('e', 45)]}]) == {'x': [5, 15, 45], 'y': [25], 'z': [35]}", "assert mbpp_run2([{'p': [('a', 100)]}, {'q': [('b', 200)]}, {'r': [('c', 300)]}, {'p': [('d', 400)]}, {'q': [('e', 500)]}]) == {'p': [100, 400], 'q': [200, 500], 'r': [300]}", "assert mbpp_run2([{'a': [('x', 1)]}, {'b': [('y', 2)]}, {'c': [('z', 3)]}, {'a': [('w', 4)]}, {'b': [('v', 5)]}]) == {'a': [1, 4], 'b': [2, 5], 'c': [3]}"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "Mbpp/87-4", "raw_problem": "Write a function to merge three dictionaries into a single dictionary.", "raw_solution": "```python\n\nimport collections as ct\ndef mbpp_run1(dict1,dict2, dict3):\n    merged_dict = dict(ct.ChainMap({},dict1,dict2,dict3))\n    return merged_dict\n\n ```", "raw_test_input": ["assert mbpp_run1({ \"R\": \"Red\", \"B\": \"Black\", \"P\": \"Pink\" }, { \"G\": \"Green\", \"W\": \"White\" },{ \"O\": \"Orange\", \"W\": \"White\", \"B\": \"Black\" })=={'B': 'Black', 'R': 'Red', 'P': 'Pink', 'G': 'Green', 'W': 'White', 'O': 'Orange'}", "assert mbpp_run1({ \"R\": \"Red\", \"B\": \"Black\", \"P\": \"Pink\" }, { \"G\": \"Green\", \"W\": \"White\" },{\"L\":\"lavender\",\"B\":\"Blue\"})=={'W': 'White', 'P': 'Pink', 'B': 'Black', 'R': 'Red', 'G': 'Green', 'L': 'lavender'}", "assert mbpp_run1({ \"R\": \"Red\", \"B\": \"Black\", \"P\": \"Pink\" },{\"L\":\"lavender\",\"B\":\"Blue\"},{ \"G\": \"Green\", \"W\": \"White\" })=={'B': 'Black', 'P': 'Pink', 'R': 'Red', 'G': 'Green', 'L': 'lavender', 'W': 'White'}"], "new_problem": "Write a function to merge three dictionaries into a single dictionary. The function should handle the following errors: 1) TypeError if any of the inputs is not a dictionary. 2) ValueError if any of the dictionaries contain non-string keys. 3) Handle error propagation by raising a custom exception 'MergeError' with a meaningful message if any of the above errors occur.", "new_solution": "import collections as ct\n\nclass MergeError(Exception):\n    pass\n\ndef mbpp_run2(dict1: dict, dict2: dict, dict3: dict) -> dict:\n    try:\n        if not all(isinstance(d, dict) for d in [dict1, dict2, dict3]):\n            raise TypeError(\"All inputs must be dictionaries.\")\n        for d in [dict1, dict2, dict3]:\n            if any(not isinstance(k, str) for k in d.keys()):\n                raise ValueError(\"All dictionary keys must be strings.\")\n        merged_dict = dict(ct.ChainMap({}, dict1, dict2, dict3))\n        return merged_dict\n    except (TypeError, ValueError) as e:\n        raise MergeError(f\"Error merging dictionaries: {e}\") from e", "input_format": "Three dictionaries to be merged", "output_format": "A single merged dictionary or an error message", "test_input": ["assert mbpp_run2({'a': 1}, {'b': 2}, {'c': 3}) == {'a': 1, 'b': 2, 'c': 3}", "try:\n    mbpp_run2({'a': 1}, {'b': 2}, [1, 2, 3])\nexcept MergeError as e:\n    assert str(e) == 'Error merging dictionaries: All inputs must be dictionaries.'", "try:\n    mbpp_run2({'a': 1}, {'b': 2}, {3: 'c'})\nexcept MergeError as e:\n    assert str(e) == 'Error merging dictionaries: All dictionary keys must be strings.'", "try:\n    mbpp_run2({'a': 1}, 'not a dict', {'c': 3})\nexcept MergeError as e:\n    assert str(e) == 'Error merging dictionaries: All inputs must be dictionaries.'", "try:\n    mbpp_run2({'a': 1}, {'b': 2}, {'c': 3, 4: 'd'})\nexcept MergeError as e:\n    assert str(e) == 'Error merging dictionaries: All dictionary keys must be strings.'"], "requirement_type": "PROMPT_ERROR_HANDLING"}
