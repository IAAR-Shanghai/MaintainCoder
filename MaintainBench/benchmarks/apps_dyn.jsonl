{"task_id": "APPS/2005-2", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nToad Rash has a binary string $s$. A binary string consists only of zeros and ones.\n\nLet $n$ be the length of $s$.\n\nRash needs to find the number of such pairs of integers $l$, $r$ that $1 \\leq l \\leq r \\leq n$ and there is at least one pair of integers $x$, $k$ such that $1 \\leq x, k \\leq n$, $l \\leq x < x + 2k \\leq r$, and $s_x = s_{x+k} = s_{x+2k}$.\n\nFind this number of pairs for Rash.\n\n\n-----Input-----\n\nThe first line contains the string $s$ ($1 \\leq |s| \\leq 300\\,000$), consisting of zeros and ones.\n\n\n-----Output-----\n\nOutput one integer: the number of such pairs of integers $l$, $r$ that $1 \\leq l \\leq r \\leq n$ and there is at least one pair of integers $x$, $k$ such that $1 \\leq x, k \\leq n$, $l \\leq x < x + 2k \\leq r$, and $s_x = s_{x+k} = s_{x+2k}$.\n\n\n-----Examples-----\nInput\n010101\n\nOutput\n3\n\nInput\n11001100\n\nOutput\n0\n\n\n\n-----Note-----\n\nIn the first example, there are three $l$, $r$ pairs we need to count: $1$, $6$; $2$, $6$; and $1$, $5$.\n\nIn the second example, there are no values $x$, $k$ for the initial string, so the answer is $0$.", "raw_solution": "def apps_run1(s):\n    X = [[], ['0', '1'], ['00', '01', '10', '11'], ['001', '010', '011', '100', '101', '110'], ['0010', '0011', '0100', '0101', '0110', '1001', '1010', '1011', '1100', '1101'], ['00100', '00101', '00110', '01001', '01011', '01100', '01101', '10010', '10011', '10100', '10110', '11001', '11010', '11011'], ['001001', '001011', '001100', '001101', '010010', '010011', '010110', '011001', '011010', '011011', '100100', '100101', '100110', '101001', '101100', '101101', '110010', '110011', '110100', '110110'], ['0010011', '0011001', '0011010', '0011011', '0100101', '0101100', '0101101', '0110011', '1001100', '1010010', '1010011', '1011010', '1100100', '1100101', '1100110', '1101100'], ['00110011', '01011010', '01100110', '10011001', '10100101', '11001100']]\n    N = len(s)\n    ans = (N-1)*(N-2)//2\n    for i in range(N):\n        for j in range(i+3, min(i+9, N+1)):\n            if s[i:j] in X[j-i]:\n                ans -= 1\n    return ans", "raw_test_input": ["assert apps_run1('010101') == 3", "assert apps_run1('11001100') == 0", "assert apps_run1('0') == 0", "assert apps_run1('00') == 0", "assert apps_run1('01') == 0", "assert apps_run1('000') == 1", "assert apps_run1('100') == 0", "assert apps_run1('001') == 0", "assert apps_run1('101') == 0", "assert apps_run1('0000') == 3", "assert apps_run1('0100101110') == 16", "assert apps_run1('1101111000011110111111110101100111111110111100001111011010111001101100010110000001010101101010111000') == 4672", "assert apps_run1('1000') == 2", "assert apps_run1('0010') == 0", "assert apps_run1('1010') == 0", "assert apps_run1('0001') == 2", "assert apps_run1('1001') == 0", "assert apps_run1('0011') == 0", "assert apps_run1('1011') == 0"], "new_problem": "Toad Rash has a binary string s. A binary string consists only of zeros and ones. Let n be the length of s. Rash needs to find the number of such pairs of integers l, r that 1 \u2264 l \u2264 r \u2264 n and there is at least one pair of integers x, k such that 1 \u2264 x, k \u2264 n, l \u2264 x < x + 2k \u2264 r, and s_x = s_{x+k} = s_{x+2k}. Additionally, Rash can provide an optional threshold m. If m is provided, the function should only return the number of pairs if it is greater than m, otherwise return 0. The function should maintain backward compatibility and support the original function parameters, with the addition of type hints and the new optional parameter m.", "new_solution": "def apps_run2(s: str, m: int = 0) -> int:\n    X = [[], ['0', '1'], ['00', '01', '10', '11'], ['001', '010', '011', '100', '101', '110'], ['0010', '0011', '0100', '0101', '0110', '1001', '1010', '1011', '1100', '1101'], ['00100', '00101', '00110', '01001', '01011', '01100', '01101', '10010', '10011', '10100', '10110', '11001', '11010', '11011'], ['001001', '001011', '001100', '001101', '010010', '010011', '010110', '011001', '011010', '011011', '100100', '100101', '100110', '101001', '101100', '101101', '110010', '110011', '110100', '110110'], ['0010011', '0011001', '0011010', '0011011', '0100101', '0101100', '0101101', '0110011', '1001100', '1010010', '1010011', '1011010', '1100100', '1100101', '1100110', '1101100'], ['00110011', '01011010', '01100110', '10011001', '10100101', '11001100']]\n    N = len(s)\n    ans = (N-1)*(N-2)//2\n    for i in range(N):\n        for j in range(i+3, min(i+9, N+1)):\n            if s[i:j] in X[j-i]:\n                ans -= 1\n    return ans if ans > m else 0", "input_format": "The first parameter contains the string s (1 \u2264 |s| \u2264 300,000), consisting of zeros and ones. Optionally, a second parameter may contain an integer m (1 \u2264 m \u2264 10^9) representing a threshold for the number of pairs.", "output_format": "Output one integer: the number of such pairs of integers l, r that 1 \u2264 l \u2264 r \u2264 n and there is at least one pair of integers x, k such that 1 \u2264 x, k \u2264 n, l \u2264 x < x + 2k \u2264 r, and s_x = s_{x+k} = s_{x+2k}. If m is provided, output the number of pairs only if it is greater than m, otherwise output 0.", "test_input": ["assert apps_run2('010101') == 3", "assert apps_run2('11001100') == 0", "assert apps_run2('010101', 2) == 3", "assert apps_run2('010101', 3) == 0", "assert apps_run2('111000111', 25) == 0"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "APPS/2005-1", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nToad Rash has a binary string $s$. A binary string consists only of zeros and ones.\n\nLet $n$ be the length of $s$.\n\nRash needs to find the number of such pairs of integers $l$, $r$ that $1 \\leq l \\leq r \\leq n$ and there is at least one pair of integers $x$, $k$ such that $1 \\leq x, k \\leq n$, $l \\leq x < x + 2k \\leq r$, and $s_x = s_{x+k} = s_{x+2k}$.\n\nFind this number of pairs for Rash.\n\n\n-----Input-----\n\nThe first line contains the string $s$ ($1 \\leq |s| \\leq 300\\,000$), consisting of zeros and ones.\n\n\n-----Output-----\n\nOutput one integer: the number of such pairs of integers $l$, $r$ that $1 \\leq l \\leq r \\leq n$ and there is at least one pair of integers $x$, $k$ such that $1 \\leq x, k \\leq n$, $l \\leq x < x + 2k \\leq r$, and $s_x = s_{x+k} = s_{x+2k}$.\n\n\n-----Examples-----\nInput\n010101\n\nOutput\n3\n\nInput\n11001100\n\nOutput\n0\n\n\n\n-----Note-----\n\nIn the first example, there are three $l$, $r$ pairs we need to count: $1$, $6$; $2$, $6$; and $1$, $5$.\n\nIn the second example, there are no values $x$, $k$ for the initial string, so the answer is $0$.", "raw_solution": "def apps_run1(s):\n    X = [[], ['0', '1'], ['00', '01', '10', '11'], ['001', '010', '011', '100', '101', '110'], ['0010', '0011', '0100', '0101', '0110', '1001', '1010', '1011', '1100', '1101'], ['00100', '00101', '00110', '01001', '01011', '01100', '01101', '10010', '10011', '10100', '10110', '11001', '11010', '11011'], ['001001', '001011', '001100', '001101', '010010', '010011', '010110', '011001', '011010', '011011', '100100', '100101', '100110', '101001', '101100', '101101', '110010', '110011', '110100', '110110'], ['0010011', '0011001', '0011010', '0011011', '0100101', '0101100', '0101101', '0110011', '1001100', '1010010', '1010011', '1011010', '1100100', '1100101', '1100110', '1101100'], ['00110011', '01011010', '01100110', '10011001', '10100101', '11001100']]\n    N = len(s)\n    ans = (N-1)*(N-2)//2\n    for i in range(N):\n        for j in range(i+3, min(i+9, N+1)):\n            if s[i:j] in X[j-i]:\n                ans -= 1\n    return ans", "raw_test_input": ["assert apps_run1('010101') == 3", "assert apps_run1('11001100') == 0", "assert apps_run1('0') == 0", "assert apps_run1('00') == 0", "assert apps_run1('01') == 0", "assert apps_run1('000') == 1", "assert apps_run1('100') == 0", "assert apps_run1('001') == 0", "assert apps_run1('101') == 0", "assert apps_run1('0000') == 3", "assert apps_run1('0100101110') == 16", "assert apps_run1('1101111000011110111111110101100111111110111100001111011010111001101100010110000001010101101010111000') == 4672", "assert apps_run1('1000') == 2", "assert apps_run1('0010') == 0", "assert apps_run1('1010') == 0", "assert apps_run1('0001') == 2", "assert apps_run1('1001') == 0", "assert apps_run1('0011') == 0", "assert apps_run1('1011') == 0"], "new_problem": "In a financial system, each transaction is represented as a binary string. A transaction is considered 'stable' if there exists a subsequence within the transaction that follows a specific pattern. The pattern is defined as having at least one pair of integers x, k such that 1 \u2264 x, k \u2264 n, l \u2264 x < x + 2k \u2264 r, and s_x = s_{x+k} = s_{x+2k}. Given a list of binary strings, determine the number of stable subsequences for each transaction. This can help in identifying stable transaction patterns over time.", "new_solution": "def count_stable_subsequences(s):\n    X = [[], ['0', '1'], ['00', '01', '10', '11'], ['001', '010', '011', '100', '101', '110'], ['0010', '0011', '0100', '0101', '0110', '1001', '1010', '1011', '1100', '1101'], ['00100', '00101', '00110', '01001', '01011', '01100', '01101', '10010', '10011', '10100', '10110', '11001', '11010', '11011'], ['001001', '001011', '001100', '001101', '010010', '010011', '010110', '011001', '011010', '011011', '100100', '100101', '100110', '101001', '101100', '101101', '110010', '110011', '110100', '110110'], ['0010011', '0011001', '0011010', '0011011', '0100101', '0101100', '0101101', '0110011', '1001100', '1010010', '1010011', '1011010', '1100100', '1100101', '1100110', '1101100'], ['00110011', '01011010', '01100110', '10011001', '10100101', '11001100']]\n    N = len(s)\n    ans = (N-1)*(N-2)//2\n    for i in range(N):\n        for j in range(i+3, min(i+9, N+1)):\n            if s[i:j] in X[j-i]:\n                ans -= 1\n    return ans\n\ndef apps_run2(transactions):\n    results = []\n    for transaction in transactions:\n        result = count_stable_subsequences(transaction)\n        results.append(result)\n    return results", "input_format": "A list of binary strings representing different transactions in a financial system.", "output_format": "A list of integers where each integer represents the number of valid (l, r) pairs for the corresponding binary string.", "test_input": ["assert apps_run2(['010101', '11001100', '111000111', '1010101010', '000111000']) == [3, 0, 22, 21, 22]", "assert apps_run2(['111111', '000000', '101010', '110110', '001001']) == [10, 10, 3, 0, 0]", "assert apps_run2(['101', '010', '111', '000', '110']) == [0, 0, 1, 1, 0]", "assert apps_run2(['001001', '010101', '110110', '101101', '011011']) == [0, 3, 0, 0, 0]", "assert apps_run2(['110', '101', '011', '100', '111']) == [0, 0, 0, 0, 1]"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "APPS/2005-3", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nToad Rash has a binary string $s$. A binary string consists only of zeros and ones.\n\nLet $n$ be the length of $s$.\n\nRash needs to find the number of such pairs of integers $l$, $r$ that $1 \\leq l \\leq r \\leq n$ and there is at least one pair of integers $x$, $k$ such that $1 \\leq x, k \\leq n$, $l \\leq x < x + 2k \\leq r$, and $s_x = s_{x+k} = s_{x+2k}$.\n\nFind this number of pairs for Rash.\n\n\n-----Input-----\n\nThe first line contains the string $s$ ($1 \\leq |s| \\leq 300\\,000$), consisting of zeros and ones.\n\n\n-----Output-----\n\nOutput one integer: the number of such pairs of integers $l$, $r$ that $1 \\leq l \\leq r \\leq n$ and there is at least one pair of integers $x$, $k$ such that $1 \\leq x, k \\leq n$, $l \\leq x < x + 2k \\leq r$, and $s_x = s_{x+k} = s_{x+2k}$.\n\n\n-----Examples-----\nInput\n010101\n\nOutput\n3\n\nInput\n11001100\n\nOutput\n0\n\n\n\n-----Note-----\n\nIn the first example, there are three $l$, $r$ pairs we need to count: $1$, $6$; $2$, $6$; and $1$, $5$.\n\nIn the second example, there are no values $x$, $k$ for the initial string, so the answer is $0$.", "raw_solution": "def apps_run1(s):\n    X = [[], ['0', '1'], ['00', '01', '10', '11'], ['001', '010', '011', '100', '101', '110'], ['0010', '0011', '0100', '0101', '0110', '1001', '1010', '1011', '1100', '1101'], ['00100', '00101', '00110', '01001', '01011', '01100', '01101', '10010', '10011', '10100', '10110', '11001', '11010', '11011'], ['001001', '001011', '001100', '001101', '010010', '010011', '010110', '011001', '011010', '011011', '100100', '100101', '100110', '101001', '101100', '101101', '110010', '110011', '110100', '110110'], ['0010011', '0011001', '0011010', '0011011', '0100101', '0101100', '0101101', '0110011', '1001100', '1010010', '1010011', '1011010', '1100100', '1100101', '1100110', '1101100'], ['00110011', '01011010', '01100110', '10011001', '10100101', '11001100']]\n    N = len(s)\n    ans = (N-1)*(N-2)//2\n    for i in range(N):\n        for j in range(i+3, min(i+9, N+1)):\n            if s[i:j] in X[j-i]:\n                ans -= 1\n    return ans", "raw_test_input": ["assert apps_run1('010101') == 3", "assert apps_run1('11001100') == 0", "assert apps_run1('0') == 0", "assert apps_run1('00') == 0", "assert apps_run1('01') == 0", "assert apps_run1('000') == 1", "assert apps_run1('100') == 0", "assert apps_run1('001') == 0", "assert apps_run1('101') == 0", "assert apps_run1('0000') == 3", "assert apps_run1('0100101110') == 16", "assert apps_run1('1101111000011110111111110101100111111110111100001111011010111001101100010110000001010101101010111000') == 4672", "assert apps_run1('1000') == 2", "assert apps_run1('0010') == 0", "assert apps_run1('1010') == 0", "assert apps_run1('0001') == 2", "assert apps_run1('1001') == 0", "assert apps_run1('0011') == 0", "assert apps_run1('1011') == 0"], "new_problem": "Toad Rash has a binary string s. A binary string consists only of zeros and ones. Let n be the length of s. Rash needs to find the number of such pairs of integers l, r that 1 \u2264 l \u2264 r \u2264 n and there is at least one pair of integers x, k such that 1 \u2264 x, k \u2264 n, l \u2264 x < x + 2k \u2264 r, and s_x = s_{x+k} = s_{x+2k}. However, this time, Rash wants to optimize the solution using a dictionary to store previously computed results for subproblems to avoid redundant calculations. Additionally, the solution should handle more complex data relationships by considering overlapping subproblems and should include type hints. The solution should also be able to handle strings with a maximum length of 500,000.", "new_solution": "from typing import Dict, Tuple\n\ndef apps_run2(s: str) -> int:\n    X = [[], ['0', '1'], ['00', '01', '10', '11'], ['001', '010', '011', '100', '101', '110'], ['0010', '0011', '0100', '0101', '0110', '1001', '1010', '1011', '1100', '1101'], ['00100', '00101', '00110', '01001', '01011', '01100', '01101', '10010', '10011', '10100', '10110', '11001', '11010', '11011'], ['001001', '001011', '001100', '001101', '010010', '010011', '010110', '011001', '011010', '011011', '100100', '100101', '100110', '101001', '101100', '101101', '110010', '110011', '110100', '110110'], ['0010011', '0011001', '0011010', '0011011', '0100101', '0101100', '0101101', '0110011', '1001100', '1010010', '1010011', '1011010', '1100100', '1100101', '1100110', '1101100'], ['00110011', '01011010', '01100110', '10011001', '10100101', '11001100']]\n    N = len(s)\n    ans = (N-1)*(N-2)//2\n    memo: Dict[Tuple[int, int], bool] = {}\n    for i in range(N):\n        for j in range(i+3, min(i+9, N+1)):\n            if (i, j) not in memo:\n                memo[(i, j)] = s[i:j] in X[j-i]\n            if memo[(i, j)]:\n                ans -= 1\n    return ans", "input_format": "The first parameter contains the string s (1 \u2264 |s| \u2264 300,000), consisting of zeros and ones.", "output_format": "Output one integer: the number of such pairs of integers l, r that 1 \u2264 l \u2264 r \u2264 n and there is at least one pair of integers x, k such that 1 \u2264 x, k \u2264 n, l \u2264 x < x + 2k \u2264 r, and s_x = s_{x+k} = s_{x+2k}.", "test_input": ["assert apps_run2('010101') == 3", "assert apps_run2('11001100') == 0", "assert apps_run2('000000') == 10", "assert apps_run2('111111') == 10", "assert apps_run2('1010101010') == 21"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "APPS/2005-4", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nToad Rash has a binary string $s$. A binary string consists only of zeros and ones.\n\nLet $n$ be the length of $s$.\n\nRash needs to find the number of such pairs of integers $l$, $r$ that $1 \\leq l \\leq r \\leq n$ and there is at least one pair of integers $x$, $k$ such that $1 \\leq x, k \\leq n$, $l \\leq x < x + 2k \\leq r$, and $s_x = s_{x+k} = s_{x+2k}$.\n\nFind this number of pairs for Rash.\n\n\n-----Input-----\n\nThe first line contains the string $s$ ($1 \\leq |s| \\leq 300\\,000$), consisting of zeros and ones.\n\n\n-----Output-----\n\nOutput one integer: the number of such pairs of integers $l$, $r$ that $1 \\leq l \\leq r \\leq n$ and there is at least one pair of integers $x$, $k$ such that $1 \\leq x, k \\leq n$, $l \\leq x < x + 2k \\leq r$, and $s_x = s_{x+k} = s_{x+2k}$.\n\n\n-----Examples-----\nInput\n010101\n\nOutput\n3\n\nInput\n11001100\n\nOutput\n0\n\n\n\n-----Note-----\n\nIn the first example, there are three $l$, $r$ pairs we need to count: $1$, $6$; $2$, $6$; and $1$, $5$.\n\nIn the second example, there are no values $x$, $k$ for the initial string, so the answer is $0$.", "raw_solution": "def apps_run1(s):\n    X = [[], ['0', '1'], ['00', '01', '10', '11'], ['001', '010', '011', '100', '101', '110'], ['0010', '0011', '0100', '0101', '0110', '1001', '1010', '1011', '1100', '1101'], ['00100', '00101', '00110', '01001', '01011', '01100', '01101', '10010', '10011', '10100', '10110', '11001', '11010', '11011'], ['001001', '001011', '001100', '001101', '010010', '010011', '010110', '011001', '011010', '011011', '100100', '100101', '100110', '101001', '101100', '101101', '110010', '110011', '110100', '110110'], ['0010011', '0011001', '0011010', '0011011', '0100101', '0101100', '0101101', '0110011', '1001100', '1010010', '1010011', '1011010', '1100100', '1100101', '1100110', '1101100'], ['00110011', '01011010', '01100110', '10011001', '10100101', '11001100']]\n    N = len(s)\n    ans = (N-1)*(N-2)//2\n    for i in range(N):\n        for j in range(i+3, min(i+9, N+1)):\n            if s[i:j] in X[j-i]:\n                ans -= 1\n    return ans", "raw_test_input": ["assert apps_run1('010101') == 3", "assert apps_run1('11001100') == 0", "assert apps_run1('0') == 0", "assert apps_run1('00') == 0", "assert apps_run1('01') == 0", "assert apps_run1('000') == 1", "assert apps_run1('100') == 0", "assert apps_run1('001') == 0", "assert apps_run1('101') == 0", "assert apps_run1('0000') == 3", "assert apps_run1('0100101110') == 16", "assert apps_run1('1101111000011110111111110101100111111110111100001111011010111001101100010110000001010101101010111000') == 4672", "assert apps_run1('1000') == 2", "assert apps_run1('0010') == 0", "assert apps_run1('1010') == 0", "assert apps_run1('0001') == 2", "assert apps_run1('1001') == 0", "assert apps_run1('0011') == 0", "assert apps_run1('1011') == 0"], "new_problem": "Toad Rash has a binary string s. A binary string consists only of zeros and ones. Let n be the length of s. Rash needs to find the number of such pairs of integers l, r that 1 <= l <= r <= n and there is at least one pair of integers x, k such that 1 <= x, k <= n, l <= x < x + 2k <= r, and s_x = s_{x+k} = s_{x+2k}. However, the function should handle the following errors: 1. InvalidCharacterError: Raised if the string contains characters other than '0' or '1'. 2. StringTooShortError: Raised if the string length is less than 3, as no valid l, r pairs can exist. 3. StringTooLongError: Raised if the string length exceeds 300,000. Implement error handling to manage these scenarios and propagate meaningful error messages.", "new_solution": "class InvalidCharacterError(Exception):\n    pass\n\nclass StringTooShortError(Exception):\n    pass\n\nclass StringTooLongError(Exception):\n    pass\n\ndef apps_run2(s: str) -> int:\n    if any(c not in '01' for c in s):\n        raise InvalidCharacterError(\"The string contains invalid characters. Only '0' and '1' are allowed.\")\n    if len(s) < 3:\n        raise StringTooShortError(\"The string is too short to form any valid pairs.\")\n    if len(s) > 300000:\n        raise StringTooLongError(\"The string exceeds the maximum allowed length of 300,000.\")\n\n    X = [[], ['0', '1'], ['00', '01', '10', '11'], ['001', '010', '011', '100', '101', '110'], ['0010', '0011', '0100', '0101', '0110', '1001', '1010', '1011', '1100', '1101'], ['00100', '00101', '00110', '01001', '01011', '01100', '01101', '10010', '10011', '10100', '10110', '11001', '11010', '11011'], ['001001', '001011', '001100', '001101', '010010', '010011', '010110', '011001', '011010', '011011', '100100', '100101', '100110', '101001', '101100', '101101', '110010', '110011', '110100', '110110'], ['0010011', '0011001', '0011010', '0011011', '0100101', '0101100', '0101101', '0110011', '1001100', '1010010', '1010011', '1011010', '1100100', '1100101', '1100110', '1101100'], ['00110011', '01011010', '01100110', '10011001', '10100101', '11001100']]\n    N = len(s)\n    ans = (N-1)*(N-2)//2\n    for i in range(N):\n        for j in range(i+3, min(i+9, N+1)):\n            if s[i:j] in X[j-i]:\n                ans -= 1\n    return ans", "input_format": "A binary string s (1 <= |s| <= 300,000), consisting of zeros and ones.", "output_format": "One integer: the number of such pairs of integers l, r that satisfy the given conditions.", "test_input": ["assert apps_run2('010101') == 3", "assert apps_run2('11001100') == 0", "try:\n    apps_run2('012345')\nexcept InvalidCharacterError as e:\n    assert str(e) == \"The string contains invalid characters. Only '0' and '1' are allowed.\"", "try:\n    apps_run2('')\nexcept StringTooShortError as e:\n    assert str(e) == \"The string is too short to form any valid pairs.\"", "try:\n    apps_run2('0' * 300001)\nexcept StringTooLongError as e:\n    assert str(e) == \"The string exceeds the maximum allowed length of 300,000.\""], "requirement_type": "PROMPT_ERROR_HANDLING"}
{"task_id": "APPS/2002-1", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nVasya and Kolya play a game with a string, using the following rules. Initially, Kolya creates a string s, consisting of small English letters, and uniformly at random chooses an integer k from a segment [0, len(s) - 1]. He tells Vasya this string s, and then shifts it k letters to the left, i.\u00a0e. creates a new string t = s_{k} + 1s_{k} + 2... s_{n}s_1s_2... s_{k}. Vasya does not know the integer k nor the string t, but he wants to guess the integer k. To do this, he asks Kolya to tell him the first letter of the new string, and then, after he sees it, open one more letter on some position, which Vasya can choose.\n\nVasya understands, that he can't guarantee that he will win, but he wants to know the probability of winning, if he plays optimally. He wants you to compute this probability. \n\nNote that Vasya wants to know the value of k uniquely, it means, that if there are at least two cyclic shifts of s that fit the information Vasya knowns, Vasya loses. Of course, at any moment of the game Vasya wants to maximize the probability of his win.\n\n\n-----Input-----\n\nThe only string contains the string s of length l (3 \u2264 l \u2264 5000), consisting of small English letters only.\n\n\n-----Output-----\n\nPrint the only number\u00a0\u2014 the answer for the problem. You answer is considered correct, if its absolute or relative error does not exceed 10^{ - 6}.\n\nFormally, let your answer be a, and the jury's answer be b. Your answer is considered correct if $\\frac{|a - b|}{\\operatorname{max}(1,|b|)} \\leq 10^{-6}$\n\n\n-----Examples-----\nInput\ntechnocup\n\nOutput\n1.000000000000000\n\nInput\ntictictactac\n\nOutput\n0.333333333333333\n\nInput\nbbaabaabbb\n\nOutput\n0.100000000000000\n\n\n\n-----Note-----\n\nIn the first example Vasya can always open the second letter after opening the first letter, and the cyclic shift is always determined uniquely.\n\nIn the second example if the first opened letter of t is \"t\" or \"c\", then Vasya can't guess the shift by opening only one other letter. On the other hand, if the first letter is \"i\" or \"a\", then he can open the fourth letter and determine the shift uniquely.", "raw_solution": "def apps_run1(s):\n    l = len(s)\n    a = [0] * (2 * l)\n    pos = [[] for i in range(26)]\n    for i, c in enumerate(s):\n        t = ord(c) - ord('a')\n        a[i] = t\n        a[i + l] = t\n        pos[t].append(i)\n    ans = 0\n    for c in range(26):\n        cur = 0\n        for k in range(1, l):\n            cnt = [0] * 26\n            for i in pos[c]:\n                cnt[a[i + k]] += 1\n            cur = max(cur, len(list([x for x in cnt if x == 1])))\n        ans += cur\n    return ans / l\n", "raw_test_input": ["assert apps_run1('technocup') == 1.000000000000000", "assert apps_run1('tictictactac') == 0.3333333333333333", "assert apps_run1('bbaabaabbb') == 0.100000000000000", "assert apps_run1('cbbbbcaaca') == 0.800000000000000", "assert apps_run1('cadbcdddda') == 0.800000000000000", "assert apps_run1('bababbdaee') == 1.000000000000000", "assert apps_run1('fabbbhgedd') == 1.000000000000000", "assert apps_run1('gaejllebhn') == 1.000000000000000", "assert apps_run1('bbababaaababaabbbbbabbbbbbaaabbabaaaaabbbbbaaaabbbbabaabaabababbbabbabbabaaababbabbababaaaaabaaaabbb') == 0.000000000000000", "assert apps_run1('eaaebccaeacdecaedcaabbbdeebccdcdaabeeaeeaddbaabdccebecebbbbedbdcbbbbbbecbaddcddcccdcbbadbecddecedbba') == 0.080000000000000", "assert apps_run1('hcdhgcchbdhbeagdcfedgcbaffebgcbcccadeefacbhefgeadfgchabgeebegahfgegahbddedfhffeadcedadgfbeebhgfahhfb') == 0.450000000000000", "assert apps_run1('difhjdjbcdjedhiegagdejkbjfcdcdagdijdjajecbheiabfbjdgjdecfhdkgdbkcgcgakkiiggfkgcfadkjhiijkjacgejfhjge') == 0.840000000000000", "assert apps_run1('khjcoijiicdkdianmdolmadobdkcmgifdnffddnjehhbldlkjffknficdcmokfacioiegjedbmadjioomdacbodcajcmonmnlabo') == 0.960000000000000", "assert apps_run1('kpsaloedscghjeaqadfhmlibjepjafdomkkorinrpakondtnrnknbqarbejcenrlsbfgdbsdmkpphbkdnbitjfcofsjibssmmlll') == 1.000000000000000", "assert apps_run1('jkeaagakbifeaechkifkdghcjcgighidcgdccfbdbcackfgaebkddabgijkhjkaffkabacekdkjekeccegbecbkecbgbgcacgdackcdfjefaifgbigahkbedidfhjbikejdhejcgideaeejdcegeeccaefbddejkbdkfagfcdjbikbidfggkidcdcic') == 0.4385026737967914", "assert apps_run1('ibledofnibedebifmnjdoaijeghajecbkjaebbkofnacceaodiifbhgkihkibddneeiemacodeafeaiiiaoajhmkjffbmmiehebhokfklhbkeoanoajdedjdlkbhenidclagggfhhhldfleccgmjbkhaginlhabkabagikalccndciokabfaebjkndf') == 0.786096256684492", "assert apps_run1('aaabbbaaaabbbbaaabbbbbaabbbbaaababbaaabbbbaaabbbbababbbbaaabbbbaaabbbbbaabbbbaaabbbbaaabbbb') == 0.000000000000000", "assert apps_run1('abbbaababbbaababbbaababbbaababbbaababbbaababbbaababbbaababbbaababbbaababbbaababbbaababbbaab') == 0.000000000000000", "assert apps_run1('abbacba') == 1.000000000000000"], "new_problem": "In a competitive gaming platform, multiple players are playing the Vasya and Kolya string shifting game simultaneously. Each player is given a different string, and they need to determine the probability of Vasya winning for their respective strings. Your task is to write a function that takes a list of strings, each representing a game scenario, and returns a list of probabilities, each representing the probability of Vasya winning for the corresponding input string. The function should utilize the original function to compute the probability for each string.", "new_solution": "def calculate_probability(s):\n    l = len(s)\n    a = [0] * (2 * l)\n    pos = [[] for i in range(26)]\n    for i, c in enumerate(s):\n        t = ord(c) - ord('a')\n        a[i] = t\n        a[i + l] = t\n        pos[t].append(i)\n    ans = 0\n    for c in range(26):\n        cur = 0\n        for k in range(1, l):\n            cnt = [0] * 26\n            for i in pos[c]:\n                cnt[a[i + k]] += 1\n            cur = max(cur, len(list([x for x in cnt if x == 1])))\n        ans += cur\n    return ans / l\n\ndef apps_run2(strings):\n    return [calculate_probability(s) for s in strings]", "input_format": "A list of strings, each representing a game scenario where Vasya and Kolya play the string shifting game.", "output_format": "A list of probabilities, each representing the probability of Vasya winning for the corresponding input string.", "test_input": ["assert apps_run2(['technocup', 'tictictactac', 'bbaabaabbb']) == [1.0, 0.3333333333333333, 0.1]", "assert apps_run2(['abcabcabc', 'xyzxyzxyz', 'abababab']) == [0.0, 0.0, 0.0]", "assert apps_run2(['aaaa', 'bbbb', 'cccc']) == [0.0, 0.0, 0.0]", "assert apps_run2(['abcdef', 'ghijkl', 'mnopqr']) == [1.0, 1.0, 1.0]", "assert apps_run2(['aabbcc', 'ddeeff', 'gghhii']) == [1.0, 1.0, 1.0]"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "APPS/2002-2", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nVasya and Kolya play a game with a string, using the following rules. Initially, Kolya creates a string s, consisting of small English letters, and uniformly at random chooses an integer k from a segment [0, len(s) - 1]. He tells Vasya this string s, and then shifts it k letters to the left, i.\u00a0e. creates a new string t = s_{k} + 1s_{k} + 2... s_{n}s_1s_2... s_{k}. Vasya does not know the integer k nor the string t, but he wants to guess the integer k. To do this, he asks Kolya to tell him the first letter of the new string, and then, after he sees it, open one more letter on some position, which Vasya can choose.\n\nVasya understands, that he can't guarantee that he will win, but he wants to know the probability of winning, if he plays optimally. He wants you to compute this probability. \n\nNote that Vasya wants to know the value of k uniquely, it means, that if there are at least two cyclic shifts of s that fit the information Vasya knowns, Vasya loses. Of course, at any moment of the game Vasya wants to maximize the probability of his win.\n\n\n-----Input-----\n\nThe only string contains the string s of length l (3 \u2264 l \u2264 5000), consisting of small English letters only.\n\n\n-----Output-----\n\nPrint the only number\u00a0\u2014 the answer for the problem. You answer is considered correct, if its absolute or relative error does not exceed 10^{ - 6}.\n\nFormally, let your answer be a, and the jury's answer be b. Your answer is considered correct if $\\frac{|a - b|}{\\operatorname{max}(1,|b|)} \\leq 10^{-6}$\n\n\n-----Examples-----\nInput\ntechnocup\n\nOutput\n1.000000000000000\n\nInput\ntictictactac\n\nOutput\n0.333333333333333\n\nInput\nbbaabaabbb\n\nOutput\n0.100000000000000\n\n\n\n-----Note-----\n\nIn the first example Vasya can always open the second letter after opening the first letter, and the cyclic shift is always determined uniquely.\n\nIn the second example if the first opened letter of t is \"t\" or \"c\", then Vasya can't guess the shift by opening only one other letter. On the other hand, if the first letter is \"i\" or \"a\", then he can open the fourth letter and determine the shift uniquely.", "raw_solution": "def apps_run1(s):\n    l = len(s)\n    a = [0] * (2 * l)\n    pos = [[] for i in range(26)]\n    for i, c in enumerate(s):\n        t = ord(c) - ord('a')\n        a[i] = t\n        a[i + l] = t\n        pos[t].append(i)\n    ans = 0\n    for c in range(26):\n        cur = 0\n        for k in range(1, l):\n            cnt = [0] * 26\n            for i in pos[c]:\n                cnt[a[i + k]] += 1\n            cur = max(cur, len(list([x for x in cnt if x == 1])))\n        ans += cur\n    return ans / l\n", "raw_test_input": ["assert apps_run1('technocup') == 1.000000000000000", "assert apps_run1('tictictactac') == 0.3333333333333333", "assert apps_run1('bbaabaabbb') == 0.100000000000000", "assert apps_run1('cbbbbcaaca') == 0.800000000000000", "assert apps_run1('cadbcdddda') == 0.800000000000000", "assert apps_run1('bababbdaee') == 1.000000000000000", "assert apps_run1('fabbbhgedd') == 1.000000000000000", "assert apps_run1('gaejllebhn') == 1.000000000000000", "assert apps_run1('bbababaaababaabbbbbabbbbbbaaabbabaaaaabbbbbaaaabbbbabaabaabababbbabbabbabaaababbabbababaaaaabaaaabbb') == 0.000000000000000", "assert apps_run1('eaaebccaeacdecaedcaabbbdeebccdcdaabeeaeeaddbaabdccebecebbbbedbdcbbbbbbecbaddcddcccdcbbadbecddecedbba') == 0.080000000000000", "assert apps_run1('hcdhgcchbdhbeagdcfedgcbaffebgcbcccadeefacbhefgeadfgchabgeebegahfgegahbddedfhffeadcedadgfbeebhgfahhfb') == 0.450000000000000", "assert apps_run1('difhjdjbcdjedhiegagdejkbjfcdcdagdijdjajecbheiabfbjdgjdecfhdkgdbkcgcgakkiiggfkgcfadkjhiijkjacgejfhjge') == 0.840000000000000", "assert apps_run1('khjcoijiicdkdianmdolmadobdkcmgifdnffddnjehhbldlkjffknficdcmokfacioiegjedbmadjioomdacbodcajcmonmnlabo') == 0.960000000000000", "assert apps_run1('kpsaloedscghjeaqadfhmlibjepjafdomkkorinrpakondtnrnknbqarbejcenrlsbfgdbsdmkpphbkdnbitjfcofsjibssmmlll') == 1.000000000000000", "assert apps_run1('jkeaagakbifeaechkifkdghcjcgighidcgdccfbdbcackfgaebkddabgijkhjkaffkabacekdkjekeccegbecbkecbgbgcacgdackcdfjefaifgbigahkbedidfhjbikejdhejcgideaeejdcegeeccaefbddejkbdkfagfcdjbikbidfggkidcdcic') == 0.4385026737967914", "assert apps_run1('ibledofnibedebifmnjdoaijeghajecbkjaebbkofnacceaodiifbhgkihkibddneeiemacodeafeaiiiaoajhmkjffbmmiehebhokfklhbkeoanoajdedjdlkbhenidclagggfhhhldfleccgmjbkhaginlhabkabagikalccndciokabfaebjkndf') == 0.786096256684492", "assert apps_run1('aaabbbaaaabbbbaaabbbbbaabbbbaaababbaaabbbbaaabbbbababbbbaaabbbbaaabbbbbaabbbbaaabbbbaaabbbb') == 0.000000000000000", "assert apps_run1('abbbaababbbaababbbaababbbaababbbaababbbaababbbaababbbaababbbaababbbaababbbaababbbaababbbaab') == 0.000000000000000", "assert apps_run1('abbacba') == 1.000000000000000"], "new_problem": "Vasya and Kolya play a game with a string, using the following rules. Initially, Kolya creates a string s, consisting of small English letters, and uniformly at random chooses an integer k from a segment [0, len(s) - 1]. He tells Vasya this string s, and then shifts it k letters to the left, i.e., creates a new string t = s_{k} + 1s_{k} + 2... s_{n}s_1s_2... s_{k}. Vasya does not know the integer k nor the string t, but he wants to guess the integer k. To do this, he asks Kolya to tell him the first letter of the new string, and then, after he sees it, open one more letter on some position, which Vasya can choose. Vasya understands that he can't guarantee that he will win, but he wants to know the probability of winning if he plays optimally. He wants you to compute this probability. Additionally, Vasya wants to know detailed information about the possible shifts if requested. Implement a function that maintains backward compatibility with existing implementations, supports the original function parameters, includes type hints, and adds a new optional parameter detailed_output. If detailed_output is True, return a dictionary with detailed information about the possible shifts and the keys in this dictionary should only contain the letters in the string s.", "new_solution": "from typing import Tuple, Union, Dict\n\ndef apps_run2(s: str, detailed_output: bool = False) -> Union[float, Tuple[float, Dict[str, int]]]:\n    l = len(s)\n    a = [0] * (2 * l)\n    pos = [[] for _ in range(26)]\n    for i, c in enumerate(s):\n        t = ord(c) - ord('a')\n        a[i] = t\n        a[i + l] = t\n        pos[t].append(i)\n    ans = 0\n    detailed_info = {}\n    for c in range(26):\n        cur = 0\n        for k in range(1, l):\n            cnt = [0] * 26\n            for i in pos[c]:\n                cnt[a[i + k]] += 1\n            cur = max(cur, len(list([x for x in cnt if x == 1])))\n        ans += cur\n        if detailed_output and chr(c + ord('a')) in list(s):\n            detailed_info[chr(c + ord('a'))] = cur\n    probability = ans / l\n    if detailed_output:\n        return probability, detailed_info\n    return probability", "input_format": "A string s of length l (3 \u2264 l \u2264 5000), consisting of small English letters only, and an optional boolean parameter detailed_output.", "output_format": "A float representing the probability of Vasya winning, and optionally a dictionary with detailed information if detailed_output is True. And the keys in this dictionary should only contain the letters in the string s", "test_input": ["assert apps_run2('technocup') == 1.0", "assert apps_run2('tictictactac') == 0.3333333333333333", "assert apps_run2('bbaabaabbb') == 0.1", "assert apps_run2('technocup', detailed_output=True) == (1.0, {'c': 2, 'e': 1, 'h': 1, 'n': 1, 'o': 1, 'p': 1, 't': 1, 'u': 1})", "assert apps_run2('tictictactac', detailed_output=True)[0] == 0.3333333333333333"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "APPS/2002-3", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nVasya and Kolya play a game with a string, using the following rules. Initially, Kolya creates a string s, consisting of small English letters, and uniformly at random chooses an integer k from a segment [0, len(s) - 1]. He tells Vasya this string s, and then shifts it k letters to the left, i.\u00a0e. creates a new string t = s_{k} + 1s_{k} + 2... s_{n}s_1s_2... s_{k}. Vasya does not know the integer k nor the string t, but he wants to guess the integer k. To do this, he asks Kolya to tell him the first letter of the new string, and then, after he sees it, open one more letter on some position, which Vasya can choose.\n\nVasya understands, that he can't guarantee that he will win, but he wants to know the probability of winning, if he plays optimally. He wants you to compute this probability. \n\nNote that Vasya wants to know the value of k uniquely, it means, that if there are at least two cyclic shifts of s that fit the information Vasya knowns, Vasya loses. Of course, at any moment of the game Vasya wants to maximize the probability of his win.\n\n\n-----Input-----\n\nThe only string contains the string s of length l (3 \u2264 l \u2264 5000), consisting of small English letters only.\n\n\n-----Output-----\n\nPrint the only number\u00a0\u2014 the answer for the problem. You answer is considered correct, if its absolute or relative error does not exceed 10^{ - 6}.\n\nFormally, let your answer be a, and the jury's answer be b. Your answer is considered correct if $\\frac{|a - b|}{\\operatorname{max}(1,|b|)} \\leq 10^{-6}$\n\n\n-----Examples-----\nInput\ntechnocup\n\nOutput\n1.000000000000000\n\nInput\ntictictactac\n\nOutput\n0.333333333333333\n\nInput\nbbaabaabbb\n\nOutput\n0.100000000000000\n\n\n\n-----Note-----\n\nIn the first example Vasya can always open the second letter after opening the first letter, and the cyclic shift is always determined uniquely.\n\nIn the second example if the first opened letter of t is \"t\" or \"c\", then Vasya can't guess the shift by opening only one other letter. On the other hand, if the first letter is \"i\" or \"a\", then he can open the fourth letter and determine the shift uniquely.", "raw_solution": "def apps_run1(s):\n    l = len(s)\n    a = [0] * (2 * l)\n    pos = [[] for i in range(26)]\n    for i, c in enumerate(s):\n        t = ord(c) - ord('a')\n        a[i] = t\n        a[i + l] = t\n        pos[t].append(i)\n    ans = 0\n    for c in range(26):\n        cur = 0\n        for k in range(1, l):\n            cnt = [0] * 26\n            for i in pos[c]:\n                cnt[a[i + k]] += 1\n            cur = max(cur, len(list([x for x in cnt if x == 1])))\n        ans += cur\n    return ans / l", "raw_test_input": ["assert apps_run1('technocup') == 1.000000000000000", "assert apps_run1('tictictactac') == 0.3333333333333333", "assert apps_run1('bbaabaabbb') == 0.100000000000000", "assert apps_run1('cbbbbcaaca') == 0.800000000000000", "assert apps_run1('cadbcdddda') == 0.800000000000000", "assert apps_run1('bababbdaee') == 1.000000000000000", "assert apps_run1('fabbbhgedd') == 1.000000000000000", "assert apps_run1('gaejllebhn') == 1.000000000000000", "assert apps_run1('bbababaaababaabbbbbabbbbbbaaabbabaaaaabbbbbaaaabbbbabaabaabababbbabbabbabaaababbabbababaaaaabaaaabbb') == 0.000000000000000", "assert apps_run1('eaaebccaeacdecaedcaabbbdeebccdcdaabeeaeeaddbaabdccebecebbbbedbdcbbbbbbecbaddcddcccdcbbadbecddecedbba') == 0.080000000000000", "assert apps_run1('hcdhgcchbdhbeagdcfedgcbaffebgcbcccadeefacbhefgeadfgchabgeebegahfgegahbddedfhffeadcedadgfbeebhgfahhfb') == 0.450000000000000", "assert apps_run1('difhjdjbcdjedhiegagdejkbjfcdcdagdijdjajecbheiabfbjdgjdecfhdkgdbkcgcgakkiiggfkgcfadkjhiijkjacgejfhjge') == 0.840000000000000", "assert apps_run1('khjcoijiicdkdianmdolmadobdkcmgifdnffddnjehhbldlkjffknficdcmokfacioiegjedbmadjioomdacbodcajcmonmnlabo') == 0.960000000000000", "assert apps_run1('kpsaloedscghjeaqadfhmlibjepjafdomkkorinrpakondtnrnknbqarbejcenrlsbfgdbsdmkpphbkdnbitjfcofsjibssmmlll') == 1.000000000000000", "assert apps_run1('jkeaagakbifeaechkifkdghcjcgighidcgdccfbdbcackfgaebkddabgijkhjkaffkabacekdkjekeccegbecbkecbgbgcacgdackcdfjefaifgbigahkbedidfhjbikejdhejcgideaeejdcegeeccaefbddejkbdkfagfcdjbikbidfggkidcdcic') == 0.4385026737967914", "assert apps_run1('ibledofnibedebifmnjdoaijeghajecbkjaebbkofnacceaodiifbhgkihkibddneeiemacodeafeaiiiaoajhmkjffbmmiehebhokfklhbkeoanoajdedjdlkbhenidclagggfhhhldfleccgmjbkhaginlhabkabagikalccndciokabfaebjkndf') == 0.786096256684492", "assert apps_run1('aaabbbaaaabbbbaaabbbbbaabbbbaaababbaaabbbbaaabbbbababbbbaaabbbbaaabbbbbaabbbbaaabbbbaaabbbb') == 0.000000000000000", "assert apps_run1('abbbaababbbaababbbaababbbaababbbaababbbaababbbaababbbaababbbaababbbaababbbaababbbaababbbaab') == 0.000000000000000", "assert apps_run1('abbacba') == 1.000000000000000"], "new_problem": "Vasya and Kolya play a game with a string, using the following rules. Initially, Kolya creates a string s, consisting of small English letters, and uniformly at random chooses an integer k from a segment [0, len(s) - 1]. He tells Vasya this string s, and then shifts it k letters to the left, i.e., creates a new string t = s_{k} + 1s_{k} + 2... s_{n}s_1s_2... s_{k}. Vasya does not know the integer k nor the string t, but he wants to guess the integer k. To do this, he asks Kolya to tell him the first letter of the new string, and then, after he sees it, open one more letter on some position, which Vasya can choose. Vasya understands that he can't guarantee that he will win, but he wants to know the probability of winning if he plays optimally. He wants you to compute this probability. Note that Vasya wants to know the value of k uniquely, it means that if there are at least two cyclic shifts of s that fit the information Vasya knows, Vasya loses. Of course, at any moment of the game Vasya wants to maximize the probability of his win. In this new version of the problem, you are required to use a dictionary to store the positions of each character in the string instead of a list of lists. Additionally, the solution should handle the case where the string contains special characters, and the length of the string is a prime number.", "new_solution": "from typing import Dict, List\n\ndef apps_run2(data: Dict[str, str]) -> float:\n    s = data['string']\n    l = len(s)\n    a = [0] * (2 * l)\n    pos: Dict[int, List[int]] = {i: [] for i in range(26)}\n    for i, c in enumerate(s):\n        t = ord(c) - ord('a')\n        a[i] = t\n        a[i + l] = t\n        pos[t].append(i)\n    ans = 0\n    for c in range(26):\n        cur = 0\n        for k in range(1, l):\n            cnt = [0] * 26\n            for i in pos[c]:\n                cnt[a[i + k]] += 1\n            cur = max(cur, len(list([x for x in cnt if x == 1])))\n        ans += cur\n    return ans / l", "input_format": "A dictionary with a single key 'string' containing the string s of length l (3 \u2264 l \u2264 5000), consisting of small English letters only.", "output_format": "A float number representing the probability of Vasya winning, with an absolute or relative error not exceeding 10^{-6}.", "test_input": ["assert abs(apps_run2({'string': 'technocup'}) - 1.0) < 1e-6", "assert abs(apps_run2({'string': 'tictictactac'}) - 0.333333333333333) < 1e-6", "assert abs(apps_run2({'string': 'bbaabaabbb'}) - 0.1) < 1e-6", "assert abs(apps_run2({'string': 'abcabcabcabc'})) < 1e-6", "assert abs(apps_run2({'string': 'primeprimeprime'})) < 1e-6"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "APPS/2002-4", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nVasya and Kolya play a game with a string, using the following rules. Initially, Kolya creates a string s, consisting of small English letters, and uniformly at random chooses an integer k from a segment [0, len(s) - 1]. He tells Vasya this string s, and then shifts it k letters to the left, i.\u00a0e. creates a new string t = s_{k} + 1s_{k} + 2... s_{n}s_1s_2... s_{k}. Vasya does not know the integer k nor the string t, but he wants to guess the integer k. To do this, he asks Kolya to tell him the first letter of the new string, and then, after he sees it, open one more letter on some position, which Vasya can choose.\n\nVasya understands, that he can't guarantee that he will win, but he wants to know the probability of winning, if he plays optimally. He wants you to compute this probability. \n\nNote that Vasya wants to know the value of k uniquely, it means, that if there are at least two cyclic shifts of s that fit the information Vasya knowns, Vasya loses. Of course, at any moment of the game Vasya wants to maximize the probability of his win.\n\n\n-----Input-----\n\nThe only string contains the string s of length l (3 \u2264 l \u2264 5000), consisting of small English letters only.\n\n\n-----Output-----\n\nPrint the only number\u00a0\u2014 the answer for the problem. You answer is considered correct, if its absolute or relative error does not exceed 10^{ - 6}.\n\nFormally, let your answer be a, and the jury's answer be b. Your answer is considered correct if $\\frac{|a - b|}{\\operatorname{max}(1,|b|)} \\leq 10^{-6}$\n\n\n-----Examples-----\nInput\ntechnocup\n\nOutput\n1.000000000000000\n\nInput\ntictictactac\n\nOutput\n0.333333333333333\n\nInput\nbbaabaabbb\n\nOutput\n0.100000000000000\n\n\n\n-----Note-----\n\nIn the first example Vasya can always open the second letter after opening the first letter, and the cyclic shift is always determined uniquely.\n\nIn the second example if the first opened letter of t is \"t\" or \"c\", then Vasya can't guess the shift by opening only one other letter. On the other hand, if the first letter is \"i\" or \"a\", then he can open the fourth letter and determine the shift uniquely.", "raw_solution": "def apps_run1(s):\n    l = len(s)\n    a = [0] * (2 * l)\n    pos = [[] for i in range(26)]\n    for i, c in enumerate(s):\n        t = ord(c) - ord('a')\n        a[i] = t\n        a[i + l] = t\n        pos[t].append(i)\n    ans = 0\n    for c in range(26):\n        cur = 0\n        for k in range(1, l):\n            cnt = [0] * 26\n            for i in pos[c]:\n                cnt[a[i + k]] += 1\n            cur = max(cur, len(list([x for x in cnt if x == 1])))\n        ans += cur\n    return ans / l\n", "raw_test_input": ["assert apps_run1('technocup') == 1.000000000000000", "assert apps_run1('tictictactac') == 0.3333333333333333", "assert apps_run1('bbaabaabbb') == 0.100000000000000", "assert apps_run1('cbbbbcaaca') == 0.800000000000000", "assert apps_run1('cadbcdddda') == 0.800000000000000", "assert apps_run1('bababbdaee') == 1.000000000000000", "assert apps_run1('fabbbhgedd') == 1.000000000000000", "assert apps_run1('gaejllebhn') == 1.000000000000000", "assert apps_run1('bbababaaababaabbbbbabbbbbbaaabbabaaaaabbbbbaaaabbbbabaabaabababbbabbabbabaaababbabbababaaaaabaaaabbb') == 0.000000000000000", "assert apps_run1('eaaebccaeacdecaedcaabbbdeebccdcdaabeeaeeaddbaabdccebecebbbbedbdcbbbbbbecbaddcddcccdcbbadbecddecedbba') == 0.080000000000000", "assert apps_run1('hcdhgcchbdhbeagdcfedgcbaffebgcbcccadeefacbhefgeadfgchabgeebegahfgegahbddedfhffeadcedadgfbeebhgfahhfb') == 0.450000000000000", "assert apps_run1('difhjdjbcdjedhiegagdejkbjfcdcdagdijdjajecbheiabfbjdgjdecfhdkgdbkcgcgakkiiggfkgcfadkjhiijkjacgejfhjge') == 0.840000000000000", "assert apps_run1('khjcoijiicdkdianmdolmadobdkcmgifdnffddnjehhbldlkjffknficdcmokfacioiegjedbmadjioomdacbodcajcmonmnlabo') == 0.960000000000000", "assert apps_run1('kpsaloedscghjeaqadfhmlibjepjafdomkkorinrpakondtnrnknbqarbejcenrlsbfgdbsdmkpphbkdnbitjfcofsjibssmmlll') == 1.000000000000000", "assert apps_run1('jkeaagakbifeaechkifkdghcjcgighidcgdccfbdbcackfgaebkddabgijkhjkaffkabacekdkjekeccegbecbkecbgbgcacgdackcdfjefaifgbigahkbedidfhjbikejdhejcgideaeejdcegeeccaefbddejkbdkfagfcdjbikbidfggkidcdcic') == 0.4385026737967914", "assert apps_run1('ibledofnibedebifmnjdoaijeghajecbkjaebbkofnacceaodiifbhgkihkibddneeiemacodeafeaiiiaoajhmkjffbmmiehebhokfklhbkeoanoajdedjdlkbhenidclagggfhhhldfleccgmjbkhaginlhabkabagikalccndciokabfaebjkndf') == 0.786096256684492", "assert apps_run1('aaabbbaaaabbbbaaabbbbbaabbbbaaababbaaabbbbaaabbbbababbbbaaabbbbaaabbbbbaabbbbaaabbbbaaabbbb') == 0.000000000000000", "assert apps_run1('abbbaababbbaababbbaababbbaababbbaababbbaababbbaababbbaababbbaababbbaababbbaababbbaababbbaab') == 0.000000000000000", "assert apps_run1('abbacba') == 1.000000000000000"], "new_problem": "Vasya and Kolya play a game with a string, using the following rules. Initially, Kolya creates a string s, consisting of small English letters, and uniformly at random chooses an integer k from a segment [0, len(s) - 1]. He tells Vasya this string s, and then shifts it k letters to the left, i.e., creates a new string t = s_{k} + 1s_{k} + 2... s_{n}s_1s_2... s_{k}. Vasya does not know the integer k nor the string t, but he wants to guess the integer k. To do this, he asks Kolya to tell him the first letter of the new string, and then, after he sees it, open one more letter on some position, which Vasya can choose. Vasya understands that he can't guarantee that he will win, but he wants to know the probability of winning if he plays optimally. He wants you to compute this probability. However, the function should handle the following errors: 1. If the input string is empty or not a valid string, raise a ValueError with a message 'Invalid input string'. 2. If the input string length is less than 3 or greater than 5000, raise a ValueError with a message 'String length out of bounds'. 3. If the input string contains characters other than lowercase English letters, raise a ValueError with a message 'Invalid characters in string'. Implement error handling to manage these scenarios and ensure the function propagates errors with meaningful messages.", "new_solution": "def apps_run2(s: str) -> float:\n    if not isinstance(s, str) or not s:\n        raise ValueError('Invalid input string')\n    if len(s) < 3 or len(s) > 5000:\n        raise ValueError('String length out of bounds')\n    if not all('a' <= c <= 'z' for c in s):\n        raise ValueError('Invalid characters in string')\n\n    l = len(s)\n    a = [0] * (2 * l)\n    pos = [[] for _ in range(26)]\n    for i, c in enumerate(s):\n        t = ord(c) - ord('a')\n        a[i] = t\n        a[i + l] = t\n        pos[t].append(i)\n    ans = 0\n    for c in range(26):\n        cur = 0\n        for k in range(1, l):\n            cnt = [0] * 26\n            for i in pos[c]:\n                cnt[a[i + k]] += 1\n            cur = max(cur, len([x for x in cnt if x == 1]))\n        ans += cur\n    return ans / l", "input_format": "A string s of length l (3 \u2264 l \u2264 5000), consisting of small English letters only.", "output_format": "A float number representing the probability of Vasya winning, with an absolute or relative error not exceeding 10^{-6}.", "test_input": ["assert apps_run2('technocup') == 1.0", "assert apps_run2('tictictactac') == 0.3333333333333333", "assert apps_run2('bbaabaabbb') == 0.1", "try:\n    apps_run2('')\nexcept ValueError as e:\n    assert str(e) == 'Invalid input string'", "try:\n    apps_run2('a')\nexcept ValueError as e:\n    assert str(e) == 'String length out of bounds'", "try:\n    apps_run2('Astring')\nexcept ValueError as e:\n    assert str(e) == 'Invalid characters in string'", "try:\n    apps_run2('a' * 5001)\nexcept ValueError as e:\n    assert str(e) == 'String length out of bounds'"], "requirement_type": "PROMPT_ERROR_HANDLING"}
{"task_id": "APPS/2003-1", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nIn the evenings Donkey would join Shrek to look at the stars. They would sit on a log, sipping tea and they would watch the starry sky. The sky hung above the roof, right behind the chimney. Shrek's stars were to the right of the chimney and the Donkey's stars were to the left. Most days the Donkey would just count the stars, so he knew that they are exactly n. This time he wanted a challenge. He imagined a coordinate system: he put the origin of the coordinates at the intersection of the roof and the chimney, directed the OX axis to the left along the roof and the OY axis \u2014 up along the chimney (see figure). The Donkey imagined two rays emanating from he origin of axes at angles \u03b1_1 and \u03b1_2 to the OX axis.\n\n [Image] \n\nNow he chooses any star that lies strictly between these rays. After that he imagines more rays that emanate from this star at the same angles \u03b1_1 and \u03b1_2 to the OX axis and chooses another star that lies strictly between the new rays. He repeats the operation as long as there still are stars he can choose between the rays that emanate from a star. \n\n [Image] \n\nAs a result, the Donkey gets a chain of stars. He can consecutively get to each star if he acts by the given rules.\n\nYour task is to find the maximum number of stars m that the Donkey's chain can contain.\n\nNote that the chain must necessarily start in the point of the origin of the axes, that isn't taken into consideration while counting the number m of stars in the chain.\n\n\n-----Input-----\n\nThe first line contains an integer n (1 \u2264 n \u2264 10^5) \u2014 the number of stars. The second line contains simple fractions representing relationships \"a/b c/d\", such that $\\frac{a}{b} = \\frac{\\operatorname{sin} \\alpha_{1}}{\\operatorname{cos} \\alpha_{1}}$ and $\\frac{c}{d} = \\frac{\\operatorname{sin} \\alpha_{2}}{\\operatorname{cos} \\alpha}$ (0 \u2264 a, b, c, d \u2264 10^5; $0^{\\circ} \\leq \\alpha_{1} < \\alpha_{2} \\leq 90^{\\circ}$; $\\frac{a}{b} \\neq \\frac{0}{0}$; $\\frac{c}{d} \\neq \\frac{0}{0}$). The given numbers a, b, c, d are integers.\n\nNext n lines contain pairs of integers x_{i}, y_{i} (1 \u2264 x_{i}, y_{i} \u2264 10^5)\u2014 the stars' coordinates.\n\nIt is guaranteed that all stars have distinct coordinates.\n\n\n-----Output-----\n\nIn a single line print number m \u2014 the answer to the problem.\n\n\n-----Examples-----\nInput\n15\n1/3 2/1\n3 1\n6 2\n4 2\n2 5\n4 5\n6 6\n3 4\n1 6\n2 1\n7 4\n9 3\n5 3\n1 3\n15 5\n12 4\n\nOutput\n4\n\n\n\n-----Note-----\n\nIn the sample the longest chain the Donkey can build consists of four stars. Note that the Donkey can't choose the stars that lie on the rays he imagines.\n\n [Image].", "raw_solution": "def apps_run1(n, ab, points):\n    from bisect import bisect_left\n    from math import atan2,tan\n\n    a, b = map(int, ab.split('/'))\n    c, d = 0, 0  # Placeholder for c and d since they are not provided in the input\n\n    alpha = atan2(c, d) - atan2(a, b)\n    tan_alpha = tan(alpha)\n\n    lis = []\n\n    for x, y in sorted((y/tan_alpha - x, y) for x, y in [ (x, y) for x, y in points if a*x - b*y <= 0 and d*y - c*x <= 0]):\n        pos = bisect_left(lis, -y)\n        if pos == len(lis):\n            lis.append(-y)\n        else:\n            lis[pos] = -y\n\n    return len(lis)\n\n# Example usage:\n# print(apps_run1(15, '1/3', [(3, 1), (6, 2), (4, 2), (2, 5), (4, 5), (6, 6), (3, 4), (1, 6), (2, 1), (7, 4), (9, 3), (5, 3), (1, 3), (15, 5), (12, 4)]))", "raw_test_input": ["assert apps_run1(15, '1/3', [(3, 1), (6, 2), (4, 2), (2, 5), (4, 5), (6, 6), (3, 4), (1, 6), (2, 1), (7, 4), (9, 3), (5, 3), (1, 3), (15, 5), (12, 4)]) == 6", "assert apps_run1(15, '2/1', [(3, 1), (6, 2), (9, 3), (12, 4), (15, 5), (2, 1), (4, 2), (5, 3), (7, 4), (1, 3), (3, 4), (2, 5), (4, 5), (1, 6), (6, 6)]) == 2", "assert apps_run1(5, '3/24', [(31394, 23366), (27990, 71363), (33642, 36903), (79731, 10588), (10907, 5058)]) == 5"], "new_problem": "In a space observatory, scientists are tracking the movement of stars. They have a system to determine the longest chain of stars that can be observed based on specific angles. The observatory receives new data about stars periodically. Your task is to determine the maximum number of stars in the chain after each new star is added. The system uses the same rules as the original problem to determine the chain. Given the initial set of stars and a series of queries where each query adds a new star, calculate the maximum chain length after each addition.", "new_solution": "from typing import List, Tuple\n\ndef max_star_chain(n: int, angles: str, stars: List[Tuple[int, int]]):\n    from bisect import bisect_left\n    from math import atan2, tan\n\n    a, b, c, d = map(int, angles.replace('/', ' ').split())\n    alpha = atan2(c, d) - atan2(a, b)\n    tan_alpha = tan(alpha)\n\n    lis = []\n\n    for x, y in sorted((y / tan_alpha - x, y) for x, y in [\n        (x, y) for x, y in [(b * x + a * y, -a * x + b * y) for x, y in stars\n                             if a * x - b * y <= 0 and d * y - c * x <= 0]\n    ]):\n        pos = bisect_left(lis, -y)\n        if pos == len(lis):\n            lis.append(-y)\n        else:\n            lis[pos] = -y\n\n    return len(lis)\n\n\ndef apps_run2(n, angles, stars, queries):\n    results = []\n    current_stars = stars[:]\n\n    for query in queries:\n        current_stars.append(query)\n        max_chain_length = max_star_chain(n + len(results) + 1, angles, current_stars)\n        results.append(max_chain_length)\n\n    return results\n", "input_format": "The first parameter is an integer n (1 \u2264 n \u2264 10^5) \u2014 the number of stars. The second parameter is a string and contains simple fractions representing relationships \"a/b c/d\", such that \\(\\frac{a}{b} = \\frac{\\operatorname{sin} \\alpha_{1}}{\\operatorname{cos} \\alpha_{1}}\\) and \\(\\frac{c}{d} = \\frac{\\operatorname{sin} \\alpha_{2}}{\\operatorname{cos} \\alpha}\\) (0 \u2264 a, b, c, d \u2264 10^5; \\(0^{\\circ} \\leq \\alpha_{1} < \\alpha_{2} \\leq 90^{\\circ}\\); \\(\\frac{a}{b} \\neq \\frac{0}{0}\\); \\(\\frac{c}{d} \\neq \\frac{0}{0}\\)). The given numbers a, b, c, d are integers. Next parameter is given as List[Tuple[int, int]] and the pairs of integers x_{i}, y_{i} (1 \u2264 x_{i}, y_{i} \u2264 10^5)\u2014 are the stars' coordinates. It is guaranteed that all stars have distinct coordinates. The next parameter contains is given as List[Tuple[int,int]], and each of the pair contains two integers x and y representing a new star's coordinates.", "output_format": "For each query, print the maximum number of stars in the chain after adding the new star.", "test_input": ["assert apps_run2(15,'1/3 2/1', [(3, 1), (6, 2), (4, 2), (2, 5), (4, 5), (6, 6), (3, 4), (1, 6), (2, 1), (7, 4), (9, 3), (5, 3), (1, 3), (15, 5), (12, 4)], [(10, 10), (5, 5), (8, 8)]) == [4, 4, 5]", "assert apps_run2(5, '1/2 3/4', [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5)], [(6, 6), (7, 7)]) == [0, 0]", "assert apps_run2(3, '2/3 4/5', [(1, 2), (2, 3), (3, 4)], [(4, 5), (5, 6), (6, 7)]) == [0, 0, 0]", "assert apps_run2(4, '1/3 2/1', [(1, 1), (2, 2), (3, 3), (4, 4)], [(5, 5), (6, 6)]) == [5, 6]", "assert apps_run2(6, '1/2 4/1', [(1, 3), (2, 6), (3, 9), (4, 12), (5, 15), (6, 18)], [(7, 21), (8, 24)]) == [7, 8]"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "APPS/2003-2", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nIn the evenings Donkey would join Shrek to look at the stars. They would sit on a log, sipping tea and they would watch the starry sky. The sky hung above the roof, right behind the chimney. Shrek's stars were to the right of the chimney and the Donkey's stars were to the left. Most days the Donkey would just count the stars, so he knew that they are exactly n. This time he wanted a challenge. He imagined a coordinate system: he put the origin of the coordinates at the intersection of the roof and the chimney, directed the OX axis to the left along the roof and the OY axis \u2014 up along the chimney (see figure). The Donkey imagined two rays emanating from he origin of axes at angles \u03b1_1 and \u03b1_2 to the OX axis.\n\n [Image] \n\nNow he chooses any star that lies strictly between these rays. After that he imagines more rays that emanate from this star at the same angles \u03b1_1 and \u03b1_2 to the OX axis and chooses another star that lies strictly between the new rays. He repeats the operation as long as there still are stars he can choose between the rays that emanate from a star. \n\n [Image] \n\nAs a result, the Donkey gets a chain of stars. He can consecutively get to each star if he acts by the given rules.\n\nYour task is to find the maximum number of stars m that the Donkey's chain can contain.\n\nNote that the chain must necessarily start in the point of the origin of the axes, that isn't taken into consideration while counting the number m of stars in the chain.\n\n\n-----Input-----\n\nThe first line contains an integer n (1 \u2264 n \u2264 10^5) \u2014 the number of stars. The second line contains simple fractions representing relationships \"a/b c/d\", such that $\\frac{a}{b} = \\frac{\\operatorname{sin} \\alpha_{1}}{\\operatorname{cos} \\alpha_{1}}$ and $\\frac{c}{d} = \\frac{\\operatorname{sin} \\alpha_{2}}{\\operatorname{cos} \\alpha}$ (0 \u2264 a, b, c, d \u2264 10^5; $0^{\\circ} \\leq \\alpha_{1} < \\alpha_{2} \\leq 90^{\\circ}$; $\\frac{a}{b} \\neq \\frac{0}{0}$; $\\frac{c}{d} \\neq \\frac{0}{0}$). The given numbers a, b, c, d are integers.\n\nNext n lines contain pairs of integers x_{i}, y_{i} (1 \u2264 x_{i}, y_{i} \u2264 10^5)\u2014 the stars' coordinates.\n\nIt is guaranteed that all stars have distinct coordinates.\n\n\n-----Output-----\n\nIn a single line print number m \u2014 the answer to the problem.\n\n\n-----Examples-----\nInput\n15\n1/3 2/1\n3 1\n6 2\n4 2\n2 5\n4 5\n6 6\n3 4\n1 6\n2 1\n7 4\n9 3\n5 3\n1 3\n15 5\n12 4\n\nOutput\n4\n\n\n\n-----Note-----\n\nIn the sample the longest chain the Donkey can build consists of four stars. Note that the Donkey can't choose the stars that lie on the rays he imagines.\n\n [Image].", "raw_solution": "def apps_run1(n, ab, points):\n    from bisect import bisect_left\n    from math import atan2,tan\n\n    a, b = map(int, ab.split('/'))\n    c, d = 0, 0  # Assuming c and d are not provided in the input\n\n    alpha = atan2(c, d) - atan2(a, b)\n    tan_alpha = tan(alpha)\n\n    lis = []\n\n    for x, y in sorted((y/tan_alpha - x, y) for x, y in [(x, y) for x, y in points if a*x - b*y <= 0 and d*y - c*x <= 0]):\n        pos = bisect_left(lis, -y)\n        if pos == len(lis):\n            lis.append(-y)\n        else:\n            lis[pos] = -y\n\n    return len(lis)", "raw_test_input": ["assert apps_run1(15, '1/3', [(3, 1), (6, 2), (4, 2), (2, 5), (4, 5), (6, 6), (3, 4), (1, 6), (2, 1), (7, 4), (9, 3), (5, 3), (1, 3), (15, 5), (12, 4)]) == 6", "assert apps_run1(15, '2/1', [(3, 1), (6, 2), (9, 3), (12, 4), (15, 5), (2, 1), (4, 2), (5, 3), (7, 4), (1, 3), (3, 4), (2, 5), (4, 5), (1, 6), (6, 6)]) == 2", "assert apps_run1(5, '3/24', [(31394, 23366), (27990, 71363), (33642, 36903), (79731, 10588), (10907, 5058)]) == 5"], "new_problem": "Enhance the function to solve the problem of finding the maximum number of stars in the Donkey's chain, with an optional parameter `include_origin` that, when set to True, includes the origin in the count of the chain. The function should maintain backward compatibility, support original function parameters, and include type hints.", "new_solution": "from bisect import bisect_left\nfrom math import atan2, tan\nfrom typing import List, Tuple\n\ndef apps_run2(n: int, angles:str, stars: List[Tuple[int, int]], include_origin: bool = False) -> int:\n    a, b, c, d = map(int, angles.replace('/', ' ').split())\n    alpha = atan2(c, d) - atan2(a, b)\n    tan_alpha = tan(alpha)\n\n    lis = []\n\n    for x, y in sorted((y / tan_alpha - x, y) for x, y in [(b * x + a * y, -a * x + b * y) for x, y in stars if a * x - b * y <= 0 and d * y - c * x <= 0]):\n        pos = bisect_left(lis, -y)\n        if pos == len(lis):\n            lis.append(-y)\n        else:\n            lis[pos] = -y\n\n    return len(lis) + (1 if include_origin else 0)", "input_format": "The first parameter contains an integer n (1 \u2264 n \u2264 10^5) \u2014 the number of stars. The second parameter is a string, and contains simple fractions representing relationships \"a/b c/d\", such that \\(\\frac{a}{b} = \\frac{\\operatorname{sin} \\alpha_{1}}{\\operatorname{cos} \\alpha_{1}}\\) and \\(\\frac{c}{d} = \\frac{\\operatorname{sin} \\alpha_{2}}{\\operatorname{cos} \\alpha}\\) (0 \u2264 a, b, c, d \u2264 10^5; \\(0^{\\circ} \\leq \\alpha_{1} < \\alpha_{2} \\leq 90^{\\circ}\\); \\(\\frac{a}{b} \\neq \\frac{0}{0}\\); \\(\\frac{c}{d} \\neq \\frac{0}{0}\\)). The given numbers a, b, c, d are integers. Next parameter is given as List[Tuple[int, int]] and the pairs of integers x_{i}, y_{i} (1 \u2264 x_{i}, y_{i} \u2264 10^5)\u2014 are the stars' coordinates. It is guaranteed that all stars have distinct coordinates. An optional parameter `include_origin` (boolean) can be provided to include the origin in the count.", "output_format": "In a single line print number m \u2014 the answer to the problem.", "test_input": ["assert apps_run2(15, '1/3 2/1', [(3, 1), (6, 2), (4, 2), (2, 5), (4, 5), (6, 6), (3, 4), (1, 6), (2, 1), (7, 4), (9, 3), (5, 3), (1, 3), (15, 5), (12, 4)]) == 4", "assert apps_run2(15, '1/3 2/1', [(3, 1), (6, 2), (4, 2), (2, 5), (4, 5), (6, 6), (3, 4), (1, 6), (2, 1), (7, 4), (9, 3), (5, 3), (1, 3), (15, 5), (12, 4)], include_origin=True) == 5", "assert apps_run2(5, '1/2 3/4', [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5)]) == 0", "assert apps_run2(5, '1/2 3/4', [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5)], include_origin=True) == 1", "assert apps_run2(3, '1/1 1/1', [(1, 2), (2, 3), (3, 4)]) == 0"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "APPS/2003-3", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nIn the evenings Donkey would join Shrek to look at the stars. They would sit on a log, sipping tea and they would watch the starry sky. The sky hung above the roof, right behind the chimney. Shrek's stars were to the right of the chimney and the Donkey's stars were to the left. Most days the Donkey would just count the stars, so he knew that they are exactly n. This time he wanted a challenge. He imagined a coordinate system: he put the origin of the coordinates at the intersection of the roof and the chimney, directed the OX axis to the left along the roof and the OY axis \u2014 up along the chimney (see figure). The Donkey imagined two rays emanating from he origin of axes at angles \u03b1_1 and \u03b1_2 to the OX axis.\n\n [Image] \n\nNow he chooses any star that lies strictly between these rays. After that he imagines more rays that emanate from this star at the same angles \u03b1_1 and \u03b1_2 to the OX axis and chooses another star that lies strictly between the new rays. He repeats the operation as long as there still are stars he can choose between the rays that emanate from a star. \n\n [Image] \n\nAs a result, the Donkey gets a chain of stars. He can consecutively get to each star if he acts by the given rules.\n\nYour task is to find the maximum number of stars m that the Donkey's chain can contain.\n\nNote that the chain must necessarily start in the point of the origin of the axes, that isn't taken into consideration while counting the number m of stars in the chain.\n\n\n-----Input-----\n\nThe first line contains an integer n (1 \u2264 n \u2264 10^5) \u2014 the number of stars. The second line contains simple fractions representing relationships \"a/b c/d\", such that $\\frac{a}{b} = \\frac{\\operatorname{sin} \\alpha_{1}}{\\operatorname{cos} \\alpha_{1}}$ and $\\frac{c}{d} = \\frac{\\operatorname{sin} \\alpha_{2}}{\\operatorname{cos} \\alpha}$ (0 \u2264 a, b, c, d \u2264 10^5; $0^{\\circ} \\leq \\alpha_{1} < \\alpha_{2} \\leq 90^{\\circ}$; $\\frac{a}{b} \\neq \\frac{0}{0}$; $\\frac{c}{d} \\neq \\frac{0}{0}$). The given numbers a, b, c, d are integers.\n\nNext n lines contain pairs of integers x_{i}, y_{i} (1 \u2264 x_{i}, y_{i} \u2264 10^5)\u2014 the stars' coordinates.\n\nIt is guaranteed that all stars have distinct coordinates.\n\n\n-----Output-----\n\nIn a single line print number m \u2014 the answer to the problem.\n\n\n-----Examples-----\nInput\n15\n1/3 2/1\n3 1\n6 2\n4 2\n2 5\n4 5\n6 6\n3 4\n1 6\n2 1\n7 4\n9 3\n5 3\n1 3\n15 5\n12 4\n\nOutput\n4\n\n\n\n-----Note-----\n\nIn the sample the longest chain the Donkey can build consists of four stars. Note that the Donkey can't choose the stars that lie on the rays he imagines.\n\n [Image].", "raw_solution": "def apps_run1(n, ab, points):\n    from bisect import bisect_left\n    from math import atan2,tan\n\n    a, b = map(int, ab.split('/'))\n    c, d = 0, 0  # Assuming c and d are not provided in the input\n\n    alpha = atan2(c, d) - atan2(a, b)\n    tan_alpha = tan(alpha)\n\n    lis = []\n\n    for x, y in sorted((y/tan_alpha - x, y) for x, y in [ (x, y) for x, y in points if a*x - b*y <= 0 and d*y - c*x <= 0]):\n        pos = bisect_left(lis, -y)\n        if pos == len(lis):\n            lis.append(-y)\n        else:\n            lis[pos] = -y\n\n    return len(lis)", "raw_test_input": ["assert apps_run1(15, '1/3', [(3, 1), (6, 2), (4, 2), (2, 5), (4, 5), (6, 6), (3, 4), (1, 6), (2, 1), (7, 4), (9, 3), (5, 3), (1, 3), (15, 5), (12, 4)]) == 6", "assert apps_run1(15, '2/1', [(3, 1), (6, 2), (9, 3), (12, 4), (15, 5), (2, 1), (4, 2), (5, 3), (7, 4), (1, 3), (3, 4), (2, 5), (4, 5), (1, 6), (6, 6)]) == 2", "assert apps_run1(5, '3/24', [(31394, 23366), (27990, 71363), (33642, 36903), (79731, 10588), (10907, 5058)]) == 5"], "new_problem": "In the evenings, Donkey and Shrek have decided to make their star-gazing more challenging. They now want to categorize the stars based on their brightness levels. Each star has a unique brightness value associated with it. The task is to find the longest chain of stars Donkey can choose, where each subsequent star in the chain has a higher brightness than the previous one. The stars are still chosen based on the angles \\(\\alpha_1\\) and \\(\\alpha_2\\) as before. However, the stars' coordinates and brightness values are now stored in a dictionary, where the key is a tuple of coordinates (x, y) and the value is the brightness level. Your task is to find the maximum number of stars m that the Donkey's chain can contain, considering the brightness constraint.", "new_solution": "from bisect import bisect_left\nfrom math import atan2, tan\nfrom typing import Dict, Tuple\n\ndef apps_run2(n: int, angles: str, stars: Dict[Tuple[int, int], int]) -> int:\n    a, b, c, d = map(int, angles.replace('/', ' ').split())\n    alpha = atan2(c, d) - atan2(a, b)\n    tan_alpha = tan(alpha)\n    lis = []\n    sorted_stars = sorted(((y / tan_alpha - x, y, brightness) for (x, y), brightness in stars.items() if a * x - b * y <= 0 and d * y - c * x <= 0), key=lambda star: (star[0], star[2]))\n    for _, y, brightness in sorted_stars:\n        pos = bisect_left(lis, -brightness)\n        if pos == len(lis):\n            lis.append(-brightness)\n        else:\n            lis[pos] = -brightness\n    return len(lis)", "input_format": "The first parameter contains an integer n (1 \u2264 n \u2264 10^5) \u2014 the number of stars. The second parameter is a string and contains simple fractions representing relationships \"a/b c/d\", such that \\(\\frac{a}{b} = \\frac{\\operatorname{sin} \\alpha_{1}}{\\operatorname{cos} \\alpha_{1}}\\) and \\(\\frac{c}{d} = \\frac{\\operatorname{sin} \\alpha_{2}}{\\operatorname{cos} \\alpha}\\) (0 \u2264 a, b, c, d \u2264 10^5; \\(0^{\\circ} \\leq \\alpha_{1} < \\alpha_{2} \\leq 90^{\\circ}\\); \\(\\frac{a}{b} \\neq \\frac{0}{0}\\); \\(\\frac{c}{d} \\neq \\frac{0}{0}\\)). The given numbers a, b, c, d are integers. Next parameter is given as Dict[Tuple[int, int], int] and the keys of dictionary are the stars' coordinates. It is guaranteed that all stars have distinct coordinates. And the values of dictionary are stars' brightness levels", "output_format": "In a single line print number m \u2014 the answer to the problem.", "test_input": ["assert apps_run2(15,'1/3 2/1', {(3, 1): 5, (6, 2): 3, (4, 2): 8, (2, 5): 7, (4, 5): 6, (6, 6): 9, (3, 4): 4, (1, 6): 2, (2, 1): 1, (7, 4): 10, (9, 3): 11, (5, 3): 12, (1, 3): 13, (15, 5): 14, (12, 4): 15}) == 5", "assert apps_run2(5,'1/2 3/4', {(1, 1): 1, (2, 2): 2, (3, 3): 3, (4, 4): 4, (5, 5): 5}) == 0", "assert apps_run2(3, '1/3 5/1', {(1, 2): 3, (2, 3): 2, (3, 4): 1}) == 1", "assert apps_run2(4, '2/3 4/5', {(1, 1): 10, (2, 2): 20, (3, 3): 30, (4, 4): 40}) == 0", "assert apps_run2(6, '1/2 4/2', {(1, 1): 6, (2, 2): 5, (3, 3): 4, (4, 4): 3, (5, 5): 2, (6, 6): 1}) == 6"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "APPS/2003-4", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nIn the evenings Donkey would join Shrek to look at the stars. They would sit on a log, sipping tea and they would watch the starry sky. The sky hung above the roof, right behind the chimney. Shrek's stars were to the right of the chimney and the Donkey's stars were to the left. Most days the Donkey would just count the stars, so he knew that they are exactly n. This time he wanted a challenge. He imagined a coordinate system: he put the origin of the coordinates at the intersection of the roof and the chimney, directed the OX axis to the left along the roof and the OY axis \u2014 up along the chimney (see figure). The Donkey imagined two rays emanating from he origin of axes at angles \u03b1_1 and \u03b1_2 to the OX axis.\n\n [Image] \n\nNow he chooses any star that lies strictly between these rays. After that he imagines more rays that emanate from this star at the same angles \u03b1_1 and \u03b1_2 to the OX axis and chooses another star that lies strictly between the new rays. He repeats the operation as long as there still are stars he can choose between the rays that emanate from a star. \n\n [Image] \n\nAs a result, the Donkey gets a chain of stars. He can consecutively get to each star if he acts by the given rules.\n\nYour task is to find the maximum number of stars m that the Donkey's chain can contain.\n\nNote that the chain must necessarily start in the point of the origin of the axes, that isn't taken into consideration while counting the number m of stars in the chain.\n\n\n-----Input-----\n\nThe first line contains an integer n (1 \u2264 n \u2264 10^5) \u2014 the number of stars. The second line contains simple fractions representing relationships \"a/b c/d\", such that $\\frac{a}{b} = \\frac{\\operatorname{sin} \\alpha_{1}}{\\operatorname{cos} \\alpha_{1}}$ and $\\frac{c}{d} = \\frac{\\operatorname{sin} \\alpha_{2}}{\\operatorname{cos} \\alpha}$ (0 \u2264 a, b, c, d \u2264 10^5; $0^{\\circ} \\leq \\alpha_{1} < \\alpha_{2} \\leq 90^{\\circ}$; $\\frac{a}{b} \\neq \\frac{0}{0}$; $\\frac{c}{d} \\neq \\frac{0}{0}$). The given numbers a, b, c, d are integers.\n\nNext n lines contain pairs of integers x_{i}, y_{i} (1 \u2264 x_{i}, y_{i} \u2264 10^5)\u2014 the stars' coordinates.\n\nIt is guaranteed that all stars have distinct coordinates.\n\n\n-----Output-----\n\nIn a single line print number m \u2014 the answer to the problem.\n\n\n-----Examples-----\nInput\n15\n1/3 2/1\n3 1\n6 2\n4 2\n2 5\n4 5\n6 6\n3 4\n1 6\n2 1\n7 4\n9 3\n5 3\n1 3\n15 5\n12 4\n\nOutput\n4\n\n\n\n-----Note-----\n\nIn the sample the longest chain the Donkey can build consists of four stars. Note that the Donkey can't choose the stars that lie on the rays he imagines.\n\n [Image].", "raw_solution": "def apps_run1(n, ab, points):\n    from bisect import bisect_left\n    from math import atan2,tan\n\n    a, b = map(int, ab.split('/'))\n    c, d = 0, 0  # Assuming c and d are not provided in the function parameters\n\n    alpha = atan2(c, d) - atan2(a, b)\n    tan_alpha = tan(alpha)\n\n    lis = []\n\n    for x, y in sorted((y/tan_alpha - x, y) for x, y in [ (x, y) for x, y in points if a*x - b*y <= 0 and d*y - c*x <= 0]):\n        pos = bisect_left(lis, -y)\n        if pos == len(lis):\n            lis.append(-y)\n        else:\n            lis[pos] = -y\n\n    return len(lis)", "raw_test_input": ["assert apps_run1(15, '1/3', [(3, 1), (6, 2), (4, 2), (2, 5), (4, 5), (6, 6), (3, 4), (1, 6), (2, 1), (7, 4), (9, 3), (5, 3), (1, 3), (15, 5), (12, 4)]) == 6", "assert apps_run1(15, '2/1', [(3, 1), (6, 2), (9, 3), (12, 4), (15, 5), (2, 1), (4, 2), (5, 3), (7, 4), (1, 3), (3, 4), (2, 5), (4, 5), (1, 6), (6, 6)]) == 2", "assert apps_run1(5, '3/24', [(31394, 23366), (27990, 71363), (33642, 36903), (79731, 10588), (10907, 5058)]) == 5"], "new_problem": "In the evenings, Donkey would join Shrek to look at the stars. They would sit on a log, sipping tea and they would watch the starry sky. The sky hung above the roof, right behind the chimney. Shrek's stars were to the right of the chimney and the Donkey's stars were to the left. Most days the Donkey would just count the stars, so he knew that they are exactly n. This time he wanted a challenge. He imagined a coordinate system: he put the origin of the coordinates at the intersection of the roof and the chimney, directed the OX axis to the left along the roof and the OY axis \u2014 up along the chimney. The Donkey imagined two rays emanating from the origin of axes at angles \u03b1_1 and \u03b1_2 to the OX axis. Now he chooses any star that lies strictly between these rays. After that, he imagines more rays that emanate from this star at the same angles \u03b1_1 and \u03b1_2 to the OX axis and chooses another star that lies strictly between the new rays. He repeats the operation as long as there still are stars he can choose between the rays that emanate from a star. As a result, the Donkey gets a chain of stars. He can consecutively get to each star if he acts by the given rules. Your task is to find the maximum number of stars m that the Donkey's chain can contain. Note that the chain must necessarily start in the point of the origin of the axes, that isn't taken into consideration while counting the number m of stars in the chain. However, this time, you need to handle potential errors in the input data. Specifically, you need to handle the following errors: 1. Division by zero when calculating angles. 2. Invalid input format (e.g., non-integer values where integers are expected). 3. Out of range values for coordinates or fractions. 4. Propagation of errors with meaningful messages. 5. Custom exceptions for specific error types.", "new_solution": "from bisect import bisect_left\nfrom math import atan2, tan\nfrom typing import List, Tuple\n\nclass StarChainError(Exception):\n    pass\n\nclass DivisionByZeroError(StarChainError):\n    pass\n\nclass InvalidInputError(StarChainError):\n    pass\n\nclass OutOfRangeError(StarChainError):\n    pass\n\ndef apps_run2(n: int, angles: str, stars: List[Tuple[int, int]]) -> int:\n    try:\n        a, b, c, d = map(int, angles.replace('/', ' ').split())\n        if b == 0 or d == 0:\n            raise DivisionByZeroError(\"Denominator in angle fraction cannot be zero.\")\n        if not (0 <= a <= 100000 and 0 <= b <= 100000 and 0 <= c <= 100000 and 0 <= d <= 100000):\n            raise OutOfRangeError(\"Fraction values must be between 0 and 100000.\")\n\n        alpha = atan2(c, d) - atan2(a, b)\n        tan_alpha = tan(alpha)\n\n        lis = []\n\n        for x, y in sorted((y / tan_alpha - x, y) for x, y in [\n            (x, y) for x, y in [\n                (b * x + a * y, -a * x + b * y) for x, y in stars\n                if a * x - b * y <= 0 and d * y - c * x <= 0\n            ]\n        ]):\n            pos = bisect_left(lis, -y)\n            if pos == len(lis):\n                lis.append(-y)\n            else:\n                lis[pos] = -y\n\n        return len(lis)\n    except TypeError:\n        raise InvalidInputError(\"Invalid input format. Expected integers.\")\n", "input_format": "The first parameter contains an integer n (1 \u2264 n \u2264 10^5) \u2014 the number of stars. The second parameter is a string and contains simple fractions representing relationships \"a/b c/d\", such that \\(\\frac{a}{b} = \\frac{\\operatorname{sin} \\alpha_{1}}{\\operatorname{cos} \\alpha_{1}}\\) and \\(\\frac{c}{d} = \\frac{\\operatorname{sin} \\alpha_{2}}{\\operatorname{cos} \\alpha}\\) (0 \u2264 a, b, c, d \u2264 10^5; \\(0^{\\circ} \\leq \\alpha_{1} < \\alpha_{2} \\leq 90^{\\circ}\\); \\(\\frac{a}{b} \\neq \\frac{0}{0}\\); \\(\\frac{c}{d} \\neq \\frac{0}{0}\\)). The given numbers a, b, c, d are integers. Next parameter is given as List[Tuple[int, int]] and the pairs of integers x_{i}, y_{i} (1 \u2264 x_{i}, y_{i} \u2264 10^5)\u2014 are the stars' coordinates. It is guaranteed that all stars have distinct coordinates.", "output_format": "In a single line print number m \u2014 the answer to the problem.", "test_input": ["assert apps_run2(15, '1/3 2/1', [(3, 1), (6, 2), (4, 2), (2, 5), (4, 5), (6, 6), (3, 4), (1, 6), (2, 1), (7, 4), (9, 3), (5, 3), (1, 3), (15, 5), (12, 4)]) == 4", "try:\n    apps_run2(15, '1/0 2/1', [(3, 1), (6, 2), (4, 2), (2, 5), (4, 5), (6, 6), (3, 4), (1, 6), (2, 1), (7, 4), (9, 3), (5, 3), (1, 3), (15, 5), (12, 4)])\nexcept DivisionByZeroError as e:\n    assert f'{e}' == \"Denominator in angle fraction cannot be zero.\"", "try:\n    apps_run2(15, '1/3 2/1', [(3, 1), (6, 2), (4, 2), (2, 5), (4, 5), (6, 6), (3, 4), (1, 6), (2, 1), (7, 4), (9, 3), (5, 3), (1, 3), (15, 5), (12, 4), (100001, 100001)])\nexcept OutOfRangeError as e:\n    assert f'{e}' == \"Fraction values must be between 0 and 100000.\"", "try:\n    apps_run2(15, '1/3 2/1', [(3, 1), (6, 2), (4, 2), (2, 5), (4, 5), (6, 6), (3, 4), (1, 6), (2, 1), (7, 4), (9, 3), (5, 3), (1, 3), (15, 5), ('a', 4)])\nexcept InvalidInputError as e:\n    assert f'{e}' == \"Invalid input format. Expected integers.\"", "try:\n    apps_run2(15, '1/3 2/1', [(3, 1), (6, 2), (4, 2), (2, 5), (4, 5), (6, 6), (3, 4), (1, 6), (2, 1), (7, 4), (9, 3), (5, 3), (1, 3), (15, 5), (12, 4)])\nexcept StarChainError:\n    assert False, \"No error should occur for valid input.\""], "requirement_type": "PROMPT_ERROR_HANDLING"}
{"task_id": "APPS/2007-1", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nMad scientist Mike does not use slow hard disks. His modification of a hard drive has not one, but n different heads that can read data in parallel.\n\nWhen viewed from the side, Mike's hard drive is an endless array of tracks. The tracks of the array are numbered from left to right with integers, starting with 1. In the initial state the i-th reading head is above the track number h_{i}. For each of the reading heads, the hard drive's firmware can move the head exactly one track to the right or to the left, or leave it on the current track. During the operation each head's movement does not affect the movement of the other heads: the heads can change their relative order; there can be multiple reading heads above any of the tracks. A track is considered read if at least one head has visited this track. In particular, all of the tracks numbered h_1, h_2, ..., h_{n} have been read at the beginning of the operation. [Image] \n\nMike needs to read the data on m distinct tracks with numbers p_1, p_2, ..., p_{m}. Determine the minimum time the hard drive firmware needs to move the heads and read all the given tracks. Note that an arbitrary number of other tracks can also be read.\n\n\n-----Input-----\n\nThe first line of the input contains two space-separated integers n, m (1 \u2264 n, m \u2264 10^5) \u2014 the number of disk heads and the number of tracks to read, accordingly. The second line contains n distinct integers h_{i} in ascending order (1 \u2264 h_{i} \u2264 10^10, h_{i} < h_{i} + 1) \u2014 the initial positions of the heads. The third line contains m distinct integers p_{i} in ascending order (1 \u2264 p_{i} \u2264 10^10, p_{i} < p_{i} + 1) - the numbers of tracks to read.\n\nPlease, do not use the %lld specifier to read or write 64-bit integers in \u0421++. It is recommended to use the cin, cout streams or the %I64d specifier.\n\n\n-----Output-----\n\nPrint a single number \u2014 the minimum time required, in seconds, to read all the needed tracks.\n\n\n-----Examples-----\nInput\n3 4\n2 5 6\n1 3 6 8\n\nOutput\n2\n\nInput\n3 3\n1 2 3\n1 2 3\n\nOutput\n0\n\nInput\n1 2\n165\n142 200\n\nOutput\n81\n\n\n\n-----Note-----\n\nThe first test coincides with the figure. In this case the given tracks can be read in 2 seconds in the following way:   during the first second move the 1-st head to the left and let it stay there;  move the second head to the left twice;  move the third head to the right twice (note that the 6-th track has already been read at the beginning). \n\nOne cannot read the tracks in 1 second as the 3-rd head is at distance 2 from the 8-th track.", "raw_solution": "def apps_run1(n, m, h, p):\n    ss, ll = 0, int(2.2e10)\n    while ss < ll:\n        avg = (ss + ll) // 2\n        works = True\n        hidx = 0\n        pidx = 0\n        while hidx < len(h) and pidx < len(p):\n            leftget = p[pidx]\n            curpos = h[hidx]\n            if curpos - leftget > avg:\n                works = False\n                break\n            getbacktime = max(0, 2*(curpos - leftget))\n            alsotoright = max(0, avg - getbacktime)\n            leftime = max(0, curpos - leftget)\n            remtime = max(0, (avg - leftime) // 2)\n            furthestright = curpos + max(alsotoright, remtime)\n            while pidx < len(p) and p[pidx] <= furthestright: pidx += 1\n            hidx += 1\n        if pidx != len(p): works = False\n        if works: ll = avg\n        else: ss = avg + 1\n    return ss\n", "raw_test_input": ["assert apps_run1(3, 4, [2, 5, 6], [1, 3, 6, 8]) == 2", "assert apps_run1(3, 3, [1, 2, 3], [1, 2, 3]) == 0", "assert apps_run1(1, 2, [165], [142, 200]) == 81", "assert apps_run1(1, 2, [5000000000], [1, 10000000000]) == 14999999998", "assert apps_run1(2, 4, [3, 12], [1, 7, 8, 14]) == 8", "assert apps_run1(3, 3, [1, 2, 3], [2, 3, 4]) == 1", "assert apps_run1(2, 1, [1, 10], [9]) == 1", "assert apps_run1(3, 19, [7, 10, 13], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]) == 6", "assert apps_run1(3, 3, [2, 3, 4], [1, 3, 5]) == 1", "assert apps_run1(10, 11, [1, 909090909, 1818181817, 2727272725, 3636363633, 4545454541, 5454545449, 6363636357, 7272727265, 8181818173], [454545455, 1363636363, 2272727271, 3181818179, 4090909087, 4999999995, 5909090903, 6818181811, 7727272719, 8636363627, 9545454535]) == 1363636362", "assert apps_run1(3, 10, [4999999999, 5000000000, 5000000001], [1, 1000, 100000, 1000000, 4999999999, 5000000000, 5000000001, 6000000000, 8000000000, 10000000000]) == 4999999999", "assert apps_run1(2, 4, [4500000000, 5500000000], [5, 499999999, 5000000001, 9999999995]) == 5499999993", "assert apps_run1(10, 10, [331462447, 1369967506, 1504296131, 2061390288, 2309640071, 3006707770, 4530801731, 4544099460, 7357049371, 9704808257], [754193799, 3820869903, 4594383880, 5685752675, 6303322854, 6384906441, 7863448848, 8542634752, 9573124462, 9665646063]) == 1840806981", "assert apps_run1(1, 1, [10000000000], [1]) == 9999999999", "assert apps_run1(1, 1, [1], [10000000000]) == 9999999999", "assert apps_run1(10, 10, [9999999991, 9999999992, 9999999993, 9999999994, 9999999995, 9999999996, 9999999997, 9999999998, 9999999999, 10000000000], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 9999999990", "assert apps_run1(3, 12, [477702277, 4717363935, 8947981095], [477702276, 477702304, 477702312, 477702317, 4717363895, 4717363896, 4717363920, 4717363936, 8947981094, 8947981111, 8947981112, 8947981135]) == 42", "assert apps_run1(10, 10, [389151626, 1885767612, 2609703695, 3054567325, 4421751790, 5636236054, 6336088034, 7961001379, 8631992167, 9836923433], [389144165, 389158510, 1885760728, 1885775073, 2609696234, 2609710579, 3054559864, 3054574209, 4421744329, 4421758674]) == 21229", "assert apps_run1(1, 1, [10000000000], [1]) == 9999999999"], "new_problem": "In a data center, a new storage system is being tested. This system uses multiple reading heads to access data tracks on a disk. Initially, the system is tasked with reading a set of specific tracks. However, during operation, additional ranges of tracks may be requested to be read. Given the initial positions of the reading heads and the tracks to be read, determine the minimum time required to read all the specified tracks, including any additional ranges that are requested during operation.", "new_solution": "def solve_initial_problem(n, m, h, p):\n    ss, ll = 0, int(2.2e10)\n    while ss < ll:\n        avg = (ss + ll) // 2\n        works = True\n        hidx = 0\n        pidx = 0\n        while hidx < len(h) and pidx < len(p):\n            leftget = p[pidx]\n            curpos = h[hidx]\n            if curpos - leftget > avg:\n                works = False\n                break\n            getbacktime = max(0, 2*(curpos - leftget))\n            alsotoright = max(0, avg - getbacktime)\n            leftime = max(0, curpos - leftget)\n            remtime = max(0, (avg - leftime) // 2)\n            furthestright = curpos + max(alsotoright, remtime)\n            while pidx < len(p) and p[pidx] <= furthestright: pidx += 1\n            hidx += 1\n        if pidx != len(p): works = False\n        if works: ll = avg\n        else: ss = avg + 1\n    return ss\n\ndef apps_run2(n, m, h, p, k, additional_ranges):\n    # Add additional ranges to the list of tracks to read\n    for a, b in additional_ranges:\n        p.extend(range(a, b + 1))\n    # Remove duplicates and sort the list of tracks to read\n    p = sorted(set(p))\n    # Use the original function to solve the problem with the extended list of tracks\n    return solve_initial_problem(n, len(p), h, p)\n", "input_format": "The first line contains two integers n and m, representing the number of disk heads and the number of tracks to read, respectively. The second line contains n distinct integers representing the initial positions of the heads. The third line contains m distinct integers representing the numbers of tracks to read. The fourth line contains an integer k, representing the number of additional operations. The next k lines each contain two integers a and b, representing a range of tracks that must be read in addition to the original m tracks.", "output_format": "Print a single number \u2014 the minimum time required, in seconds, to read all the needed tracks, including the additional ranges.", "test_input": ["assert apps_run2(3, 4, [2, 5, 6], [1, 3, 6, 8], 1, [(7, 9)]) == 3", "assert apps_run2(3, 3, [1, 2, 3], [1, 2, 3], 2, [(4, 5), (6, 7)]) == 4", "assert apps_run2(1, 2, [165], [142, 200], 1, [(150, 160)]) == 81", "assert apps_run2(2, 2, [10, 20], [15, 25], 1, [(5, 30)]) == 16", "assert apps_run2(4, 5, [1, 10, 20, 30], [5, 15, 25, 35, 45], 2, [(2, 3), (40, 50)]) == 20"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "APPS/2007-2", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nMad scientist Mike does not use slow hard disks. His modification of a hard drive has not one, but n different heads that can read data in parallel.\n\nWhen viewed from the side, Mike's hard drive is an endless array of tracks. The tracks of the array are numbered from left to right with integers, starting with 1. In the initial state the i-th reading head is above the track number h_{i}. For each of the reading heads, the hard drive's firmware can move the head exactly one track to the right or to the left, or leave it on the current track. During the operation each head's movement does not affect the movement of the other heads: the heads can change their relative order; there can be multiple reading heads above any of the tracks. A track is considered read if at least one head has visited this track. In particular, all of the tracks numbered h_1, h_2, ..., h_{n} have been read at the beginning of the operation. [Image] \n\nMike needs to read the data on m distinct tracks with numbers p_1, p_2, ..., p_{m}. Determine the minimum time the hard drive firmware needs to move the heads and read all the given tracks. Note that an arbitrary number of other tracks can also be read.\n\n\n-----Input-----\n\nThe first line of the input contains two space-separated integers n, m (1 \u2264 n, m \u2264 10^5) \u2014 the number of disk heads and the number of tracks to read, accordingly. The second line contains n distinct integers h_{i} in ascending order (1 \u2264 h_{i} \u2264 10^10, h_{i} < h_{i} + 1) \u2014 the initial positions of the heads. The third line contains m distinct integers p_{i} in ascending order (1 \u2264 p_{i} \u2264 10^10, p_{i} < p_{i} + 1) - the numbers of tracks to read.\n\nPlease, do not use the %lld specifier to read or write 64-bit integers in \u0421++. It is recommended to use the cin, cout streams or the %I64d specifier.\n\n\n-----Output-----\n\nPrint a single number \u2014 the minimum time required, in seconds, to read all the needed tracks.\n\n\n-----Examples-----\nInput\n3 4\n2 5 6\n1 3 6 8\n\nOutput\n2\n\nInput\n3 3\n1 2 3\n1 2 3\n\nOutput\n0\n\nInput\n1 2\n165\n142 200\n\nOutput\n81\n\n\n\n-----Note-----\n\nThe first test coincides with the figure. In this case the given tracks can be read in 2 seconds in the following way:   during the first second move the 1-st head to the left and let it stay there;  move the second head to the left twice;  move the third head to the right twice (note that the 6-th track has already been read at the beginning). \n\nOne cannot read the tracks in 1 second as the 3-rd head is at distance 2 from the 8-th track.", "raw_solution": "def apps_run1(n, m, h, p):\n    ss, ll = 0, int(2.2e10)\n    while ss < ll:\n        avg = (ss + ll) // 2\n        works = True\n        hidx = 0\n        pidx = 0\n        while hidx < len(h) and pidx < len(p):\n            leftget = p[pidx]\n            curpos = h[hidx]\n            if curpos - leftget > avg:\n                works = False\n                break\n            getbacktime = max(0, 2*(curpos - leftget))\n            alsotoright = max(0, avg - getbacktime)\n            leftime = max(0, curpos - leftget)\n            remtime = max(0, (avg - leftime) // 2)\n            furthestright = curpos + max(alsotoright, remtime)\n            while pidx < len(p) and p[pidx] <= furthestright: pidx += 1\n            hidx += 1\n        if pidx != len(p): works = False\n        if works: ll = avg\n        else: ss = avg + 1\n    return ss\n", "raw_test_input": ["assert apps_run1(3, 4, [2, 5, 6], [1, 3, 6, 8]) == 2", "assert apps_run1(3, 3, [1, 2, 3], [1, 2, 3]) == 0", "assert apps_run1(1, 2, [165], [142, 200]) == 81", "assert apps_run1(1, 2, [5000000000], [1, 10000000000]) == 14999999998", "assert apps_run1(2, 4, [3, 12], [1, 7, 8, 14]) == 8", "assert apps_run1(3, 3, [1, 2, 3], [2, 3, 4]) == 1", "assert apps_run1(2, 1, [1, 10], [9]) == 1", "assert apps_run1(3, 19, [7, 10, 13], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]) == 6", "assert apps_run1(3, 3, [2, 3, 4], [1, 3, 5]) == 1", "assert apps_run1(10, 11, [1, 909090909, 1818181817, 2727272725, 3636363633, 4545454541, 5454545449, 6363636357, 7272727265, 8181818173], [454545455, 1363636363, 2272727271, 3181818179, 4090909087, 4999999995, 5909090903, 6818181811, 7727272719, 8636363627, 9545454535]) == 1363636362", "assert apps_run1(3, 10, [4999999999, 5000000000, 5000000001], [1, 1000, 100000, 1000000, 4999999999, 5000000000, 5000000001, 6000000000, 8000000000, 10000000000]) == 4999999999", "assert apps_run1(2, 4, [4500000000, 5500000000], [5, 499999999, 5000000001, 9999999995]) == 5499999993", "assert apps_run1(10, 10, [331462447, 1369967506, 1504296131, 2061390288, 2309640071, 3006707770, 4530801731, 4544099460, 7357049371, 9704808257], [754193799, 3820869903, 4594383880, 5685752675, 6303322854, 6384906441, 7863448848, 8542634752, 9573124462, 9665646063]) == 1840806981", "assert apps_run1(1, 1, [10000000000], [1]) == 9999999999", "assert apps_run1(1, 1, [1], [10000000000]) == 9999999999", "assert apps_run1(10, 10, [9999999991, 9999999992, 9999999993, 9999999994, 9999999995, 9999999996, 9999999997, 9999999998, 9999999999, 10000000000], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 9999999990", "assert apps_run1(3, 12, [477702277, 4717363935, 8947981095], [477702276, 477702304, 477702312, 477702317, 4717363895, 4717363896, 4717363920, 4717363936, 8947981094, 8947981111, 8947981112, 8947981135]) == 42", "assert apps_run1(10, 10, [389151626, 1885767612, 2609703695, 3054567325, 4421751790, 5636236054, 6336088034, 7961001379, 8631992167, 9836923433], [389144165, 389158510, 1885760728, 1885775073, 2609696234, 2609710579, 3054559864, 3054574209, 4421744329, 4421758674]) == 21229", "assert apps_run1(1, 1, [10000000000], [1]) == 9999999999"], "new_problem": "Mad scientist Mike has upgraded his hard drive system. In addition to the n different heads that can read data in parallel, the system now supports an optional time offset parameter. This offset represents additional time that should be added to the minimum time required to read all the needed tracks. Determine the minimum time the hard drive firmware needs to move the heads and read all the given tracks, including the optional time offset. The function should maintain backward compatibility, meaning it should work with or without the time offset parameter.", "new_solution": "from typing import List, Optional\n\ndef apps_run2(n: int, m: int, h: List[int], p: List[int], t: Optional[int] = 0) -> int:\n    ss, ll = 0, int(2.2e10)\n    while ss < ll:\n        avg = (ss + ll) // 2\n        works = True\n        hidx = 0\n        pidx = 0\n        while hidx < len(h) and pidx < len(p):\n            leftget = p[pidx]\n            curpos = h[hidx]\n            if curpos - leftget > avg:\n                works = False\n                break\n            getbacktime = max(0, 2*(curpos - leftget))\n            alsotoright = max(0, avg - getbacktime)\n            leftime = max(0, curpos - leftget)\n            remtime = max(0, (avg - leftime) // 2)\n            furthestright = curpos + max(alsotoright, remtime)\n            while pidx < len(p) and p[pidx] <= furthestright: pidx += 1\n            hidx += 1\n        if pidx != len(p): works = False\n        if works: ll = avg\n        else: ss = avg + 1\n    return ss + (t if t is not None else 0)", "input_format": "The first line of the input contains two space-separated integers n, m (1 \u2264 n, m \u2264 10^5) \u2014 the number of disk heads and the number of tracks to read, accordingly. The second line contains n distinct integers h_{i} in ascending order (1 \u2264 h_{i} \u2264 10^10, h_{i} < h_{i} + 1) \u2014 the initial positions of the heads. The third line contains m distinct integers p_{i} in ascending order (1 \u2264 p_{i} \u2264 10^10, p_{i} < p_{i} + 1) - the numbers of tracks to read. Optionally, a fourth line can contain a single integer t (0 \u2264 t \u2264 10^10) representing a time offset that should be added to the final result.", "output_format": "Print a single number \u2014 the minimum time required, in seconds, to read all the needed tracks, including any optional time offset.", "test_input": ["assert apps_run2(3, 4, [2, 5, 6], [1, 3, 6, 8]) == 2", "assert apps_run2(3, 3, [1, 2, 3], [1, 2, 3]) == 0", "assert apps_run2(1, 2, [165], [142, 200]) == 81", "assert apps_run2(3, 4, [2, 5, 6], [1, 3, 6, 8], 5) == 7", "assert apps_run2(3, 3, [1, 2, 3], [1, 2, 3], 10) == 10"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "APPS/2007-3", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nMad scientist Mike does not use slow hard disks. His modification of a hard drive has not one, but n different heads that can read data in parallel.\n\nWhen viewed from the side, Mike's hard drive is an endless array of tracks. The tracks of the array are numbered from left to right with integers, starting with 1. In the initial state the i-th reading head is above the track number h_{i}. For each of the reading heads, the hard drive's firmware can move the head exactly one track to the right or to the left, or leave it on the current track. During the operation each head's movement does not affect the movement of the other heads: the heads can change their relative order; there can be multiple reading heads above any of the tracks. A track is considered read if at least one head has visited this track. In particular, all of the tracks numbered h_1, h_2, ..., h_{n} have been read at the beginning of the operation. [Image] \n\nMike needs to read the data on m distinct tracks with numbers p_1, p_2, ..., p_{m}. Determine the minimum time the hard drive firmware needs to move the heads and read all the given tracks. Note that an arbitrary number of other tracks can also be read.\n\n\n-----Input-----\n\nThe first line of the input contains two space-separated integers n, m (1 \u2264 n, m \u2264 10^5) \u2014 the number of disk heads and the number of tracks to read, accordingly. The second line contains n distinct integers h_{i} in ascending order (1 \u2264 h_{i} \u2264 10^10, h_{i} < h_{i} + 1) \u2014 the initial positions of the heads. The third line contains m distinct integers p_{i} in ascending order (1 \u2264 p_{i} \u2264 10^10, p_{i} < p_{i} + 1) - the numbers of tracks to read.\n\nPlease, do not use the %lld specifier to read or write 64-bit integers in \u0421++. It is recommended to use the cin, cout streams or the %I64d specifier.\n\n\n-----Output-----\n\nPrint a single number \u2014 the minimum time required, in seconds, to read all the needed tracks.\n\n\n-----Examples-----\nInput\n3 4\n2 5 6\n1 3 6 8\n\nOutput\n2\n\nInput\n3 3\n1 2 3\n1 2 3\n\nOutput\n0\n\nInput\n1 2\n165\n142 200\n\nOutput\n81\n\n\n\n-----Note-----\n\nThe first test coincides with the figure. In this case the given tracks can be read in 2 seconds in the following way:   during the first second move the 1-st head to the left and let it stay there;  move the second head to the left twice;  move the third head to the right twice (note that the 6-th track has already been read at the beginning). \n\nOne cannot read the tracks in 1 second as the 3-rd head is at distance 2 from the 8-th track.", "raw_solution": "def apps_run1(n, m, h, p):\n    ss, ll = 0, int(2.2e10)\n    while ss < ll:\n        avg = (ss + ll) // 2\n        works = True\n        hidx = 0\n        pidx = 0\n        while hidx < len(h) and pidx < len(p):\n            leftget = p[pidx]\n            curpos = h[hidx]\n            if curpos - leftget > avg:\n                works = False\n                break\n            getbacktime = max(0, 2*(curpos - leftget))\n            alsotoright = max(0, avg - getbacktime)\n            leftime = max(0, curpos - leftget)\n            remtime = max(0, (avg - leftime) // 2)\n            furthestright = curpos + max(alsotoright, remtime)\n            while pidx < len(p) and p[pidx] <= furthestright: pidx += 1\n            hidx += 1\n        if pidx != len(p): works = False\n        if works: ll = avg\n        else: ss = avg + 1\n    return ss\n", "raw_test_input": ["assert apps_run1(3, 4, [2, 5, 6], [1, 3, 6, 8]) == 2", "assert apps_run1(3, 3, [1, 2, 3], [1, 2, 3]) == 0", "assert apps_run1(1, 2, [165], [142, 200]) == 81", "assert apps_run1(1, 2, [5000000000], [1, 10000000000]) == 14999999998", "assert apps_run1(2, 4, [3, 12], [1, 7, 8, 14]) == 8", "assert apps_run1(3, 3, [1, 2, 3], [2, 3, 4]) == 1", "assert apps_run1(2, 1, [1, 10], [9]) == 1", "assert apps_run1(3, 19, [7, 10, 13], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]) == 6", "assert apps_run1(3, 3, [2, 3, 4], [1, 3, 5]) == 1", "assert apps_run1(10, 11, [1, 909090909, 1818181817, 2727272725, 3636363633, 4545454541, 5454545449, 6363636357, 7272727265, 8181818173], [454545455, 1363636363, 2272727271, 3181818179, 4090909087, 4999999995, 5909090903, 6818181811, 7727272719, 8636363627, 9545454535]) == 1363636362", "assert apps_run1(3, 10, [4999999999, 5000000000, 5000000001], [1, 1000, 100000, 1000000, 4999999999, 5000000000, 5000000001, 6000000000, 8000000000, 10000000000]) == 4999999999", "assert apps_run1(2, 4, [4500000000, 5500000000], [5, 499999999, 5000000001, 9999999995]) == 5499999993", "assert apps_run1(10, 10, [331462447, 1369967506, 1504296131, 2061390288, 2309640071, 3006707770, 4530801731, 4544099460, 7357049371, 9704808257], [754193799, 3820869903, 4594383880, 5685752675, 6303322854, 6384906441, 7863448848, 8542634752, 9573124462, 9665646063]) == 1840806981", "assert apps_run1(1, 1, [10000000000], [1]) == 9999999999", "assert apps_run1(1, 1, [1], [10000000000]) == 9999999999", "assert apps_run1(10, 10, [9999999991, 9999999992, 9999999993, 9999999994, 9999999995, 9999999996, 9999999997, 9999999998, 9999999999, 10000000000], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 9999999990", "assert apps_run1(3, 12, [477702277, 4717363935, 8947981095], [477702276, 477702304, 477702312, 477702317, 4717363895, 4717363896, 4717363920, 4717363936, 8947981094, 8947981111, 8947981112, 8947981135]) == 42", "assert apps_run1(10, 10, [389151626, 1885767612, 2609703695, 3054567325, 4421751790, 5636236054, 6336088034, 7961001379, 8631992167, 9836923433], [389144165, 389158510, 1885760728, 1885775073, 2609696234, 2609710579, 3054559864, 3054574209, 4421744329, 4421758674]) == 21229", "assert apps_run1(1, 1, [10000000000], [1]) == 9999999999"], "new_problem": "Mad scientist Mike has upgraded his hard drive system. Now, each head can be assigned a priority level, and the tracks to be read are grouped into clusters. Each cluster must be read completely before moving to the next. The heads can be moved to any track within a cluster, but the priority level determines the order in which heads should be used to read tracks. Determine the minimum time required to read all clusters, given that heads with higher priority should be used first. Use a dictionary to map head priorities to their initial positions and a list of lists to represent clusters of tracks.", "new_solution": "from typing import List, Dict\n\ndef apps_run2(n: int, m: int, head_priorities: Dict[int, int], track_clusters: List[List[int]]) -> int:\n    def can_read_all_clusters(max_time: int) -> bool:\n        for cluster in track_clusters:\n            cluster.sort()\n            hidx = 0\n            pidx = 0\n            heads = sorted(head_priorities.items())\n            while hidx < len(heads) and pidx < len(cluster):\n                leftget = cluster[pidx]\n                curpos = heads[hidx][1]\n                if curpos - leftget > max_time:\n                    return False\n                getbacktime = max(0, 2 * (curpos - leftget))\n                alsotoright = max(0, max_time - getbacktime)\n                leftime = max(0, curpos - leftget)\n                remtime = max(0, (max_time - leftime) // 2)\n                furthestright = curpos + max(alsotoright, remtime)\n                while pidx < len(cluster) and cluster[pidx] <= furthestright:\n                    pidx += 1\n                hidx += 1\n            if pidx != len(cluster):\n                return False\n        return True\n\n    ss, ll = 0, int(2.2e10)\n    while ss < ll:\n        avg = (ss + ll) // 2\n        if can_read_all_clusters(avg):\n            ll = avg\n        else:\n            ss = avg + 1\n    return ss", "input_format": "The first line of the input contains two space-separated integers n, m (1 \u2264 n, m \u2264 10^5) \u2014 the number of disk heads and the number of tracks to read, accordingly. The second line contains n distinct integers h_{i} in ascending order (1 \u2264 h_{i} \u2264 10^10, h_{i} < h_{i} + 1) \u2014 the initial positions of the heads. The third line contains m distinct integers p_{i} in ascending order (1 \u2264 p_{i} \u2264 10^10, p_{i} < p_{i} + 1) - the numbers of tracks to read.", "output_format": "Print a single number \u2014 the minimum time required, in seconds, to read all the needed tracks.", "test_input": ["assert apps_run2(3, 4, {1: 2, 2: 5, 3: 6}, [[1, 3], [6, 8]]) == 2", "assert apps_run2(3, 3, {1: 1, 2: 2, 3: 3}, [[1, 2, 3]]) == 0", "assert apps_run2(1, 2, {1: 165}, [[142], [200]]) == 35", "assert apps_run2(2, 3, {1: 10, 2: 20}, [[5, 15], [25, 30]]) == 10", "assert apps_run2(4, 5, {1: 1, 2: 10, 3: 20, 4: 30}, [[2, 3], [15, 25], [28, 35]]) == 8"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "APPS/2007-4", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nMad scientist Mike does not use slow hard disks. His modification of a hard drive has not one, but n different heads that can read data in parallel.\n\nWhen viewed from the side, Mike's hard drive is an endless array of tracks. The tracks of the array are numbered from left to right with integers, starting with 1. In the initial state the i-th reading head is above the track number h_{i}. For each of the reading heads, the hard drive's firmware can move the head exactly one track to the right or to the left, or leave it on the current track. During the operation each head's movement does not affect the movement of the other heads: the heads can change their relative order; there can be multiple reading heads above any of the tracks. A track is considered read if at least one head has visited this track. In particular, all of the tracks numbered h_1, h_2, ..., h_{n} have been read at the beginning of the operation. [Image] \n\nMike needs to read the data on m distinct tracks with numbers p_1, p_2, ..., p_{m}. Determine the minimum time the hard drive firmware needs to move the heads and read all the given tracks. Note that an arbitrary number of other tracks can also be read.\n\n\n-----Input-----\n\nThe first line of the input contains two space-separated integers n, m (1 \u2264 n, m \u2264 10^5) \u2014 the number of disk heads and the number of tracks to read, accordingly. The second line contains n distinct integers h_{i} in ascending order (1 \u2264 h_{i} \u2264 10^10, h_{i} < h_{i} + 1) \u2014 the initial positions of the heads. The third line contains m distinct integers p_{i} in ascending order (1 \u2264 p_{i} \u2264 10^10, p_{i} < p_{i} + 1) - the numbers of tracks to read.\n\nPlease, do not use the %lld specifier to read or write 64-bit integers in \u0421++. It is recommended to use the cin, cout streams or the %I64d specifier.\n\n\n-----Output-----\n\nPrint a single number \u2014 the minimum time required, in seconds, to read all the needed tracks.\n\n\n-----Examples-----\nInput\n3 4\n2 5 6\n1 3 6 8\n\nOutput\n2\n\nInput\n3 3\n1 2 3\n1 2 3\n\nOutput\n0\n\nInput\n1 2\n165\n142 200\n\nOutput\n81\n\n\n\n-----Note-----\n\nThe first test coincides with the figure. In this case the given tracks can be read in 2 seconds in the following way:   during the first second move the 1-st head to the left and let it stay there;  move the second head to the left twice;  move the third head to the right twice (note that the 6-th track has already been read at the beginning). \n\nOne cannot read the tracks in 1 second as the 3-rd head is at distance 2 from the 8-th track.", "raw_solution": "def apps_run1(n, m, h, p):\n    ss, ll = 0, int(2.2e10)\n    while ss < ll:\n        avg = (ss + ll) // 2\n        works = True\n        hidx = 0\n        pidx = 0\n        while hidx < len(h) and pidx < len(p):\n            leftget = p[pidx]\n            curpos = h[hidx]\n            if curpos - leftget > avg:\n                works = False\n                break\n            getbacktime = max(0, 2*(curpos - leftget))\n            alsotoright = max(0, avg - getbacktime)\n            leftime = max(0, curpos - leftget)\n            remtime = max(0, (avg - leftime) // 2)\n            furthestright = curpos + max(alsotoright, remtime)\n            while pidx < len(p) and p[pidx] <= furthestright: pidx += 1\n            hidx += 1\n        if pidx != len(p): works = False\n        if works: ll = avg\n        else: ss = avg + 1\n    return ss\n", "raw_test_input": ["assert apps_run1(3, 4, [2, 5, 6], [1, 3, 6, 8]) == 2", "assert apps_run1(3, 3, [1, 2, 3], [1, 2, 3]) == 0", "assert apps_run1(1, 2, [165], [142, 200]) == 81", "assert apps_run1(1, 2, [5000000000], [1, 10000000000]) == 14999999998", "assert apps_run1(2, 4, [3, 12], [1, 7, 8, 14]) == 8", "assert apps_run1(3, 3, [1, 2, 3], [2, 3, 4]) == 1", "assert apps_run1(2, 1, [1, 10], [9]) == 1", "assert apps_run1(3, 19, [7, 10, 13], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]) == 6", "assert apps_run1(3, 3, [2, 3, 4], [1, 3, 5]) == 1", "assert apps_run1(10, 11, [1, 909090909, 1818181817, 2727272725, 3636363633, 4545454541, 5454545449, 6363636357, 7272727265, 8181818173], [454545455, 1363636363, 2272727271, 3181818179, 4090909087, 4999999995, 5909090903, 6818181811, 7727272719, 8636363627, 9545454535]) == 1363636362", "assert apps_run1(3, 10, [4999999999, 5000000000, 5000000001], [1, 1000, 100000, 1000000, 4999999999, 5000000000, 5000000001, 6000000000, 8000000000, 10000000000]) == 4999999999", "assert apps_run1(2, 4, [4500000000, 5500000000], [5, 499999999, 5000000001, 9999999995]) == 5499999993", "assert apps_run1(10, 10, [331462447, 1369967506, 1504296131, 2061390288, 2309640071, 3006707770, 4530801731, 4544099460, 7357049371, 9704808257], [754193799, 3820869903, 4594383880, 5685752675, 6303322854, 6384906441, 7863448848, 8542634752, 9573124462, 9665646063]) == 1840806981", "assert apps_run1(1, 1, [10000000000], [1]) == 9999999999", "assert apps_run1(1, 1, [1], [10000000000]) == 9999999999", "assert apps_run1(10, 10, [9999999991, 9999999992, 9999999993, 9999999994, 9999999995, 9999999996, 9999999997, 9999999998, 9999999999, 10000000000], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 9999999990", "assert apps_run1(3, 12, [477702277, 4717363935, 8947981095], [477702276, 477702304, 477702312, 477702317, 4717363895, 4717363896, 4717363920, 4717363936, 8947981094, 8947981111, 8947981112, 8947981135]) == 42", "assert apps_run1(10, 10, [389151626, 1885767612, 2609703695, 3054567325, 4421751790, 5636236054, 6336088034, 7961001379, 8631992167, 9836923433], [389144165, 389158510, 1885760728, 1885775073, 2609696234, 2609710579, 3054559864, 3054574209, 4421744329, 4421758674]) == 21229", "assert apps_run1(1, 1, [10000000000], [1]) == 9999999999"], "new_problem": "Mad scientist Mike's hard drive system is now being used in a critical data center, and it is crucial to ensure that the system handles errors gracefully. You need to modify the function to handle the following errors: 1. InputValidationError: Raised when the input does not meet the specified constraints (e.g., n or m is out of bounds, or the lists are not sorted). 2. TrackNotFoundError: Raised when a track to be read is not within the range of possible track numbers. 3. SystemFailureError: Raised when an unexpected system failure occurs during the operation. Implement error handling for these scenarios and ensure that meaningful error messages are provided. The function should propagate errors up the call stack if they cannot be handled locally.", "new_solution": "from typing import List\n\nclass InputValidationError(Exception):\n    pass\n\nclass TrackNotFoundError(Exception):\n    pass\n\nclass SystemFailureError(Exception):\n    pass\n\ndef apps_run2(n: int, m: int, h: List[int], p: List[int]) -> int:\n    try:\n        if not (1 <= n <= 100000) or not (1 <= m <= 100000):\n            raise InputValidationError(\"n or m is out of bounds\")\n        if h != sorted(h) or p != sorted(p):\n            raise InputValidationError(\"Input lists must be sorted\")\n        if any(track < 1 or track > 10000000000 for track in h + p):\n            raise TrackNotFoundError(\"Track number out of valid range\")\n\n        ss, ll = 0, int(2.2e10)\n        while ss < ll:\n            avg = (ss + ll) // 2\n            works = True\n            hidx = 0\n            pidx = 0\n            while hidx < len(h) and pidx < len(p):\n                leftget = p[pidx]\n                curpos = h[hidx]\n                if curpos - leftget > avg:\n                    works = False\n                    break\n                getbacktime = max(0, 2*(curpos - leftget))\n                alsotoright = max(0, avg - getbacktime)\n                leftime = max(0, curpos - leftget)\n                remtime = max(0, (avg - leftime) // 2)\n                furthestright = curpos + max(alsotoright, remtime)\n                while pidx < len(p) and p[pidx] <= furthestright: pidx += 1\n                hidx += 1\n            if pidx != len(p): works = False\n            if works: ll = avg\n            else: ss = avg + 1\n        return ss\n    except (InputValidationError, TrackNotFoundError) as e:\n        print(f\"Error: {e}\")\n        raise\n    except Exception as e:\n        raise SystemFailureError(\"An unexpected system failure occurred\") from e", "input_format": "The first line of the input contains two space-separated integers n, m (1 \u2264 n, m \u2264 10^5) \u2014 the number of disk heads and the number of tracks to read, accordingly. The second line contains n distinct integers h_{i} in ascending order (1 \u2264 h_{i} \u2264 10^10, h_{i} < h_{i} + 1) \u2014 the initial positions of the heads. The third line contains m distinct integers p_{i} in ascending order (1 \u2264 p_{i} \u2264 10^10, p_{i} < p_{i} + 1) - the numbers of tracks to read.", "output_format": "Print a single number \u2014 the minimum time required, in seconds, to read all the needed tracks.", "test_input": ["assert apps_run2(3, 4, [2, 5, 6], [1, 3, 6, 8]) == 2", "assert apps_run2(3, 3, [1, 2, 3], [1, 2, 3]) == 0", "assert apps_run2(1, 2, [165], [142, 200]) == 81", "try:\n    apps_run2(0, 2, [165], [142, 200])\nexcept InputValidationError as e:\n    assert str(e) == \"n or m is out of bounds\"", "try:\n    apps_run2(1, 2, [165], [20000000000])\nexcept TrackNotFoundError as e:\n    assert str(e) == \"Track number out of valid range\""], "requirement_type": "PROMPT_ERROR_HANDLING"}
{"task_id": "APPS/2000-1", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nCodefortia is a small island country located somewhere in the West Pacific. It consists of $n$ settlements connected by $m$ bidirectional gravel roads. Curiously enough, the beliefs of the inhabitants require the time needed to pass each road to be equal either to $a$ or $b$ seconds. It's guaranteed that one can go between any pair of settlements by following a sequence of roads.\n\nCodefortia was recently struck by the financial crisis. Therefore, the king decided to abandon some of the roads so that:\n\n  it will be possible to travel between each pair of cities using the remaining roads only,  the sum of times required to pass each remaining road will be minimum possible (in other words, remaining roads must form minimum spanning tree, using the time to pass the road as its weight),  among all the plans minimizing the sum of times above, the time required to travel between the king's residence (in settlement $1$) and the parliament house (in settlement $p$) using the remaining roads only will be minimum possible. \n\nThe king, however, forgot where the parliament house was. For each settlement $p = 1, 2, \\dots, n$, can you tell what is the minimum time required to travel between the king's residence and the parliament house (located in settlement $p$) after some roads are abandoned?\n\n\n-----Input-----\n\nThe first line of the input contains four integers $n$, $m$, $a$ and $b$ ($2 \\leq n \\leq 70$, $n - 1 \\leq m \\leq 200$, $1 \\leq a < b \\leq 10^7$) \u2014 the number of settlements and gravel roads in Codefortia, and two possible travel times. Each of the following lines contains three integers $u, v, c$ ($1 \\leq u, v \\leq n$, $u \\neq v$, $c \\in \\{a, b\\}$) denoting a single gravel road between the settlements $u$ and $v$, which requires $c$ minutes to travel.\n\nYou can assume that the road network is connected and has no loops or multiedges.\n\n\n-----Output-----\n\nOutput a single line containing $n$ integers. The $p$-th of them should denote the minimum possible time required to travel from $1$ to $p$ after the selected roads are abandoned. Note that for each $p$ you can abandon a different set of roads.\n\n\n-----Examples-----\nInput\n5 5 20 25\n1 2 25\n2 3 25\n3 4 20\n4 5 20\n5 1 20\n\nOutput\n0 25 60 40 20\n\nInput\n6 7 13 22\n1 2 13\n2 3 13\n1 4 22\n3 4 13\n4 5 13\n5 6 13\n6 1 13\n\nOutput\n0 13 26 39 26 13\n\n\n\n-----Note-----\n\nThe minimum possible sum of times required to pass each road in the first example is $85$ \u2014 exactly one of the roads with passing time $25$ must be abandoned. Note that after one of these roads is abandoned, it's now impossible to travel between settlements $1$ and $3$ in time $50$.", "raw_solution": "def apps_run1(n, m, a, b, edges):\n    import heapq\n    graph = {i: [] for i in range(n)}\n    for u, v, w in edges:\n        graph[u-1].append((v-1, w))\n        graph[v-1].append((u-1, w))\n    components = [-1] * n\n    comp = -1\n    for i in range(n):\n        if components[i] == -1:\n            comp += 1\n            components[i] = comp\n            prev = []\n            layer = [i]\n            while layer != []:\n                newlayer = []\n                for guy in layer:\n                    for guy1 in graph[guy]:\n                        if guy1[1] == a and components[guy1[0]] == -1:\n                            newlayer.append(guy1[0])\n                            components[guy1[0]] = comp\n                prev = layer[:]\n                layer = newlayer[:]\n    useless = []\n    for guy in graph:\n        for neigh in graph[guy]:\n            if components[guy] == components[neigh[0]] and neigh[1] == b:\n                useless.append((guy, neigh))\n    for guy in useless:\n        graph[guy[0]].remove(guy[1])\n    counts = [0] * (comp + 1)\n    for i in range(n):\n        counts[components[i]] += 1\n    bad = []\n    for i in range(comp + 1):\n        if counts[i] <= 3:\n            bad.append(i)\n            for j in range(n):\n                if components[j] == i:\n                    components[j] = -1\n    for guy in bad[::-1]:\n        for i in range(n):\n            if components[i] > guy:\n                components[i] -= 1\n    comp -= len(bad)\n    comp += 1\n    dists = [[float('inf') for i in range(2 ** comp)] for j in range(n)]\n    dists[0][0] = 0\n    pq = []\n    heapq.heappush(pq, [0, 0, 0])\n    remaining = n\n    visited = [0] * n\n    while len(pq) > 0 and remaining > 0:\n        dist, vert, mask = heapq.heappop(pq)\n        if visited[vert] == 0:\n            visited[vert] = 1\n            remaining -= 1\n        for neigh in graph[vert]:\n            if neigh[1] == b:\n                if components[vert] == components[neigh[0]] and components[vert] != -1:\n                    continue\n                if components[neigh[0]] != -1:\n                    if mask & (2 ** components[neigh[0]]) > 0:\n                        continue\n                if components[vert] != -1:\n                    maskn = mask + 2 ** (components[vert])\n                else:\n                    maskn = mask\n            else:\n                maskn = mask\n            if dist + neigh[1] < dists[neigh[0]][maskn]:\n                dists[neigh[0]][maskn] = dist + neigh[1]\n                heapq.heappush(pq, [dist + neigh[1], neigh[0], maskn])\n    optimal = [str(min(dists[i])) for i in range(n)]\n    return ' '.join(optimal)", "raw_test_input": ["assert apps_run1(5, 5, 20, 25, [(1, 2, 25), (2, 3, 25), (3, 4, 20), (4, 5, 20), (5, 1, 20)]) == '0 25 60 40 20'", "assert apps_run1(6, 7, 13, 22, [(1, 2, 13), (2, 3, 13), (1, 4, 22), (3, 4, 13), (4, 5, 13), (5, 6, 13), (6, 1, 13)]) == '0 13 26 39 26 13'", "assert apps_run1(2, 1, 1, 2, [(2, 1, 1)]) == '0 1'"], "new_problem": "In the island country of Codefortia, the government is planning to optimize the road network to minimize travel times between settlements. The roads have travel times of either a or b seconds. The government wants to ensure that the road network remains connected and the sum of travel times is minimized. Additionally, they want to answer multiple queries about the minimum travel time between different pairs of settlements after the optimization. Can you help them by providing the minimum travel time for each query?", "new_solution": "import heapq\n\ndef optimize_road_network(n, m, a, b, roads):\n    graph = {i: [] for i in range(n)}\n    for u, v, w in roads:\n        graph[u-1].append((v-1, w))\n        graph[v-1].append((u-1, w))\n    components = [-1] * n\n    comp = -1\n    for i in range(n):\n        if components[i] == -1:\n            comp += 1\n            components[i] = comp\n            prev = []\n            layer = [i]\n            while layer != []:\n                newlayer = []\n                for guy in layer:\n                    for guy1 in graph[guy]:\n                        if guy1[1] == a and components[guy1[0]] == -1:\n                            newlayer.append(guy1[0])\n                            components[guy1[0]] = comp\n                prev = layer[:]\n                layer = newlayer[:]\n    useless = []\n    for guy in graph:\n        for neigh in graph[guy]:\n            if components[guy] == components[neigh[0]] and neigh[1] == b:\n                useless.append((guy, neigh))\n    for guy in useless:\n        graph[guy[0]].remove(guy[1])\n    counts = [0] * (comp + 1)\n    for i in range(n):\n        counts[components[i]] += 1\n    bad = []\n    for i in range(comp + 1):\n        if counts[i] <= 3:\n            bad.append(i)\n            for j in range(n):\n                if components[j] == i:\n                    components[j] = -1\n    for guy in bad[::-1]:\n        for i in range(n):\n            if components[i] > guy:\n                components[i] -= 1\n    comp -= len(bad)\n    comp += 1\n    dists = [[float(\"inf\") for i in range(2**comp)] for j in range(n)]\n    dists[0][0] = 0\n    pq = []\n    heapq.heappush(pq, [0, 0, 0])\n    remaining = n\n    visited = [0] * n\n    while len(pq) > 0 and remaining > 0:\n        dist, vert, mask = heapq.heappop(pq)\n        if visited[vert] == 0:\n            visited[vert] = 1\n            remaining -= 1\n        for neigh in graph[vert]:\n            if neigh[1] == b:\n                if components[vert] == components[neigh[0]] and components[vert] != -1:\n                    continue\n                if components[neigh[0]] != -1:\n                    if mask & (2**components[neigh[0]]) > 0:\n                        continue\n                if components[vert] != -1:\n                    maskn = mask + 2**(components[vert])\n                else:\n                    maskn = mask\n            else:\n                maskn = mask\n            if dist + neigh[1] < dists[neigh[0]][maskn]:\n                dists[neigh[0]][maskn] = dist + neigh[1]\n                heapq.heappush(pq, [dist + neigh[1], neigh[0], maskn])\n    return [min(dists[i]) for i in range(n)]\n\ndef apps_run2(n, m, a, b, roads, queries):\n    min_times = optimize_road_network(n, m, a, b, roads)\n    results = []\n    for x, y in queries:\n        results.append(min_times[y-1])\n    return results\n", "input_format": "The first line contains four integers n, m, a, b. Each of the following m lines contains three integers u, v, c. The next line contains an integer q, the number of queries. Each of the following q lines contains two integers x, y representing a query for the minimum travel time between settlements x and y.", "output_format": "Output q lines, each containing a single integer representing the minimum travel time between the queried settlements after the roads are optimized.", "test_input": ["assert apps_run2(5, 5, 20, 25, [(1, 2, 25), (2, 3, 25), (3, 4, 20), (4, 5, 20), (5, 1, 20)], [(1, 3), (1, 4), (1, 5)]) == [60, 40, 20]", "assert apps_run2(6, 7, 13, 22, [(1, 2, 13), (2, 3, 13), (1, 4, 22), (3, 4, 13), (4, 5, 13), (5, 6, 13), (6, 1, 13)], [(1, 6), (1, 5), (1, 3)]) == [13, 26, 26]", "assert apps_run2(4, 4, 5, 10, [(1, 2, 5), (2, 3, 10), (3, 4, 5), (4, 1, 10)], [(1, 2), (1, 3), (1, 4)]) == [5, 15, 10]", "assert apps_run2(3, 3, 7, 14, [(1, 2, 7), (2, 3, 14), (3, 1, 7)], [(1, 3), (1, 2)]) == [7, 7]", "assert apps_run2(7, 8, 8, 16, [(1, 2, 8), (2, 3, 8), (3, 4, 16), (4, 5, 8), (5, 6, 8), (6, 7, 16), (7, 1, 8), (3, 5, 8)], [(1, 4), (1, 6), (1, 7)]) == [32, 32, 8]"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "APPS/2000-2", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nCodefortia is a small island country located somewhere in the West Pacific. It consists of $n$ settlements connected by $m$ bidirectional gravel roads. Curiously enough, the beliefs of the inhabitants require the time needed to pass each road to be equal either to $a$ or $b$ seconds. It's guaranteed that one can go between any pair of settlements by following a sequence of roads.\n\nCodefortia was recently struck by the financial crisis. Therefore, the king decided to abandon some of the roads so that:\n\n  it will be possible to travel between each pair of cities using the remaining roads only,  the sum of times required to pass each remaining road will be minimum possible (in other words, remaining roads must form minimum spanning tree, using the time to pass the road as its weight),  among all the plans minimizing the sum of times above, the time required to travel between the king's residence (in settlement $1$) and the parliament house (in settlement $p$) using the remaining roads only will be minimum possible. \n\nThe king, however, forgot where the parliament house was. For each settlement $p = 1, 2, \\dots, n$, can you tell what is the minimum time required to travel between the king's residence and the parliament house (located in settlement $p$) after some roads are abandoned?\n\n\n-----Input-----\n\nThe first line of the input contains four integers $n$, $m$, $a$ and $b$ ($2 \\leq n \\leq 70$, $n - 1 \\leq m \\leq 200$, $1 \\leq a < b \\leq 10^7$) \u2014 the number of settlements and gravel roads in Codefortia, and two possible travel times. Each of the following lines contains three integers $u, v, c$ ($1 \\leq u, v \\leq n$, $u \\neq v$, $c \\in \\{a, b\\}$) denoting a single gravel road between the settlements $u$ and $v$, which requires $c$ minutes to travel.\n\nYou can assume that the road network is connected and has no loops or multiedges.\n\n\n-----Output-----\n\nOutput a single line containing $n$ integers. The $p$-th of them should denote the minimum possible time required to travel from $1$ to $p$ after the selected roads are abandoned. Note that for each $p$ you can abandon a different set of roads.\n\n\n-----Examples-----\nInput\n5 5 20 25\n1 2 25\n2 3 25\n3 4 20\n4 5 20\n5 1 20\n\nOutput\n0 25 60 40 20\n\nInput\n6 7 13 22\n1 2 13\n2 3 13\n1 4 22\n3 4 13\n4 5 13\n5 6 13\n6 1 13\n\nOutput\n0 13 26 39 26 13\n\n\n\n-----Note-----\n\nThe minimum possible sum of times required to pass each road in the first example is $85$ \u2014 exactly one of the roads with passing time $25$ must be abandoned. Note that after one of these roads is abandoned, it's now impossible to travel between settlements $1$ and $3$ in time $50$.", "raw_solution": "def apps_run1(n, m, a, b, edges):\n    import heapq\n    graph = {i: [] for i in range(n)}\n    for u, v, w in edges:\n        graph[u-1].append((v-1, w))\n        graph[v-1].append((u-1, w))\n    components = [-1] * n\n    comp = -1\n    for i in range(n):\n        if components[i] == -1:\n            comp += 1\n            components[i] = comp\n            prev = []\n            layer = [i]\n            while layer != []:\n                newlayer = []\n                for guy in layer:\n                    for guy1 in graph[guy]:\n                        if guy1[1] == a and components[guy1[0]] == -1:\n                            newlayer.append(guy1[0])\n                            components[guy1[0]] = comp\n                prev = layer[:]\n                layer = newlayer[:]\n    useless = []\n    for guy in graph:\n        for neigh in graph[guy]:\n            if components[guy] == components[neigh[0]] and neigh[1] == b:\n                useless.append((guy, neigh))\n    for guy in useless:\n        graph[guy[0]].remove(guy[1])\n    counts = [0] * (comp + 1)\n    for i in range(n):\n        counts[components[i]] += 1\n    bad = []\n    for i in range(comp + 1):\n        if counts[i] <= 3:\n            bad.append(i)\n            for j in range(n):\n                if components[j] == i:\n                    components[j] = -1\n    for guy in bad[::-1]:\n        for i in range(n):\n            if components[i] > guy:\n                components[i] -= 1\n    comp -= len(bad)\n    comp += 1\n    dists = [[float('inf') for i in range(2 ** comp)] for j in range(n)]\n    dists[0][0] = 0\n    pq = []\n    heapq.heappush(pq, [0, 0, 0])\n    remaining = n\n    visited = [0] * n\n    while len(pq) > 0 and remaining > 0:\n        dist, vert, mask = heapq.heappop(pq)\n        if visited[vert] == 0:\n            visited[vert] = 1\n            remaining -= 1\n        for neigh in graph[vert]:\n            if neigh[1] == b:\n                if components[vert] == components[neigh[0]] and components[vert] != -1:\n                    continue\n                if components[neigh[0]] != -1:\n                    if mask & (2 ** components[neigh[0]]) > 0:\n                        continue\n                if components[vert] != -1:\n                    maskn = mask + 2 ** (components[vert])\n                else:\n                    maskn = mask\n            else:\n                maskn = mask\n            if dist + neigh[1] < dists[neigh[0]][maskn]:\n                dists[neigh[0]][maskn] = dist + neigh[1]\n                heapq.heappush(pq, [dist + neigh[1], neigh[0], maskn])\n    optimal = [str(min(dists[i])) for i in range(n)]\n    return ' '.join(optimal)", "raw_test_input": ["assert apps_run1(5, 5, 20, 25, [(1, 2, 25), (2, 3, 25), (3, 4, 20), (4, 5, 20), (5, 1, 20)]) == '0 25 60 40 20'", "assert apps_run1(6, 7, 13, 22, [(1, 2, 13), (2, 3, 13), (1, 4, 22), (3, 4, 13), (4, 5, 13), (5, 6, 13), (6, 1, 13)]) == '0 13 26 39 26 13'", "assert apps_run1(2, 1, 1, 2, [(2, 1, 1)]) == '0 1'"], "new_problem": "Codefortia is a small island country located somewhere in the West Pacific. It consists of n settlements connected by m bidirectional gravel roads. Curiously enough, the beliefs of the inhabitants require the time needed to pass each road to be equal either to a or b seconds. It's guaranteed that one can go between any pair of settlements by following a sequence of roads. Codefortia was recently struck by the financial crisis. Therefore, the king decided to abandon some of the roads so that: it will be possible to travel between each pair of cities using the remaining roads only, the sum of times required to pass each remaining road will be minimum possible (in other words, remaining roads must form minimum spanning tree, using the time to pass the road as its weight), among all the plans minimizing the sum of times above, the time required to travel between the king's residence (in settlement 1) and the parliament house (in settlement p) using the remaining roads only will be minimum possible. The king, however, forgot where the parliament house was. For each settlement p = 1, 2, ..., n, can you tell what is the minimum time required to travel between the king's residence and the parliament house (located in settlement p) after some roads are abandoned? Additionally, the king wants to know the total number of roads that were abandoned. Implement a function that maintains backward compatibility with existing implementations, supports original function parameters, includes type hints, and adds a new optional parameter to return the number of abandoned roads.", "new_solution": "from typing import List, Tuple, Optional\nimport heapq\n\ndef apps_run2(n: int, m: int, a: int, b: int, roads: List[Tuple[int, int, int]], return_abandoned_count: Optional[bool] = False) -> Tuple[List[int], Optional[int]]:\n    graph = {i: [] for i in range(n)}\n    for u, v, w in roads:\n        graph[u - 1].append((v - 1, w))\n        graph[v - 1].append((u - 1, w))\n    components = [-1] * n\n    comp = -1\n    for i in range(n):\n        if components[i] == -1:\n            comp += 1\n            components[i] = comp\n            prev = []\n            layer = [i]\n            while layer != []:\n                newlayer = []\n                for guy in layer:\n                    for guy1 in graph[guy]:\n                        if guy1[1] == a and components[guy1[0]] == -1:\n                            newlayer.append(guy1[0])\n                            components[guy1[0]] = comp\n                prev = layer[:]\n                layer = newlayer[:]\n    useless = []\n    for guy in graph:\n        for neigh in graph[guy]:\n            if components[guy] == components[neigh[0]] and neigh[1] == b:\n                useless.append((guy, neigh))\n    for guy in useless:\n        graph[guy[0]].remove(guy[1])\n    counts = [0] * (comp + 1)\n    for i in range(n):\n        counts[components[i]] += 1\n    bad = []\n    for i in range(comp + 1):\n        if counts[i] <= 3:\n            bad.append(i)\n            for j in range(n):\n                if components[j] == i:\n                    components[j] = -1\n    for guy in bad[::-1]:\n        for i in range(n):\n            if components[i] > guy:\n                components[i] -= 1\n    comp -= len(bad)\n    comp += 1\n    dists = [[float(\"inf\") for i in range(2 ** comp)] for j in range(n)]\n    dists[0][0] = 0\n    pq = []\n    heapq.heappush(pq, [0, 0, 0])\n    remaining = n\n    visited = [0] * n\n    while len(pq) > 0 and remaining > 0:\n        dist, vert, mask = heapq.heappop(pq)\n        if visited[vert] == 0:\n            visited[vert] = 1\n            remaining -= 1\n        for neigh in graph[vert]:\n            if neigh[1] == b:\n                if components[vert] == components[neigh[0]] and components[vert] != -1:\n                    continue\n                if components[neigh[0]] != -1:\n                    if mask & (2 ** components[neigh[0]]) > 0:\n                        continue\n                if components[vert] != -1:\n                    maskn = mask + 2 ** (components[vert])\n                else:\n                    maskn = mask\n            else:\n                maskn = mask\n            if dist + neigh[1] < dists[neigh[0]][maskn]:\n                dists[neigh[0]][maskn] = dist + neigh[1]\n                heapq.heappush(pq, [dist + neigh[1], neigh[0], maskn])\n    optimal = [min(dists[i]) for i in range(n)]\n    abandoned_count = len(useless) if return_abandoned_count else None\n    return optimal, abandoned_count", "input_format": "The first line of the input contains four integers n, m, a, b (2 \u2264 n \u2264 70, n - 1 \u2264 m \u2264 200, 1 \u2264 a < b \u2264 10^7) \u2014 the number of settlements and gravel roads in Codefortia, and two possible travel times. Each of the following lines contains three integers u, v, c (1 \u2264 u, v \u2264 n, u \u2260 v, c \u2208 {a, b}) denoting a single gravel road between the settlements u and v, which requires c minutes to travel.", "output_format": "Output a single line containing n integers. The p-th of them should denote the minimum possible time required to travel from 1 to p after the selected roads are abandoned.", "test_input": ["assert apps_run2(5, 5, 20, 25, [(1, 2, 25), (2, 3, 25), (3, 4, 20), (4, 5, 20), (5, 1, 20)]) == ([0, 25, 60, 40, 20], None)", "assert apps_run2(6, 7, 13, 22, [(1, 2, 13), (2, 3, 13), (1, 4, 22), (3, 4, 13), (4, 5, 13), (5, 6, 13), (6, 1, 13)]) == ([0, 13, 26, 39, 26, 13], None)", "assert apps_run2(5, 5, 20, 25, [(1, 2, 25), (2, 3, 25), (3, 4, 20), (4, 5, 20), (5, 1, 20)], True) == ([0, 25, 60, 40, 20], 0)", "assert apps_run2(6, 7, 13, 22, [(1, 2, 13), (2, 3, 13), (1, 4, 22), (3, 4, 13), (4, 5, 13), (5, 6, 13), (6, 1, 13)], True) == ([0, 13, 26, 39, 26, 13], 2)", "assert apps_run2(4, 4, 5, 10, [(1, 2, 5), (2, 3, 10), (3, 4, 5), (4, 1, 10)], True) == ([0, 5, 15, 10], 0)"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "APPS/2000-3", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nCodefortia is a small island country located somewhere in the West Pacific. It consists of $n$ settlements connected by $m$ bidirectional gravel roads. Curiously enough, the beliefs of the inhabitants require the time needed to pass each road to be equal either to $a$ or $b$ seconds. It's guaranteed that one can go between any pair of settlements by following a sequence of roads.\n\nCodefortia was recently struck by the financial crisis. Therefore, the king decided to abandon some of the roads so that:\n\n  it will be possible to travel between each pair of cities using the remaining roads only,  the sum of times required to pass each remaining road will be minimum possible (in other words, remaining roads must form minimum spanning tree, using the time to pass the road as its weight),  among all the plans minimizing the sum of times above, the time required to travel between the king's residence (in settlement $1$) and the parliament house (in settlement $p$) using the remaining roads only will be minimum possible. \n\nThe king, however, forgot where the parliament house was. For each settlement $p = 1, 2, \\dots, n$, can you tell what is the minimum time required to travel between the king's residence and the parliament house (located in settlement $p$) after some roads are abandoned?\n\n\n-----Input-----\n\nThe first line of the input contains four integers $n$, $m$, $a$ and $b$ ($2 \\leq n \\leq 70$, $n - 1 \\leq m \\leq 200$, $1 \\leq a < b \\leq 10^7$) \u2014 the number of settlements and gravel roads in Codefortia, and two possible travel times. Each of the following lines contains three integers $u, v, c$ ($1 \\leq u, v \\leq n$, $u \\neq v$, $c \\in \\{a, b\\}$) denoting a single gravel road between the settlements $u$ and $v$, which requires $c$ minutes to travel.\n\nYou can assume that the road network is connected and has no loops or multiedges.\n\n\n-----Output-----\n\nOutput a single line containing $n$ integers. The $p$-th of them should denote the minimum possible time required to travel from $1$ to $p$ after the selected roads are abandoned. Note that for each $p$ you can abandon a different set of roads.\n\n\n-----Examples-----\nInput\n5 5 20 25\n1 2 25\n2 3 25\n3 4 20\n4 5 20\n5 1 20\n\nOutput\n0 25 60 40 20\n\nInput\n6 7 13 22\n1 2 13\n2 3 13\n1 4 22\n3 4 13\n4 5 13\n5 6 13\n6 1 13\n\nOutput\n0 13 26 39 26 13\n\n\n\n-----Note-----\n\nThe minimum possible sum of times required to pass each road in the first example is $85$ \u2014 exactly one of the roads with passing time $25$ must be abandoned. Note that after one of these roads is abandoned, it's now impossible to travel between settlements $1$ and $3$ in time $50$.", "raw_solution": "def apps_run1(n, m, a, b, edges):\n    import heapq\n    graph={i:[] for i in range(n)}\n    for i in range(m):\n        u,v,w=edges[i]\n        graph[u-1].append((v-1,w))\n        graph[v-1].append((u-1,w))\n    components=[-1]*n\n    comp=-1\n    for i in range(n):\n        if components[i]==-1:\n            comp+=1\n            components[i]=comp\n            prev=[]\n            layer=[i]\n            while layer!=[]:\n                newlayer=[]\n                for guy in layer:\n                    for guy1 in graph[guy]:\n                        if guy1[1]==a and components[guy1[0]]==-1:\n                            newlayer.append(guy1[0])\n                            components[guy1[0]]=comp\n                prev=layer[:]\n                layer=newlayer[:]\n    useless=[]\n    for guy in graph:\n        for neigh in graph[guy]:\n            if components[guy]==components[neigh[0]] and neigh[1]==b:\n                useless.append((guy,neigh))\n    for guy in useless:\n        graph[guy[0]].remove(guy[1])\n    counts=[0]*(comp+1)\n    for i in range(n):\n        counts[components[i]]+=1\n    bad=[]\n    for i in range(comp+1):\n        if counts[i]<=3:\n            bad.append(i)\n            for j in range(n):\n                if components[j]==i:\n                    components[j]=-1\n    for guy in bad[::-1]:\n        for i in range(n):\n            if components[i]>guy:\n                components[i]-=1\n    comp-=len(bad)\n    comp+=1\n    dists=[[float(\"inf\") for i in range(2**comp)] for j in range(n)]\n    dists[0][0]=0\n    pq=[]\n    heapq.heappush(pq,[0,0,0])\n    remaining=n\n    visited=[0]*n\n    while len(pq)>0 and remaining>0:\n        dist,vert,mask=heapq.heappop(pq)\n        if visited[vert]==0:\n            visited[vert]=1\n            remaining-=1\n        for neigh in graph[vert]:\n            if neigh[1]==b:\n                if components[vert]==components[neigh[0]] and components[vert]!=-1:\n                    continue\n                if components[neigh[0]]!=-1:\n                    if mask & (2**components[neigh[0]])>0:\n                        continue\n                if components[vert]!=-1:\n                    maskn=mask+2**(components[vert])\n                else:\n                    maskn=mask\n            else:\n                maskn=mask\n            if dist+neigh[1]<dists[neigh[0]][maskn]:\n                dists[neigh[0]][maskn]=dist+neigh[1]\n                heapq.heappush(pq,[dist+neigh[1],neigh[0],maskn])\n    optimal=[str(min(dists[i])) for i in range(n)]\n    return \" \".join(optimal)", "raw_test_input": ["assert apps_run1(5, 5, 20, 25, [(1, 2, 25), (2, 3, 25), (3, 4, 20), (4, 5, 20), (5, 1, 20)]) == '0 25 60 40 20'", "assert apps_run1(6, 7, 13, 22, [(1, 2, 13), (2, 3, 13), (1, 4, 22), (3, 4, 13), (4, 5, 13), (5, 6, 13), (6, 1, 13)]) == '0 13 26 39 26 13'", "assert apps_run1(2, 1, 1, 2, [(2, 1, 1)]) == '0 1'"], "new_problem": "Codefortia is a small island country located somewhere in the West Pacific. It consists of n settlements connected by m bidirectional gravel roads. Curiously enough, the beliefs of the inhabitants require the time needed to pass each road to be equal either to a or b seconds. It's guaranteed that one can go between any pair of settlements by following a sequence of roads. Codefortia was recently struck by the financial crisis. Therefore, the king decided to abandon some of the roads so that: it will be possible to travel between each pair of cities using the remaining roads only, the sum of times required to pass each remaining road will be minimum possible (in other words, remaining roads must form minimum spanning tree, using the time to pass the road as its weight), among all the plans minimizing the sum of times above, the time required to travel between the king's residence (in settlement 1) and the parliament house (in settlement p) using the remaining roads only will be minimum possible. The king, however, forgot where the parliament house was. For each settlement p = 1, 2, ..., n, can you tell what is the minimum time required to travel between the king's residence and the parliament house (located in settlement p) after some roads are abandoned? Additionally, each settlement has a priority level, and the roads should be optimized to prioritize higher priority settlements. Use a dictionary to store the graph and a priority queue to handle the priority of settlements.", "new_solution": "from typing import List, Tuple, Dict\nimport heapq\n\ndef apps_run2(n: int, m: int, a: int, b: int, roads: List[Tuple[int, int, int]], priorities: List[Tuple[int, int]]) -> List[int]:\n    graph: Dict[int, List[Tuple[int, int]]] = {i: [] for i in range(n)}\n    for u, v, w in roads:\n        graph[u-1].append((v-1, w))\n        graph[v-1].append((u-1, w))\n    components = [-1] * n\n    comp = -1\n    for i in range(n):\n        if components[i] == -1:\n            comp += 1\n            components[i] = comp\n            prev = []\n            layer = [i]\n            while layer:\n                newlayer = []\n                for guy in layer:\n                    for guy1 in graph[guy]:\n                        if guy1[1] == a and components[guy1[0]] == -1:\n                            newlayer.append(guy1[0])\n                            components[guy1[0]] = comp\n                prev = layer[:]\n                layer = newlayer[:]\n    useless = []\n    for guy in graph:\n        for neigh in graph[guy]:\n            if components[guy] == components[neigh[0]] and neigh[1] == b:\n                useless.append((guy, neigh))\n    for guy in useless:\n        graph[guy[0]].remove(guy[1])\n    counts = [0] * (comp + 1)\n    for i in range(n):\n        counts[components[i]] += 1\n    bad = []\n    for i in range(comp + 1):\n        if counts[i] <= 3:\n            bad.append(i)\n            for j in range(n):\n                if components[j] == i:\n                    components[j] = -1\n    for guy in bad[::-1]:\n        for i in range(n):\n            if components[i] > guy:\n                components[i] -= 1\n    comp -= len(bad)\n    comp += 1\n    dists = [[float('inf') for _ in range(2**comp)] for _ in range(n)]\n    dists[0][0] = 0\n    pq = []\n    heapq.heappush(pq, (0, 0, 0))\n    remaining = n\n    visited = [0] * n\n    while pq and remaining > 0:\n        dist, vert, mask = heapq.heappop(pq)\n        if visited[vert] == 0:\n            visited[vert] = 1\n            remaining -= 1\n        for neigh in graph[vert]:\n            if neigh[1] == b:\n                if components[vert] == components[neigh[0]] and components[vert] != -1:\n                    continue\n                if components[neigh[0]] != -1:\n                    if mask & (2**components[neigh[0]]) > 0:\n                        continue\n                if components[vert] != -1:\n                    maskn = mask + 2**(components[vert])\n                else:\n                    maskn = mask\n            else:\n                maskn = mask\n            if dist + neigh[1] < dists[neigh[0]][maskn]:\n                dists[neigh[0]][maskn] = dist + neigh[1]\n                heapq.heappush(pq, (dist + neigh[1], neigh[0], maskn))\n    optimal = [min(dists[i]) for i in range(n)]\n    return optimal", "input_format": "The first line of the input contains four integers n, m, a, b (2 \u2264 n \u2264 70, n - 1 \u2264 m \u2264 200, 1 \u2264 a < b \u2264 10^7) \u2014 the number of settlements and gravel roads in Codefortia, and two possible travel times. Each of the following lines contains three integers u, v, c (1 \u2264 u, v \u2264 n, u \u2260 v, c \u2208 {a, b}) denoting a single gravel road between the settlements u and v, which requires c minutes to travel. Additionally, a list of tuples representing the priority of each settlement is provided.", "output_format": "Output a single line containing n integers. The p-th of them should denote the minimum possible time required to travel from 1 to p after the selected roads are abandoned, considering the priority of settlements.", "test_input": ["assert apps_run2(5, 5, 20, 25, [(1, 2, 25), (2, 3, 25), (3, 4, 20), (4, 5, 20), (5, 1, 20)], [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5)]) == [0, 25, 60, 40, 20]", "assert apps_run2(6, 7, 13, 22, [(1, 2, 13), (2, 3, 13), (1, 4, 22), (3, 4, 13), (4, 5, 13), (5, 6, 13), (6, 1, 13)], [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)]) == [0, 13, 26, 39, 26, 13]", "assert apps_run2(4, 4, 10, 15, [(1, 2, 10), (2, 3, 15), (3, 4, 10), (4, 1, 15)], [(1, 1), (2, 2), (3, 3), (4, 4)]) == [0, 10, 25, 15]", "assert apps_run2(3, 3, 5, 10, [(1, 2, 5), (2, 3, 10), (3, 1, 5)], [(1, 1), (2, 2), (3, 3)]) == [0, 5, 5]", "assert apps_run2(7, 8, 8, 12, [(1, 2, 8), (2, 3, 8), (3, 4, 12), (4, 5, 8), (5, 6, 12), (6, 7, 8), (7, 1, 12), (3, 5, 8)], [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6), (7, 7)]) == [0, 8, 16, 32, 24, 20, 12]"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "APPS/2000-4", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nCodefortia is a small island country located somewhere in the West Pacific. It consists of $n$ settlements connected by $m$ bidirectional gravel roads. Curiously enough, the beliefs of the inhabitants require the time needed to pass each road to be equal either to $a$ or $b$ seconds. It's guaranteed that one can go between any pair of settlements by following a sequence of roads.\n\nCodefortia was recently struck by the financial crisis. Therefore, the king decided to abandon some of the roads so that:\n\n  it will be possible to travel between each pair of cities using the remaining roads only,  the sum of times required to pass each remaining road will be minimum possible (in other words, remaining roads must form minimum spanning tree, using the time to pass the road as its weight),  among all the plans minimizing the sum of times above, the time required to travel between the king's residence (in settlement $1$) and the parliament house (in settlement $p$) using the remaining roads only will be minimum possible. \n\nThe king, however, forgot where the parliament house was. For each settlement $p = 1, 2, \\dots, n$, can you tell what is the minimum time required to travel between the king's residence and the parliament house (located in settlement $p$) after some roads are abandoned?\n\n\n-----Input-----\n\nThe first line of the input contains four integers $n$, $m$, $a$ and $b$ ($2 \\leq n \\leq 70$, $n - 1 \\leq m \\leq 200$, $1 \\leq a < b \\leq 10^7$) \u2014 the number of settlements and gravel roads in Codefortia, and two possible travel times. Each of the following lines contains three integers $u, v, c$ ($1 \\leq u, v \\leq n$, $u \\neq v$, $c \\in \\{a, b\\}$) denoting a single gravel road between the settlements $u$ and $v$, which requires $c$ minutes to travel.\n\nYou can assume that the road network is connected and has no loops or multiedges.\n\n\n-----Output-----\n\nOutput a single line containing $n$ integers. The $p$-th of them should denote the minimum possible time required to travel from $1$ to $p$ after the selected roads are abandoned. Note that for each $p$ you can abandon a different set of roads.\n\n\n-----Examples-----\nInput\n5 5 20 25\n1 2 25\n2 3 25\n3 4 20\n4 5 20\n5 1 20\n\nOutput\n0 25 60 40 20\n\nInput\n6 7 13 22\n1 2 13\n2 3 13\n1 4 22\n3 4 13\n4 5 13\n5 6 13\n6 1 13\n\nOutput\n0 13 26 39 26 13\n\n\n\n-----Note-----\n\nThe minimum possible sum of times required to pass each road in the first example is $85$ \u2014 exactly one of the roads with passing time $25$ must be abandoned. Note that after one of these roads is abandoned, it's now impossible to travel between settlements $1$ and $3$ in time $50$.", "raw_solution": "def apps_run1(n, m, a, b, edges):\n    import heapq\n    graph = {i: [] for i in range(n)}\n    for u, v, w in edges:\n        graph[u - 1].append((v - 1, w))\n        graph[v - 1].append((u - 1, w))\n    components = [-1] * n\n    comp = -1\n    for i in range(n):\n        if components[i] == -1:\n            comp += 1\n            components[i] = comp\n            prev = []\n            layer = [i]\n            while layer != []:\n                newlayer = []\n                for guy in layer:\n                    for guy1 in graph[guy]:\n                        if guy1[1] == a and components[guy1[0]] == -1:\n                            newlayer.append(guy1[0])\n                            components[guy1[0]] = comp\n                prev = layer[:]\n                layer = newlayer[:]\n    useless = []\n    for guy in graph:\n        for neigh in graph[guy]:\n            if components[guy] == components[neigh[0]] and neigh[1] == b:\n                useless.append((guy, neigh))\n    for guy in useless:\n        graph[guy[0]].remove(guy[1])\n    counts = [0] * (comp + 1)\n    for i in range(n):\n        counts[components[i]] += 1\n    bad = []\n    for i in range(comp + 1):\n        if counts[i] <= 3:\n            bad.append(i)\n            for j in range(n):\n                if components[j] == i:\n                    components[j] = -1\n    for guy in bad[::-1]:\n        for i in range(n):\n            if components[i] > guy:\n                components[i] -= 1\n    comp -= len(bad)\n    comp += 1\n    dists = [[float('inf') for i in range(2 ** comp)] for j in range(n)]\n    dists[0][0] = 0\n    pq = []\n    heapq.heappush(pq, [0, 0, 0])\n    remaining = n\n    visited = [0] * n\n    while len(pq) > 0 and remaining > 0:\n        dist, vert, mask = heapq.heappop(pq)\n        if visited[vert] == 0:\n            visited[vert] = 1\n            remaining -= 1\n        for neigh in graph[vert]:\n            if neigh[1] == b:\n                if components[vert] == components[neigh[0]] and components[vert] != -1:\n                    continue\n                if components[neigh[0]] != -1:\n                    if mask & (2 ** components[neigh[0]]) > 0:\n                        continue\n                if components[vert] != -1:\n                    maskn = mask + 2 ** (components[vert])\n                else:\n                    maskn = mask\n            else:\n                maskn = mask\n            if dist + neigh[1] < dists[neigh[0]][maskn]:\n                dists[neigh[0]][maskn] = dist + neigh[1]\n                heapq.heappush(pq, [dist + neigh[1], neigh[0], maskn])\n    optimal = [str(min(dists[i])) for i in range(n)]\n    return \" \".join(optimal)", "raw_test_input": ["assert apps_run1(5, 5, 20, 25, [(1, 2, 25), (2, 3, 25), (3, 4, 20), (4, 5, 20), (5, 1, 20)]) == '0 25 60 40 20'", "assert apps_run1(6, 7, 13, 22, [(1, 2, 13), (2, 3, 13), (1, 4, 22), (3, 4, 13), (4, 5, 13), (5, 6, 13), (6, 1, 13)]) == '0 13 26 39 26 13'", "assert apps_run1(2, 1, 1, 2, [(2, 1, 1)]) == '0 1'"], "new_problem": "Codefortia is a small island country located somewhere in the West Pacific. It consists of n settlements connected by m bidirectional gravel roads. The time needed to pass each road is either a or b seconds. It's guaranteed that one can go between any pair of settlements by following a sequence of roads. Codefortia was recently struck by a financial crisis. Therefore, the king decided to abandon some of the roads so that: it will be possible to travel between each pair of cities using the remaining roads only, the sum of times required to pass each remaining road will be minimum possible (in other words, remaining roads must form a minimum spanning tree, using the time to pass the road as its weight), among all the plans minimizing the sum of times above, the time required to travel between the king's residence (in settlement 1) and the parliament house (in settlement p) using the remaining roads only will be minimum possible. The king, however, forgot where the parliament house was. For each settlement p = 1, 2, ..., n, can you tell what is the minimum time required to travel between the king's residence and the parliament house (located in settlement p) after some roads are abandoned? However, due to recent data corruption, the input data might contain errors. You need to handle the following errors: 1. Invalid number of settlements or roads (e.g., n < 2 or m < n - 1). 2. Invalid travel times (e.g., a >= b or a < 1). 3. Invalid road definitions (e.g., u or v not in the range 1 to n, or c not in {a, b}). 4. Disconnected graph (e.g., not all settlements are reachable). Implement error handling to manage these scenarios and provide meaningful error messages.", "new_solution": "import heapq\nfrom typing import List, Tuple\n\nclass InvalidInputError(Exception):\n    pass\n\nclass DisconnectedGraphError(Exception):\n    pass\n\ndef validate_input(n: int, m: int, a: int, b: int, roads: List[Tuple[int, int, int]]) -> None:\n    if n < 2 or m < n - 1:\n        raise InvalidInputError(\"Invalid number of settlements or roads.\")\n    if a >= b or a < 1:\n        raise InvalidInputError(\"Invalid travel times.\")\n    for u, v, c in roads:\n        if not (1 <= u <= n) or not (1 <= v <= n) or c not in {a, b}:\n            raise InvalidInputError(\"Invalid road definition.\")\n\ndef apps_run2(n: int, m: int, a: int, b: int, roads: List[Tuple[int, int, int]]) -> List[int]:\n    validate_input(n, m, a, b, roads)\n    graph = {i: [] for i in range(n)}\n    for u, v, w in roads:\n        graph[u-1].append((v-1, w))\n        graph[v-1].append((u-1, w))\n    components = [-1] * n\n    comp = -1\n    for i in range(n):\n        if components[i] == -1:\n            comp += 1\n            components[i] = comp\n            prev = []\n            layer = [i]\n            while layer != []:\n                newlayer = []\n                for guy in layer:\n                    for guy1 in graph[guy]:\n                        if guy1[1] == a and components[guy1[0]] == -1:\n                            newlayer.append(guy1[0])\n                            components[guy1[0]] = comp\n                prev = layer[:]\n                layer = newlayer[:]\n    if -1 in components:\n        raise DisconnectedGraphError(\"The graph is disconnected.\")\n    useless = []\n    for guy in graph:\n        for neigh in graph[guy]:\n            if components[guy] == components[neigh[0]] and neigh[1] == b:\n                useless.append((guy, neigh))\n    for guy in useless:\n        graph[guy[0]].remove(guy[1])\n    counts = [0] * (comp + 1)\n    for i in range(n):\n        counts[components[i]] += 1\n    bad = []\n    for i in range(comp + 1):\n        if counts[i] <= 3:\n            bad.append(i)\n            for j in range(n):\n                if components[j] == i:\n                    components[j] = -1\n    for guy in bad[::-1]:\n        for i in range(n):\n            if components[i] > guy:\n                components[i] -= 1\n    comp -= len(bad)\n    comp += 1\n    dists = [[float(\"inf\") for i in range(2**comp)] for j in range(n)]\n    dists[0][0] = 0\n    pq = []\n    heapq.heappush(pq, [0, 0, 0])\n    remaining = n\n    visited = [0] * n\n    while len(pq) > 0 and remaining > 0:\n        dist, vert, mask = heapq.heappop(pq)\n        if visited[vert] == 0:\n            visited[vert] = 1\n            remaining -= 1\n        for neigh in graph[vert]:\n            if neigh[1] == b:\n                if components[vert] == components[neigh[0]] and components[vert] != -1:\n                    continue\n                if components[neigh[0]] != -1:\n                    if mask & (2**components[neigh[0]]) > 0:\n                        continue\n                if components[vert] != -1:\n                    maskn = mask + 2**(components[vert])\n                else:\n                    maskn = mask\n            else:\n                maskn = mask\n            if dist + neigh[1] < dists[neigh[0]][maskn]:\n                dists[neigh[0]][maskn] = dist + neigh[1]\n                heapq.heappush(pq, [dist + neigh[1], neigh[0], maskn])\n    optimal = [min(dists[i]) for i in range(n)]\n    return optimal\n", "input_format": "The first line of the input contains four integers n, m, a, and b (2 <= n <= 70, n - 1 <= m <= 200, 1 <= a < b <= 10^7) \u2014 the number of settlements and gravel roads in Codefortia, and two possible travel times. Each of the following lines contains three integers u, v, c (1 <= u, v <= n, u != v, c in {a, b}) denoting a single gravel road between the settlements u and v, which requires c minutes to travel.", "output_format": "Output a single line containing n integers. The p-th of them should denote the minimum possible time required to travel from 1 to p after the selected roads are abandoned.", "test_input": ["try: apps_run2(1, 1, 10, 20, [(1, 2, 10)])\nexcept InvalidInputError as e: assert str(e) == 'Invalid number of settlements or roads.'", "try: apps_run2(5, 5, 20, 20, [(1, 2, 20), (2, 3, 20), (3, 4, 20), (4, 5, 20), (5, 1, 20)])\nexcept InvalidInputError as e: assert str(e) == 'Invalid travel times.'", "try: apps_run2(5, 5, 10, 20, [(1, 2, 10), (2, 3, 10), (3, 4, 10), (4, 5, 10), (5, 6, 10)])\nexcept InvalidInputError as e: assert str(e) == 'Invalid road definition.'", "try: apps_run2(5, 4, 10, 20, [(1, 2, 10), (2, 3, 10), (3, 4, 10), (4, 5, 10)])\nexcept DisconnectedGraphError as e: assert str(e) == 'The graph is disconnected.'", "assert apps_run2(5, 5, 10, 20, [(1, 2, 10), (2, 3, 10), (3, 4, 10), (4, 5, 10), (5, 1, 20)]) == [0, 10, 20, 30, 40]"], "requirement_type": "PROMPT_ERROR_HANDLING"}
{"task_id": "APPS/2008-1", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nA schoolboy named Vasya loves reading books on programming and mathematics. He has recently read an encyclopedia article that described the method of median smoothing (or median filter) and its many applications in science and engineering. Vasya liked the idea of the method very much, and he decided to try it in practice.\n\nApplying the simplest variant of median smoothing to the sequence of numbers a_1, a_2, ..., a_{n} will result a new sequence b_1, b_2, ..., b_{n} obtained by the following algorithm:  b_1 = a_1, b_{n} = a_{n}, that is, the first and the last number of the new sequence match the corresponding numbers of the original sequence.  For i = 2, ..., n - 1 value b_{i} is equal to the median of three values a_{i} - 1, a_{i} and a_{i} + 1. \n\nThe median of a set of three numbers is the number that goes on the second place, when these three numbers are written in the non-decreasing order. For example, the median of the set 5, 1, 2 is number 2, and the median of set 1, 0, 1 is equal to 1.\n\nIn order to make the task easier, Vasya decided to apply the method to sequences consisting of zeros and ones only.\n\nHaving made the procedure once, Vasya looked at the resulting sequence and thought: what if I apply the algorithm to it once again, and then apply it to the next result, and so on? Vasya tried a couple of examples and found out that after some number of median smoothing algorithm applications the sequence can stop changing. We say that the sequence is stable, if it does not change when the median smoothing is applied to it.\n\nNow Vasya wonders, whether the sequence always eventually becomes stable. He asks you to write a program that, given a sequence of zeros and ones, will determine whether it ever becomes stable. Moreover, if it ever becomes stable, then you should determine what will it look like and how many times one needs to apply the median smoothing algorithm to initial sequence in order to obtain a stable one.\n\n\n-----Input-----\n\nThe first input line of the input contains a single integer n (3 \u2264 n \u2264 500 000)\u00a0\u2014 the length of the initial sequence.\n\nThe next line contains n integers a_1, a_2, ..., a_{n} (a_{i} = 0 or a_{i} = 1), giving the initial sequence itself.\n\n\n-----Output-----\n\nIf the sequence will never become stable, print a single number  - 1.\n\nOtherwise, first print a single integer\u00a0\u2014 the minimum number of times one needs to apply the median smoothing algorithm to the initial sequence before it becomes is stable. In the second line print n numbers separated by a space \u00a0\u2014 the resulting sequence itself.\n\n\n-----Examples-----\nInput\n4\n0 0 1 1\n\nOutput\n0\n0 0 1 1\n\nInput\n5\n0 1 0 1 0\n\nOutput\n2\n0 0 0 0 0\n\n\n\n-----Note-----\n\nIn the second sample the stabilization occurs in two steps: $01010 \\rightarrow 00100 \\rightarrow 00000$, and the sequence 00000 is obviously stable.", "raw_solution": "def apps_run1(n, seq):\n    carry = seq[0]\n    result = [carry]\n\n    mark = False\n    cur_len = 0\n    max_len = 0\n\n    i = 1\n    while i < len(seq) - 1:\n        if mark:\n            if seq[i] != seq[i + 1]:\n                cur_len += 1\n            else:\n                if cur_len > max_len:\n                    max_len = cur_len\n\n                if seq[i] == carry:\n                    result.extend([carry]*cur_len)\n                else:\n                    result.extend([carry]*(cur_len//2))\n                    result.extend([seq[i]]*(cur_len//2))\n\n                result.append(seq[i])\n                mark = False\n                cur_len = 0\n        elif seq[i] != seq[i - 1] and seq[i] != seq[i + 1]:\n            mark = True\n            cur_len = 1\n            carry = seq[i - 1]\n        else:\n            result.append(seq[i])\n\n        i += 1\n\n    if mark:\n        if cur_len > max_len:\n            max_len = cur_len\n\n        if seq[i] == carry:\n            result.extend([carry]*cur_len)\n        else:\n            result.extend([carry]*(cur_len//2))\n            result.extend([seq[i]]*(cur_len//2))\n\n    result.append(seq[i])\n\n    return ((max_len + 1)//2,result)", "raw_test_input": ["assert apps_run1(4, [0, 0, 1, 1]) == (0, [0, 0, 1, 1])", "assert apps_run1(5, [0, 1, 0, 1, 0]) == (2, [0, 0, 0, 0, 0])", "assert apps_run1(3, [1, 0, 0]) == (0, [1, 0, 0])", "assert apps_run1(4, [1, 0, 0, 1]) == (0, [1, 0, 0, 1])", "assert apps_run1(7, [1, 0, 1, 1, 1, 0, 1]) == (1, [1, 1, 1, 1, 1, 1, 1])", "assert apps_run1(14, [0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0]) == (3, [0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0])", "assert apps_run1(3, [1, 0, 1]) == (1, [1, 1, 1])", "assert apps_run1(3, [0, 0, 1]) == (0, [0, 0, 1])", "assert apps_run1(3, [1, 1, 0]) == (0, [1, 1, 0])", "assert apps_run1(3, [1, 1, 1]) == (0, [1, 1, 1])", "assert apps_run1(4, [1, 1, 0, 1]) == (1, [1, 1, 1, 1])", "assert apps_run1(4, [1, 0, 1, 1]) == (1, [1, 1, 1, 1])", "assert apps_run1(10, [0, 1, 0, 1, 0, 0, 1, 0, 1, 0]) == (2, [0, 0, 0, 0, 0, 0, 0, 0, 0, 0])", "assert apps_run1(4, [0, 1, 1, 0]) == (0, [0, 1, 1, 0])", "assert apps_run1(3, [0, 1, 1]) == (0, [0, 1, 1])", "assert apps_run1(3, [0, 0, 0]) == (0, [0, 0, 0])", "assert apps_run1(4, [0, 1, 0, 1]) == (1, [0, 0, 1, 1])", "assert apps_run1(3, [0, 1, 0]) == (1, [0, 0, 0])"], "new_problem": "In a data processing company, a system is designed to stabilize binary sequences using median smoothing. The system receives multiple sequences and processes each to determine if they can be stabilized. If a sequence can be stabilized, the system outputs the number of steps required and the stabilized sequence. If not, it outputs -1. The company needs a program that can handle multiple sequences efficiently and provide the required output for each sequence.", "new_solution": "def median_smoothing(seq):\n    carry = seq[0]\n    result = [carry]\n    mark = False\n    cur_len = 0\n    max_len = 0\n    i = 1\n    while i < len(seq) - 1:\n        if mark:\n            if seq[i] != seq[i + 1]:\n                cur_len += 1\n            else:\n                if cur_len > max_len:\n                    max_len = cur_len\n                if seq[i] == carry:\n                    result.extend([carry]*cur_len)\n                else:\n                    result.extend([carry]*(cur_len//2))\n                    result.extend([seq[i]]*(cur_len//2))\n                result.append(seq[i])\n                mark = False\n                cur_len = 0\n        elif seq[i] != seq[i - 1] and seq[i] != seq[i + 1]:\n            mark = True\n            cur_len = 1\n            carry = seq[i - 1]\n        else:\n            result.append(seq[i])\n        i += 1\n    if mark:\n        if cur_len > max_len:\n            max_len = cur_len\n        if seq[i] == carry:\n            result.extend([carry]*cur_len)\n        else:\n            result.extend([carry]*(cur_len//2))\n            result.extend([seq[i]]*(cur_len//2))\n    result.append(seq[i])\n    return (max_len + 1)//2, result\n\ndef apps_run2(sequences):\n    results = []\n    for seq in sequences:\n        steps, stabilized_seq = median_smoothing(seq)\n        if steps == 0:\n            results.append((0, stabilized_seq))\n        else:\n            results.append((steps, stabilized_seq))\n    return results\n\n# Example usage:\n# sequences = [\n#     [0, 0, 1, 1],\n#     [0, 1, 0, 1, 0],\n#     [1, 1, 1, 0, 0, 0],\n#     [0, 0, 0, 0, 0],\n#     [1, 0, 1, 0, 1]\n# ]\n# print(apps_run2(sequences))", "input_format": "The input consists of multiple lines. The first line contains a single integer m (1 \u2264 m \u2264 1000) \u2014 the number of sequences. Each of the next m lines contains a sequence of integers separated by spaces, where the first integer n (3 \u2264 n \u2264 500 000) is the length of the sequence, followed by n integers a_1, a_2, ..., a_{n} (a_{i} = 0 or a_{i} = 1), giving the initial sequence itself.", "output_format": "For each sequence, if it will never become stable, print a single number -1. Otherwise, first print a single integer \u2014 the minimum number of times one needs to apply the median smoothing algorithm to the initial sequence before it becomes stable. In the second line print n numbers separated by a space \u2014 the resulting sequence itself.", "test_input": ["assert apps_run2([[0, 0, 1, 1]]) == [(0, [0, 0, 1, 1])]", "assert apps_run2([[0, 1, 0, 1, 0]]) == [(2, [0, 0, 0, 0, 0])]", "assert apps_run2([[1, 1, 1, 0, 0, 0]]) == [(0, [1, 1, 1, 0, 0, 0])]", "assert apps_run2([[0, 0, 0, 0, 0]]) == [(0, [0, 0, 0, 0, 0])]", "assert apps_run2([[1, 0, 1, 0, 1]]) == [(2, [1, 1, 1, 1, 1])]"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "APPS/2008-2", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nA schoolboy named Vasya loves reading books on programming and mathematics. He has recently read an encyclopedia article that described the method of median smoothing (or median filter) and its many applications in science and engineering. Vasya liked the idea of the method very much, and he decided to try it in practice.\n\nApplying the simplest variant of median smoothing to the sequence of numbers a_1, a_2, ..., a_{n} will result a new sequence b_1, b_2, ..., b_{n} obtained by the following algorithm:  b_1 = a_1, b_{n} = a_{n}, that is, the first and the last number of the new sequence match the corresponding numbers of the original sequence.  For i = 2, ..., n - 1 value b_{i} is equal to the median of three values a_{i} - 1, a_{i} and a_{i} + 1. \n\nThe median of a set of three numbers is the number that goes on the second place, when these three numbers are written in the non-decreasing order. For example, the median of the set 5, 1, 2 is number 2, and the median of set 1, 0, 1 is equal to 1.\n\nIn order to make the task easier, Vasya decided to apply the method to sequences consisting of zeros and ones only.\n\nHaving made the procedure once, Vasya looked at the resulting sequence and thought: what if I apply the algorithm to it once again, and then apply it to the next result, and so on? Vasya tried a couple of examples and found out that after some number of median smoothing algorithm applications the sequence can stop changing. We say that the sequence is stable, if it does not change when the median smoothing is applied to it.\n\nNow Vasya wonders, whether the sequence always eventually becomes stable. He asks you to write a program that, given a sequence of zeros and ones, will determine whether it ever becomes stable. Moreover, if it ever becomes stable, then you should determine what will it look like and how many times one needs to apply the median smoothing algorithm to initial sequence in order to obtain a stable one.\n\n\n-----Input-----\n\nThe first input line of the input contains a single integer n (3 \u2264 n \u2264 500 000)\u00a0\u2014 the length of the initial sequence.\n\nThe next line contains n integers a_1, a_2, ..., a_{n} (a_{i} = 0 or a_{i} = 1), giving the initial sequence itself.\n\n\n-----Output-----\n\nIf the sequence will never become stable, print a single number  - 1.\n\nOtherwise, first print a single integer\u00a0\u2014 the minimum number of times one needs to apply the median smoothing algorithm to the initial sequence before it becomes is stable. In the second line print n numbers separated by a space \u00a0\u2014 the resulting sequence itself.\n\n\n-----Examples-----\nInput\n4\n0 0 1 1\n\nOutput\n0\n0 0 1 1\n\nInput\n5\n0 1 0 1 0\n\nOutput\n2\n0 0 0 0 0\n\n\n\n-----Note-----\n\nIn the second sample the stabilization occurs in two steps: $01010 \\rightarrow 00100 \\rightarrow 00000$, and the sequence 00000 is obviously stable.", "raw_solution": "def apps_run1(n, seq):\n    carry = seq[0]\n    result = [carry]\n\n    mark = False\n    cur_len = 0\n    max_len = 0\n\n    i = 1\n    while i < len(seq) - 1:\n        if mark:\n            if seq[i] != seq[i + 1]:\n                cur_len += 1\n            else:\n                if cur_len > max_len:\n                    max_len = cur_len\n\n                if seq[i] == carry:\n                    result.extend([carry]*cur_len)\n                else:\n                    result.extend([carry]*(cur_len//2))\n                    result.extend([seq[i]]*(cur_len//2))\n\n                result.append(seq[i])\n                mark = False\n                cur_len = 0\n        elif seq[i] != seq[i - 1] and seq[i] != seq[i + 1]:\n            mark = True\n            cur_len = 1\n            carry = seq[i - 1]\n        else:\n            result.append(seq[i])\n\n        i += 1\n\n    if mark:\n        if cur_len > max_len:\n            max_len = cur_len\n\n        if seq[i] == carry:\n            result.extend([carry]*cur_len)\n        else:\n            result.extend([carry]*(cur_len//2))\n            result.extend([seq[i]]*(cur_len//2))\n\n    result.append(seq[i])\n\n    return ((max_len + 1)//2,result)", "raw_test_input": ["assert apps_run1(4, [0, 0, 1, 1]) == (0, [0, 0, 1, 1])", "assert apps_run1(5, [0, 1, 0, 1, 0]) == (2, [0, 0, 0, 0, 0])", "assert apps_run1(3, [1, 0, 0]) == (0, [1, 0, 0])"], "new_problem": "\nEnhanced Task Description:\n\nVasya's exploration of the median smoothing process has inspired him to experiment with different window sizes in the smoothing algorithm. This additional complexity leads to a generalized problem where the smoothing window is not fixed at size 3 but can be any odd integer greater than or equal to 3. To maintain consistency with the original method's handling of boundary elements, the following rules apply:\n\n1. Window Size Constraints:\n   - The window size, `w`, must be an odd integer (`w = 2n + 1` where `n` is a positive integer). This ensures there is a clear central element in the window, which is necessary to compute the median.\n\n2. Boundary Handling:\n   - The first `n` numbers (`a_1` through `a_n`) and the last `n` numbers (`a_{n-(w-1)//2+1}` through `a_n`) in the new sequence should remain unchanged. This rule generalizes the boundary rule for `n = 1` and `w = 3`, where only the first and last elements remain unchanged.\n\n3. Generalized Smoothing Application:\n   - For each element `b_i` in the new sequence, where `i` ranges from `n+1` to `n-(w-1)//2`, calculate the median of the `w` numbers in the window centered on `a_i`.\n\nObjective:\n\nGiven these conditions, write a function that:\n- Applies the adjusted median smoothing process to an initial sequence of zeros and ones.\n- Determines when this sequence becomes stable, meaning further applications of smoothing do not change it.\n- If stabilization occurs, outputs the stabilized sequence and the number of smoothing iterations required to reach stability. If stability is impossible, output `-1`.\n", "new_solution": "\ndef apps_run2(n, sequence, w=3):\n    def median(lst):\n        sorted_lst = sorted(lst)\n        return sorted_lst[len(sorted_lst) // 2]\n\n    def apply_smoothing(seq, w):\n        new_seq = seq[:]\n        half_window = w // 2\n        for i in range(half_window, len(seq) - half_window):\n            window = seq[i - half_window:i + half_window + 1]\n            new_seq[i] = median(window)\n        return new_seq\n\n    current_seq = sequence[:]\n    iterations = 0\n\n    while True:\n        next_seq = apply_smoothing(current_seq, w)\n        iterations += 1\n        if next_seq == current_seq:\n            return (iterations - 1, current_seq)\n        if iterations > n:  # Arbitrary large number to prevent infinite loops\n            return (-1,)\n        current_seq = next_seq\n\n# Example usage:\nn = 5\nsequence = [0, 1, 0, 1, 0]\nw = 3\nresult = apps_run2(n, sequence, w)\nprint(result)  # Output: (2, [0, 0, 0, 0, 0])\n", "input_format": "The input line contains a single integer n (3 \u2264 n \u2264 500 000) \u2014 the length of the initial sequence, a list contains n integers a_1, a_2, ..., a_{n} (a_{i} = 0 or a_{i} = 1), giving the initial sequence itself, and a optional input single integer m \u2014 the window size, the default value is three.", "output_format": "If the sequence will never become stable, return a tuple with a single number -1. Otherwise, return a tuple where the first element is the minimum number of times one needs to apply the median smoothing algorithm to the initial sequence before it becomes stable, and the second element is a list of n numbers representing the resulting sequence itself.", "test_input": ["assert apps_run2(5, [0, 0, 1, 1, 1]) == (0, [0, 0, 1, 1, 1])", "assert apps_run2(5, [0, 1, 0, 1, 0], 5) == (0, [0, 1, 0, 1, 0])", "assert apps_run2(3, [1, 0, 1]) == (1, [1, 1, 1])", "assert apps_run2(7, [0, 1, 1, 0, 1, 0, 0], 5) == (1, [0, 1, 1, 1, 0, 0, 0])", "assert apps_run2(14, [0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0], 7) == (3, [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0])"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "APPS/2008-3", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nA schoolboy named Vasya loves reading books on programming and mathematics. He has recently read an encyclopedia article that described the method of median smoothing (or median filter) and its many applications in science and engineering. Vasya liked the idea of the method very much, and he decided to try it in practice.\n\nApplying the simplest variant of median smoothing to the sequence of numbers a_1, a_2, ..., a_{n} will result a new sequence b_1, b_2, ..., b_{n} obtained by the following algorithm:  b_1 = a_1, b_{n} = a_{n}, that is, the first and the last number of the new sequence match the corresponding numbers of the original sequence.  For i = 2, ..., n - 1 value b_{i} is equal to the median of three values a_{i} - 1, a_{i} and a_{i} + 1. \n\nThe median of a set of three numbers is the number that goes on the second place, when these three numbers are written in the non-decreasing order. For example, the median of the set 5, 1, 2 is number 2, and the median of set 1, 0, 1 is equal to 1.\n\nIn order to make the task easier, Vasya decided to apply the method to sequences consisting of zeros and ones only.\n\nHaving made the procedure once, Vasya looked at the resulting sequence and thought: what if I apply the algorithm to it once again, and then apply it to the next result, and so on? Vasya tried a couple of examples and found out that after some number of median smoothing algorithm applications the sequence can stop changing. We say that the sequence is stable, if it does not change when the median smoothing is applied to it.\n\nNow Vasya wonders, whether the sequence always eventually becomes stable. He asks you to write a program that, given a sequence of zeros and ones, will determine whether it ever becomes stable. Moreover, if it ever becomes stable, then you should determine what will it look like and how many times one needs to apply the median smoothing algorithm to initial sequence in order to obtain a stable one.\n\n\n-----Input-----\n\nThe first input line of the input contains a single integer n (3 \u2264 n \u2264 500 000)\u00a0\u2014 the length of the initial sequence.\n\nThe next line contains n integers a_1, a_2, ..., a_{n} (a_{i} = 0 or a_{i} = 1), giving the initial sequence itself.\n\n\n-----Output-----\n\nIf the sequence will never become stable, print a single number  - 1.\n\nOtherwise, first print a single integer\u00a0\u2014 the minimum number of times one needs to apply the median smoothing algorithm to the initial sequence before it becomes is stable. In the second line print n numbers separated by a space \u00a0\u2014 the resulting sequence itself.\n\n\n-----Examples-----\nInput\n4\n0 0 1 1\n\nOutput\n0\n0 0 1 1\n\nInput\n5\n0 1 0 1 0\n\nOutput\n2\n0 0 0 0 0\n\n\n\n-----Note-----\n\nIn the second sample the stabilization occurs in two steps: $01010 \\rightarrow 00100 \\rightarrow 00000$, and the sequence 00000 is obviously stable.", "raw_solution": "def apps_run1(n, seq):\n    carry = seq[0]\n    result = [carry]\n\n    mark = False\n    cur_len = 0\n    max_len = 0\n\n    i = 1\n    while i < len(seq) - 1:\n        if mark:\n            if seq[i] != seq[i + 1]:\n                cur_len += 1\n            else:\n                if cur_len > max_len:\n                    max_len = cur_len\n\n                if seq[i] == carry:\n                    result.extend([carry]*cur_len)\n                else:\n                    result.extend([carry]*(cur_len//2))\n                    result.extend([seq[i]]*(cur_len//2))\n\n                result.append(seq[i])\n                mark = False\n                cur_len = 0\n        elif seq[i] != seq[i - 1] and seq[i] != seq[i + 1]:\n            mark = True\n            cur_len = 1\n            carry = seq[i - 1]\n        else:\n            result.append(seq[i])\n\n        i += 1\n\n    if mark:\n        if cur_len > max_len:\n            max_len = cur_len\n\n        if seq[i] == carry:\n            result.extend([carry]*cur_len)\n        else:\n            result.extend([carry]*(cur_len//2))\n            result.extend([seq[i]]*(cur_len//2))\n\n    result.append(seq[i])\n\n    return ((max_len + 1)//2,result)", "raw_test_input": ["assert apps_run1(4, [0, 0, 1, 1]) == (0, [0, 0, 1, 1])", "assert apps_run1(5, [0, 1, 0, 1, 0]) == (2, [0, 0, 0, 0, 0])", "assert apps_run1(3, [1, 0, 0]) == (0, [1, 0, 0])", "assert apps_run1(4, [1, 0, 0, 1]) == (0, [1, 0, 0, 1])", "assert apps_run1(7, [1, 0, 1, 1, 1, 0, 1]) == (1, [1, 1, 1, 1, 1, 1, 1])", "assert apps_run1(14, [0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0]) == (3, [0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0])", "assert apps_run1(3, [1, 0, 1]) == (1, [1, 1, 1])", "assert apps_run1(3, [0, 0, 1]) == (0, [0, 0, 1])", "assert apps_run1(3, [1, 1, 0]) == (0, [1, 1, 0])", "assert apps_run1(3, [1, 1, 1]) == (0, [1, 1, 1])", "assert apps_run1(4, [1, 1, 0, 1]) == (1, [1, 1, 1, 1])", "assert apps_run1(4, [1, 0, 1, 1]) == (1, [1, 1, 1, 1])", "assert apps_run1(10, [0, 1, 0, 1, 0, 0, 1, 0, 1, 0]) == (2, [0, 0, 0, 0, 0, 0, 0, 0, 0, 0])", "assert apps_run1(4, [0, 1, 1, 0]) == (0, [0, 1, 1, 0])", "assert apps_run1(3, [0, 1, 1]) == (0, [0, 1, 1])", "assert apps_run1(3, [0, 0, 0]) == (0, [0, 0, 0])", "assert apps_run1(4, [0, 1, 0, 1]) == (1, [0, 0, 1, 1])", "assert apps_run1(3, [0, 1, 0]) == (1, [0, 0, 0])"], "new_problem": "\nEnhanced Task Description:\n\nA schoolboy named Vasya loves reading books on programming and mathematics. He has recently read an encyclopedia article that described the method of median smoothing (or median filter) and its many applications in science and engineering. Vasya liked the idea of the method very much, and he decided to try it in practice.\n\nApplying the simplest variant of median smoothing to the sequence of numbers a_1, a_2, ..., a_n will result in a new sequence b_1, b_2, ..., b_n obtained by the following algorithm:\n- b_1 = a_1, b_n = a_n, that is, the first and the last number of the new sequence match the corresponding numbers of the original sequence.\n- For i = 2, ..., n - 1, value b_i is equal to the median of three values a_{i-1}, a_i, and a_{i+1}. The median of a set of three numbers is the number that goes in the second place when these numbers are written in non-decreasing order. For example, the median of the set {5, 1, 2} is number 2, and the median of the set {1, 0, 1} is 1.\n\nTo make the task easier, Vasya decided to apply the method to sequences consisting of zeros and ones only. Having made the procedure once, Vasya looked at the resulting sequence and thought: what if I apply the algorithm to it once again, and then apply it to the next result, and so on? Vasya tried a couple of examples and found out that after some number of median smoothing algorithm applications the sequence can stop changing. We say that the sequence is stable if it does not change when the median smoothing is applied to it.\n\nNow Vasya wonders, whether the sequence always eventually becomes stable. He asks you to write a program that, given a sequence of zeros and ones, will determine whether it ever becomes stable. Moreover, if it ever becomes stable, then you should determine what it will look like and how many times one needs to apply the median smoothing algorithm to the initial sequence in order to obtain a stable one.\n\nHowever, this time, the sequence is represented as a dictionary where keys are indices and values are the sequence elements. Additionally, the sequence may contain '2' as a wildcard that can be either '0' or '1'. The sequence is stable if it does not change when the median smoothing is applied to it.\n\nAdditional Condition:\n- When '2' is used as a wildcard and appears in a window where the counts of '0's and '1's are equal, the result of smoothing for that window should be '2'. Otherwise, the result should be the digit that appears more frequently in the window.\n\nYou need to determine the minimum number of times the algorithm needs to be applied for the sequence to become stable, and what the stable sequence looks like.\n", "new_solution": "def apps_run2(n, sequence_dict):\n    # Convert the dictionary to a list for easier manipulation\n    seq = [sequence_dict[i] for i in range(n)]\n    \n    def apply_apps_run2(seq):\n        new_seq = seq[:]\n        for i in range(1, n - 1):\n            window = [seq[i - 1], seq[i], seq[i + 1]]\n            if window.count(2) == 0:\n                # No wildcards, apply normal median smoothing\n                new_seq[i] = sorted(window)[1]\n            else:\n                # Handle wildcards\n                count_0 = window.count(0)\n                count_1 = window.count(1)\n                if count_0 > count_1:\n                    new_seq[i] = 0\n                elif count_1 > count_0:\n                    new_seq[i] = 1\n                else:\n                    new_seq[i] = 2\n        return new_seq\n\n    # Initialize variables\n    steps = 0\n    while True:\n        new_seq = apply_apps_run2(seq)\n        if new_seq == seq:\n            # Sequence is stable\n            break\n        seq = new_seq\n        steps += 1\n        if steps > n:  # Safety check to prevent infinite loops\n            return -1, []\n\n    return steps, seq\n\n", "input_format": "A single integer n (3 \u2264 n \u2264 500,000) \u2014 the length of the initial sequence and a dictionary where keys are indices and values are the sequence elements, giving the initial sequence itself.", "output_format": "If the sequence will never become stable, print a single number -1. Otherwise, first print a single integer \u2014 the minimum number of times one needs to apply the median smoothing algorithm to the initial sequence before it becomes stable. In the second line print n numbers separated by a space \u2014 the resulting sequence itself.", "test_input": ["assert apps_run2(4, {0: 0, 1: 0, 2: 1, 3: 1}) == (0, [0, 0, 1, 1])", "assert apps_run2(5, {0: 0, 1: 1, 2: 0, 3: 1, 4: 0}) == (2, [0, 0, 0, 0, 0])", "assert apps_run2(5, {0: 1, 1: 2, 2: 0, 3: 2, 4: 1}) == (0, [1, 2, 0, 2, 1])", "assert apps_run2(5, {0: 2, 1: 2, 2: 2, 3: 2, 4: 2}) == (0, [2, 2, 2, 2, 2])", "assert apps_run2(14, {0: 0, 1: 2, 2: 1, 3: 2, 4: 0, 5: 0, 6: 1, 7: 0, 8: 2, 9: 1, 10: 2, 11: 0, 12: 1, 13: 2}) == (4, [0, 2, 1, 2, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2])"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "APPS/2008-4", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nA schoolboy named Vasya loves reading books on programming and mathematics. He has recently read an encyclopedia article that described the method of median smoothing (or median filter) and its many applications in science and engineering. Vasya liked the idea of the method very much, and he decided to try it in practice.\n\nApplying the simplest variant of median smoothing to the sequence of numbers a_1, a_2, ..., a_{n} will result a new sequence b_1, b_2, ..., b_{n} obtained by the following algorithm:  b_1 = a_1, b_{n} = a_{n}, that is, the first and the last number of the new sequence match the corresponding numbers of the original sequence.  For i = 2, ..., n - 1 value b_{i} is equal to the median of three values a_{i} - 1, a_{i} and a_{i} + 1. \n\nThe median of a set of three numbers is the number that goes on the second place, when these three numbers are written in the non-decreasing order. For example, the median of the set 5, 1, 2 is number 2, and the median of set 1, 0, 1 is equal to 1.\n\nIn order to make the task easier, Vasya decided to apply the method to sequences consisting of zeros and ones only.\n\nHaving made the procedure once, Vasya looked at the resulting sequence and thought: what if I apply the algorithm to it once again, and then apply it to the next result, and so on? Vasya tried a couple of examples and found out that after some number of median smoothing algorithm applications the sequence can stop changing. We say that the sequence is stable, if it does not change when the median smoothing is applied to it.\n\nNow Vasya wonders, whether the sequence always eventually becomes stable. He asks you to write a program that, given a sequence of zeros and ones, will determine whether it ever becomes stable. Moreover, if it ever becomes stable, then you should determine what will it look like and how many times one needs to apply the median smoothing algorithm to initial sequence in order to obtain a stable one.\n\n\n-----Input-----\n\nThe first input line of the input contains a single integer n (3 \u2264 n \u2264 500 000)\u00a0\u2014 the length of the initial sequence.\n\nThe next line contains n integers a_1, a_2, ..., a_{n} (a_{i} = 0 or a_{i} = 1), giving the initial sequence itself.\n\n\n-----Output-----\n\nIf the sequence will never become stable, print a single number  - 1.\n\nOtherwise, first print a single integer\u00a0\u2014 the minimum number of times one needs to apply the median smoothing algorithm to the initial sequence before it becomes is stable. In the second line print n numbers separated by a space \u00a0\u2014 the resulting sequence itself.\n\n\n-----Examples-----\nInput\n4\n0 0 1 1\n\nOutput\n0\n0 0 1 1\n\nInput\n5\n0 1 0 1 0\n\nOutput\n2\n0 0 0 0 0\n\n\n\n-----Note-----\n\nIn the second sample the stabilization occurs in two steps: $01010 \\rightarrow 00100 \\rightarrow 00000$, and the sequence 00000 is obviously stable.", "raw_solution": "def apps_run1(n, seq):\n    carry = seq[0]\n    result = [carry]\n\n    mark = False\n    cur_len = 0\n    max_len = 0\n\n    i = 1\n    while i < len(seq) - 1:\n        if mark:\n            if seq[i] != seq[i + 1]:\n                cur_len += 1\n            else:\n                if cur_len > max_len:\n                    max_len = cur_len\n\n                if seq[i] == carry:\n                    result.extend([carry]*cur_len)\n                else:\n                    result.extend([carry]*(cur_len//2))\n                    result.extend([seq[i]]*(cur_len//2))\n\n                result.append(seq[i])\n                mark = False\n                cur_len = 0\n        elif seq[i] != seq[i - 1] and seq[i] != seq[i + 1]:\n            mark = True\n            cur_len = 1\n            carry = seq[i - 1]\n        else:\n            result.append(seq[i])\n\n        i += 1\n\n    if mark:\n        if cur_len > max_len:\n            max_len = cur_len\n\n        if seq[i] == carry:\n            result.extend([carry]*cur_len)\n        else:\n            result.extend([carry]*(cur_len//2))\n            result.extend([seq[i]]*(cur_len//2))\n\n    result.append(seq[i])\n\n    return ((max_len + 1)//2,result)", "raw_test_input": ["assert apps_run1(4, [0, 0, 1, 1]) == (0, [0, 0, 1, 1])", "assert apps_run1(5, [0, 1, 0, 1, 0]) == (2, [0, 0, 0, 0, 0])", "assert apps_run1(3, [1, 0, 0]) == (0, [1, 0, 0])"], "new_problem": "Vasya's school has decided to use the median smoothing algorithm to process student attendance records, which are represented as sequences of 0s and 1s. However, due to data entry errors, the sequences might contain invalid numbers or be of incorrect length. Your task is to write a function that applies the median smoothing algorithm to these sequences, ensuring that the input is valid. If the input is invalid, raise appropriate exceptions. The function should handle the following errors: 1. InvalidSequenceError: Raised if the sequence contains numbers other than 0 or 1. 2. SequenceLengthError: Raised if the sequence length is less than 3. 3. SequenceStabilityError: Raised if the sequence never becomes stable. Implement error handling to manage these exceptions and provide meaningful error messages.", "new_solution": "class InvalidSequenceError(Exception):\n    pass\n\nclass SequenceLengthError(Exception):\n    pass\n\nclass SequenceStabilityError(Exception):\n    pass\n\ndef apps_run2(n, sequence):\n    # Check for sequence length error\n    if n < 3:\n        raise SequenceLengthError(\"Sequence length must be at least 3.\")\n    \n    # Check for invalid sequence error\n    if any(x not in (0, 1) for x in sequence):\n        raise InvalidSequenceError(\"Sequence must contain only 0s and 1s.\")\n    \n    # Initialize variables\n    carry = sequence[0]\n    result = [carry]\n    mark = False\n    cur_len = 0\n    max_len = 0\n    i = 1\n    \n    while i < len(sequence) - 1:\n        if mark:\n            if sequence[i] != sequence[i + 1]:\n                cur_len += 1\n            else:\n                if cur_len > max_len:\n                    max_len = cur_len\n\n                if sequence[i] == carry:\n                    result.extend([carry] * cur_len)\n                else:\n                    result.extend([carry] * (cur_len // 2))\n                    result.extend([sequence[i]] * (cur_len // 2))\n\n                result.append(sequence[i])\n                mark = False\n                cur_len = 0\n        elif sequence[i] != sequence[i - 1] and sequence[i] != sequence[i + 1]:\n            mark = True\n            cur_len = 1\n            carry = sequence[i - 1]\n        else:\n            result.append(sequence[i])\n\n        i += 1\n\n    if mark:\n        if cur_len > max_len:\n            max_len = cur_len\n\n        if sequence[i] == carry:\n            result.extend([carry] * cur_len)\n        else:\n            result.extend([carry] * (cur_len // 2))\n            result.extend([sequence[i]] * (cur_len // 2))\n\n    result.append(sequence[i])\n\n    # Check for sequence stability error\n    if max_len >= 2*n:\n        raise SequenceStabilityError(\"The sequence never becomes stable.\")\n\n    return [(max_len+1)//2, result]\n", "input_format": "The first line contains a single integer n (3 \u2264 n \u2264 500,000) \u2014 the length of the initial sequence. The next line contains n integers a_1, a_2, ..., a_n (a_i = 0 or a_i = 1), giving the initial sequence itself.", "output_format": "If the sequence will never become stable, print a single number -1. Otherwise, first print a single integer \u2014 the minimum number of times one needs to apply the median smoothing algorithm to the initial sequence before it becomes stable. In the second line print n numbers separated by a space \u2014 the resulting sequence itself. If there is an exception, report the corresponding exception error.", "test_input": ["assert apps_run2(4, [0, 0, 1, 1]) == [0, [0, 0, 1, 1]]", "assert apps_run2(5, [0, 1, 0, 1, 0]) == [2, [0, 0, 0, 0, 0]]", "try:\n    apps_run2(5, [0, 1, 2, 1, 0])\nexcept InvalidSequenceError as e:\n    assert str(e) == \"Sequence must contain only 0s and 1s.\"", "try:\n    apps_run2(2, [0, 1])\nexcept SequenceLengthError as e:\n    assert str(e) == \"Sequence length must be at least 3.\"", "assert apps_run2(5, [0, 0, 0, 0, 0]) == [0, [0, 0, 0, 0, 0]]"], "requirement_type": "PROMPT_ERROR_HANDLING"}
{"task_id": "APPS/2006-1", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nIt is so boring in the summer holiday, isn't it? So Alice and Bob have invented a new game to play. The rules are as follows. First, they get a set of n distinct integers. And then they take turns to make the following moves. During each move, either Alice or Bob (the player whose turn is the current) can choose two distinct integers x and y from the set, such that the set doesn't contain their absolute difference |x - y|. Then this player adds integer |x - y| to the set (so, the size of the set increases by one).\n\nIf the current player has no valid move, he (or she) loses the game. The question is who will finally win the game if both players play optimally. Remember that Alice always moves first.\n\n\n-----Input-----\n\nThe first line contains an integer n (2 \u2264 n \u2264 100) \u2014 the initial number of elements in the set. The second line contains n distinct space-separated integers a_1, a_2, ..., a_{n} (1 \u2264 a_{i} \u2264 10^9) \u2014 the elements of the set.\n\n\n-----Output-----\n\nPrint a single line with the winner's name. If Alice wins print \"Alice\", otherwise print \"Bob\" (without quotes).\n\n\n-----Examples-----\nInput\n2\n2 3\n\nOutput\nAlice\n\nInput\n2\n5 3\n\nOutput\nAlice\n\nInput\n3\n5 6 7\n\nOutput\nBob\n\n\n\n-----Note-----\n\nConsider the first test sample. Alice moves first, and the only move she can do is to choose 2 and 3, then to add 1 to the set. Next Bob moves, there is no valid move anymore, so the winner is Alice.", "raw_solution": "def apps_run1(n, A):\n    def gcd(a, b):\n        while b > 0:\n            a, b = b, a % b\n        return a\n\n    GCD = A[0]\n    for x in A[1:]:\n        GCD = gcd(GCD, x)\n    num = max(A) // GCD - n\n    return \"Bob\" if num % 2 == 0 else \"Alice\"\n", "raw_test_input": ["assert apps_run1(2, [2, 3]) == 'Alice'", "assert apps_run1(2, [5, 3]) == 'Alice'", "assert apps_run1(3, [5, 6, 7]) == 'Bob'", "assert apps_run1(10, [72, 96, 24, 66, 6, 18, 12, 30, 60, 48]) == 'Bob'", "assert apps_run1(10, [78, 66, 6, 60, 18, 84, 36, 96, 72, 48]) == 'Bob'", "assert apps_run1(10, [98, 63, 42, 56, 14, 77, 70, 35, 84, 21]) == 'Bob'", "assert apps_run1(2, [1, 1000000000]) == 'Bob'", "assert apps_run1(2, [1000000000, 999999999]) == 'Bob'", "assert apps_run1(3, [2, 4, 6]) == 'Bob'", "assert apps_run1(2, [4, 6]) == 'Alice'", "assert apps_run1(2, [2, 6]) == 'Alice'", "assert apps_run1(2, [6, 2]) == 'Alice'", "assert apps_run1(10, [100000000, 200000000, 300000000, 400000000, 500000000, 600000000, 700000000, 800000000, 900000000, 1000000000]) == 'Bob'", "assert apps_run1(2, [1, 2]) == 'Bob'", "assert apps_run1(10, [1, 999999999, 999999998, 999999997, 999999996, 999999995, 999999994, 999999993, 999999992, 999999991]) == 'Alice'", "assert apps_run1(3, [6, 14, 21]) == 'Bob'", "assert apps_run1(3, [4, 12, 18]) == 'Bob'", "assert apps_run1(4, [2, 3, 15, 30]) == 'Bob'", "assert apps_run1(2, [10, 4]) == 'Alice'"], "new_problem": "In a competitive e-commerce platform, Alice and Bob are trying to optimize their product pricing strategy. They have a set of n distinct product prices. They take turns to adjust the prices by adding a new price, which is the absolute difference between any two existing prices, provided this new price is not already in the set. The player who cannot make a move loses. Given multiple test cases, determine who will win if both play optimally.", "new_solution": "def gcd(a, b):\n    while b > 0:\n        a, b = b, a % b\n    return a\n\ndef determine_winner(n, A):\n    GCD = A[0]\n    for x in A[1:]:\n        GCD = gcd(GCD, x)\n    num = max(A) // GCD - n\n    if num % 2 == 0:\n        return \"Bob\"\n    else:\n        return \"Alice\"\n\ndef apps_run2(t, test_cases):\n    results = []\n    for i in range(t):\n        n, A = test_cases[i]\n        results.append(determine_winner(n, A))\n    return results", "input_format": "The first line contains an integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. For each test case, the first line contains an integer n (2 \u2264 n \u2264 100) \u2014 the initial number of elements in the set. The second line contains n distinct space-separated integers a_1, a_2, ..., a_{n} (1 \u2264 a_{i} \u2264 10^9) \u2014 the elements of the set.", "output_format": "For each test case, print a single line with the winner's name. If Alice wins print \"Alice\", otherwise print \"Bob\" (without quotes).", "test_input": ["assert apps_run2(1, [(2, [2, 3])]) == ['Alice']", "assert apps_run2(1, [(2, [5, 3])]) == ['Alice']", "assert apps_run2(1, [(3, [5, 6, 7])]) == ['Bob']", "assert apps_run2(2, [(2, [2, 3]), (3, [5, 6, 7])]) == ['Alice', 'Bob']", "assert apps_run2(3, [(2, [8, 12]), (3, [1, 2, 3]), (4, [10, 20, 30, 40])]) == ['Alice', 'Bob', 'Bob']"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "APPS/2006-2", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nIt is so boring in the summer holiday, isn't it? So Alice and Bob have invented a new game to play. The rules are as follows. First, they get a set of n distinct integers. And then they take turns to make the following moves. During each move, either Alice or Bob (the player whose turn is the current) can choose two distinct integers x and y from the set, such that the set doesn't contain their absolute difference |x - y|. Then this player adds integer |x - y| to the set (so, the size of the set increases by one).\n\nIf the current player has no valid move, he (or she) loses the game. The question is who will finally win the game if both players play optimally. Remember that Alice always moves first.\n\n\n-----Input-----\n\nThe first line contains an integer n (2 \u2264 n \u2264 100) \u2014 the initial number of elements in the set. The second line contains n distinct space-separated integers a_1, a_2, ..., a_{n} (1 \u2264 a_{i} \u2264 10^9) \u2014 the elements of the set.\n\n\n-----Output-----\n\nPrint a single line with the winner's name. If Alice wins print \"Alice\", otherwise print \"Bob\" (without quotes).\n\n\n-----Examples-----\nInput\n2\n2 3\n\nOutput\nAlice\n\nInput\n2\n5 3\n\nOutput\nAlice\n\nInput\n3\n5 6 7\n\nOutput\nBob\n\n\n\n-----Note-----\n\nConsider the first test sample. Alice moves first, and the only move she can do is to choose 2 and 3, then to add 1 to the set. Next Bob moves, there is no valid move anymore, so the winner is Alice.", "raw_solution": "def apps_run1(n, A):\n    def gcd(a, b):\n        while b > 0:\n            a, b = b, a % b\n        return a\n\n    GCD = A[0]\n    for x in A[1:]:\n        GCD = gcd(GCD, x)\n    num = max(A) // GCD - n\n    return \"Bob\" if num % 2 == 0 else \"Alice\"\n", "raw_test_input": ["assert apps_run1(2, [2, 3]) == 'Alice'", "assert apps_run1(2, [5, 3]) == 'Alice'", "assert apps_run1(3, [5, 6, 7]) == 'Bob'", "assert apps_run1(10, [72, 96, 24, 66, 6, 18, 12, 30, 60, 48]) == 'Bob'", "assert apps_run1(10, [78, 66, 6, 60, 18, 84, 36, 96, 72, 48]) == 'Bob'", "assert apps_run1(10, [98, 63, 42, 56, 14, 77, 70, 35, 84, 21]) == 'Bob'", "assert apps_run1(2, [1, 1000000000]) == 'Bob'", "assert apps_run1(2, [1000000000, 999999999]) == 'Bob'", "assert apps_run1(3, [2, 4, 6]) == 'Bob'", "assert apps_run1(2, [4, 6]) == 'Alice'", "assert apps_run1(2, [2, 6]) == 'Alice'", "assert apps_run1(2, [6, 2]) == 'Alice'", "assert apps_run1(10, [100000000, 200000000, 300000000, 400000000, 500000000, 600000000, 700000000, 800000000, 900000000, 1000000000]) == 'Bob'", "assert apps_run1(2, [1, 2]) == 'Bob'", "assert apps_run1(10, [1, 999999999, 999999998, 999999997, 999999996, 999999995, 999999994, 999999993, 999999992, 999999991]) == 'Alice'", "assert apps_run1(3, [6, 14, 21]) == 'Bob'", "assert apps_run1(3, [4, 12, 18]) == 'Bob'", "assert apps_run1(4, [2, 3, 15, 30]) == 'Bob'", "assert apps_run1(2, [10, 4]) == 'Alice'"], "new_problem": "Alice and Bob have invented a new game to play with a set of n distinct integers. They take turns to make moves by choosing two distinct integers x and y from the set, such that the set doesn't contain their absolute difference |x - y|. The player then adds |x - y| to the set. If the current player has no valid move, they lose the game. Alice always moves first. The task is to determine the winner if both play optimally. Additionally, the function should support an optional 'verbose' mode that outputs the sequence of moves made.", "new_solution": "\ndef gcd(a, b):\n    while b > 0:\n        a, b = b, a % b\n    return a\n\ndef apps_run2(n, A, verbose=False):\n    GCD = A[0]\n    for x in A[1:]:\n        GCD = gcd(GCD, x)\n    \n    num = max(A) // GCD - n\n    winner = \"Alice\" if num % 2 != 0 else \"Bob\"\n    \n    if verbose:\n        moves = []\n        current_player = \"Alice\"\n        for i in range(num):\n            moves.append(current_player)\n            current_player = \"Bob\" if current_player == \"Alice\" else \"Alice\"\n        return winner, moves\n    else:\n        return winner\n", "input_format": "The first line contains an integer n (2 \u2264 n \u2264 100) \u2014 the initial number of elements in the set. The second line contains n distinct space-separated integers a_1, a_2, ..., a_{n} (1 \u2264 a_{i} \u2264 10^9) \u2014 the elements of the set. Optionally, a third line may contain a string 'verbose' to enable detailed output.", "output_format": "Return a single line with the winner's name. If Alice wins return 'Alice', otherwise return 'Bob' (without quotes). If 'verbose' is provided, also return a list of characters' moving order.", "test_input": ["assert apps_run2(2, [2, 3]) == 'Alice'", "assert apps_run2(2, [5, 3]) == 'Alice'", "assert apps_run2(3, [5, 6, 7], verbose=True) == ('Bob', ['Alice', 'Bob', 'Alice', 'Bob'])", "assert apps_run2(4, [10, 20, 30, 40]) == 'Bob'", "assert apps_run2(3, [1, 2, 4], verbose=True) == ('Alice', ['Alice'])"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "APPS/2006-3", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nIt is so boring in the summer holiday, isn't it? So Alice and Bob have invented a new game to play. The rules are as follows. First, they get a set of n distinct integers. And then they take turns to make the following moves. During each move, either Alice or Bob (the player whose turn is the current) can choose two distinct integers x and y from the set, such that the set doesn't contain their absolute difference |x - y|. Then this player adds integer |x - y| to the set (so, the size of the set increases by one).\n\nIf the current player has no valid move, he (or she) loses the game. The question is who will finally win the game if both players play optimally. Remember that Alice always moves first.\n\n\n-----Input-----\n\nThe first line contains an integer n (2 \u2264 n \u2264 100) \u2014 the initial number of elements in the set. The second line contains n distinct space-separated integers a_1, a_2, ..., a_{n} (1 \u2264 a_{i} \u2264 10^9) \u2014 the elements of the set.\n\n\n-----Output-----\n\nPrint a single line with the winner's name. If Alice wins print \"Alice\", otherwise print \"Bob\" (without quotes).\n\n\n-----Examples-----\nInput\n2\n2 3\n\nOutput\nAlice\n\nInput\n2\n5 3\n\nOutput\nAlice\n\nInput\n3\n5 6 7\n\nOutput\nBob\n\n\n\n-----Note-----\n\nConsider the first test sample. Alice moves first, and the only move she can do is to choose 2 and 3, then to add 1 to the set. Next Bob moves, there is no valid move anymore, so the winner is Alice.", "raw_solution": "def apps_run1(n, A):\n    def gcd(a, b):\n        while b > 0:\n            a, b = b, a % b\n        return a\n\n    GCD = A[0]\n    for x in A[1:]:\n        GCD = gcd(GCD, x)\n    num = max(A) // GCD - n\n    return \"Bob\" if num % 2 == 0 else \"Alice\"", "raw_test_input": ["assert apps_run1(2, [2, 3]) == 'Alice'", "assert apps_run1(2, [5, 3]) == 'Alice'", "assert apps_run1(3, [5, 6, 7]) == 'Bob'", "assert apps_run1(10, [72, 96, 24, 66, 6, 18, 12, 30, 60, 48]) == 'Bob'", "assert apps_run1(10, [78, 66, 6, 60, 18, 84, 36, 96, 72, 48]) == 'Bob'", "assert apps_run1(10, [98, 63, 42, 56, 14, 77, 70, 35, 84, 21]) == 'Bob'", "assert apps_run1(2, [1, 1000000000]) == 'Bob'", "assert apps_run1(2, [1000000000, 999999999]) == 'Bob'", "assert apps_run1(3, [2, 4, 6]) == 'Bob'", "assert apps_run1(2, [4, 6]) == 'Alice'", "assert apps_run1(2, [2, 6]) == 'Alice'", "assert apps_run1(2, [6, 2]) == 'Alice'", "assert apps_run1(10, [100000000, 200000000, 300000000, 400000000, 500000000, 600000000, 700000000, 800000000, 900000000, 1000000000]) == 'Bob'", "assert apps_run1(2, [1, 2]) == 'Bob'", "assert apps_run1(10, [1, 999999999, 999999998, 999999997, 999999996, 999999995, 999999994, 999999993, 999999992, 999999991]) == 'Alice'", "assert apps_run1(3, [6, 14, 21]) == 'Bob'", "assert apps_run1(3, [4, 12, 18]) == 'Bob'", "assert apps_run1(4, [2, 3, 15, 30]) == 'Bob'", "assert apps_run1(2, [10, 4]) == 'Alice'"], "new_problem": "Alice and Bob have a new game with a twist. They start with a set of n distinct integers. They take turns to make moves as before, but now they can only choose integers within a specified range of indices. During each move, the current player can choose two distinct integers x and y from the set within the given range, such that the set doesn't contain their absolute difference |x - y|. Then this player adds integer |x - y| to the set. If the current player has no valid move, they lose the game. Given multiple queries, each specifying a range of indices, determine who will win the game for each query if both players play optimally. Alice always moves first.", "new_solution": "from typing import List, Tuple\n\ndef gcd(a: int, b: int) -> int:\n    while b > 0:\n        a, b = b, a % b\n    return a\n\ndef apps_run2(n: int, A: List[int], queries: List[Tuple[int, int]]) -> List[str]:\n    results = []\n    for l, r in queries:\n        subarray = A[l-1:r]\n        GCD = subarray[0]\n        for x in subarray[1:]:\n            GCD = gcd(GCD, x)\n        num = max(subarray) // GCD - len(subarray)\n        if num % 2 == 0:\n            results.append(\"Bob\")\n        else:\n            results.append(\"Alice\")\n    return results", "input_format": "The first line contains an integer n (2 \u2264 n \u2264 100) \u2014 the initial number of elements in the set. The second line contains n distinct space-separated integers a_1, a_2, ..., a_{n} (1 \u2264 a_{i} \u2264 10^9) \u2014 the elements of the set. The third line contains an integer m (1 \u2264 m \u2264 100) \u2014 the number of queries. Each of the next m lines contains two integers l and r (1 \u2264 l \u2264 r \u2264 n) representing a range of indices.", "output_format": "For each query, print a single line with the winner's name. If Alice wins print \"Alice\", otherwise print \"Bob\" (without quotes).", "test_input": ["assert apps_run2(3, [5, 6, 7], [(1, 3)]) == ['Bob']", "assert apps_run2(2, [2, 3], [(1, 2)]) == ['Alice']", "assert apps_run2(4, [2, 3, 5, 7], [(1, 2), (2, 4)]) == ['Alice', 'Bob']", "assert apps_run2(5, [10, 15, 20, 25, 30], [(1, 5), (2, 4)]) == ['Alice', 'Bob']", "assert apps_run2(3, [1, 2, 4], [(1, 2), (2, 3)]) == ['Bob', 'Bob']"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "APPS/2006-4", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nIt is so boring in the summer holiday, isn't it? So Alice and Bob have invented a new game to play. The rules are as follows. First, they get a set of n distinct integers. And then they take turns to make the following moves. During each move, either Alice or Bob (the player whose turn is the current) can choose two distinct integers x and y from the set, such that the set doesn't contain their absolute difference |x - y|. Then this player adds integer |x - y| to the set (so, the size of the set increases by one).\n\nIf the current player has no valid move, he (or she) loses the game. The question is who will finally win the game if both players play optimally. Remember that Alice always moves first.\n\n\n-----Input-----\n\nThe first line contains an integer n (2 \u2264 n \u2264 100) \u2014 the initial number of elements in the set. The second line contains n distinct space-separated integers a_1, a_2, ..., a_{n} (1 \u2264 a_{i} \u2264 10^9) \u2014 the elements of the set.\n\n\n-----Output-----\n\nPrint a single line with the winner's name. If Alice wins print \"Alice\", otherwise print \"Bob\" (without quotes).\n\n\n-----Examples-----\nInput\n2\n2 3\n\nOutput\nAlice\n\nInput\n2\n5 3\n\nOutput\nAlice\n\nInput\n3\n5 6 7\n\nOutput\nBob\n\n\n\n-----Note-----\n\nConsider the first test sample. Alice moves first, and the only move she can do is to choose 2 and 3, then to add 1 to the set. Next Bob moves, there is no valid move anymore, so the winner is Alice.", "raw_solution": "def apps_run1(n, A):\n    def gcd(a, b):\n        while b > 0:\n            a, b = b, a % b\n        return a\n\n    GCD = A[0]\n    for x in A[1:]:\n        GCD = gcd(GCD, x)\n    num = max(A) // GCD - n\n    return \"Bob\" if num % 2 == 0 else \"Alice\"\n", "raw_test_input": ["assert apps_run1(2, [2, 3]) == 'Alice'", "assert apps_run1(2, [5, 3]) == 'Alice'", "assert apps_run1(3, [5, 6, 7]) == 'Bob'", "assert apps_run1(10, [72, 96, 24, 66, 6, 18, 12, 30, 60, 48]) == 'Bob'", "assert apps_run1(10, [78, 66, 6, 60, 18, 84, 36, 96, 72, 48]) == 'Bob'", "assert apps_run1(10, [98, 63, 42, 56, 14, 77, 70, 35, 84, 21]) == 'Bob'", "assert apps_run1(2, [1, 1000000000]) == 'Bob'", "assert apps_run1(2, [1000000000, 999999999]) == 'Bob'", "assert apps_run1(3, [2, 4, 6]) == 'Bob'", "assert apps_run1(2, [4, 6]) == 'Alice'", "assert apps_run1(2, [2, 6]) == 'Alice'", "assert apps_run1(2, [6, 2]) == 'Alice'", "assert apps_run1(10, [100000000, 200000000, 300000000, 400000000, 500000000, 600000000, 700000000, 800000000, 900000000, 1000000000]) == 'Bob'", "assert apps_run1(2, [1, 2]) == 'Bob'", "assert apps_run1(10, [1, 999999999, 999999998, 999999997, 999999996, 999999995, 999999994, 999999993, 999999992, 999999991]) == 'Alice'", "assert apps_run1(3, [6, 14, 21]) == 'Bob'", "assert apps_run1(3, [4, 12, 18]) == 'Bob'", "assert apps_run1(4, [2, 3, 15, 30]) == 'Bob'", "assert apps_run1(2, [10, 4]) == 'Alice'"], "new_problem": "Alice and Bob are playing a game with a set of distinct integers. The rules are the same as before, but now you need to handle potential errors in the input data. Specifically, you need to handle the following errors: \n1. Invalid number of elements (n not in the range 2 to 100).\n2. Non-distinct integers in the set.\n3. Integers out of the allowed range (1 to 10^9).\n4. Non-integer inputs.\n\nYour task is to write a function that determines the winner of the game while handling these errors gracefully. If an error is detected, raise a custom exception with a meaningful error message.", "new_solution": "from typing import List\n\nclass GameError(Exception):\n    pass\n\nclass InvalidNumberOfElementsError(GameError):\n    pass\n\nclass NonDistinctElementsError(GameError):\n    pass\n\nclass OutOfRangeError(GameError):\n    pass\n\nclass NonIntegerInputError(GameError):\n    pass\n\n\ndef gcd(a: int, b: int) -> int:\n    while b > 0:\n        a, b = b, a % b\n    return a\n\n\ndef apps_run2(n: int, A: List[int]) -> str:\n    if not (2 <= n <= 100):\n        raise InvalidNumberOfElementsError(\"The number of elements must be between 2 and 100.\")\n    if len(A) != len(set(A)):\n        raise NonDistinctElementsError(\"All elements in the set must be distinct.\")\n    if any(not (1 <= x <= 10**9) for x in A):\n        raise OutOfRangeError(\"All elements must be in the range 1 to 10^9.\")\n    if any(not isinstance(x, int) for x in A):\n        raise NonIntegerInputError(\"All inputs must be integers.\")\n\n    GCD = A[0]\n    for x in A[1:]:\n        GCD = gcd(GCD, x)\n    num = max(A) // GCD - n\n    return \"Bob\" if num % 2 == 0 else \"Alice\"\n", "input_format": "The first line contains an integer n (2 \u2264 n \u2264 100) \u2014 the initial number of elements in the set. The second line contains n distinct space-separated integers a_1, a_2, ..., a_{n} (1 \u2264 a_{i} \u2264 10^9) \u2014 the elements of the set.", "output_format": "Print a single line with the winner's name. If Alice wins print \"Alice\", otherwise print \"Bob\" (without quotes).", "test_input": ["try:\n    apps_run2(1, [2, 3])\nexcept InvalidNumberOfElementsError as e:\n    assert str(e) == \"The number of elements must be between 2 and 100.\"\n", "try:\n    apps_run2(3, [5, 5, 7])\nexcept NonDistinctElementsError as e:\n    assert str(e) == \"All elements in the set must be distinct.\"\n", "try:\n    apps_run2(3, [5, 6, 1000000001])\nexcept OutOfRangeError as e:\n    assert str(e) == \"All elements must be in the range 1 to 10^9.\"\n", "try:\n    apps_run2(3, [5, 6, 'a'])\nexcept NonIntegerInputError as e:\n    assert str(e) == \"All inputs must be integers.\"\nexcept TypeError as e:\n    assert str(e) == \"'<=' not supported between instances of 'int' and 'str'\"\n", "assert apps_run2(3, [5, 6, 7]) == \"Bob\""], "requirement_type": "PROMPT_ERROR_HANDLING"}
{"task_id": "APPS/0112-1", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nNow that Heidi has made sure her Zombie Contamination level checker works, it's time to strike! This time, the zombie lair is a strictly convex polygon on the lattice. Each vertex of the polygon occupies a point on the lattice. For each cell of the lattice, Heidi knows the level of Zombie Contamination \u2013 the number of corners of the cell that are inside or on the border of the lair.\n\nGiven this information, Heidi wants to know the exact shape of the lair to rain destruction on the zombies. Help her!\n\n[Image]\n\n\n-----Input-----\n\nThe input contains multiple test cases.\n\nThe first line of each test case contains one integer N, the size of the lattice grid (5 \u2264 N \u2264 500). The next N lines each contain N characters, describing the level of Zombie Contamination of each cell in the lattice. Every character of every line is a digit between 0 and 4. \n\nCells are given in the same order as they are shown in the picture above: rows go in the decreasing value of y coordinate, and in one row cells go in the order of increasing x coordinate. This means that the first row corresponds to cells with coordinates (1, N), ..., (N, N) and the last row corresponds to cells with coordinates (1, 1), ..., (N, 1).\n\nThe last line of the file contains a zero. This line should not be treated as a test case. The sum of the N values for all tests in one file will not exceed 5000.\n\n\n-----Output-----\n\nFor each test case, give the following output:\n\nThe first line of the output should contain one integer V, the number of vertices of the polygon that is the secret lair. The next V lines each should contain two integers, denoting the vertices of the polygon in the clockwise order, starting from the lexicographically smallest vertex.\n\n\n-----Examples-----\nInput\n8\n00000000\n00000110\n00012210\n01234200\n02444200\n01223200\n00001100\n00000000\n5\n00000\n01210\n02420\n01210\n00000\n7\n0000000\n0122100\n0134200\n0013200\n0002200\n0001100\n0000000\n0\n\nOutput\n4\n2 3\n2 4\n6 6\n5 2\n4\n2 2\n2 3\n3 3\n3 2\n3\n2 5\n4 5\n4 2\n\n\n\n-----Note-----\n\nIt is guaranteed that the solution always exists and is unique. It is guaranteed that in the correct solution the coordinates of the polygon vertices are between 2 and N - 2. A vertex (x_1, y_1) is lexicographically smaller than vertex (x_2, y_2) if x_1 < x_2 or $x_{1} = x_{2} \\wedge y_{1} < y_{2}$.", "raw_solution": "```python\nimport math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n    \ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef apps_run1(n,a):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if a[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                x, y = i - 1 + dx + ddx, j - 1 + dy + ddy\n                                if 0 <= x < n and 0 <= y < n and a[x][y] == 0:\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            points[0], points[i] = points[i], points[0]\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    return hull\n\n ```", "raw_test_input": ["assert apps_run1(7,[[0, 0, 0, 0, 0, 0, 0],[0, 0, 0, 0, 0, 0, 0],[0, 1, 2, 3, 2, 1, 0],[0, 2, 3, 4, 3, 2, 0],[0, 1, 2, 3, 2, 1, 0],[0, 0, 0, 0, 0, 0, 0],[0, 0, 0, 0, 0, 0, 0]])==[(2, 3), (2, 4), (5, 4), (5, 3)]", "assert apps_run1(6, [[0, 0, 0, 0, 0, 0],[0, 0, 1, 1, 1, 0],[0, 1, 2, 3, 2, 0],[0, 1, 2, 3, 2, 0],[0, 0, 1, 1, 1, 0],[0, 0, 0, 0, 0, 0]]) == [(2, 3), (3, 4), (4, 4), (4, 2), (3, 2)]", "assert apps_run1(8,[[0, 0, 0, 0, 0, 0, 0, 0],[0, 0, 0, 0, 0, 1, 1, 0],[0, 0, 0, 1, 2, 2, 1, 0],[0, 1, 2, 3, 4, 2, 0, 0],[0, 2, 4, 4, 4, 2, 0, 0],[0, 1, 2, 2, 3, 2, 0, 0],[0, 0, 0, 0, 1, 1, 0, 0],[0, 0, 0, 0, 0, 0, 0, 0]])==[(2, 3), (2, 4), (6, 6), (5, 2)]", "assert apps_run1(7,[ [0, 0, 0, 0, 0, 0, 0],[0, 1, 2, 2, 1, 0, 0],[0, 1, 3, 4, 2, 0, 0],[0, 0, 1, 3, 2, 0, 0],[0, 0, 0, 2, 2, 0, 0],[0, 0, 0, 1, 1, 0, 0],[0, 0, 0, 0, 0, 0, 0]])==[(2, 5), (4, 5), (4, 2)]", "assert apps_run1(5, [[0, 0, 0, 0, 0],[0, 1, 2, 1, 0],[0, 2, 4, 2, 0],[0, 1, 2, 1, 0],[0, 0, 0, 0, 0]])==[(2, 2), (2, 3), (3, 3), (3, 2)]"], "new_problem": "Heidi is now working with a team of scientists to develop a system that can identify and track multiple zombie lairs in a large area. Each lair is represented as a strictly convex polygon on a lattice grid, and the contamination levels are given for each cell. The system should not only identify the shape of each lair but also calculate the total area covered by all lairs combined. Additionally, the system should be able to handle multiple grids and provide a summary of the total area covered by lairs in each grid. Help Heidi and her team by extending the original function to solve this problem.", "new_solution": "import math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n    \ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef solve(n, grid):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                x, y = i - 1 + dx + ddx, j - 1 + dy + ddy\n                                if 0 <= x < n and 0 <= y < n and grid[x][y] == 0:\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            points[0], points[i] = points[i], points[0]\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    return hull\n\ndef calculate_area(hull):\n    area = 0\n    for i in range(len(hull)):\n        j = (i + 1) % len(hull)\n        area += hull[i][0] * hull[j][1]\n        area -= hull[j][0] * hull[i][1]\n    return abs(area) / 2\n\ndef apps_run2(grids):\n    total_areas = []\n    for grid in grids:\n        n = len(grid)\n        hull = solve(n, grid)\n        area = calculate_area(hull)\n        total_areas.append(area)\n    return total_areas\n", "input_format": "The function process_grids takes one parameter - grids: A list of 2D arrays, where each 2D array represents a lattice grid containing Zombie Contamination levels. Each element in the grids is a two-dimensional list where each cell contains an integer from 0 to 4 indicating the contamination level at that position", "output_format": "For each test case, output the number of vertices of the polygon that is the secret lair, followed by the coordinates of each vertex in clockwise order, starting from the lexicographically smallest vertex.", "test_input": ["assert apps_run2([[[0,0,0,0,0,0,0,0],[0,0,0,0,0,1,1,0],[0,0,0,1,2,2,1,0],[0,1,2,3,4,2,0,0],[0,2,4,4,4,2,0,0],[0,1,2,2,3,2,0,0],[0,0,0,0,1,1,0,0],[0,0,0,0,0,0,0,0]]]) == [8.5]", "assert apps_run2([[[0,0,0,0,0],[0,1,2,1,0],[0,2,4,2,0],[0,1,2,1,0],[0,0,0,0,0]]]) == [1.0]", "assert apps_run2([[[0,0,0,0,0,0,0],[0,1,2,2,1,0,0],[0,1,3,4,2,0,0],[0,0,1,3,2,0,0],[0,0,0,2,2,0,0],[0,0,0,1,1,0,0],[0,0,0,0,0,0,0]]]) == [3.0]", "assert apps_run2([[[0,0,0,0,0,0,0,0],[0,0,0,0,0,1,1,0],[0,0,0,1,2,2,1,0],[0,1,2,3,4,2,0,0],[0,2,4,4,4,2,0,0],[0,1,2,2,3,2,0,0],[0,0,0,0,1,1,0,0],[0,0,0,0,0,0,0,0]], [[0,0,0,0,0],[0,1,2,1,0],[0,2,4,2,0],[0,1,2,1,0],[0,0,0,0,0]]]) == [8.5, 1.0]", "assert apps_run2([[[0,0,0,0,0,0,0],[0,1,2,2,1,0,0],[0,1,3,4,2,0,0],[0,0,1,3,2,0,0],[0,0,0,2,2,0,0],[0,0,0,1,1,0,0],[0,0,0,0,0,0,0]], [[0,0,0,0,0,0,0,0],[0,0,0,0,0,1,1,0],[0,0,0,1,2,2,1,0],[0,1,2,3,4,2,0,0],[0,2,4,4,4,2,0,0],[0,1,2,2,3,2,0,0],[0,0,0,0,1,1,0,0],[0,0,0,0,0,0,0,0]]]) == [3.0,8.5]"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "APPS/0112-2", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nNow that Heidi has made sure her Zombie Contamination level checker works, it's time to strike! This time, the zombie lair is a strictly convex polygon on the lattice. Each vertex of the polygon occupies a point on the lattice. For each cell of the lattice, Heidi knows the level of Zombie Contamination \u2013 the number of corners of the cell that are inside or on the border of the lair.\n\nGiven this information, Heidi wants to know the exact shape of the lair to rain destruction on the zombies. Help her!\n\n[Image]\n\n\n-----Input-----\n\nThe input contains multiple test cases.\n\nThe first line of each test case contains one integer N, the size of the lattice grid (5 \u2264 N \u2264 500). The next N lines each contain N characters, describing the level of Zombie Contamination of each cell in the lattice. Every character of every line is a digit between 0 and 4. \n\nCells are given in the same order as they are shown in the picture above: rows go in the decreasing value of y coordinate, and in one row cells go in the order of increasing x coordinate. This means that the first row corresponds to cells with coordinates (1, N), ..., (N, N) and the last row corresponds to cells with coordinates (1, 1), ..., (N, 1).\n\nThe last line of the file contains a zero. This line should not be treated as a test case. The sum of the N values for all tests in one file will not exceed 5000.\n\n\n-----Output-----\n\nFor each test case, give the following output:\n\nThe first line of the output should contain one integer V, the number of vertices of the polygon that is the secret lair. The next V lines each should contain two integers, denoting the vertices of the polygon in the clockwise order, starting from the lexicographically smallest vertex.\n\n\n-----Examples-----\nInput\n8\n00000000\n00000110\n00012210\n01234200\n02444200\n01223200\n00001100\n00000000\n5\n00000\n01210\n02420\n01210\n00000\n7\n0000000\n0122100\n0134200\n0013200\n0002200\n0001100\n0000000\n0\n\nOutput\n4\n2 3\n2 4\n6 6\n5 2\n4\n2 2\n2 3\n3 3\n3 2\n3\n2 5\n4 5\n4 2\n\n\n\n-----Note-----\n\nIt is guaranteed that the solution always exists and is unique. It is guaranteed that in the correct solution the coordinates of the polygon vertices are between 2 and N - 2. A vertex (x_1, y_1) is lexicographically smaller than vertex (x_2, y_2) if x_1 < x_2 or $x_{1} = x_{2} \\wedge y_{1} < y_{2}$.", "raw_solution": "```python\nimport math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n    \ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef apps_run1(n,a):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if a[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                x, y = i - 1 + dx + ddx, j - 1 + dy + ddy\n                                if 0 <= x < n and 0 <= y < n and a[x][y] == 0:\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            points[0], points[i] = points[i], points[0]\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    return hull\n\n ```", "raw_test_input": ["assert apps_run1(7,[[0, 0, 0, 0, 0, 0, 0],[0, 0, 0, 0, 0, 0, 0],[0, 1, 2, 3, 2, 1, 0],[0, 2, 3, 4, 3, 2, 0],[0, 1, 2, 3, 2, 1, 0],[0, 0, 0, 0, 0, 0, 0],[0, 0, 0, 0, 0, 0, 0]])==[(2, 3), (2, 4), (5, 4), (5, 3)]", "assert apps_run1(6, [[0, 0, 0, 0, 0, 0],[0, 0, 1, 1, 1, 0],[0, 1, 2, 3, 2, 0],[0, 1, 2, 3, 2, 0],[0, 0, 1, 1, 1, 0],[0, 0, 0, 0, 0, 0]]) == [(2, 3), (3, 4), (4, 4), (4, 2), (3, 2)]", "assert apps_run1(8,[[0, 0, 0, 0, 0, 0, 0, 0],[0, 0, 0, 0, 0, 1, 1, 0],[0, 0, 0, 1, 2, 2, 1, 0],[0, 1, 2, 3, 4, 2, 0, 0],[0, 2, 4, 4, 4, 2, 0, 0],[0, 1, 2, 2, 3, 2, 0, 0],[0, 0, 0, 0, 1, 1, 0, 0],[0, 0, 0, 0, 0, 0, 0, 0]])==[(2, 3), (2, 4), (6, 6), (5, 2)]", "assert apps_run1(7,[ [0, 0, 0, 0, 0, 0, 0],[0, 1, 2, 2, 1, 0, 0],[0, 1, 3, 4, 2, 0, 0],[0, 0, 1, 3, 2, 0, 0],[0, 0, 0, 2, 2, 0, 0],[0, 0, 0, 1, 1, 0, 0],[0, 0, 0, 0, 0, 0, 0]])==[(2, 5), (4, 5), (4, 2)]", "assert apps_run1(5, [[0, 0, 0, 0, 0],[0, 1, 2, 1, 0],[0, 2, 4, 2, 0],[0, 1, 2, 1, 0],[0, 0, 0, 0, 0]])==[(2, 2), (2, 3), (3, 3), (3, 2)]"], "new_problem": "Heidi's Zombie Contamination level checker now needs to support additional features. The lair is still a strictly convex polygon on the lattice, but now Heidi wants to optionally filter the vertices based on a minimum distance from a given point. The function should maintain backward compatibility, meaning it should still work with the original input format. However, it should now also accept an optional parameter `min_distance` (defaulting to 0) and a `reference_point` (defaulting to None). If `min_distance` is provided, only vertices that are at least `min_distance` away from the `reference_point` should be included in the output.", "new_solution": "import math\nfrom typing import List, Tuple, Optional\n\ndef lexComp(a: Tuple[int, int], b: Tuple[int, int]) -> int:\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a: Tuple[int, int], b: Tuple[int, int], c: Tuple[int, int]) -> int:\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n    \ndef dist2(a: Tuple[int, int], b: Tuple[int, int]) -> int:\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef apps_run2(n: int,input_lines: List[str],min_distance: Optional[int] = 0, reference_point: Optional[Tuple[int, int]] = None) -> List[Tuple[int, int]]:\n    a = [list(map(int, line)) for line in input_lines]\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if a[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                x, y = i - 1 + dx + ddx, j - 1 + dy + ddy\n                                if 0 <= x < n and 0 <= y < n and a[x][y] == 0:\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            points[0], points[i] = points[i], points[0]\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n  - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    if reference_point is not None and min_distance > 0:\n            hull = [p for p in hull if dist2(p, reference_point) >= min_distance ** 2]\n    return hull\n", "input_format": "The function solve takes four parameters: - n: An integer (5 \u2264 n \u2264 500) representing the size of the lattice grid - input_lines: A list of n strings, where each string contains n digits (0-4) representing the Zombie Contamination level at each cell - min_distance: An optional integer (default: 0) specifying minimum distance requirement from reference point - reference_point: An optional tuple (x, y) (default: None) representing the point from which min_distance is calculated", "output_format": "For each test case, give the following output: The first line of the output should contain one integer V, the number of vertices of the polygon that is the secret lair. The next V lines each should contain two integers, denoting the vertices of the polygon in the clockwise order, starting from the lexicographically smallest vertex.", "test_input": ["assert apps_run2(8,[[0,0,0,0,0,0,0,0],[0,0,0,0,0,1,1,0],[0,0,0,1,2,2,1,0],[0,1,2,3,4,2,0,0],[0,2,4,4,4,2,0,0],[0,1,2,2,3,2,0,0],[0,0,0,0,1,1,0,0],[0,0,0,0,0,0,0,0]], 0, None) == [(2, 3), (2, 4), (6, 6), (5, 2)]", "assert apps_run2(5,[[0,0,0,0,0],[0,1,2,1,0],[0,2,4,2,0],[0,1,2,1,0],[0,0,0,0,0]], 0, None) ==  [(2, 2), (2, 3), (3, 3), (3, 2)]", "assert apps_run2(7,[[0,0,0,0,0,0,0],[0,1,2,2,1,0,0],[0,1,3,4,2,0,0],[0,0,1,3,2,0,0],[0,0,0,2,2,0,0],[0,0,0,1,1,0,0],[0,0,0,0,0,0,0]], 0, None) == [(2, 5), (4, 5), (4, 2)]", "assert apps_run2(8,[[0,0,0,0,0,0,0,0],[0,0,0,0,0,1,1,0],[0,0,0,1,2,2,1,0],[0,1,2,3,4,2,0,0],[0,2,4,4,4,2,0,0],[0,1,2,2,3,2,0,0],[0,0,0,0,1,1,0,0],[0,0,0,0,0,0,0,0]], 2, (4, 4)) == [(2, 3), (2, 4), (6, 6), (5, 2)]", "assert apps_run2(5,[[0,0,0,0,0],[0,1,2,1,0],[0,2,4,2,0],[0,1,2,1,0],[0,0,0,0,0]], 1, (3, 3)) == [(2, 2), (2, 3), (3, 2)]"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "APPS/0112-3", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nNow that Heidi has made sure her Zombie Contamination level checker works, it's time to strike! This time, the zombie lair is a strictly convex polygon on the lattice. Each vertex of the polygon occupies a point on the lattice. For each cell of the lattice, Heidi knows the level of Zombie Contamination \u2013 the number of corners of the cell that are inside or on the border of the lair.\n\nGiven this information, Heidi wants to know the exact shape of the lair to rain destruction on the zombies. Help her!\n\n[Image]\n\n\n-----Input-----\n\nThe input contains multiple test cases.\n\nThe first line of each test case contains one integer N, the size of the lattice grid (5 \u2264 N \u2264 500). The next N lines each contain N characters, describing the level of Zombie Contamination of each cell in the lattice. Every character of every line is a digit between 0 and 4. \n\nCells are given in the same order as they are shown in the picture above: rows go in the decreasing value of y coordinate, and in one row cells go in the order of increasing x coordinate. This means that the first row corresponds to cells with coordinates (1, N), ..., (N, N) and the last row corresponds to cells with coordinates (1, 1), ..., (N, 1).\n\nThe last line of the file contains a zero. This line should not be treated as a test case. The sum of the N values for all tests in one file will not exceed 5000.\n\n\n-----Output-----\n\nFor each test case, give the following output:\n\nThe first line of the output should contain one integer V, the number of vertices of the polygon that is the secret lair. The next V lines each should contain two integers, denoting the vertices of the polygon in the clockwise order, starting from the lexicographically smallest vertex.\n\n\n-----Examples-----\nInput\n8\n00000000\n00000110\n00012210\n01234200\n02444200\n01223200\n00001100\n00000000\n5\n00000\n01210\n02420\n01210\n00000\n7\n0000000\n0122100\n0134200\n0013200\n0002200\n0001100\n0000000\n0\n\nOutput\n4\n2 3\n2 4\n6 6\n5 2\n4\n2 2\n2 3\n3 3\n3 2\n3\n2 5\n4 5\n4 2\n\n\n\n-----Note-----\n\nIt is guaranteed that the solution always exists and is unique. It is guaranteed that in the correct solution the coordinates of the polygon vertices are between 2 and N - 2. A vertex (x_1, y_1) is lexicographically smaller than vertex (x_2, y_2) if x_1 < x_2 or $x_{1} = x_{2} \\wedge y_{1} < y_{2}$.", "raw_solution": "```python\nimport math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n    \ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef apps_run1(n,a):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if a[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                x, y = i - 1 + dx + ddx, j - 1 + dy + ddy\n                                if 0 <= x < n and 0 <= y < n and a[x][y] == 0:\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            points[0], points[i] = points[i], points[0]\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    return hull\n\n ```", "raw_test_input": ["assert apps_run1(7,[[0, 0, 0, 0, 0, 0, 0],[0, 0, 0, 0, 0, 0, 0],[0, 1, 2, 3, 2, 1, 0],[0, 2, 3, 4, 3, 2, 0],[0, 1, 2, 3, 2, 1, 0],[0, 0, 0, 0, 0, 0, 0],[0, 0, 0, 0, 0, 0, 0]])==[(2, 3), (2, 4), (5, 4), (5, 3)]", "assert apps_run1(6, [[0, 0, 0, 0, 0, 0],[0, 0, 1, 1, 1, 0],[0, 1, 2, 3, 2, 0],[0, 1, 2, 3, 2, 0],[0, 0, 1, 1, 1, 0],[0, 0, 0, 0, 0, 0]]) == [(2, 3), (3, 4), (4, 4), (4, 2), (3, 2)]", "assert apps_run1(8,[[0, 0, 0, 0, 0, 0, 0, 0],[0, 0, 0, 0, 0, 1, 1, 0],[0, 0, 0, 1, 2, 2, 1, 0],[0, 1, 2, 3, 4, 2, 0, 0],[0, 2, 4, 4, 4, 2, 0, 0],[0, 1, 2, 2, 3, 2, 0, 0],[0, 0, 0, 0, 1, 1, 0, 0],[0, 0, 0, 0, 0, 0, 0, 0]])==[(2, 3), (2, 4), (6, 6), (5, 2)]", "assert apps_run1(7,[ [0, 0, 0, 0, 0, 0, 0],[0, 1, 2, 2, 1, 0, 0],[0, 1, 3, 4, 2, 0, 0],[0, 0, 1, 3, 2, 0, 0],[0, 0, 0, 2, 2, 0, 0],[0, 0, 0, 1, 1, 0, 0],[0, 0, 0, 0, 0, 0, 0]])==[(2, 5), (4, 5), (4, 2)]", "assert apps_run1(5, [[0, 0, 0, 0, 0],[0, 1, 2, 1, 0],[0, 2, 4, 2, 0],[0, 1, 2, 1, 0],[0, 0, 0, 0, 0]])==[(2, 2), (2, 3), (3, 3), (3, 2)]"], "new_problem": "Heidi's Zombie Contamination level checker now needs to handle a more complex scenario. The zombie lair is represented as a graph where each vertex is a point on the lattice, and edges represent direct connections between these points. Each cell of the lattice has a contamination level, and Heidi needs to determine the exact shape of the lair using a graph data structure. The vertices of the polygon should be stored in a dictionary where keys are vertex identifiers and values are tuples representing coordinates. Additionally, the solution must handle multiple lairs in a single grid, and output the vertices of each lair separately. The vertices should be output in clockwise order, starting from the lexicographically smallest vertex. The solution should include type hints and handle up to 10,000 vertices in total across all test cases.", "new_solution": "def apps_run2(n: int, grid: list[str]) -> list[list[tuple[int, int]]]:\n    import math\n    from collections import defaultdict\n    def lexComp(a: tuple[int, int], b: tuple[int, int]) -> int:\n        if a[0] != b[0]:\n            return -1 if a[0] < b[0] else 1\n        if a[1] != b[1]:\n            return -1 if a[1] < b[1] else 1\n        return 0\n    def turn(a: tuple[int, int], b: tuple[int, int], c: tuple[int, int]) -> int:\n        return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n    \n    def dist2(a: tuple[int, int], b: tuple[int, int]) -> int:\n        return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\n    points = set()\n    for i in range(n-1):\n        for j in range(n-1):\n            cell = [[int(grid[i+y][j+x]) for x in range(2)] for y in range(2)]\n            for y in range(2):\n                for x in range(2):\n                    if cell[y][x] >= 1:\n                        point = (j+x+1, n-i-y)\n                        points.add(point)\n                    \n    points = sorted(list(points))\n    if not points:\n        return []\n        \n    start = points[0]\n    hull = []\n    current = start\n    \n    while True:\n        hull.append(current)\n        endpoint = points[0]\n        \n        for next_point in points[1:]:\n            t = turn(current, endpoint, next_point)\n            if endpoint == current or t > 0 or (t == 0 and dist2(current, next_point) > dist2(current, endpoint)):\n                endpoint = next_point\n                \n        current = endpoint\n        if current == start:\n            break\n    \n    start_idx = min(range(len(hull)), key=lambda i: hull[i])\n    hull = hull[start_idx:] + hull[:start_idx]\n\n    return [hull]", "input_format": "The function solve takes two parameters: - n: An integer (5 \u2264 n \u2264 500) representing the size of the lattice grid - grid: A list of n strings, each containing n characters (0-4) representing the Zombie Contamination levels", "output_format": "For each test case, output the number of vertices V of the polygon that is the secret lair, followed by V lines each containing two integers, denoting the vertices of the polygon in the clockwise order, starting from the lexicographically smallest vertex.", "test_input": ["assert apps_run2(8, ['00000000', '00000110', '00012210', '01234200', '02444200', '01223200', '00001100', '00000000']) == [[(2, 3), (2, 5), (6, 7), (7, 7), (7, 6), (6, 2), (5, 2)]]", "assert apps_run2(5, ['00000', '01210', '02420', '01210', '00000']) == [[(2, 2), (2, 4), (4, 4), (4, 2)]]", "assert apps_run2(7, ['0000000', '0122100', '0134200', '0013200', '0002200', '0001100', '0000000']) == [[(2, 5), (2, 6), (5, 6), (5, 2), (4, 2)]]", "assert apps_run2(6, ['000000', '001110', '012210', '012210', '001110', '000000']) == [[(2, 3), (2, 4), (3, 5), (5, 5), (5, 2), (3, 2)]]", "assert apps_run2(10, ['0000000000', '0000111100', '0011222100', '0012222100', '0012222100', '0011222100', '0000111100', '0000000000', '0000000000', '0000000000']) == [[(3, 5), (3, 8), (5, 9), (8, 9), (8, 4), (5, 4)]]"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "APPS/0112-4", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nNow that Heidi has made sure her Zombie Contamination level checker works, it's time to strike! This time, the zombie lair is a strictly convex polygon on the lattice. Each vertex of the polygon occupies a point on the lattice. For each cell of the lattice, Heidi knows the level of Zombie Contamination \u2013 the number of corners of the cell that are inside or on the border of the lair.\n\nGiven this information, Heidi wants to know the exact shape of the lair to rain destruction on the zombies. Help her!\n\n[Image]\n\n\n-----Input-----\n\nThe input contains multiple test cases.\n\nThe first line of each test case contains one integer N, the size of the lattice grid (5 \u2264 N \u2264 500). The next N lines each contain N characters, describing the level of Zombie Contamination of each cell in the lattice. Every character of every line is a digit between 0 and 4. \n\nCells are given in the same order as they are shown in the picture above: rows go in the decreasing value of y coordinate, and in one row cells go in the order of increasing x coordinate. This means that the first row corresponds to cells with coordinates (1, N), ..., (N, N) and the last row corresponds to cells with coordinates (1, 1), ..., (N, 1).\n\nThe last line of the file contains a zero. This line should not be treated as a test case. The sum of the N values for all tests in one file will not exceed 5000.\n\n\n-----Output-----\n\nFor each test case, give the following output:\n\nThe first line of the output should contain one integer V, the number of vertices of the polygon that is the secret lair. The next V lines each should contain two integers, denoting the vertices of the polygon in the clockwise order, starting from the lexicographically smallest vertex.\n\n\n-----Examples-----\nInput\n8\n00000000\n00000110\n00012210\n01234200\n02444200\n01223200\n00001100\n00000000\n5\n00000\n01210\n02420\n01210\n00000\n7\n0000000\n0122100\n0134200\n0013200\n0002200\n0001100\n0000000\n0\n\nOutput\n4\n2 3\n2 4\n6 6\n5 2\n4\n2 2\n2 3\n3 3\n3 2\n3\n2 5\n4 5\n4 2\n\n\n\n-----Note-----\n\nIt is guaranteed that the solution always exists and is unique. It is guaranteed that in the correct solution the coordinates of the polygon vertices are between 2 and N - 2. A vertex (x_1, y_1) is lexicographically smaller than vertex (x_2, y_2) if x_1 < x_2 or $x_{1} = x_{2} \\wedge y_{1} < y_{2}$.", "raw_solution": "```python\nimport math\n\ndef lexComp(a, b):\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a, b, c):\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n    \ndef dist2(a, b):\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef apps_run1(n,a):\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if a[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                x, y = i - 1 + dx + ddx, j - 1 + dy + ddy\n                                if 0 <= x < n and 0 <= y < n and a[x][y] == 0:\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            points[0], points[i] = points[i], points[0]\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    return hull\n\n ```", "raw_test_input": ["assert apps_run1(7,[[0, 0, 0, 0, 0, 0, 0],[0, 0, 0, 0, 0, 0, 0],[0, 1, 2, 3, 2, 1, 0],[0, 2, 3, 4, 3, 2, 0],[0, 1, 2, 3, 2, 1, 0],[0, 0, 0, 0, 0, 0, 0],[0, 0, 0, 0, 0, 0, 0]])==[(2, 3), (2, 4), (5, 4), (5, 3)]", "assert apps_run1(6, [[0, 0, 0, 0, 0, 0],[0, 0, 1, 1, 1, 0],[0, 1, 2, 3, 2, 0],[0, 1, 2, 3, 2, 0],[0, 0, 1, 1, 1, 0],[0, 0, 0, 0, 0, 0]]) == [(2, 3), (3, 4), (4, 4), (4, 2), (3, 2)]", "assert apps_run1(8,[[0, 0, 0, 0, 0, 0, 0, 0],[0, 0, 0, 0, 0, 1, 1, 0],[0, 0, 0, 1, 2, 2, 1, 0],[0, 1, 2, 3, 4, 2, 0, 0],[0, 2, 4, 4, 4, 2, 0, 0],[0, 1, 2, 2, 3, 2, 0, 0],[0, 0, 0, 0, 1, 1, 0, 0],[0, 0, 0, 0, 0, 0, 0, 0]])==[(2, 3), (2, 4), (6, 6), (5, 2)]", "assert apps_run1(7,[ [0, 0, 0, 0, 0, 0, 0],[0, 1, 2, 2, 1, 0, 0],[0, 1, 3, 4, 2, 0, 0],[0, 0, 1, 3, 2, 0, 0],[0, 0, 0, 2, 2, 0, 0],[0, 0, 0, 1, 1, 0, 0],[0, 0, 0, 0, 0, 0, 0]])==[(2, 5), (4, 5), (4, 2)]", "assert apps_run1(5, [[0, 0, 0, 0, 0],[0, 1, 2, 1, 0],[0, 2, 4, 2, 0],[0, 1, 2, 1, 0],[0, 0, 0, 0, 0]])==[(2, 2), (2, 3), (3, 3), (3, 2)]"], "new_problem": "Heidi's Zombie Contamination level checker is now being used in a real-world scenario where the input data might be corrupted or incomplete. The input grid may contain invalid characters, or the grid size might not match the specified N. Additionally, the grid might contain cells with contamination levels outside the expected range of 0 to 4. Implement error handling to manage these scenarios. Specifically, handle the following errors: 1. InvalidCharacterError if the grid contains characters other than digits 0-4. 2. GridSizeMismatchError if the number of rows or columns does not match N. 3. ContaminationLevelError if any cell contains a contamination level outside the range 0-4. Ensure that the program continues processing subsequent test cases even if one test case fails.", "new_solution": "```python\nimport math\nfrom typing import List, Tuple\n\nclass InvalidCharacterError(Exception):\n    pass\n\nclass GridSizeMismatchError(Exception):\n    pass\n\nclass ContaminationLevelError(Exception):\n    pass\n\ndef lexComp(a: Tuple[int, int], b: Tuple[int, int]) -> int:\n    if a[0] != b[0]:\n        return -1 if a[0] < b[0] else 1\n    if a[1] != b[1]:\n        return -1 if a[1] < b[1] else 1\n    return 0\n\ndef turn(a: Tuple[int, int], b: Tuple[int, int], c: Tuple[int, int]) -> int:\n    return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n    \ndef dist2(a: Tuple[int, int], b: Tuple[int, int]) -> int:\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\ndef apps_run2(n: int, grid: List[str]) -> List[Tuple[int, int]]:\n    if len(grid) != n:\n        raise GridSizeMismatchError(\"The number of rows does not match N.\")\n    a = []\n    for line in grid:\n        if len(line) != n:\n            raise GridSizeMismatchError(\"The number of columns does not match N.\")\n        row = []\n        for char in line:\n            if not char.isdigit(): \n                raise InvalidCharacterError(\"Grid contains invalid characters.\")\n            level = int(char)\n            if level > 4:\n                raise ContaminationLevelError(\"Contamination level out of range.\")\n            row.append(level)\n        a.append(row)\n    points = []\n    for i in range(n):\n        for j in range(n):\n            if a[i][j] == 1:\n                curPoints = []\n                for dx in range(0, 2):\n                    for dy in range(0, 2):\n                        ok = True\n                        for ddx in range(0, 2):\n                            for ddy in range(0, 2):\n                                x, y = i - 1 + dx + ddx, j - 1 + dy + ddy\n                                if 0 <= x < n and 0 <= y < n and a[x][y] == 0:\n                                    ok = False\n                        if ok:\n                            curPoints.append((i + dx, j + dy))\n                points.append(curPoints[0])\n    points = list(set(points))\n    for i in range(1, len(points)):\n        if lexComp(points[0], points[i]) > 0:\n            points[0], points[i] = points[i], points[0]\n    points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n    hull = [(p[1], n - p[0]) for p in hull]\n    hull = hull[::-1]\n    start = 0\n    for i in range(1, len(hull)):\n        if lexComp(hull[i], hull[start]) < 0:\n            start = i\n    newHull = hull[start:]\n    newHull.extend(hull[:start])\n    hull = newHull\n    return hull\n\n# Example usage:\n# try:\n#     result = apps_run2(8, [\"00000000\", \"00000110\", \"00012210\", \"01234200\", \"02444200\", \"01223200\", \"00001100\", \"00000000\"])\n#     print(len(result))\n#     for p in result:\n#         print(p[0], p[1])\n# except (InvalidCharacterError, GridSizeMismatchError, ContaminationLevelError) as e:\n#     print(f\"Error: {e}\")\n```", "input_format": "The function solve takes two parameters: - n: An integer (5 \u2264 n \u2264 500) representing the size of the lattice grid - grid: A list of n strings, each containing n characters (0-4) representing contamination levels", "output_format": "For each test case, output the number of vertices of the polygon followed by the coordinates of each vertex in clockwise order, starting from the lexicographically smallest vertex.", "test_input": ["assert apps_run2(5, [\"00000\", \"01210\", \"02420\", \"01210\", \"00000\"]) == [(2, 2), (2, 3), (3, 3), (3, 2)]", "try:\n    apps_run2(5, [\"00000\", \"01210\", \"02420\", \"01210\", \"0000A\"])\nexcept InvalidCharacterError as e:\n    assert str(e) == \"Grid contains invalid characters.\"", "try:\n    apps_run2(5, [\"00000\", \"01210\", \"02420\", \"01210\"])\nexcept GridSizeMismatchError as e:\n    assert str(e) == \"The number of rows does not match N.\"", "try:\n    apps_run2(5, [\"00000\", \"01210\", \"02420\", \"01210\", \"000000\"])\nexcept GridSizeMismatchError as e:\n    assert str(e) == \"The number of columns does not match N.\"", "try:\n    apps_run2(5, [\"00000\", \"01210\", \"02420\", \"01210\", \"00005\"])\nexcept ContaminationLevelError as e:\n    assert str(e) == \"Contamination level out of range.\""], "requirement_type": "PROMPT_ERROR_HANDLING"}
{"task_id": "APPS/0114-1", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nYou play a computer game. In this game, you lead a party of $m$ heroes, and you have to clear a dungeon with $n$ monsters. Each monster is characterized by its power $a_i$. Each hero is characterized by his power $p_i$ and endurance $s_i$.\n\nThe heroes clear the dungeon day by day. In the beginning of each day, you choose a hero (exactly one) who is going to enter the dungeon this day.\n\nWhen the hero enters the dungeon, he is challenged by the first monster which was not defeated during the previous days (so, if the heroes have already defeated $k$ monsters, the hero fights with the monster $k + 1$). When the hero fights the monster, there are two possible outcomes:\n\n  if the monster's power is strictly greater than the hero's power, the hero retreats from the dungeon. The current day ends;  otherwise, the monster is defeated. \n\nAfter defeating a monster, the hero either continues fighting with the next monster or leaves the dungeon. He leaves the dungeon either if he has already defeated the number of monsters equal to his endurance during this day (so, the $i$-th hero cannot defeat more than $s_i$ monsters during each day), or if all monsters are defeated \u2014 otherwise, he fights with the next monster. When the hero leaves the dungeon, the current day ends.\n\nYour goal is to defeat the last monster. What is the minimum number of days that you need to achieve your goal? Each day you have to use exactly one hero; it is possible that some heroes don't fight the monsters at all. Each hero can be used arbitrary number of times.\n\n\n-----Input-----\n\nThe first line contains one integer $t$ ($1 \\le t \\le 10^5$) \u2014 the number of test cases. Then the test cases follow.\n\nThe first line of each test case contains one integer $n$ ($1 \\le n \\le 2 \\cdot 10^5$) \u2014 the number of monsters in the dungeon.\n\nThe second line contains $n$ integers $a_1$, $a_2$, ..., $a_n$ ($1 \\le a_i \\le 10^9$), where $a_i$ is the power of the $i$-th monster.\n\nThe third line contains one integer $m$ ($1 \\le m \\le 2 \\cdot 10^5$) \u2014 the number of heroes in your party.\n\nThen $m$ lines follow, each describing a hero. Each line contains two integers $p_i$ and $s_i$ ($1 \\le p_i \\le 10^9$, $1 \\le s_i \\le n$) \u2014 the power and the endurance of the $i$-th hero.\n\nIt is guaranteed that the sum of $n + m$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n\n-----Output-----\n\nFor each test case print one integer \u2014 the minimum number of days you have to spend to defeat all of the monsters (or $-1$ if it is impossible).\n\n\n-----Example-----\nInput\n2\n6\n2 3 11 14 1 8\n2\n3 2\n100 1\n5\n3 5 100 2 3\n2\n30 5\n90 1\n\nOutput\n5\n-1.", "raw_solution": "def apps_run1(test_cases):\n    import bisect\n    results = []\n    for t in test_cases:\n        n = t['n']\n        A = t['A']\n        m = t['m']\n        PS = t['PS']\n\n        PS.sort()\n        K = [PS[-1]]\n\n        for a, b in PS[::-1][1:]:\n            if b <= K[-1][1]:\n                continue\n            else:\n                K.append((a, b))\n\n        K.reverse()\n\n        ANS = 1\n        count = 0\n        countmax = n + 1\n        LEN = len(K)\n        for a in A:\n            x = bisect.bisect_left(K, (a, 0))\n            if x == LEN:\n                results.append(-1)\n                break\n            elif K[x][1] >= count + 1 and countmax >= count + 1:\n                count += 1\n                countmax = min(countmax, K[x][1])\n            else:\n                ANS += 1\n                count = 1\n                countmax = K[x][1]\n        else:\n            results.append(ANS)\n    return results\n", "raw_test_input": ["assert apps_run1([{'n': 6, 'A': [2, 3, 11, 14, 1, 8], 'm': 2, 'PS': [(3, 2), (100, 1)]}]) == [5]", "assert apps_run1([{'n': 5, 'A': [3, 5, 100, 2, 3], 'm': 2, 'PS': [(30, 5), (90, 1)]}]) == [-1]", "assert apps_run1([{'n': 4, 'A': [1, 2, 3, 4], 'm': 2, 'PS': [(5, 4), (6, 3)]}]) == [1]", "assert apps_run1([{'n': 3, 'A': [10, 20, 30], 'm': 2, 'PS': [(5, 1), (9, 2)]}]) == [-1]", "assert apps_run1([{'n': 7, 'A': [2, 3, 2, 4, 3, 5, 2], 'm': 3, 'PS': [(3, 2), (4, 3), (5, 1)]}]) == [4]", "assert apps_run1([{'n': 5, 'A': [1, 1, 1, 1, 1], 'm': 2, 'PS': [(1, 2), (1, 3)]}]) == [2]", "assert apps_run1([{'n': 6, 'A': [1, 2, 3, 4, 5, 6], 'm': 3, 'PS': [(6, 1), (5, 2), (4, 3)]}]) == [3]"], "new_problem": "You are managing a team of heroes tasked with clearing multiple dungeons, each containing a subset of monsters. Each dungeon is characterized by the number of monsters it contains. Your goal is to determine the minimum number of days required to clear each dungeon using the heroes available. Each day, exactly one hero can be chosen to fight, and the hero can defeat monsters up to their endurance limit. If a hero's power is less than a monster's power, the hero retreats, and the day ends. Determine the minimum number of days required to clear each dungeon, or if it is impossible.", "new_solution": "import sys\nimport bisect\n\ndef apps_run2(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        n, A, m, PS, k, dungeons = test_case\n        PS.sort()\n        K = [PS[-1]]\n\n        for a, b in PS[::-1][1:]:\n            if b <= K[-1][1]:\n                continue\n            else:\n                K.append((a, b))\n\n        K.reverse()\n\n        def calculate_days(monsters):\n            ANS = 1\n            count = 0\n            countmax = len(monsters) + 1\n            LEN = len(K)\n            for a in monsters:\n                x = bisect.bisect_left(K, (a, 0))\n                if x == LEN:\n                    return -1\n                elif K[x][1] >= count + 1 and countmax >= count + 1:\n                    count += 1\n                    countmax = min(countmax, K[x][1])\n                else:\n                    ANS += 1\n                    count = 1\n                    countmax = K[x][1]\n            return ANS\n\n        for d in dungeons:\n            monsters = A[:d]\n            results.append(calculate_days(monsters))\n    return results\n\n# Example usage:\n# t = 1\n# test_cases = [\n#     (6, [2, 3, 11, 14, 1, 8], 2, [(3, 2), (100, 1)], 2, [3, 6])\n# ]\n# print(apps_run2(t, test_cases))\n", "input_format": "minimum_days_to_clear_dungeon parameters: - t: Integer (1 \u2264 t \u2264 10^5) representing number of test cases - test_cases: List of tuples, each containing: - n: Integer (1 \u2264 n \u2264 2\u22c510^5) number of monsters - A: List of n integers (1 \u2264 a_i \u2264 10^9) representing monster powers - m: Integer (1 \u2264 m \u2264 2\u22c510^5) number of heroes - PS: List of m tuples (p_i, s_i) where: - p_i: Integer (1 \u2264 p_i \u2264 10^9) hero power - s_i: Integer (1 \u2264 s_i \u2264 n) hero endurance - k: Integer (1 \u2264 k \u2264 10^5) number of dungeons - dungeons: List of k integers (1 \u2264 d_j \u2264 n) representing monsters per dungeon", "output_format": "For each test case, print k integers \u2014 the minimum number of days required to clear each dungeon, or -1 if it is impossible.", "test_input": ["assert apps_run2(1, [(6, [2, 3, 11, 14, 1, 8], 2, [(3, 2), (100, 1)], 2, [3, 6])]) == [2, 5]", "assert apps_run2(1, [(5, [3, 5, 100, 2, 3], 2, [(30, 5), (90, 1)], 1, [5])]) == [-1]", "assert apps_run2(1, [(4, [1, 2, 3, 4], 1, [(5, 4)], 1, [4])]) == [1]", "assert apps_run2(1, [(3, [10, 20, 30], 2, [(15, 2), (25, 1)], 2, [2, 3])]) == [2, -1]", "assert apps_run2(1, [(7, [1, 1, 1, 1, 1, 1, 1], 1, [(1, 7)], 1, [7])]) == [1]"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "APPS/0114-2", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nYou play a computer game. In this game, you lead a party of $m$ heroes, and you have to clear a dungeon with $n$ monsters. Each monster is characterized by its power $a_i$. Each hero is characterized by his power $p_i$ and endurance $s_i$.\n\nThe heroes clear the dungeon day by day. In the beginning of each day, you choose a hero (exactly one) who is going to enter the dungeon this day.\n\nWhen the hero enters the dungeon, he is challenged by the first monster which was not defeated during the previous days (so, if the heroes have already defeated $k$ monsters, the hero fights with the monster $k + 1$). When the hero fights the monster, there are two possible outcomes:\n\n  if the monster's power is strictly greater than the hero's power, the hero retreats from the dungeon. The current day ends;  otherwise, the monster is defeated. \n\nAfter defeating a monster, the hero either continues fighting with the next monster or leaves the dungeon. He leaves the dungeon either if he has already defeated the number of monsters equal to his endurance during this day (so, the $i$-th hero cannot defeat more than $s_i$ monsters during each day), or if all monsters are defeated \u2014 otherwise, he fights with the next monster. When the hero leaves the dungeon, the current day ends.\n\nYour goal is to defeat the last monster. What is the minimum number of days that you need to achieve your goal? Each day you have to use exactly one hero; it is possible that some heroes don't fight the monsters at all. Each hero can be used arbitrary number of times.\n\n\n-----Input-----\n\nThe first line contains one integer $t$ ($1 \\le t \\le 10^5$) \u2014 the number of test cases. Then the test cases follow.\n\nThe first line of each test case contains one integer $n$ ($1 \\le n \\le 2 \\cdot 10^5$) \u2014 the number of monsters in the dungeon.\n\nThe second line contains $n$ integers $a_1$, $a_2$, ..., $a_n$ ($1 \\le a_i \\le 10^9$), where $a_i$ is the power of the $i$-th monster.\n\nThe third line contains one integer $m$ ($1 \\le m \\le 2 \\cdot 10^5$) \u2014 the number of heroes in your party.\n\nThen $m$ lines follow, each describing a hero. Each line contains two integers $p_i$ and $s_i$ ($1 \\le p_i \\le 10^9$, $1 \\le s_i \\le n$) \u2014 the power and the endurance of the $i$-th hero.\n\nIt is guaranteed that the sum of $n + m$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n\n-----Output-----\n\nFor each test case print one integer \u2014 the minimum number of days you have to spend to defeat all of the monsters (or $-1$ if it is impossible).\n\n\n-----Example-----\nInput\n2\n6\n2 3 11 14 1 8\n2\n3 2\n100 1\n5\n3 5 100 2 3\n2\n30 5\n90 1\n\nOutput\n5\n-1.", "raw_solution": "def apps_run1(test_cases):\n    import bisect\n    results = []\n    for t in test_cases:\n        n = t['n']\n        A = t['A']\n        m = t['m']\n        PS = t['PS']\n\n        PS.sort()\n        K = [PS[-1]]\n\n        for a, b in PS[::-1][1:]:\n            if b <= K[-1][1]:\n                continue\n            else:\n                K.append((a, b))\n\n        K.reverse()\n\n        ANS = 1\n        count = 0\n        countmax = n + 1\n        LEN = len(K)\n        for a in A:\n            x = bisect.bisect_left(K, (a, 0))\n            if x == LEN:\n                results.append(-1)\n                break\n            elif K[x][1] >= count + 1 and countmax >= count + 1:\n                count += 1\n                countmax = min(countmax, K[x][1])\n            else:\n                ANS += 1\n                count = 1\n                countmax = K[x][1]\n        else:\n            results.append(ANS)\n    return results\n", "raw_test_input": ["assert apps_run1([{'n': 6, 'A': [2, 3, 11, 14, 1, 8], 'm': 2, 'PS': [(3, 2), (100, 1)]}]) == [5]", "assert apps_run1([{'n': 5, 'A': [3, 5, 100, 2, 3], 'm': 2, 'PS': [(30, 5), (90, 1)]}]) == [-1]", "assert apps_run1([{'n': 4, 'A': [1, 2, 3, 4], 'm': 2, 'PS': [(5, 4), (6, 3)]}]) == [1]", "assert apps_run1([{'n': 3, 'A': [10, 20, 30], 'm': 2, 'PS': [(5, 1), (9, 2)]}]) == [-1]", "assert apps_run1([{'n': 7, 'A': [2, 3, 2, 4, 3, 5, 2], 'm': 3, 'PS': [(3, 2), (4, 3), (5, 1)]}]) == [4]", "assert apps_run1([{'n': 5, 'A': [1, 1, 1, 1, 1], 'm': 2, 'PS': [(1, 2), (1, 3)]}]) == [2]", "assert apps_run1([{'n': 6, 'A': [1, 2, 3, 4, 5, 6], 'm': 3, 'PS': [(6, 1), (5, 2), (4, 3)]}]) == [3]"], "new_problem": "You play a computer game. In this game, you lead a party of m heroes, and you have to clear a dungeon with n monsters. Each monster is characterized by its power a_i. Each hero is characterized by his power p_i and endurance s_i. The heroes clear the dungeon day by day. In the beginning of each day, you choose a hero (exactly one) who is going to enter the dungeon this day. When the hero enters the dungeon, he is challenged by the first monster which was not defeated during the previous days (so, if the heroes have already defeated k monsters, the hero fights with the monster k + 1). When the hero fights the monster, there are two possible outcomes: if the monster's power is strictly greater than the hero's power, the hero retreats from the dungeon. The current day ends; otherwise, the monster is defeated. After defeating a monster, the hero either continues fighting with the next monster or leaves the dungeon. He leaves the dungeon either if he has already defeated the number of monsters equal to his endurance during this day (so, the i-th hero cannot defeat more than s_i monsters during each day), or if all monsters are defeated \u2014 otherwise, he fights with the next monster. When the hero leaves the dungeon, the current day ends. Your goal is to defeat the last monster. What is the minimum number of days that you need to achieve your goal? Each day you have to use exactly one hero; it is possible that some heroes don't fight the monsters at all. Each hero can be used arbitrary number of times. Additionally, you can now specify an optional parameter 'strategy' which can be 'aggressive' or 'conservative'. If 'aggressive', heroes will always try to defeat as many monsters as possible. If 'conservative', heroes will retreat after defeating half of their endurance limit. The default strategy is 'aggressive'.", "new_solution": "from typing import List, Tuple, Optional\nimport bisect\n\ndef apps_run2(t: int, test_cases: List[Tuple[int, List[int], int, List[Tuple[int, int]]]], strategy: Optional[str] = 'aggressive') -> List[int]:\n    results = []\n    for n, A, m, PS in test_cases:\n        PS.sort()\n        K = [PS[-1]]\n\n        for a, b in PS[::-1][1:]:\n            if b <= K[-1][1]:\n                continue\n            else:\n                K.append((a, b))\n\n        K.reverse()\n\n        ANS = 1\n        count = 0\n        countmax = n + 1\n        LEN = len(K)\n        for a in A:\n            x = bisect.bisect_left(K, (a, 0))\n            if x == LEN:\n                results.append(-1)\n                break\n            elif K[x][1] >= count + 1 and countmax >= count + 1:\n                count += 1\n                if strategy == 'conservative' and count >= K[x][1] // 2:\n                    ANS += 1\n                    count = 0\n                    countmax = n + 1\n                else:\n                    countmax = min(countmax, K[x][1])\n            else:\n                ANS += 1\n                count = 1\n                countmax = K[x][1]\n        else:\n            results.append(ANS)\n    return results", "input_format": "minimum_days_to_defeat_monsters parameters: - t: Integer (1 \u2264 t \u2264 10^5) number of test cases - test_cases: List of tuples, each containing: - n: Integer (1 \u2264 n \u2264 2\u22c510^5) number of monsters - A: List of n integers (1 \u2264 a_i \u2264 10^9) monster powers - m: Integer (1 \u2264 m \u2264 2\u22c510^5) number of heroes - PS: List of m tuples (p_i, s_i) where: - p_i: Integer (1 \u2264 p_i \u2264 10^9) hero power - s_i: Integer (1 \u2264 s_i \u2264 n) hero endurance - strategy: Optional string ('aggressive' or 'conservative', default='aggressive') battle strategy", "output_format": "For each test case print one integer \u2014 the minimum number of days you have to spend to defeat all of the monsters (or -1 if it is impossible).", "test_input": ["assert apps_run2(2, [(6, [2, 3, 11, 14, 1, 8], 2, [(3, 2), (100, 1)]), (5, [3, 5, 100, 2, 3], 2, [(30, 5), (90, 1)])]) == [5, -1]", "assert apps_run2(1, [(3, [1, 2, 3], 1, [(3, 3)])]) == [1]", "assert apps_run2(1, [(4, [4, 4, 4, 4], 2, [(5, 2), (6, 1)])]) == [2]", "assert apps_run2(1, [(5, [10, 20, 30, 40, 50], 3, [(15, 2), (25, 3), (35, 1)])], strategy='conservative') == [-1]", "assert apps_run2(1, [(5, [10, 20, 30, 40, 50], 3, [(15, 2), (25, 3), (35, 1)])], strategy='aggressive') == [-1]"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "APPS/0114-3", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nYou play a computer game. In this game, you lead a party of $m$ heroes, and you have to clear a dungeon with $n$ monsters. Each monster is characterized by its power $a_i$. Each hero is characterized by his power $p_i$ and endurance $s_i$.\n\nThe heroes clear the dungeon day by day. In the beginning of each day, you choose a hero (exactly one) who is going to enter the dungeon this day.\n\nWhen the hero enters the dungeon, he is challenged by the first monster which was not defeated during the previous days (so, if the heroes have already defeated $k$ monsters, the hero fights with the monster $k + 1$). When the hero fights the monster, there are two possible outcomes:\n\n  if the monster's power is strictly greater than the hero's power, the hero retreats from the dungeon. The current day ends;  otherwise, the monster is defeated. \n\nAfter defeating a monster, the hero either continues fighting with the next monster or leaves the dungeon. He leaves the dungeon either if he has already defeated the number of monsters equal to his endurance during this day (so, the $i$-th hero cannot defeat more than $s_i$ monsters during each day), or if all monsters are defeated \u2014 otherwise, he fights with the next monster. When the hero leaves the dungeon, the current day ends.\n\nYour goal is to defeat the last monster. What is the minimum number of days that you need to achieve your goal? Each day you have to use exactly one hero; it is possible that some heroes don't fight the monsters at all. Each hero can be used arbitrary number of times.\n\n\n-----Input-----\n\nThe first line contains one integer $t$ ($1 \\le t \\le 10^5$) \u2014 the number of test cases. Then the test cases follow.\n\nThe first line of each test case contains one integer $n$ ($1 \\le n \\le 2 \\cdot 10^5$) \u2014 the number of monsters in the dungeon.\n\nThe second line contains $n$ integers $a_1$, $a_2$, ..., $a_n$ ($1 \\le a_i \\le 10^9$), where $a_i$ is the power of the $i$-th monster.\n\nThe third line contains one integer $m$ ($1 \\le m \\le 2 \\cdot 10^5$) \u2014 the number of heroes in your party.\n\nThen $m$ lines follow, each describing a hero. Each line contains two integers $p_i$ and $s_i$ ($1 \\le p_i \\le 10^9$, $1 \\le s_i \\le n$) \u2014 the power and the endurance of the $i$-th hero.\n\nIt is guaranteed that the sum of $n + m$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n\n-----Output-----\n\nFor each test case print one integer \u2014 the minimum number of days you have to spend to defeat all of the monsters (or $-1$ if it is impossible).\n\n\n-----Example-----\nInput\n2\n6\n2 3 11 14 1 8\n2\n3 2\n100 1\n5\n3 5 100 2 3\n2\n30 5\n90 1\n\nOutput\n5\n-1.", "raw_solution": "def apps_run1(test_cases):\n    import bisect\n    results = []\n    for test in test_cases:\n        n = test['n']\n        A = test['A']\n        m = test['m']\n        PS = test['PS']\n\n        PS.sort()\n        K = [PS[-1]]\n\n        for a, b in PS[::-1][1:]:\n            if b <= K[-1][1]:\n                continue\n            else:\n                K.append((a, b))\n\n        K.reverse()\n\n        ANS = 1\n        count = 0\n        countmax = n + 1\n        LEN = len(K)\n        for a in A:\n            x = bisect.bisect_left(K, (a, 0))\n            if x == LEN:\n                results.append(-1)\n                break\n            elif K[x][1] >= count + 1 and countmax >= count + 1:\n                count += 1\n                countmax = min(countmax, K[x][1])\n            else:\n                ANS += 1\n                count = 1\n                countmax = K[x][1]\n        else:\n            results.append(ANS)\n    return results\n", "raw_test_input": ["assert apps_run1([{'n': 6, 'A': [2, 3, 11, 14, 1, 8], 'm': 2, 'PS': [(3, 2), (100, 1)]}]) == [5]", "assert apps_run1([{'n': 5, 'A': [3, 5, 100, 2, 3], 'm': 2, 'PS': [(30, 5), (90, 1)]}]) == [-1]", "assert apps_run1([{'n': 4, 'A': [1, 2, 3, 4], 'm': 2, 'PS': [(5, 4), (6, 3)]}]) == [1]", "assert apps_run1([{'n': 3, 'A': [10, 20, 30], 'm': 2, 'PS': [(5, 1), (9, 2)]}]) == [-1]", "assert apps_run1([{'n': 7, 'A': [2, 3, 2, 4, 3, 5, 2], 'm': 3, 'PS': [(3, 2), (4, 3), (5, 1)]}]) == [4]", "assert apps_run1([{'n': 5, 'A': [1, 1, 1, 1, 1], 'm': 2, 'PS': [(1, 2), (1, 3)]}]) == [2]", "assert apps_run1([{'n': 6, 'A': [1, 2, 3, 4, 5, 6], 'm': 3, 'PS': [(6, 1), (5, 2), (4, 3)]}]) == [3]"], "new_problem": "You are tasked with managing a team of heroes to clear a dungeon filled with monsters. Each hero has a power and endurance, and each monster has a power level. The heroes can be used multiple times, but each day only one hero can enter the dungeon. The goal is to defeat all monsters in the minimum number of days. However, the heroes and monsters are now stored in a dictionary format, where the keys are unique identifiers for each hero and monster, and the values are tuples containing their respective attributes. Additionally, you must ensure that the solution is efficient enough to handle up to 10^6 total heroes and monsters across all test cases. Implement the solution using dictionaries and include type hints.", "new_solution": "from typing import List, Dict, Tuple\nimport bisect\n\ndef apps_run2(t: int, test_cases: List[Tuple[int, Dict[int, int], int, Dict[int, Tuple[int, int]]]]) -> List[int]:\n    results = []\n    for n, monsters, m, heroes in test_cases:\n        A = list(monsters.values())\n        PS = list(heroes.values())\n        PS.sort()\n        K = [PS[-1]]\n\n        for a, b in PS[::-1][1:]:\n            if b <= K[-1][1]:\n                continue\n            else:\n                K.append((a, b))\n\n        K.reverse()\n\n        ANS = 1\n        count = 0\n        countmax = n + 1\n        LEN = len(K)\n        for a in A:\n            x = bisect.bisect_left(K, (a, 0))\n            if x == LEN:\n                results.append(-1)\n                break\n            elif K[x][1] >= count + 1 and countmax >= count + 1:\n                count += 1\n                countmax = min(countmax, K[x][1])\n            else:\n                ANS += 1\n                count = 1\n                countmax = K[x][1]\n        else:\n            results.append(ANS)\n    return results", "input_format": "min_days_to_defeat_monsters parameters: - t: Integer (1 \u2264 t \u2264 10^5) number of test cases - test_cases: List of tuples (n, monsters, m, heroes) where: - n: Integer (1 \u2264 n \u2264 2\u22c510^5) number of monsters - monsters: Dict[int, int] mapping monster ID to power (1 \u2264 power \u2264 10^9) - m: Integer (1 \u2264 m \u2264 2\u22c510^5) number of heroes - heroes: Dict[int, Tuple[int, int]] mapping hero ID to (power, endurance) - power: Integer (1 \u2264 power \u2264 10^9) - endurance: Integer (1 \u2264 endurance \u2264 n)", "output_format": "For each test case print one integer \u2014 the minimum number of days you have to spend to defeat all of the monsters (or -1 if it is impossible).", "test_input": ["assert apps_run2(2, [(6, {1: 2, 2: 3, 3: 11, 4: 14, 5: 1, 6: 8}, 2, {1: (3, 2), 2: (100, 1)}), (5, {1: 3, 2: 5, 3: 100, 4: 2, 5: 3}, 2, {1: (30, 5), 2: (90, 1)})]) == [5, -1]", "assert apps_run2(1, [(3, {1: 5, 2: 10, 3: 15}, 2, {1: (10, 2), 2: (20, 1)})]) == [2]", "assert apps_run2(1, [(4, {1: 1, 2: 2, 3: 3, 4: 4}, 1, {1: (5, 4)})]) == [1]", "assert apps_run2(1, [(2, {1: 100, 2: 200}, 2, {1: (150, 1), 2: (250, 1)})]) == [2]", "assert apps_run2(1, [(5, {1: 10, 2: 20, 3: 30, 4: 40, 5: 50}, 3, {1: (25, 2), 2: (35, 3), 3: (45, 1)})]) == [-1]"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "APPS/0114-4", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nYou play a computer game. In this game, you lead a party of $m$ heroes, and you have to clear a dungeon with $n$ monsters. Each monster is characterized by its power $a_i$. Each hero is characterized by his power $p_i$ and endurance $s_i$.\n\nThe heroes clear the dungeon day by day. In the beginning of each day, you choose a hero (exactly one) who is going to enter the dungeon this day.\n\nWhen the hero enters the dungeon, he is challenged by the first monster which was not defeated during the previous days (so, if the heroes have already defeated $k$ monsters, the hero fights with the monster $k + 1$). When the hero fights the monster, there are two possible outcomes:\n\n  if the monster's power is strictly greater than the hero's power, the hero retreats from the dungeon. The current day ends;  otherwise, the monster is defeated. \n\nAfter defeating a monster, the hero either continues fighting with the next monster or leaves the dungeon. He leaves the dungeon either if he has already defeated the number of monsters equal to his endurance during this day (so, the $i$-th hero cannot defeat more than $s_i$ monsters during each day), or if all monsters are defeated \u2014 otherwise, he fights with the next monster. When the hero leaves the dungeon, the current day ends.\n\nYour goal is to defeat the last monster. What is the minimum number of days that you need to achieve your goal? Each day you have to use exactly one hero; it is possible that some heroes don't fight the monsters at all. Each hero can be used arbitrary number of times.\n\n\n-----Input-----\n\nThe first line contains one integer $t$ ($1 \\le t \\le 10^5$) \u2014 the number of test cases. Then the test cases follow.\n\nThe first line of each test case contains one integer $n$ ($1 \\le n \\le 2 \\cdot 10^5$) \u2014 the number of monsters in the dungeon.\n\nThe second line contains $n$ integers $a_1$, $a_2$, ..., $a_n$ ($1 \\le a_i \\le 10^9$), where $a_i$ is the power of the $i$-th monster.\n\nThe third line contains one integer $m$ ($1 \\le m \\le 2 \\cdot 10^5$) \u2014 the number of heroes in your party.\n\nThen $m$ lines follow, each describing a hero. Each line contains two integers $p_i$ and $s_i$ ($1 \\le p_i \\le 10^9$, $1 \\le s_i \\le n$) \u2014 the power and the endurance of the $i$-th hero.\n\nIt is guaranteed that the sum of $n + m$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n\n-----Output-----\n\nFor each test case print one integer \u2014 the minimum number of days you have to spend to defeat all of the monsters (or $-1$ if it is impossible).\n\n\n-----Example-----\nInput\n2\n6\n2 3 11 14 1 8\n2\n3 2\n100 1\n5\n3 5 100 2 3\n2\n30 5\n90 1\n\nOutput\n5\n-1.", "raw_solution": "def apps_run1(test_cases):\n    import bisect\n    results = []\n    for test in test_cases:\n        n = test['n']\n        A = test['A']\n        m = test['m']\n        PS = test['PS']\n\n        PS.sort()\n        K = [PS[-1]]\n\n        for a, b in PS[::-1][1:]:\n            if b <= K[-1][1]:\n                continue\n            else:\n                K.append((a, b))\n\n        K.reverse()\n\n        ANS = 1\n        count = 0\n        countmax = n + 1\n        LEN = len(K)\n        for a in A:\n            x = bisect.bisect_left(K, (a, 0))\n            if x == LEN:\n                results.append(-1)\n                break\n            elif K[x][1] >= count + 1 and countmax >= count + 1:\n                count += 1\n                countmax = min(countmax, K[x][1])\n            else:\n                ANS += 1\n                count = 1\n                countmax = K[x][1]\n        else:\n            results.append(ANS)\n    return results\n", "raw_test_input": ["assert apps_run1([{'n': 6, 'A': [2, 3, 11, 14, 1, 8], 'm': 2, 'PS': [(3, 2), (100, 1)]}]) == [5]", "assert apps_run1([{'n': 5, 'A': [3, 5, 100, 2, 3], 'm': 2, 'PS': [(30, 5), (90, 1)]}]) == [-1]", "assert apps_run1([{'n': 4, 'A': [1, 2, 3, 4], 'm': 2, 'PS': [(5, 4), (6, 3)]}]) == [1]", "assert apps_run1([{'n': 3, 'A': [10, 20, 30], 'm': 2, 'PS': [(5, 1), (9, 2)]}]) == [-1]", "assert apps_run1([{'n': 7, 'A': [2, 3, 2, 4, 3, 5, 2], 'm': 3, 'PS': [(3, 2), (4, 3), (5, 1)]}]) == [4]", "assert apps_run1([{'n': 5, 'A': [1, 1, 1, 1, 1], 'm': 2, 'PS': [(1, 2), (1, 3)]}]) == [2]", "assert apps_run1([{'n': 6, 'A': [1, 2, 3, 4, 5, 6], 'm': 3, 'PS': [(6, 1), (5, 2), (4, 3)]}]) == [3]"], "new_problem": "You are tasked with developing a function to determine the minimum number of days required to defeat all monsters in a dungeon using a team of heroes. However, you must now handle potential errors in the input data. Specifically, you need to handle the following errors: 1) Invalid input format (e.g., non-integer values, missing values). 2) Logical errors such as negative values for powers or endurance, which are not allowed. 3) Ensure that the number of monsters and heroes does not exceed the specified limits. 4) Handle cases where no hero can defeat any monster. Implement error handling using custom exceptions and ensure meaningful error messages are provided. Propagate errors appropriately and maintain type hints.", "new_solution": "```python\ndef apps_run2(t: int, test_cases: list) -> list:\n    import bisect\n    from typing import List, Tuple\n\n    class DungeonError(Exception):\n        pass\n\n    class InvalidInputError(DungeonError):\n        pass\n\n    class ImpossibleToDefeatError(DungeonError):\n        pass\n\n    def validate_input(n: int, m: int, monsters: List[int], heroes: List[Tuple[int, int]]) -> None:\n        if n <= 0 or m <= 0:\n            raise InvalidInputError(\"Number of monsters and heroes must be positive.\")\n        if len(monsters) != n or len(heroes) != m:\n            raise InvalidInputError(\"Mismatch in number of monsters or heroes.\")\n        if any(a <= 0 for a in monsters):\n            raise InvalidInputError(\"Monster powers must be positive.\")\n        if any(p <= 0 or s <= 0 for p, s in heroes):\n            raise InvalidInputError(\"Hero powers and endurance must be positive.\")\n\n    results = []\n    for test_case in test_cases:\n        try:\n            n, monsters, m, heroes = test_case\n            validate_input(n, m, monsters, heroes)\n\n            heroes.sort()\n            K = [heroes[-1]]\n\n            for a, b in heroes[::-1][1:]:\n                if b <= K[-1][1]:\n                    continue\n                else:\n                    K.append((a, b))\n\n            K.reverse()\n\n            ANS = 1\n            count = 0\n            countmax = n + 1\n            LEN = len(K)\n            for a in monsters:\n                x = bisect.bisect_left(K, (a, 0))\n                if x == LEN:\n                    raise ImpossibleToDefeatError(\"No hero can defeat the monster.\")\n                elif K[x][1] >= count + 1 and countmax >= count + 1:\n                    count += 1\n                    countmax = min(countmax, K[x][1])\n                else:\n                    ANS += 1\n                    count = 1\n                    countmax = K[x][1]\n            results.append(ANS)\n        except DungeonError as e:\n            results.append(-1)\n    return results\n```", "input_format": "The input consists of multiple test cases. Each test case starts with an integer n, the number of monsters, followed by n integers representing the power of each monster. Then, an integer m follows, representing the number of heroes, followed by m pairs of integers representing each hero's power and endurance.", "output_format": "For each test case, output the minimum number of days required to defeat all monsters, or -1 if it is impossible.", "test_input": ["assert apps_run2(1, [(6, [2, 3, 11, 14, 1, 8], 2, [(3, 2), (100, 1)])]) == [5]", "assert apps_run2(1, [(5, [3, 5, 100, 2, 3], 2, [(30, 5), (90, 1)])]) == [-1]", "assert apps_run2(1, [(3, [1, 2, 3], 1, [(0, 1)])]) == [-1]", "assert apps_run2(1, [(3, [1, 2, 3], 1, [(3, 0)])]) == [-1]", "assert apps_run2(1, [(3, [1, 2, 3], 1, [(3, 1)])]) == [3]"], "requirement_type": "PROMPT_ERROR_HANDLING"}
{"task_id": "APPS/0113-1", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nBob watches TV every day. He always sets the volume of his TV to $b$. However, today he is angry to find out someone has changed the volume to $a$. Of course, Bob has a remote control that can change the volume.\n\nThere are six buttons ($-5, -2, -1, +1, +2, +5$) on the control, which in one press can either increase or decrease the current volume by $1$, $2$, or $5$. The volume can be arbitrarily large, but can never be negative. In other words, Bob cannot press the button if it causes the volume to be lower than $0$.\n\nAs Bob is so angry, he wants to change the volume to $b$ using as few button presses as possible. However, he forgets how to do such simple calculations, so he asks you for help. Write a program that given $a$ and $b$, finds the minimum number of presses to change the TV volume from $a$ to $b$.\n\n\n-----Input-----\n\nEach test contains multiple test cases. The first line contains the number of test cases $T$ ($1 \\le T \\le 1\\,000$). Then the descriptions of the test cases follow.\n\nEach test case consists of one line containing two integers $a$ and $b$ ($0 \\le a, b \\le 10^{9}$)\u00a0\u2014 the current volume and Bob's desired volume, respectively.\n\n\n-----Output-----\n\nFor each test case, output a single integer\u00a0\u2014 the minimum number of presses to change the TV volume from $a$ to $b$. If Bob does not need to change the volume (i.e. $a=b$), then print $0$.\n\n\n-----Example-----\nInput\n3\n4 0\n5 14\n3 9\n\nOutput\n2\n3\n2\n\n\n\n-----Note-----\n\nIn the first example, Bob can press the $-2$ button twice to reach $0$. Note that Bob can not press $-5$ when the volume is $4$ since it will make the volume negative. \n\nIn the second example, one of the optimal ways for Bob is to press the $+5$ twice, then press $-1$ once.\n\nIn the last example, Bob can press the $+5$ once, then press $+1$.", "raw_solution": "def apps_run1(test_cases):\n    results = []\n    for a, b in test_cases:\n        if a == b:\n            results.append(0)\n        else:\n            d = abs(a - b)\n            k1 = d // 5\n            d -= k1 * 5\n            k2 = d // 2\n            d -= k2 * 2\n            results.append(d + k1 + k2)\n    return results\n\ntest_cases = [(4, 0), (5, 14), (3, 9)]\nprint(apps_run1(test_cases))", "raw_test_input": ["assert apps_run1([(4, 0), (5, 14), (3, 9)]) == [2, 3, 2]", "assert apps_run1([(10, 3), (1, 1)]) == [2, 0]", "assert apps_run1([(0, 5), (7, 2), (15, 10), (20, 25)]) == [1, 1, 1, 1]", "assert apps_run1([(8, 8), (12, 7), (6, 11), (0, 0), (9, 4)]) == [0, 1, 1, 0, 1]", "assert apps_run1([(2, 10), (10, 0), (5, 5)]) == [3, 2, 0]", "assert apps_run1([(1000000000, 999999995)]) == [1]"], "new_problem": "In a large office building, there is a network of TVs installed in different rooms. Each TV has a remote control with buttons that can adjust the volume by -5, -2, -1, +1, +2, +5. The building manager wants to ensure that all TVs are set to a specific volume level for an upcoming event. Given the current and desired volume levels for each TV, determine the minimum number of button presses required to adjust each TV to the desired volume. Write a program that takes a list of current and desired volume levels for multiple TVs and outputs the minimum number of button presses for each TV.", "new_solution": "def min_button_presses(a, b):\n    if a == b:\n        return 0\n    else:\n        d = abs(a - b)\n        k1 = d // 5\n        d -= k1 * 5\n        k2 = d // 2\n        d -= k2 * 2\n        return d + k1 + k2\n\ndef apps_run2(tv_volumes):\n    results = []\n    for a, b in tv_volumes:\n        results.append(min_button_presses(a, b))\n    return results", "input_format": "A list of tuples where each tuple contains two integers (a, b) representing the current and desired volume for each TV in a network of TVs.", "output_format": "A list of integers where each integer represents the minimum number of button presses required to adjust each TV's volume to the desired level.", "test_input": ["assert apps_run2([(4, 0), (5, 14), (3, 9)]) == [2, 3, 2]", "assert apps_run2([(10, 10), (0, 5), (7, 2)]) == [0, 1, 1]", "assert apps_run2([(100, 105), (50, 45), (20, 25)]) == [1, 1, 1]", "assert apps_run2([(0, 0), (1, 6), (9, 3)]) == [0, 1, 2]", "assert apps_run2([(15, 0), (8, 8), (12, 17)]) == [3, 0, 1]"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "APPS/0113-2", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nBob watches TV every day. He always sets the volume of his TV to $b$. However, today he is angry to find out someone has changed the volume to $a$. Of course, Bob has a remote control that can change the volume.\n\nThere are six buttons ($-5, -2, -1, +1, +2, +5$) on the control, which in one press can either increase or decrease the current volume by $1$, $2$, or $5$. The volume can be arbitrarily large, but can never be negative. In other words, Bob cannot press the button if it causes the volume to be lower than $0$.\n\nAs Bob is so angry, he wants to change the volume to $b$ using as few button presses as possible. However, he forgets how to do such simple calculations, so he asks you for help. Write a program that given $a$ and $b$, finds the minimum number of presses to change the TV volume from $a$ to $b$.\n\n\n-----Input-----\n\nEach test contains multiple test cases. The first line contains the number of test cases $T$ ($1 \\le T \\le 1\\,000$). Then the descriptions of the test cases follow.\n\nEach test case consists of one line containing two integers $a$ and $b$ ($0 \\le a, b \\le 10^{9}$)\u00a0\u2014 the current volume and Bob's desired volume, respectively.\n\n\n-----Output-----\n\nFor each test case, output a single integer\u00a0\u2014 the minimum number of presses to change the TV volume from $a$ to $b$. If Bob does not need to change the volume (i.e. $a=b$), then print $0$.\n\n\n-----Example-----\nInput\n3\n4 0\n5 14\n3 9\n\nOutput\n2\n3\n2\n\n\n\n-----Note-----\n\nIn the first example, Bob can press the $-2$ button twice to reach $0$. Note that Bob can not press $-5$ when the volume is $4$ since it will make the volume negative. \n\nIn the second example, one of the optimal ways for Bob is to press the $+5$ twice, then press $-1$ once.\n\nIn the last example, Bob can press the $+5$ once, then press $+1$.", "raw_solution": "def apps_run1(t, test_cases):\n    results = []\n    for i in range(t):\n        a, b = test_cases[i]\n        if a == b:\n            results.append(0)\n        else:\n            d = abs(a - b)\n            k1 = d // 5\n            d -= k1 * 5\n            k2 = d // 2\n            d -= k2 * 2\n            results.append(d + k1 + k2)\n    return results\n\n# Example usage:\n# t = 3\n# test_cases = [(4, 0), (5, 14), (3, 9)]\n# print(apps_run1(t, test_cases))\n", "raw_test_input": ["assert apps_run1(3, [(4, 0), (5, 14), (3, 9)]) == [2, 3, 2]", "assert apps_run1(2, [(10, 3), (1, 1)]) == [2, 0]", "assert apps_run1(4, [(0, 5), (7, 2), (15, 10), (20, 25)]) == [1, 1, 1, 1]", "assert apps_run1(5, [(8, 8), (12, 7), (6, 11), (0, 0), (9, 4)]) == [0, 1, 1, 0, 1]", "assert apps_run1(3, [(2, 10), (10, 0), (5, 5)]) == [3, 2, 0]", "assert apps_run1(1, [(1000000000, 999999995)]) == [1]"], "new_problem": "Bob watches TV every day. He always sets the volume of his TV to b. However, today he is angry to find out someone has changed the volume to a. Of course, Bob has a remote control that can change the volume. There are six buttons (-5, -2, -1, +1, +2, +5) on the control, which in one press can either increase or decrease the current volume by 1, 2, or 5. The volume can be arbitrarily large, but can never be negative. In other words, Bob cannot press the button if it causes the volume to be lower than 0. As Bob is so angry, he wants to change the volume to b using as few button presses as possible. However, he forgets how to do such simple calculations, so he asks you for help. Write a program that given a and b, finds the minimum number of presses to change the TV volume from a to b. Additionally, the TV now has a maximum volume limit c. If c is provided, the volume cannot exceed this limit. If c is not provided, assume there is no maximum limit.", "new_solution": "def apps_run2(t: int, cases: list[tuple[int, int, int]]) -> list[int]:\n    results = []\n    for i in range(t):\n        a, b, *optional_c = cases[i]\n        c = optional_c[0] if optional_c else float('inf')\n        \n        # \u68c0\u67e5\u521d\u59cb\u548c\u76ee\u6807\u97f3\u91cf\u662f\u5426\u5728\u5141\u8bb8\u8303\u56f4\u5185\n        if a > c or b > c:\n            results.append(float('inf'))\n            continue\n            \n        if a == b:\n            results.append(0)\n            continue\n            \n        # \u8ba1\u7b97\u6700\u5c11\u6309\u952e\u6b21\u6570\n        d = abs(a - b)\n        k1 = d // 5\n        d -= k1 * 5\n        k2 = d // 2\n        d -= k2 * 2\n        \n        results.append(d + k1 + k2)\n        \n    return results", "input_format": "min_presses parameters: - t: Integer (1 \u2264 t \u2264 1,000) number of test cases - cases: List of tuples where each tuple contains: - a: Integer (0 \u2264 a \u2264 10^9) current volume - b: Integer (0 \u2264 b \u2264 10^9) target volume - c: Optional Integer (0 \u2264 c \u2264 10^9) maximum volume limit", "output_format": "For each test case, output a single integer \u2014 the minimum number of presses to change the TV volume from a to b, considering the maximum volume limit if provided. If Bob does not need to change the volume (i.e. a=b), then print 0.", "test_input": ["assert apps_run2(3, [(4, 0), (5, 14), (3, 9)]) == [2, 3, 2]", "assert apps_run2(2, [(10, 20, 15), (5, 5)]) == [float('inf'), 0]", "assert apps_run2(1, [(0, 10, 10)]) == [2]", "assert apps_run2(1, [(100, 105)]) == [1]", "assert apps_run2(1, [(7, 2, 5)]) == [float('inf')]"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "APPS/0113-3", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nBob watches TV every day. He always sets the volume of his TV to $b$. However, today he is angry to find out someone has changed the volume to $a$. Of course, Bob has a remote control that can change the volume.\n\nThere are six buttons ($-5, -2, -1, +1, +2, +5$) on the control, which in one press can either increase or decrease the current volume by $1$, $2$, or $5$. The volume can be arbitrarily large, but can never be negative. In other words, Bob cannot press the button if it causes the volume to be lower than $0$.\n\nAs Bob is so angry, he wants to change the volume to $b$ using as few button presses as possible. However, he forgets how to do such simple calculations, so he asks you for help. Write a program that given $a$ and $b$, finds the minimum number of presses to change the TV volume from $a$ to $b$.\n\n\n-----Input-----\n\nEach test contains multiple test cases. The first line contains the number of test cases $T$ ($1 \\le T \\le 1\\,000$). Then the descriptions of the test cases follow.\n\nEach test case consists of one line containing two integers $a$ and $b$ ($0 \\le a, b \\le 10^{9}$)\u00a0\u2014 the current volume and Bob's desired volume, respectively.\n\n\n-----Output-----\n\nFor each test case, output a single integer\u00a0\u2014 the minimum number of presses to change the TV volume from $a$ to $b$. If Bob does not need to change the volume (i.e. $a=b$), then print $0$.\n\n\n-----Example-----\nInput\n3\n4 0\n5 14\n3 9\n\nOutput\n2\n3\n2\n\n\n\n-----Note-----\n\nIn the first example, Bob can press the $-2$ button twice to reach $0$. Note that Bob can not press $-5$ when the volume is $4$ since it will make the volume negative. \n\nIn the second example, one of the optimal ways for Bob is to press the $+5$ twice, then press $-1$ once.\n\nIn the last example, Bob can press the $+5$ once, then press $+1$.", "raw_solution": "def apps_run1(t, test_cases):\n    results = []\n    for i in range(t):\n        a, b = test_cases[i]\n        if a == b:\n            results.append(0)\n        else:\n            d = abs(a - b)\n            k1 = d // 5\n            d -= k1 * 5\n            k2 = d // 2\n            d -= k2 * 2\n            results.append(d + k1 + k2)\n    return results\n\n# Example usage:\n# print(apps_run1(3, [(4, 0), (5, 14), (3, 9)]))\n# Output: [2, 3, 2]", "raw_test_input": ["assert apps_run1(3, [(4, 0), (5, 14), (3, 9)]) == [2, 3, 2]", "assert apps_run1(2, [(10, 3), (1, 1)]) == [2, 0]", "assert apps_run1(4, [(0, 5), (7, 2), (15, 10), (20, 25)]) == [1, 1, 1, 1]", "assert apps_run1(5, [(8, 8), (12, 7), (6, 11), (0, 0), (9, 4)]) == [0, 1, 1, 0, 1]", "assert apps_run1(3, [(2, 10), (10, 0), (5, 5)]) == [3, 2, 0]", "assert apps_run1(1, [(1000000000, 999999995)]) == [1]"], "new_problem": "Bob watches TV every day and always sets the volume of his TV to a specific level. However, today he finds out someone has changed the volume. Bob has a remote control with six buttons (-5, -2, -1, +1, +2, +5) that can change the volume by 1, 2, or 5 units. The volume can be arbitrarily large, but can never be negative. Bob wants to change the volume to his desired level using as few button presses as possible. However, he forgets how to do such simple calculations, so he asks you for help. Write a program that given a and b, finds the minimum number of presses to change the TV volume from a to b. Additionally, Bob has a list of favorite volume levels stored in a dictionary where the key is the volume level and the value is the number of times he has set the TV to that volume. The program should also update this dictionary to reflect the new volume level after each test case.", "new_solution": "from typing import Dict, Tuple, List\n\ndef apps_run2(t: int, test_cases: List[Tuple[int, int]], favorites: Dict[int, int]) -> List[int]:\n    results = []\n    for a, b in test_cases:\n        if a == b:\n            results.append(0)\n        else:\n            d = abs(a - b)\n            k1 = d // 5\n            d -= k1 * 5\n            k2 = d // 2\n            d -= k2 * 2\n            results.append(d + k1 + k2)\n        # Update the favorites dictionary\n        if b in favorites:\n            favorites[b] += 1\n        else:\n            favorites[b] = 1\n    return results", "input_format": "Each test contains multiple test cases. The first line contains the number of test cases T (1 \u2264 T \u2264 1,000). Then the descriptions of the test cases follow. Each test case consists of one line containing two integers a and b (0 \u2264 a, b \u2264 10^9) \u2014 the current volume and Bob's desired volume, respectively.", "output_format": "For each test case, output a single integer \u2014 the minimum number of presses to change the TV volume from a to b. If Bob does not need to change the volume (i.e. a=b), then print 0.", "test_input": ["assert apps_run2(3, [(4, 0), (5, 14), (3, 9)], {0: 1, 14: 0, 9: 0}) == [2, 3, 2]", "assert apps_run2(2, [(10, 10), (7, 2)], {10: 5, 2: 1}) == [0, 1]", "assert apps_run2(1, [(0, 5)], {5: 2}) == [1]", "assert apps_run2(4, [(1, 6), (6, 1), (0, 0), (100, 105)], {6: 0, 1: 0, 0: 0, 105: 0}) == [1, 1, 0, 1]", "assert apps_run2(3, [(20, 25), (25, 20), (15, 15)], {25: 0, 20: 0, 15: 0}) == [1, 1, 0]"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "APPS/0113-4", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nBob watches TV every day. He always sets the volume of his TV to $b$. However, today he is angry to find out someone has changed the volume to $a$. Of course, Bob has a remote control that can change the volume.\n\nThere are six buttons ($-5, -2, -1, +1, +2, +5$) on the control, which in one press can either increase or decrease the current volume by $1$, $2$, or $5$. The volume can be arbitrarily large, but can never be negative. In other words, Bob cannot press the button if it causes the volume to be lower than $0$.\n\nAs Bob is so angry, he wants to change the volume to $b$ using as few button presses as possible. However, he forgets how to do such simple calculations, so he asks you for help. Write a program that given $a$ and $b$, finds the minimum number of presses to change the TV volume from $a$ to $b$.\n\n\n-----Input-----\n\nEach test contains multiple test cases. The first line contains the number of test cases $T$ ($1 \\le T \\le 1\\,000$). Then the descriptions of the test cases follow.\n\nEach test case consists of one line containing two integers $a$ and $b$ ($0 \\le a, b \\le 10^{9}$)\u00a0\u2014 the current volume and Bob's desired volume, respectively.\n\n\n-----Output-----\n\nFor each test case, output a single integer\u00a0\u2014 the minimum number of presses to change the TV volume from $a$ to $b$. If Bob does not need to change the volume (i.e. $a=b$), then print $0$.\n\n\n-----Example-----\nInput\n3\n4 0\n5 14\n3 9\n\nOutput\n2\n3\n2\n\n\n\n-----Note-----\n\nIn the first example, Bob can press the $-2$ button twice to reach $0$. Note that Bob can not press $-5$ when the volume is $4$ since it will make the volume negative. \n\nIn the second example, one of the optimal ways for Bob is to press the $+5$ twice, then press $-1$ once.\n\nIn the last example, Bob can press the $+5$ once, then press $+1$.", "raw_solution": "def apps_run1(test_cases):\n    results = []\n    for a, b in test_cases:\n        if a == b:\n            results.append(0)\n        else:\n            d = abs(a - b)\n            k1 = d // 5\n            d -= k1 * 5\n            k2 = d // 2\n            d -= k2 * 2\n            results.append(d + k1 + k2)\n    return results\n\ntest_cases = [(4, 0), (5, 14), (3, 9)]\nprint(apps_run1(test_cases))", "raw_test_input": ["assert apps_run1([(4, 0), (5, 14), (3, 9)]) == [2, 3, 2]", "assert apps_run1([(10, 3), (1, 1)]) == [2, 0]", "assert apps_run1([(0, 5), (7, 2), (15, 10), (20, 25)]) == [1, 1, 1, 1]", "assert apps_run1([(8, 8), (12, 7), (6, 11), (0, 0), (9, 4)]) == [0, 1, 1, 0, 1]", "assert apps_run1([(2, 10), (10, 0), (5, 5)]) == [3, 2, 0]", "assert apps_run1([(1000000000, 999999995)]) == [1]"], "new_problem": "Bob watches TV every day. He always sets the volume of his TV to b. However, today he is angry to find out someone has changed the volume to a. Of course, Bob has a remote control that can change the volume. There are six buttons (-5, -2, -1, +1, +2, +5) on the control, which in one press can either increase or decrease the current volume by 1, 2, or 5. The volume can be arbitrarily large, but can never be negative. In other words, Bob cannot press the button if it causes the volume to be lower than 0. As Bob is so angry, he wants to change the volume to b using as few button presses as possible. However, he forgets how to do such simple calculations, so he asks you for help. Write a program that given a and b, finds the minimum number of presses to change the TV volume from a to b. Additionally, handle the following errors: 1. InvalidVolumeError: Raised if the volume a or b is negative. 2. VolumeOutOfRangeError: Raised if the volume a or b exceeds 10^9. 3. InputFormatError: Raised if the input format is incorrect. Ensure that the program handles these errors gracefully and provides meaningful error messages.", "new_solution": "class InvalidVolumeError(Exception):\n    pass\n\nclass VolumeOutOfRangeError(Exception):\n    pass\n\nclass InputFormatError(Exception):\n    pass\n\ndef apps_run2(t: int, cases: list[tuple[int, int]]) -> list[int]:\n    MAX_VOLUME = 10**9\n    results = []\n    for case in cases:\n        if len(case) != 2:\n            raise InputFormatError(\"Invalid input format.\")\n        a, b = case\n        if a < 0 or b < 0:\n            raise InvalidVolumeError(\"Volume cannot be negative.\")\n        if a > MAX_VOLUME or b > MAX_VOLUME:\n            raise VolumeOutOfRangeError(\"Volume must be between 0 and 10^9.\")\n        if a == b:\n            results.append(0)\n            continue\n        d = abs(a - b)\n        k1 = d // 5\n        d -= k1 * 5\n        k2 = d // 2\n        d -= k2 * 2\n        results.append(d + k1 + k2)\n    return results", "input_format": "minimum_presses parameters: - t: Integer (1 \u2264 t \u2264 1,000) number of test cases - cases: List of tuples (a, b) where: - a: Integer (0 \u2264 a \u2264 10^9) current volume - b: Integer (0 \u2264 b \u2264 10^9) target volume", "output_format": "For each test case, output a single integer \u2014 the minimum number of presses to change the TV volume from a to b. If Bob does not need to change the volume (i.e. a=b), then print 0.", "test_input": ["assert apps_run2(3, [(4, 0), (5, 14), (3, 9)]) == [2, 3, 2]", "assert apps_run2(1, [(0, 0)]) == [0]", "try:\n    apps_run2(1, [(-1, 5)])\nexcept InvalidVolumeError as e:\n    assert str(e) == \"Volume cannot be negative.\"", "try:\n    apps_run2(1, [(5, 10**10)])\nexcept VolumeOutOfRangeError as e:\n    assert str(e) == \"Volume must be between 0 and 10^9.\"", "try:\n    apps_run2(2, [(5, 5), (3, 9, 1)])\nexcept InputFormatError as e:\n    assert str(e) == \"Invalid input format.\""], "requirement_type": "PROMPT_ERROR_HANDLING"}
{"task_id": "APPS/0109-1", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nYou have a bag of size $n$. Also you have $m$ boxes. The size of $i$-th box is $a_i$, where each $a_i$ is an integer non-negative power of two.\n\nYou can divide boxes into two parts of equal size. Your goal is to fill the bag completely.\n\nFor example, if $n = 10$ and $a = [1, 1, 32]$ then you have to divide the box of size $32$ into two parts of size $16$, and then divide the box of size $16$. So you can fill the bag with boxes of size $1$, $1$ and $8$.\n\nCalculate the minimum number of divisions required to fill the bag of size $n$.\n\n\n-----Input-----\n\nThe first line contains one integer $t$ ($1 \\le t \\le 1000$) \u2014 the number of test cases.\n\nThe first line of each test case contains two integers $n$ and $m$ ($1 \\le n \\le 10^{18}, 1 \\le m \\le 10^5$) \u2014 the size of bag and the number of boxes, respectively.\n\nThe second line of each test case contains $m$ integers $a_1, a_2, \\dots , a_m$ ($1 \\le a_i \\le 10^9$) \u2014 the sizes of boxes. It is guaranteed that each $a_i$ is a power of two.\n\nIt is also guaranteed that sum of all $m$ over all test cases does not exceed $10^5$.\n\n\n-----Output-----\n\nFor each test case print one integer \u2014 the minimum number of divisions required to fill the bag of size $n$ (or $-1$, if it is impossible).\n\n\n-----Example-----\nInput\n3\n10 3\n1 32 1\n23 4\n16 1 4 1\n20 5\n2 1 16 1 8\n\nOutput\n2\n-1\n0.", "raw_solution": "import math\ndef apps_run1(test_cases):\n    results = []\n    for n, m, arr in test_cases:\n        x = [0] * 65\n        if sum(arr) < n:\n            results.append(-1)\n            continue\n        for i in arr:\n            x[int(math.log2(i))] += 1\n        ans = 0\n        for i in range(65):\n            if (1 << i) & n:\n                if x[i] != 0:\n                    x[i] -= 1\n                    continue\n                total = 0\n                for j in range(i):\n                    total += (1 << j) * x[j]\n                if total >= (1 << i):\n                    temp = 1 << i\n                    for j in reversed(range(i)):\n                        while temp - (1 << j) >= 0 and x[j] > 0:\n                            temp -= 1 << j\n                            x[j] -= 1\n                    continue\n                j = i\n                while j < 65 and x[j] == 0:\n                    j += 1\n                if j == 65:\n                    results.append(-1)\n                    break\n                else:\n                    x[j] -= 1\n                    for k in range(i, j):\n                        x[k] += 1\n                    ans += (j - i)\n        else:\n            results.append(ans)\n    return results", "raw_test_input": ["assert apps_run1([(10, 3, [1, 32, 1]), (23, 4, [16, 1, 4, 1]), (20, 5, [2, 1, 16, 1, 8])]) == [2, -1, 0]", "assert apps_run1([(15, 4, [2, 4, 8, 1]), (30, 3, [16, 8, 4])]) == [0, -1]", "assert apps_run1([(50, 5, [32, 16, 8, 4, 2])]) == [0]", "assert apps_run1([(5, 2, [2, 2]), (7, 3, [4, 2, 1]), (12, 4, [8, 4, 2, 2])]) == [-1, 0, 0]", "assert apps_run1([(100, 3, [64, 32, 4]), (1, 5, [8, 2, 1])]) == [0, 0]", "assert apps_run1([(1, 1, [1])]) == [0]"], "new_problem": "In a logistics company, you are tasked with optimizing the packing of goods into containers. Each container has a specific capacity, and you have a set of boxes with sizes that are powers of two. You can divide any box into two smaller boxes of equal size. Your goal is to determine the minimum number of divisions required to completely fill each container. Additionally, you need to handle multiple shipments, each with its own set of containers and boxes. For each shipment, calculate the minimum number of divisions required for each container, or determine if it is impossible to fill the container with the available boxes.", "new_solution": "def min_divisions_to_fill_bag(n, m, arr):\n    import math\n    NO = -1\n    x = [0] * 65\n    if sum(arr) < n:\n        return NO\n    for i in arr:\n        x[int(math.log2(i))] += 1\n    ans = 0\n    for i in range(65):\n        if (1 << i) & n:\n            if x[i] != 0:\n                x[i] -= 1\n                continue\n            total = 0\n            for j in range(i):\n                total += (1 << j) * x[j]\n            if total >= (1 << i):\n                temp = 1 << i\n                for j in reversed(range(i)):\n                    while temp - (1 << j) >= 0 and x[j] > 0:\n                        temp -= 1 << j\n                        x[j] -= 1\n                continue\n            j = i\n            while j < 65 and x[j] == 0:\n                j += 1\n            if j == 65:\n                return NO\n            else:\n                x[j] -= 1\n                for k in range(i, j):\n                    x[k] += 1\n                ans += (j - i)\n    return ans\n\ndef apps_run2(t, test_cases):\n    results = []\n    for case in test_cases:\n        n, m, arr = case\n        result = min_divisions_to_fill_bag(n, m, arr)\n        results.append(result)\n    return results", "input_format": "optimize_packing parameters: - t: Integer (1 \u2264 t \u2264 1000) number of test cases - test_cases: List of tuples (n, m, arr) where: - n: Integer (1 \u2264 n \u2264 10^18) bag size - m: Integer (1 \u2264 m \u2264 10^5) number of boxes - arr: List of m integers (1 \u2264 a_i \u2264 10^9) where a_i is power of 2", "output_format": "For each test case, print one integer \u2014 the minimum number of divisions required to fill the bag of size n (or -1, if it is impossible).", "test_input": ["assert apps_run2(3, [(10, 3, [1, 32, 1]), (23, 4, [16, 1, 4, 1]), (20, 5, [2, 1, 16, 1, 8])]) == [2, -1, 0]", "assert apps_run2(2, [(15, 2, [8, 8]), (30, 3, [16, 8, 4])]) == [3, -1]", "assert apps_run2(1, [(50, 5, [32, 16, 8, 4, 2])]) == [0]", "assert apps_run2(1, [(100, 6, [64, 32, 16, 8, 4, 2])]) == [0]", "assert apps_run2(2, [(5, 1, [8]), (7, 2, [4, 4])]) == [3, 2]"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "APPS/0109-2", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nYou have a bag of size $n$. Also you have $m$ boxes. The size of $i$-th box is $a_i$, where each $a_i$ is an integer non-negative power of two.\n\nYou can divide boxes into two parts of equal size. Your goal is to fill the bag completely.\n\nFor example, if $n = 10$ and $a = [1, 1, 32]$ then you have to divide the box of size $32$ into two parts of size $16$, and then divide the box of size $16$. So you can fill the bag with boxes of size $1$, $1$ and $8$.\n\nCalculate the minimum number of divisions required to fill the bag of size $n$.\n\n\n-----Input-----\n\nThe first line contains one integer $t$ ($1 \\le t \\le 1000$) \u2014 the number of test cases.\n\nThe first line of each test case contains two integers $n$ and $m$ ($1 \\le n \\le 10^{18}, 1 \\le m \\le 10^5$) \u2014 the size of bag and the number of boxes, respectively.\n\nThe second line of each test case contains $m$ integers $a_1, a_2, \\dots , a_m$ ($1 \\le a_i \\le 10^9$) \u2014 the sizes of boxes. It is guaranteed that each $a_i$ is a power of two.\n\nIt is also guaranteed that sum of all $m$ over all test cases does not exceed $10^5$.\n\n\n-----Output-----\n\nFor each test case print one integer \u2014 the minimum number of divisions required to fill the bag of size $n$ (or $-1$, if it is impossible).\n\n\n-----Example-----\nInput\n3\n10 3\n1 32 1\n23 4\n16 1 4 1\n20 5\n2 1 16 1 8\n\nOutput\n2\n-1\n0.", "raw_solution": "import math\ndef apps_run1(test_cases):\n    results = []\n    for n, m, arr in test_cases:\n        x = [0] * 65\n        if sum(arr) < n:\n            results.append(-1)\n            continue\n        for i in arr:\n            x[int(math.log2(i))] += 1\n        ans = 0\n        for i in range(65):\n            if (1 << i) & n:\n                if x[i] != 0:\n                    x[i] -= 1\n                    continue\n                total = 0\n                for j in range(i):\n                    total += (1 << j) * x[j]\n                if total >= (1 << i):\n                    temp = 1 << i\n                    for j in reversed(range(i)):\n                        while temp - (1 << j) >= 0 and x[j] > 0:\n                            temp -= 1 << j\n                            x[j] -= 1\n                    continue\n                j = i\n                while j < 65 and x[j] == 0:\n                    j += 1\n                if j == 65:\n                    results.append(-1)\n                    break\n                else:\n                    x[j] -= 1\n                    for k in range(i, j):\n                        x[k] += 1\n                    ans += (j - i)\n        else:\n            results.append(ans)\n    return results", "raw_test_input": ["assert apps_run1([(10, 3, [1, 32, 1]), (23, 4, [16, 1, 4, 1]), (20, 5, [2, 1, 16, 1, 8])]) == [2, -1, 0]", "assert apps_run1([(15, 4, [2, 4, 8, 1]), (30, 3, [16, 8, 4])]) == [0, -1]", "assert apps_run1([(50, 5, [32, 16, 8, 4, 2])]) == [0]", "assert apps_run1([(5, 2, [2, 2]), (7, 3, [4, 2, 1]), (12, 4, [8, 4, 2, 2])]) == [-1, 0, 0]", "assert apps_run1([(100, 3, [64, 32, 4]), (1, 5, [8, 2, 1])]) == [0, 0]", "assert apps_run1([(1, 1, [1])]) == [0]"], "new_problem": "You have a bag of size n. Also, you have m boxes. The size of the i-th box is a_i, where each a_i is an integer non-negative power of two. You can divide boxes into two parts of equal size. Your goal is to fill the bag completely. Additionally, you can specify a maximum number of divisions allowed. Calculate the minimum number of divisions required to fill the bag of size n, or return -1 if it is impossible or exceeds the maximum allowed divisions. The function should maintain backward compatibility and support the original function parameters, with an optional parameter for the maximum number of divisions.", "new_solution": "from typing import List, Tuple, Optional\nimport math\n\nNO = -1\n\n\ndef apps_run2(t: int, test_cases: List[Tuple[int, int, List[int]]], max_divisions: Optional[int] = None) -> List[int]:\n    results = []\n    for case in test_cases:\n        n, m, arr = case\n        x = [0] * 65\n        if sum(arr) < n:\n            results.append(NO)\n            continue\n        for i in arr:\n            x[int(math.log2(i))] += 1\n        ans = 0\n        for i in range(65):\n            if (1 << i) & n:\n                if x[i] != 0:\n                    x[i] -= 1\n                    continue\n                total = 0\n                for j in range(i):\n                    total += (1 << j) * x[j]\n                if total >= (1 << i):\n                    temp = 1 << i\n                    for j in reversed(range(i)):\n                        while temp - (1 << j) >= 0 and x[j] > 0:\n                            temp -= 1 << j\n                            x[j] -= 1\n                    continue\n                j = i\n                while j < 65 and x[j] == 0:\n                    j += 1\n                if j == 65:\n                    results.append(NO)\n                    break\n                else:\n                    x[j] -= 1\n                    for k in range(i, j):\n                        x[k] += 1\n                    ans += (j - i)\n        if max_divisions is not None and ans > max_divisions:\n            results.append(NO)\n        else:\n            results.append(ans)\n    return results", "input_format": "min_divisions parameters: - t: Integer (1 \u2264 t \u2264 1000) number of test cases - test_cases: List of tuples (n, m, arr) where: - n: Integer (1 \u2264 n \u2264 10^18) bag size - m: Integer (1 \u2264 m \u2264 10^5) number of boxes - arr: List of m integers (1 \u2264 a_i \u2264 10^9) box sizes, each a power of 2 - max_divisions: Optional Integer, maximum allowed divisions (default None)", "output_format": "For each test case print one integer \u2014 the minimum number of divisions required to fill the bag of size n (or -1, if it is impossible).", "test_input": ["assert apps_run2(3, [(10, 3, [1, 32, 1]), (23, 4, [16, 1, 4, 1]), (20, 5, [2, 1, 16, 1, 8])]) == [2, -1, 0]", "assert apps_run2(1, [(10, 3, [1, 32, 1])], max_divisions=1) == [-1]", "assert apps_run2(1, [(10, 3, [1, 32, 1])], max_divisions=2) == [2]", "assert apps_run2(1, [(15, 4, [8, 4, 2, 1])]) == [0]", "assert apps_run2(1, [(15, 4, [8, 4, 2, 1])], max_divisions=0) == [0]"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "APPS/0109-3", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nYou have a bag of size $n$. Also you have $m$ boxes. The size of $i$-th box is $a_i$, where each $a_i$ is an integer non-negative power of two.\n\nYou can divide boxes into two parts of equal size. Your goal is to fill the bag completely.\n\nFor example, if $n = 10$ and $a = [1, 1, 32]$ then you have to divide the box of size $32$ into two parts of size $16$, and then divide the box of size $16$. So you can fill the bag with boxes of size $1$, $1$ and $8$.\n\nCalculate the minimum number of divisions required to fill the bag of size $n$.\n\n\n-----Input-----\n\nThe first line contains one integer $t$ ($1 \\le t \\le 1000$) \u2014 the number of test cases.\n\nThe first line of each test case contains two integers $n$ and $m$ ($1 \\le n \\le 10^{18}, 1 \\le m \\le 10^5$) \u2014 the size of bag and the number of boxes, respectively.\n\nThe second line of each test case contains $m$ integers $a_1, a_2, \\dots , a_m$ ($1 \\le a_i \\le 10^9$) \u2014 the sizes of boxes. It is guaranteed that each $a_i$ is a power of two.\n\nIt is also guaranteed that sum of all $m$ over all test cases does not exceed $10^5$.\n\n\n-----Output-----\n\nFor each test case print one integer \u2014 the minimum number of divisions required to fill the bag of size $n$ (or $-1$, if it is impossible).\n\n\n-----Example-----\nInput\n3\n10 3\n1 32 1\n23 4\n16 1 4 1\n20 5\n2 1 16 1 8\n\nOutput\n2\n-1\n0.", "raw_solution": "import math\ndef apps_run1(test_cases):\n    results = []\n    for n, m, arr in test_cases:\n        x = [0] * 65\n        if sum(arr) < n:\n            results.append(-1)\n            continue\n        for i in arr:\n            x[int(math.log2(i))] += 1\n        ans = 0\n        for i in range(65):\n            if (1 << i) & n:\n                if x[i] != 0:\n                    x[i] -= 1\n                    continue\n                total = 0\n                for j in range(i):\n                    total += (1 << j) * x[j]\n                if total >= (1 << i):\n                    temp = 1 << i\n                    for j in reversed(range(i)):\n                        while temp - (1 << j) >= 0 and x[j] > 0:\n                            temp -= 1 << j\n                            x[j] -= 1\n                    continue\n                j = i\n                while j < 65 and x[j] == 0:\n                    j += 1\n                if j == 65:\n                    results.append(-1)\n                    break\n                else:\n                    x[j] -= 1\n                    for k in range(i, j):\n                        x[k] += 1\n                    ans += (j - i)\n        else:\n            results.append(ans)\n    return results", "raw_test_input": ["assert apps_run1([(10, 3, [1, 32, 1]), (23, 4, [16, 1, 4, 1]), (20, 5, [2, 1, 16, 1, 8])]) == [2, -1, 0]", "assert apps_run1([(15, 4, [2, 4, 8, 1]), (30, 3, [16, 8, 4])]) == [0, -1]", "assert apps_run1([(50, 5, [32, 16, 8, 4, 2])]) == [0]", "assert apps_run1([(5, 2, [2, 2]), (7, 3, [4, 2, 1]), (12, 4, [8, 4, 2, 2])]) == [-1, 0, 0]", "assert apps_run1([(100, 3, [64, 32, 4]), (1, 5, [8, 2, 1])]) == [0, 0]", "assert apps_run1([(1, 1, [1])]) == [0]"], "new_problem": "You have a bag of size n. Also, you have m boxes. The size of the i-th box is a_i, where each a_i is an integer non-negative power of two. You can divide boxes into two parts of equal size. Your goal is to fill the bag completely. However, the boxes are now stored in a dictionary where the keys are the box sizes and the values are the counts of each box size. Calculate the minimum number of divisions required to fill the bag of size n. Additionally, you must handle the case where the total size of all boxes is greater than 2n, and return -1 if it is impossible to fill the bag. Use type hints in your solution.", "new_solution": "from typing import List, Dict\nimport math\ndef apps_run2(t: int, test_cases: List[Dict[str, List[int]]]) -> List[int]:\n    results = []\n    for case in test_cases:\n        n = case['n']\n        box_dict = case['boxes']\n        x = [0] * 65\n        total_boxes = sum(size * count for size, count in box_dict.items())\n        if total_boxes < n:\n            results.append(-1)\n            continue\n        for size, count in box_dict.items():\n            x[int(math.log2(size))] += count\n        ans = 0\n        for i in range(65):\n            if (1 << i) & n:\n                if x[i] != 0:\n                    x[i] -= 1\n                    continue\n                total = 0\n                for j in range(i):\n                    total += (1 << j) * x[j]\n                if total >= (1 << i):\n                    temp = 1 << i\n                    for j in reversed(range(i)):\n                        while temp - (1 << j) >= 0 and x[j] > 0:\n                            temp -= 1 << j\n                            x[j] -= 1\n                    continue\n                j = i\n                while j < 65 and x[j] == 0:\n                    j += 1\n                if j == 65:\n                    results.append(-1)\n                    break\n                else:\n                    x[j] -= 1\n                    for k in range(i, j):\n                        x[k] += 1\n                    ans += (j - i)\n        else:\n            results.append(ans)\n    return results", "input_format": "min_divisions_to_fill_bag parameters: - t: Integer (1 \u2264 t \u2264 1000) number of test cases - test_cases: List of dictionaries with: - 'n': Integer (1 \u2264 n \u2264 10^18) bag size - 'boxes': Dict[int, int] mapping box size to count", "output_format": "For each test case, print one integer \u2014 the minimum number of divisions required to fill the bag of size n (or -1, if it is impossible).", "test_input": ["assert apps_run2(3, [{'n': 10, 'boxes': {1: 2, 32: 1}}, {'n': 23, 'boxes': {16: 1, 1: 1, 4: 1, 1: 1}}, {'n': 20, 'boxes': {2: 1, 1: 2, 16: 1, 8: 1}}]) == [2, -1, 0]", "assert apps_run2(1, [{'n': 15, 'boxes': {8: 1, 4: 1, 2: 1, 1: 1}}]) == [0]", "assert apps_run2(1, [{'n': 31, 'boxes': {16: 1, 8: 1, 4: 1, 2: 1, 1: 1}}]) == [0]", "assert apps_run2(1, [{'n': 1, 'boxes': {2: 1}}]) == [1]", "assert apps_run2(1, [{'n': 64, 'boxes': {32: 2}}]) == [0]"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "APPS/0109-4", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nYou have a bag of size $n$. Also you have $m$ boxes. The size of $i$-th box is $a_i$, where each $a_i$ is an integer non-negative power of two.\n\nYou can divide boxes into two parts of equal size. Your goal is to fill the bag completely.\n\nFor example, if $n = 10$ and $a = [1, 1, 32]$ then you have to divide the box of size $32$ into two parts of size $16$, and then divide the box of size $16$. So you can fill the bag with boxes of size $1$, $1$ and $8$.\n\nCalculate the minimum number of divisions required to fill the bag of size $n$.\n\n\n-----Input-----\n\nThe first line contains one integer $t$ ($1 \\le t \\le 1000$) \u2014 the number of test cases.\n\nThe first line of each test case contains two integers $n$ and $m$ ($1 \\le n \\le 10^{18}, 1 \\le m \\le 10^5$) \u2014 the size of bag and the number of boxes, respectively.\n\nThe second line of each test case contains $m$ integers $a_1, a_2, \\dots , a_m$ ($1 \\le a_i \\le 10^9$) \u2014 the sizes of boxes. It is guaranteed that each $a_i$ is a power of two.\n\nIt is also guaranteed that sum of all $m$ over all test cases does not exceed $10^5$.\n\n\n-----Output-----\n\nFor each test case print one integer \u2014 the minimum number of divisions required to fill the bag of size $n$ (or $-1$, if it is impossible).\n\n\n-----Example-----\nInput\n3\n10 3\n1 32 1\n23 4\n16 1 4 1\n20 5\n2 1 16 1 8\n\nOutput\n2\n-1\n0.", "raw_solution": "import math\ndef apps_run1(test_cases):\n    results = []\n    for n, m, arr in test_cases:\n        x = [0] * 65\n        if sum(arr) < n:\n            results.append(-1)\n            continue\n        for i in arr:\n            x[int(math.log2(i))] += 1\n        ans = 0\n        for i in range(65):\n            if (1 << i) & n:\n                if x[i] != 0:\n                    x[i] -= 1\n                    continue\n                total = 0\n                for j in range(i):\n                    total += (1 << j) * x[j]\n                if total >= (1 << i):\n                    temp = 1 << i\n                    for j in reversed(range(i)):\n                        while temp - (1 << j) >= 0 and x[j] > 0:\n                            temp -= 1 << j\n                            x[j] -= 1\n                    continue\n                j = i\n                while j < 65 and x[j] == 0:\n                    j += 1\n                if j == 65:\n                    results.append(-1)\n                    continue\n                else:\n                    x[j] -= 1\n                    for k in range(i, j):\n                        x[k] += 1\n                    ans += (j - i)\n        results.append(ans)\n    return results", "raw_test_input": ["assert apps_run1([(10, 3, [1, 32, 1]), (23, 4, [16, 1, 4, 1]), (20, 5, [2, 1, 16, 1, 8])]) == [2, -1, 0]", "assert apps_run1([(15, 4, [2, 4, 8, 1]), (30, 3, [16, 8, 4])]) == [0, -1]", "assert apps_run1([(50, 5, [32, 16, 8, 4, 2])]) == [0]", "assert apps_run1([(5, 2, [2, 2]), (7, 3, [4, 2, 1]), (12, 4, [8, 4, 2, 2])]) == [-1, 0, 0]", "assert apps_run1([(100, 3, [64, 32, 4]), (1, 5, [8, 2, 1])]) == [0, 0]", "assert apps_run1([(1, 1, [1])]) == [0]"], "new_problem": "You are tasked with developing a function that calculates the minimum number of divisions required to fill a bag of size n using boxes of given sizes. However, in this real-world scenario, you must handle various errors that could occur during the process. Specifically, you need to handle the following errors: 1. InvalidBoxSizeError: Raised when a box size is not a power of two. 2. InsufficientBoxSizeError: Raised when the total size of all boxes is less than the size of the bag. 3. DivisionError: Raised when a division operation fails due to an unexpected condition. 4. Propagate any unexpected errors with meaningful messages. The function should include type hints and handle error propagation appropriately.", "new_solution": "import math\nfrom typing import List, Tuple\n\nclass InvalidBoxSizeError(Exception):\n    pass\n\nclass InsufficientBoxSizeError(Exception):\n    pass\n\nclass DivisionError(Exception):\n    pass\n\ndef apps_run2(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    results = []\n    for case in test_cases:\n        try:\n            n, m, arr = case\n            if any(a <= 0 or (a & (a - 1)) != 0 for a in arr):\n                raise InvalidBoxSizeError(\"All box sizes must be positive powers of two.\")\n            if sum(arr) < n:\n                raise InsufficientBoxSizeError(\"Total size of boxes is less than the size of the bag.\")\n            x = [0] * 65\n            for i in arr:\n                x[int(math.log2(i))] += 1\n            ans = 0\n            for i in range(65):\n                if (1 << i) & n:\n                    if x[i] != 0:\n                        x[i] -= 1\n                        continue\n                    total = 0\n                    for j in range(i):\n                        total += (1 << j) * x[j]\n                    if total >= (1 << i):\n                        temp = 1 << i\n                        for j in reversed(range(i)):\n                            while temp - (1 << j) >= 0 and x[j] > 0:\n                                temp -= 1 << j\n                                x[j] -= 1\n                        continue\n                    j = i\n                    while j < 65 and x[j] == 0:\n                        j += 1\n                    if j == 65:\n                        raise DivisionError(\"Cannot divide boxes to fill the bag.\")\n                    else:\n                        x[j] -= 1\n                        for k in range(i, j):\n                            x[k] += 1\n                        ans += (j - i)\n            results.append(ans)\n        except (InvalidBoxSizeError, InsufficientBoxSizeError, DivisionError) as e:\n            results.append(-1)\n        except Exception as e:\n            results.append(-1)\n    return results", "input_format": "min_divisions_to_fill_bag parameters: - t: Integer (1 \u2264 t \u2264 1000) number of test cases - test_cases: List of tuples (n, m, arr) where: - n: Integer (1 \u2264 n \u2264 10^18) bag size - m: Integer (1 \u2264 m \u2264 10^5) number of boxes - arr: List of m integers (1 \u2264 a_i \u2264 10^9) box sizes, must be powers of 2", "output_format": "For each test case, print one integer \u2014 the minimum number of divisions required to fill the bag of size n (or -1, if it is impossible).", "test_input": ["assert apps_run2(3, [(10, 3, [1, 32, 1]), (23, 4, [16, 1, 4, 1]), (20, 5, [2, 1, 16, 1, 8])]) == [2, -1, 0]", "assert apps_run2(1, [(10, 3, [1, 3, 1])]) == [-1]", "assert apps_run2(1, [(10, 2, [1, 1])]) == [-1]", "assert apps_run2(1, [(10, 3, [1, 1, 1])]) == [-1]", "assert apps_run2(1, [(10, 3, [1, 2, 4])]) == [-1]"], "requirement_type": "PROMPT_ERROR_HANDLING"}
{"task_id": "APPS/0100-1", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nYou have three piles of candies: red, green and blue candies:  the first pile contains only red candies and there are $r$ candies in it,  the second pile contains only green candies and there are $g$ candies in it,  the third pile contains only blue candies and there are $b$ candies in it. \n\nEach day Tanya eats exactly two candies of different colors. She is free to choose the colors of eaten candies: the only restriction that she can't eat two candies of the same color in a day.\n\nFind the maximal number of days Tanya can eat candies? Each day she needs to eat exactly two candies.\n\n\n-----Input-----\n\nThe first line contains integer $t$ ($1 \\le t \\le 1000$) \u2014 the number of test cases in the input. Then $t$ test cases follow.\n\nEach test case is given as a separate line of the input. It contains three integers $r$, $g$ and $b$ ($1 \\le r, g, b \\le 10^8$) \u2014 the number of red, green and blue candies, respectively.\n\n\n-----Output-----\n\nPrint $t$ integers: the $i$-th printed integer is the answer on the $i$-th test case in the input.\n\n\n-----Example-----\nInput\n6\n1 1 1\n1 2 1\n4 1 1\n7 4 10\n8 1 4\n8 2 8\n\nOutput\n1\n2\n2\n10\n5\n9\n\n\n\n-----Note-----\n\nIn the first example, Tanya can eat candies for one day only. She can eat any pair of candies this day because all of them have different colors.\n\nIn the second example, Tanya can eat candies for two days. For example, she can eat red and green candies on the first day, and green and blue candies on the second day.\n\nIn the third example, Tanya can eat candies for two days. For example, she can eat red and green candies on the first day, and red and blue candies on the second day. Note, that two red candies will remain uneaten.", "raw_solution": "def apps_run1(n, values):\n    results = []\n    for i in range(n):\n        a, b, c = values[i]\n        results.append(min((a+b+c)//2, a+b, a+c, b+c))\n    return results", "raw_test_input": ["assert apps_run1(6, [(1, 1, 1), (1, 2, 1), (4, 1, 1), (7, 4, 10), (8, 1, 4), (8, 2, 8)]) == [1, 2, 2, 10, 5, 9]", "assert apps_run1(5, [(2, 2, 2), (3, 5, 1), (10, 10, 10), (6, 3, 2), (1, 1, 10)]) == [3, 4, 15, 5, 2]", "assert apps_run1(4, [(1, 3, 5), (2, 2, 2), (9, 1, 1), (4, 4, 4)]) == [4, 3, 2, 6]", "assert apps_run1(3, [(5, 5, 1), (10, 1, 1), (7, 7, 7)]) == [5, 2, 10]", "assert apps_run1(6, [(3, 6, 9), (8, 3, 2), (4, 4, 1), (5, 5, 5), (2, 2, 10), (1, 3, 3)]) == [9, 5, 4, 7, 4, 3]", "assert apps_run1(2, [(1, 1, 10), (10, 10, 10)]) == [2, 15]"], "new_problem": "Tanya is planning a long vacation and wants to ensure she has enough candies to eat every day. She has three piles of candies: red, green, and blue. Each day, she wants to eat exactly two candies of different colors. However, she also wants to ensure that she can eat candies for a specified number of days, d, during her vacation. If she cannot eat candies for all d days, she wants to know the maximum number of days she can eat candies. Write a function that determines the maximum number of days Tanya can eat candies given her plan.", "new_solution": "def max_days_tanya_can_eat(r, g, b):\n    return min((r + g + b) // 2, r + g, r + b, g + b)\n\ndef apps_run2(t, test_cases):\n    results = []\n    for i in range(t):\n        r, g, b, d = test_cases[i]\n        max_days = max_days_tanya_can_eat(r, g, b)\n        results.append(min(max_days, d))\n    return results", "input_format": "The first line contains integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Each test case consists of two lines. The first line contains three integers r, g, b (1 \u2264 r, g, b \u2264 10^8) \u2014 the number of red, green, and blue candies, respectively. The second line contains an integer d (1 \u2264 d \u2264 100) \u2014 the number of days Tanya wants to eat candies.", "output_format": "For each test case, print a single integer: the maximum number of days Tanya can eat candies according to her plan.", "test_input": ["assert apps_run2(1, [(1, 1, 1, 2)]) == [1]", "assert apps_run2(1, [(1, 2, 1, 3)]) == [2]", "assert apps_run2(1, [(4, 1, 1, 1)]) == [1]", "assert apps_run2(1, [(7, 4, 10, 5)]) == [5]", "assert apps_run2(1, [(8, 2, 8, 10)]) == [9]"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "APPS/0100-2", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nYou have three piles of candies: red, green and blue candies:  the first pile contains only red candies and there are $r$ candies in it,  the second pile contains only green candies and there are $g$ candies in it,  the third pile contains only blue candies and there are $b$ candies in it. \n\nEach day Tanya eats exactly two candies of different colors. She is free to choose the colors of eaten candies: the only restriction that she can't eat two candies of the same color in a day.\n\nFind the maximal number of days Tanya can eat candies? Each day she needs to eat exactly two candies.\n\n\n-----Input-----\n\nThe first line contains integer $t$ ($1 \\le t \\le 1000$) \u2014 the number of test cases in the input. Then $t$ test cases follow.\n\nEach test case is given as a separate line of the input. It contains three integers $r$, $g$ and $b$ ($1 \\le r, g, b \\le 10^8$) \u2014 the number of red, green and blue candies, respectively.\n\n\n-----Output-----\n\nPrint $t$ integers: the $i$-th printed integer is the answer on the $i$-th test case in the input.\n\n\n-----Example-----\nInput\n6\n1 1 1\n1 2 1\n4 1 1\n7 4 10\n8 1 4\n8 2 8\n\nOutput\n1\n2\n2\n10\n5\n9\n\n\n\n-----Note-----\n\nIn the first example, Tanya can eat candies for one day only. She can eat any pair of candies this day because all of them have different colors.\n\nIn the second example, Tanya can eat candies for two days. For example, she can eat red and green candies on the first day, and green and blue candies on the second day.\n\nIn the third example, Tanya can eat candies for two days. For example, she can eat red and green candies on the first day, and red and blue candies on the second day. Note, that two red candies will remain uneaten.", "raw_solution": "def apps_run1(n, cases):\n    results = []\n    for a, b, c in cases:\n        results.append(min((a+b+c)//2, a+b, a+c, b+c))\n    return results\n\n# Example usage:\n# print(apps_run1(6, [(1, 1, 1), (1, 2, 1), (4, 1, 1), (7, 4, 10), (8, 1, 4), (8, 2, 8)]))", "raw_test_input": ["assert apps_run1(6, [(1, 1, 1), (1, 2, 1), (4, 1, 1), (7, 4, 10), (8, 1, 4), (8, 2, 8)]) == [1, 2, 2, 10, 5, 9]", "assert apps_run1(5, [(2, 2, 2), (3, 5, 1), (10, 10, 10), (6, 3, 2), (1, 1, 10)]) == [3, 4, 15, 5, 2]", "assert apps_run1(4, [(1, 3, 5), (2, 2, 2), (9, 1, 1), (4, 4, 4)]) == [4, 3, 2, 6]", "assert apps_run1(3, [(5, 5, 1), (10, 1, 1), (7, 7, 7)]) == [5, 2, 10]", "assert apps_run1(6, [(3, 6, 9), (8, 3, 2), (4, 4, 1), (5, 5, 5), (2, 2, 10), (1, 3, 3)]) == [9, 5, 4, 7, 4, 3]", "assert apps_run1(2, [(1, 1, 10), (10, 10, 10)]) == [2, 15]"], "new_problem": "You have three piles of candies: red, green, and blue candies. The first pile contains only red candies and there are r candies in it, the second pile contains only green candies and there are g candies in it, the third pile contains only blue candies and there are b candies in it. Each day Tanya eats exactly two candies of different colors. She is free to choose the colors of eaten candies: the only restriction is that she can't eat two candies of the same color in a day. Additionally, Tanya can choose to skip eating candies for up to d days. Find the maximal number of days Tanya can eat candies, considering the optional skip days. Each day she needs to eat exactly two candies unless she chooses to skip.", "new_solution": "from typing import List, Tuple, Optional\n\ndef apps_run2(t: int, test_cases: List[Tuple[int, int, int, Optional[int]]]) -> List[int]:\n    results = []\n    for case in test_cases:\n        r, g, b, *optional_d = case\n        d = optional_d[0] if optional_d else 0\n        max_days = min((r + g + b) // 2, r + g, r + b, g + b)\n        max_days = max(0, max_days - d)\n        results.append(max_days)\n    return results", "input_format": "The first line contains integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases in the input. Then t test cases follow. Each test case is given as a separate line of the input. It contains three integers r, g and b (1 \u2264 r, g, b \u2264 10^8) \u2014 the number of red, green and blue candies, respectively. Optionally, a fourth integer d (0 \u2264 d \u2264 10^8) can be provided, representing the number of days Tanya can skip eating candies.", "output_format": "Print t integers: the i-th printed integer is the answer on the i-th test case in the input.", "test_input": ["assert apps_run2(6, [(1, 1, 1), (1, 2, 1), (4, 1, 1), (7, 4, 10), (8, 1, 4), (8, 2, 8)]) == [1, 2, 2, 10, 5, 9]", "assert apps_run2(3, [(1, 1, 1, 1), (1, 2, 1, 1), (4, 1, 1, 2)]) == [0, 1, 0]", "assert apps_run2(2, [(10, 10, 10, 5), (5, 5, 5, 0)]) == [10, 7]", "assert apps_run2(1, [(100, 100, 100, 50)]) == [100]", "assert apps_run2(4, [(3, 3, 3, 2), (6, 6, 6, 3), (9, 9, 9, 4), (12, 12, 12, 6)]) == [2, 6, 9, 12]"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "APPS/0100-3", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nYou have three piles of candies: red, green and blue candies:  the first pile contains only red candies and there are $r$ candies in it,  the second pile contains only green candies and there are $g$ candies in it,  the third pile contains only blue candies and there are $b$ candies in it. \n\nEach day Tanya eats exactly two candies of different colors. She is free to choose the colors of eaten candies: the only restriction that she can't eat two candies of the same color in a day.\n\nFind the maximal number of days Tanya can eat candies? Each day she needs to eat exactly two candies.\n\n\n-----Input-----\n\nThe first line contains integer $t$ ($1 \\le t \\le 1000$) \u2014 the number of test cases in the input. Then $t$ test cases follow.\n\nEach test case is given as a separate line of the input. It contains three integers $r$, $g$ and $b$ ($1 \\le r, g, b \\le 10^8$) \u2014 the number of red, green and blue candies, respectively.\n\n\n-----Output-----\n\nPrint $t$ integers: the $i$-th printed integer is the answer on the $i$-th test case in the input.\n\n\n-----Example-----\nInput\n6\n1 1 1\n1 2 1\n4 1 1\n7 4 10\n8 1 4\n8 2 8\n\nOutput\n1\n2\n2\n10\n5\n9\n\n\n\n-----Note-----\n\nIn the first example, Tanya can eat candies for one day only. She can eat any pair of candies this day because all of them have different colors.\n\nIn the second example, Tanya can eat candies for two days. For example, she can eat red and green candies on the first day, and green and blue candies on the second day.\n\nIn the third example, Tanya can eat candies for two days. For example, she can eat red and green candies on the first day, and red and blue candies on the second day. Note, that two red candies will remain uneaten.", "raw_solution": "def apps_run1(n, cases):\n    results = []\n    for a, b, c in cases:\n        results.append(min((a+b+c)//2, a+b, a+c, b+c))\n    return results\n\napps_run1(6, [(1, 1, 1), (1, 2, 1), (4, 1, 1), (7, 4, 10), (8, 1, 4), (8, 2, 8)])", "raw_test_input": ["assert apps_run1(6, [(1, 1, 1), (1, 2, 1), (4, 1, 1), (7, 4, 10), (8, 1, 4), (8, 2, 8)]) == [1, 2, 2, 10, 5, 9]", "assert apps_run1(5, [(2, 2, 2), (3, 5, 1), (10, 10, 10), (6, 3, 2), (1, 1, 10)]) == [3, 4, 15, 5, 2]", "assert apps_run1(4, [(1, 3, 5), (2, 2, 2), (9, 1, 1), (4, 4, 4)]) == [4, 3, 2, 6]", "assert apps_run1(3, [(5, 5, 1), (10, 1, 1), (7, 7, 7)]) == [5, 2, 10]", "assert apps_run1(6, [(3, 6, 9), (8, 3, 2), (4, 4, 1), (5, 5, 5), (2, 2, 10), (1, 3, 3)]) == [9, 5, 4, 7, 4, 3]", "assert apps_run1(2, [(1, 1, 10), (10, 10, 10)]) == [2, 15]"], "new_problem": "You have a collection of candy piles, each identified by a unique color name. Each pile contains a certain number of candies. Tanya can eat exactly two candies of different colors each day. Find the maximal number of days Tanya can eat candies. Each day she needs to eat exactly two candies. The input is given as a dictionary where keys are color names and values are the number of candies. Additionally, Tanya can only eat candies from a maximum of 5 different colors in total.", "new_solution": "from typing import Dict, List\n\ndef apps_run2(candy_piles: List[Dict[str, int]]) -> List[int]:\n    results = []\n    for piles in candy_piles:\n        if len(piles) > 5:\n            results.append(0)\n            continue\n        candies = list(piles.values())\n        candies.sort(reverse=True)\n        if len(candies) < 2:\n            results.append(0)\n            continue\n        max_days = min(sum(candies) // 2, sum(candies) - max(candies))\n        results.append(max_days)\n    return results", "input_format": "The first line contains integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Each test case is given as a separate line of the input. It contains three integers r, g, and b (1 \u2264 r, g, b \u2264 10^8) \u2014 the number of red, green, and blue candies, respectively.", "output_format": "Print t integers: the i-th printed integer is the answer on the i-th test case in the input.", "test_input": ["assert apps_run2([{ 'red': 1, 'green': 1, 'blue': 1 }]) == [1]", "assert apps_run2([{ 'red': 1, 'green': 2, 'blue': 1 }]) == [2]", "assert apps_run2([{ 'red': 4, 'green': 1, 'blue': 1 }]) == [2]", "assert apps_run2([{ 'red': 7, 'green': 4, 'blue': 10 }]) == [10]", "assert apps_run2([{ 'red': 8, 'green': 1, 'blue': 4, 'yellow': 2, 'purple': 3 }]) == [9]"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "APPS/0100-4", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nYou have three piles of candies: red, green and blue candies:  the first pile contains only red candies and there are $r$ candies in it,  the second pile contains only green candies and there are $g$ candies in it,  the third pile contains only blue candies and there are $b$ candies in it. \n\nEach day Tanya eats exactly two candies of different colors. She is free to choose the colors of eaten candies: the only restriction that she can't eat two candies of the same color in a day.\n\nFind the maximal number of days Tanya can eat candies? Each day she needs to eat exactly two candies.\n\n\n-----Input-----\n\nThe first line contains integer $t$ ($1 \\le t \\le 1000$) \u2014 the number of test cases in the input. Then $t$ test cases follow.\n\nEach test case is given as a separate line of the input. It contains three integers $r$, $g$ and $b$ ($1 \\le r, g, b \\le 10^8$) \u2014 the number of red, green and blue candies, respectively.\n\n\n-----Output-----\n\nPrint $t$ integers: the $i$-th printed integer is the answer on the $i$-th test case in the input.\n\n\n-----Example-----\nInput\n6\n1 1 1\n1 2 1\n4 1 1\n7 4 10\n8 1 4\n8 2 8\n\nOutput\n1\n2\n2\n10\n5\n9\n\n\n\n-----Note-----\n\nIn the first example, Tanya can eat candies for one day only. She can eat any pair of candies this day because all of them have different colors.\n\nIn the second example, Tanya can eat candies for two days. For example, she can eat red and green candies on the first day, and green and blue candies on the second day.\n\nIn the third example, Tanya can eat candies for two days. For example, she can eat red and green candies on the first day, and red and blue candies on the second day. Note, that two red candies will remain uneaten.", "raw_solution": "def apps_run1(n, cases):\n    results = []\n    for i in range(n):\n        a, b, c = cases[i]\n        results.append(min((a+b+c)//2, a+b, a+c, b+c))\n    return results", "raw_test_input": ["assert apps_run1(6, [(1, 1, 1), (1, 2, 1), (4, 1, 1), (7, 4, 10), (8, 1, 4), (8, 2, 8)]) == [1, 2, 2, 10, 5, 9]", "assert apps_run1(5, [(2, 2, 2), (3, 5, 1), (10, 10, 10), (6, 3, 2), (1, 1, 10)]) == [3, 4, 15, 5, 2]", "assert apps_run1(4, [(1, 3, 5), (2, 2, 2), (9, 1, 1), (4, 4, 4)]) == [4, 3, 2, 6]", "assert apps_run1(3, [(5, 5, 1), (10, 1, 1), (7, 7, 7)]) == [5, 2, 10]", "assert apps_run1(6, [(3, 6, 9), (8, 3, 2), (4, 4, 1), (5, 5, 5), (2, 2, 10), (1, 3, 3)]) == [9, 5, 4, 7, 4, 3]", "assert apps_run1(2, [(1, 1, 10), (10, 10, 10)]) == [2, 15]"], "new_problem": "You are managing a candy distribution system where Tanya eats candies from three piles: red, green, and blue. Each day, she eats exactly two candies of different colors. However, due to a system error, sometimes the input data might be corrupted or invalid. Your task is to write a function that calculates the maximum number of days Tanya can eat candies, while handling the following errors: 1. Invalid number of test cases (t < 1 or t > 1000). 2. Invalid number of candies (r, g, b < 1 or r, g, b > 10^8). 3. Non-integer inputs. 4. Missing or extra inputs. You should define specific error types for these scenarios and ensure meaningful error messages are provided. The function should propagate errors appropriately and maintain type hints.", "new_solution": "from typing import List, Tuple\nclass CandyError(Exception):\n    pass\nclass InvalidTestCaseError(CandyError):\n    def __init__(self, message=\"Invalid number of test cases.\"):\n        self.message = message\n        super().__init__(self.message)\nclass InvalidCandyCountError(CandyError):\n    def __init__(self, message=\"Invalid number of candies.\"):\n        self.message = message\n        super().__init__(self.message)\nclass NonIntegerInputError(CandyError):\n    def __init__(self, message=\"Non-integer input detected.\"):\n        self.message = message\n        super().__init__(self.message)\nclass MissingOrExtraInputError(CandyError):\n    def __init__(self, message=\"Missing or extra input detected.\"):\n        self.message = message\n        super().__init__(self.message)\ndef apps_run2(t: int, test_cases: List[Tuple[int, int, int]]) -> List[int]:\n    if not (1 <= t <= 1000):\n        raise InvalidTestCaseError()\n    results = []\n    for case in test_cases:\n        if len(case) != 3:\n            raise MissingOrExtraInputError()\n        if not all(isinstance(x, int) for x in case):\n            raise NonIntegerInputError()\n        r, g, b = case\n        if not (1 <= r <= 10**8) or not (1 <= g <= 10**8) or not (1 <= b <= 10**8):\n            raise InvalidCandyCountError()\n        results.append(min((r + g + b) // 2, r + g, r + b, g + b))\n    return results", "input_format": "max_days_tanya_can_eat parameters: First test function (standard input): - t: Integer (1 \u2264 t \u2264 1000) representing the number of test cases - test_cases: List of tuples (r, g, b) where: - r: Integer (1 \u2264 r \u2264 10^8) number of red candies - g: Integer (1 \u2264 g \u2264 10^8) number of green candies - b: Integer (1 \u2264 b \u2264 10^8) number of blue candies Second test function (error testing): - t: Integer used to test invalid values outside range (1 \u2264 t \u2264 1000) - test_cases: List containing single tuple with various invalid inputs to test error handling: - Missing values (less than 3 integers) - Non-integer values - Values outside range (> 10^8)", "output_format": "Print t integers: the i-th printed integer is the answer on the i-th test case in the input.", "test_input": ["assert apps_run2(6, [(1, 1, 1), (1, 2, 1), (4, 1, 1), (7, 4, 10), (8, 1, 4), (8, 2, 8)]) == [1, 2, 2, 10, 5, 9]", "try:\n    apps_run2(0, [(1, 1, 1)])\nexcept InvalidTestCaseError as e:\n    assert str(e) == \"Invalid number of test cases.\"", "try:\n    apps_run2(1, [(1, 1)])\nexcept MissingOrExtraInputError as e:\n    assert str(e) == \"Missing or extra input detected.\"", "try:\n    apps_run2(1, [(1, 1, 1000000000)])\nexcept InvalidCandyCountError as e:\n    assert str(e) == \"Invalid number of candies.\"", "try:\n    apps_run2(1, [(1, 'a', 1)])\nexcept NonIntegerInputError as e:\n    assert str(e) == \"Non-integer input detected.\""], "requirement_type": "PROMPT_ERROR_HANDLING"}
{"task_id": "APPS/0107-1", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nChaneka has a hobby of playing with animal toys. Every toy has a different fun value, a real number. Chaneka has four boxes to store the toys with specification:   The first box stores toys with fun values in range of $(-\\infty,-1]$.  The second box stores toys with fun values in range of $(-1, 0)$.  The third box stores toys with fun values in range of $(0, 1)$.  The fourth box stores toys with fun value in range of $[1, \\infty)$. \n\nChaneka has $A$, $B$, $C$, $D$ toys in the first, second, third, and fourth box, respectively. One day she decides that she only wants one toy, a super toy. So she begins to create this super toy by sewing all the toys she has.\n\nWhile the number of toys Chaneka has is more than 1, she takes two different toys randomly and then sews them together, creating a new toy. The fun value of this new toy is equal to the multiplication of fun values of the sewn toys. She then puts this new toy in the appropriate box. She repeats this process until she only has one toy. This last toy is the super toy, and the box that stores this toy is the special box.\n\nAs an observer, you only know the number of toys in each box initially but do not know their fun values. You also don't see the sequence of Chaneka's sewing. Determine which boxes can be the special box after Chaneka found her super toy.\n\n\n-----Input-----\n\nThe first line has an integer $T$ $(1 \\le T \\le 5 \\cdot 10^4)$, the number of test cases.\n\nEvery case contains a line with four space-separated integers $A$ $B$ $C$ $D$ $(0 \\le A, B, C, D \\le 10^6, A + B + C + D > 0)$, which denotes the number of toys in the first, second, third, and fourth box, respectively.\n\n\n-----Output-----\n\nFor each case, print four space-separated strings. Each string represents the possibility that the first, second, third, and fourth box can be the special box from left to right.\n\nFor each box, print \"Ya\" (Without quotes, Indonesian for yes) if that box can be the special box. Print \"Tidak\" (Without quotes, Indonesian for No) otherwise.\n\n\n-----Example-----\nInput\n2\n1 2 0 1\n0 1 0 0\n\nOutput\nYa Ya Tidak Tidak\nTidak Ya Tidak Tidak\n\n\n\n-----Note-----\n\nFor the first case, here is a scenario where the first box is the special box:   The first box had toys with fun values $\\{-3\\}$.  The second box had toys with fun values $\\{ -0.5, -0.5 \\}$  The fourth box had toys with fun values $\\{ 3 \\}$ \n\nThe sewing sequence:   Chaneka sews the toy with fun $-0.5$ and $-0.5$ to a toy with fun $0.25$ and then put it in the third box.  Chaneka sews the toy with fun $-3$ and $0.25$ to a toy with fun $-0.75$ and then put it in the second box.  Chaneka sews the toy with fun $-0.75$ and $3$ to a toy with fun $-1.25$ and then put it in the first box, which then became the special box. \n\nHere is a scenario where the second box ends up being the special box:   The first box had toys with fun values $\\{-3\\}$  The second box had toys with fun values $\\{ -0.33, -0.25 \\}$.  The fourth box had toys with fun values $\\{ 3 \\}$. \n\nThe sewing sequence:   Chaneka sews the toy with fun $-3$ and $-0.33$ to a toy with fun $0.99$ and then put it in the third box.  Chaneka sews the toy with fun $0.99$ and $3$ to a toy with fun $2.97$ and then put in it the fourth box.  Chaneka sews the toy with fun $2.97$ and $-0.25$ to a toy with fun $-0.7425$ and then put it in the second box, which then became the special box.  There is only one toy for the second case, so Chaneka does not have to sew anything because that toy, by definition, is the super toy.", "raw_solution": "def apps_run1(t, test_cases):\n    results = []\n    for i in range(t):\n        a, b, c, d = test_cases[i]\n        sgn = (a + b) % 2\n        small = False\n        large = False\n        if a == 0 and d == 0:\n            small = True\n        if b == 0 and c == 0:\n            large = True\n        okay = [True] * 4\n        if sgn == 0:\n            okay[0] = False\n            okay[1] = False\n        else:\n            okay[2] = False\n            okay[3] = False\n        if small:\n            okay[0] = False\n            okay[3] = False\n        if large:\n            okay[1] = False\n            okay[2] = False\n        results.append(' '.join(['Ya' if okay[i] else 'Tidak' for i in range(4)]))\n    return results\n", "raw_test_input": ["assert apps_run1(2, [(1, 2, 0, 1), (0, 1, 0, 0)]) == ['Ya Ya Tidak Tidak', 'Tidak Ya Tidak Tidak']", "assert apps_run1(3, [(2, 0, 1, 1), (0, 0, 1, 3), (1, 1, 1, 1)]) == ['Tidak Tidak Ya Ya', 'Tidak Tidak Ya Ya', 'Tidak Tidak Ya Ya']", "assert apps_run1(2, [(0, 2, 2, 0), (3, 0, 0, 1)]) == ['Tidak Tidak Ya Tidak', 'Ya Tidak Tidak Tidak']"], "new_problem": "Chaneka is now running a toy store where she receives new toys every day. Each day, she receives a certain number of toys with random fun values, and she needs to decide which box to place them in. After placing the toys, she performs the sewing operation as described in the original problem. Given the initial number of toys in each box and the number of days she will receive new toys, determine which boxes can be the special box after all operations are completed.", "new_solution": "def determine_special_box(a, b, c, d):\n    sgn = (a + b) % 2\n    small = False\n    large = False\n    if a == 0 and d == 0:\n        small = True\n    if b == 0 and c == 0:\n        large = True\n    okay = [True] * 4\n    if sgn == 0:\n        okay[0] = False\n        okay[1] = False\n    else:\n        okay[2] = False\n        okay[3] = False\n    if small:\n        okay[0] = False\n        okay[3] = False\n    if large:\n        okay[1] = False\n        okay[2] = False\n    return okay\n\ndef apps_run2(t, test_cases):\n    results = []\n    for i in range(t):\n        a, b, c, d = test_cases[i][:4]\n        n = test_cases[i][4]\n        # Simulate receiving new toys for N days\n        for _ in range(n):\n            # Assume random distribution of new toys\n            new_a, new_b, new_c, new_d = 1, 1, 1, 1  # Simplified for demonstration\n            a += new_a\n            b += new_b\n            c += new_c\n            d += new_d\n        # Determine the special box after all operations\n        result = determine_special_box(a, b, c, d)\n        results.append(\" \".join([\"Ya\" if res else \"Tidak\" for res in result]))\n    return results", "input_format": "toy_store_simulation parameters: - t: Integer (1 \u2264 t \u2264 5*10^4) representing number of test cases - test_cases: List of tuples (a, b, c, d, n) where: - a: Integer (0 \u2264 a \u2264 10^6) number of toys in first box (range (-\u221e,-1]) - b: Integer (0 \u2264 b \u2264 10^6) number of toys in second box (range (-1,0)) - c: Integer (0 \u2264 c \u2264 10^6) number of toys in third box (range (0,1)) - d: Integer (0 \u2264 d \u2264 10^6) number of toys in fourth box (range [1,\u221e)) - n: Integer (1 \u2264 n \u2264 10^6) number of simulation days - Sum of a + b + c + d must be greater than 0", "output_format": "For each test case, output four space-separated strings. Each string represents the possibility that the first, second, third, and fourth box can be the special box after N days. For each box, print 'Ya' if that box can be the special box, otherwise print 'Tidak'.", "test_input": ["assert apps_run2(1, [(1, 2, 0, 1, 1)]) == ['Ya Ya Tidak Tidak']", "assert apps_run2(1, [(0, 1, 0, 0, 2)]) == ['Ya Ya Tidak Tidak']", "assert apps_run2(1, [(2, 0, 1, 1, 3)]) == ['Tidak Tidak Ya Ya']", "assert apps_run2(1, [(0, 0, 0, 1, 1)]) == ['Tidak Tidak Ya Ya']", "assert apps_run2(1, [(1, 1, 1, 1, 0)]) == ['Tidak Tidak Ya Ya']"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "APPS/0107-2", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nChaneka has a hobby of playing with animal toys. Every toy has a different fun value, a real number. Chaneka has four boxes to store the toys with specification:   The first box stores toys with fun values in range of $(-\\infty,-1]$.  The second box stores toys with fun values in range of $(-1, 0)$.  The third box stores toys with fun values in range of $(0, 1)$.  The fourth box stores toys with fun value in range of $[1, \\infty)$. \n\nChaneka has $A$, $B$, $C$, $D$ toys in the first, second, third, and fourth box, respectively. One day she decides that she only wants one toy, a super toy. So she begins to create this super toy by sewing all the toys she has.\n\nWhile the number of toys Chaneka has is more than 1, she takes two different toys randomly and then sews them together, creating a new toy. The fun value of this new toy is equal to the multiplication of fun values of the sewn toys. She then puts this new toy in the appropriate box. She repeats this process until she only has one toy. This last toy is the super toy, and the box that stores this toy is the special box.\n\nAs an observer, you only know the number of toys in each box initially but do not know their fun values. You also don't see the sequence of Chaneka's sewing. Determine which boxes can be the special box after Chaneka found her super toy.\n\n\n-----Input-----\n\nThe first line has an integer $T$ $(1 \\le T \\le 5 \\cdot 10^4)$, the number of test cases.\n\nEvery case contains a line with four space-separated integers $A$ $B$ $C$ $D$ $(0 \\le A, B, C, D \\le 10^6, A + B + C + D > 0)$, which denotes the number of toys in the first, second, third, and fourth box, respectively.\n\n\n-----Output-----\n\nFor each case, print four space-separated strings. Each string represents the possibility that the first, second, third, and fourth box can be the special box from left to right.\n\nFor each box, print \"Ya\" (Without quotes, Indonesian for yes) if that box can be the special box. Print \"Tidak\" (Without quotes, Indonesian for No) otherwise.\n\n\n-----Example-----\nInput\n2\n1 2 0 1\n0 1 0 0\n\nOutput\nYa Ya Tidak Tidak\nTidak Ya Tidak Tidak\n\n\n\n-----Note-----\n\nFor the first case, here is a scenario where the first box is the special box:   The first box had toys with fun values $\\{-3\\}$.  The second box had toys with fun values $\\{ -0.5, -0.5 \\}$  The fourth box had toys with fun values $\\{ 3 \\}$ \n\nThe sewing sequence:   Chaneka sews the toy with fun $-0.5$ and $-0.5$ to a toy with fun $0.25$ and then put it in the third box.  Chaneka sews the toy with fun $-3$ and $0.25$ to a toy with fun $-0.75$ and then put it in the second box.  Chaneka sews the toy with fun $-0.75$ and $3$ to a toy with fun $-1.25$ and then put it in the first box, which then became the special box. \n\nHere is a scenario where the second box ends up being the special box:   The first box had toys with fun values $\\{-3\\}$  The second box had toys with fun values $\\{ -0.33, -0.25 \\}$.  The fourth box had toys with fun values $\\{ 3 \\}$. \n\nThe sewing sequence:   Chaneka sews the toy with fun $-3$ and $-0.33$ to a toy with fun $0.99$ and then put it in the third box.  Chaneka sews the toy with fun $0.99$ and $3$ to a toy with fun $2.97$ and then put in it the fourth box.  Chaneka sews the toy with fun $2.97$ and $-0.25$ to a toy with fun $-0.7425$ and then put it in the second box, which then became the special box.  There is only one toy for the second case, so Chaneka does not have to sew anything because that toy, by definition, is the super toy.", "raw_solution": "def apps_run1(t, test_cases):\n    results = []\n    for i in range(t):\n        a, b, c, d = test_cases[i]\n        sgn = (a + b) % 2\n        small = False\n        large = False\n        if a == 0 and d == 0:\n            small = True\n        if b == 0 and c == 0:\n            large = True\n        okay = [True] * 4\n        if sgn == 0:\n            okay[0] = False\n            okay[1] = False\n        else:\n            okay[2] = False\n            okay[3] = False\n        if small:\n            okay[0] = False\n            okay[3] = False\n        if large:\n            okay[1] = False\n            okay[2] = False\n        results.append(' '.join(['Ya' if okay[i] else 'Tidak' for i in range(4)]))\n    return results", "raw_test_input": ["assert apps_run1(2, [(1, 2, 0, 1), (0, 1, 0, 0)]) == ['Ya Ya Tidak Tidak', 'Tidak Ya Tidak Tidak']", "assert apps_run1(3, [(2, 0, 1, 1), (0, 0, 1, 3), (1, 1, 1, 1)]) == ['Tidak Tidak Ya Ya', 'Tidak Tidak Ya Ya', 'Tidak Tidak Ya Ya']", "assert apps_run1(2, [(0, 2, 2, 0), (3, 0, 0, 1)]) == ['Tidak Tidak Ya Tidak', 'Ya Tidak Tidak Tidak']"], "new_problem": "Chaneka has a hobby of playing with animal toys. Every toy has a different fun value, a real number. Chaneka has four boxes to store the toys with specification: The first box stores toys with fun values in range of $(-\\infty,-1]$. The second box stores toys with fun values in range of $(-1, 0)$. The third box stores toys with fun values in range of $(0, 1)$. The fourth box stores toys with fun value in range of $[1, \\infty)$. Chaneka has $A$, $B$, $C$, $D$ toys in the first, second, third, and fourth box, respectively. One day she decides that she only wants one toy, a super toy. So she begins to create this super toy by sewing all the toys she has. While the number of toys Chaneka has is more than 1, she takes two different toys randomly and then sews them together, creating a new toy. The fun value of this new toy is equal to the multiplication of fun values of the sewn toys. She then puts this new toy in the appropriate box. She repeats this process until she only has one toy. This last toy is the super toy, and the box that stores this toy is the special box. As an observer, you only know the number of toys in each box initially but do not know their fun values. You also don't see the sequence of Chaneka's sewing. Determine which boxes can be the special box after Chaneka found her super toy. Additionally, the function should now support an optional parameter 'verbose' (defaulting to False) that, when set to True, prints the intermediate steps of the decision process.", "new_solution": "from typing import List, Tuple\n\ndef apps_run2(t: int, cases: List[Tuple[int, int, int, int]], verbose: bool = False) -> List[str]:\n    results = []\n    for a, b, c, d in cases:\n        sgn = (a + b) % 2\n        small = False\n        large = False\n        if a == 0 and d == 0:\n            small = True\n        if b == 0 and c == 0:\n            large = True\n        okay = [True] * 4\n        if sgn == 0:\n            okay[0] = False\n            okay[1] = False\n        else:\n            okay[2] = False\n            okay[3] = False\n        if small:\n            okay[0] = False\n            okay[3] = False\n        if large:\n            okay[1] = False\n            okay[2] = False\n        result = \" \".join([\"Ya\" if okay[i] else \"Tidak\" for i in range(4)])\n        if verbose:\n            print(f\"Case (A={a}, B={b}, C={c}, D={d}): {result}\")\n        results.append(result)\n    return results", "input_format": "determine_special_boxes parameters: - t: Integer (1 \u2264 t \u2264 5*10^4) representing number of test cases - cases: List of tuples (a, b, c, d) where: - a: Integer (0 \u2264 a \u2264 10^6) number of toys in first box (range (-\u221e,-1]) - b: Integer (0 \u2264 b \u2264 10^6) number of toys in second box (range (-1,0)) - c: Integer (0 \u2264 c \u2264 10^6) number of toys in third box (range (0,1)) - d: Integer (0 \u2264 d \u2264 10^6) number of toys in fourth box (range [1,\u221e)) - Sum of a + b + c + d must be greater than 0 - verbose: Optional boolean parameter (defaults to False) that controls printing of intermediate steps", "output_format": "For each case, print four space-separated strings. Each string represents the possibility that the first, second, third, and fourth box can be the special box from left to right. For each box, print 'Ya' if that box can be the special box. Print 'Tidak' otherwise.", "test_input": ["assert apps_run2(2, [(1, 2, 0, 1), (0, 1, 0, 0)]) == ['Ya Ya Tidak Tidak', 'Tidak Ya Tidak Tidak']", "assert apps_run2(1, [(0, 0, 1, 1)]) == ['Tidak Tidak Ya Ya']", "assert apps_run2(1, [(1, 0, 0, 0)]) == ['Ya Tidak Tidak Tidak']", "assert apps_run2(1, [(0, 0, 0, 1)]) == ['Tidak Tidak Tidak Ya']", "assert apps_run2(1, [(2, 2, 2, 2)]) == ['Tidak Tidak Ya Ya']"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "APPS/0107-3", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nChaneka has a hobby of playing with animal toys. Every toy has a different fun value, a real number. Chaneka has four boxes to store the toys with specification:   The first box stores toys with fun values in range of $(-\\infty,-1]$.  The second box stores toys with fun values in range of $(-1, 0)$.  The third box stores toys with fun values in range of $(0, 1)$.  The fourth box stores toys with fun value in range of $[1, \\infty)$. \n\nChaneka has $A$, $B$, $C$, $D$ toys in the first, second, third, and fourth box, respectively. One day she decides that she only wants one toy, a super toy. So she begins to create this super toy by sewing all the toys she has.\n\nWhile the number of toys Chaneka has is more than 1, she takes two different toys randomly and then sews them together, creating a new toy. The fun value of this new toy is equal to the multiplication of fun values of the sewn toys. She then puts this new toy in the appropriate box. She repeats this process until she only has one toy. This last toy is the super toy, and the box that stores this toy is the special box.\n\nAs an observer, you only know the number of toys in each box initially but do not know their fun values. You also don't see the sequence of Chaneka's sewing. Determine which boxes can be the special box after Chaneka found her super toy.\n\n\n-----Input-----\n\nThe first line has an integer $T$ $(1 \\le T \\le 5 \\cdot 10^4)$, the number of test cases.\n\nEvery case contains a line with four space-separated integers $A$ $B$ $C$ $D$ $(0 \\le A, B, C, D \\le 10^6, A + B + C + D > 0)$, which denotes the number of toys in the first, second, third, and fourth box, respectively.\n\n\n-----Output-----\n\nFor each case, print four space-separated strings. Each string represents the possibility that the first, second, third, and fourth box can be the special box from left to right.\n\nFor each box, print \"Ya\" (Without quotes, Indonesian for yes) if that box can be the special box. Print \"Tidak\" (Without quotes, Indonesian for No) otherwise.\n\n\n-----Example-----\nInput\n2\n1 2 0 1\n0 1 0 0\n\nOutput\nYa Ya Tidak Tidak\nTidak Ya Tidak Tidak\n\n\n\n-----Note-----\n\nFor the first case, here is a scenario where the first box is the special box:   The first box had toys with fun values $\\{-3\\}$.  The second box had toys with fun values $\\{ -0.5, -0.5 \\}$  The fourth box had toys with fun values $\\{ 3 \\}$ \n\nThe sewing sequence:   Chaneka sews the toy with fun $-0.5$ and $-0.5$ to a toy with fun $0.25$ and then put it in the third box.  Chaneka sews the toy with fun $-3$ and $0.25$ to a toy with fun $-0.75$ and then put it in the second box.  Chaneka sews the toy with fun $-0.75$ and $3$ to a toy with fun $-1.25$ and then put it in the first box, which then became the special box. \n\nHere is a scenario where the second box ends up being the special box:   The first box had toys with fun values $\\{-3\\}$  The second box had toys with fun values $\\{ -0.33, -0.25 \\}$.  The fourth box had toys with fun values $\\{ 3 \\}$. \n\nThe sewing sequence:   Chaneka sews the toy with fun $-3$ and $-0.33$ to a toy with fun $0.99$ and then put it in the third box.  Chaneka sews the toy with fun $0.99$ and $3$ to a toy with fun $2.97$ and then put in it the fourth box.  Chaneka sews the toy with fun $2.97$ and $-0.25$ to a toy with fun $-0.7425$ and then put it in the second box, which then became the special box.  There is only one toy for the second case, so Chaneka does not have to sew anything because that toy, by definition, is the super toy.", "raw_solution": "def apps_run1(t, test_cases):\n    results = []\n    for i in range(t):\n        a, b, c, d = test_cases[i]\n        sgn = (a + b) % 2\n        small = False\n        large = False\n        if a == 0 and d == 0:\n            small = True\n        if b == 0 and c == 0:\n            large = True\n        okay = [True] * 4\n        if sgn == 0:\n            okay[0] = False\n            okay[1] = False\n        else:\n            okay[2] = False\n            okay[3] = False\n        if small:\n            okay[0] = False\n            okay[3] = False\n        if large:\n            okay[1] = False\n            okay[2] = False\n        results.append(' '.join(['Ya' if okay[i] else 'Tidak' for i in range(4)]))\n    return results", "raw_test_input": ["assert apps_run1(2, [(1, 2, 0, 1), (0, 1, 0, 0)]) == ['Ya Ya Tidak Tidak', 'Tidak Ya Tidak Tidak']", "assert apps_run1(3, [(2, 0, 1, 1), (0, 0, 1, 3), (1, 1, 1, 1)]) == ['Tidak Tidak Ya Ya', 'Tidak Tidak Ya Ya', 'Tidak Tidak Ya Ya']", "assert apps_run1(2, [(0, 2, 2, 0), (3, 0, 0, 1)]) == ['Tidak Tidak Ya Tidak', 'Ya Tidak Tidak Tidak']", "assert apps_run1(1, [(1, 1, 1, 0)]) == ['Tidak Tidak Ya Ya']", "assert apps_run1(4, [(0, 0, 0, 1), (1, 0, 0, 0), (0, 1, 1, 1), (1, 2, 1, 0)]) == ['Tidak Tidak Tidak Ya', 'Ya Tidak Tidak Tidak', 'Ya Ya Tidak Tidak', 'Ya Ya Tidak Tidak']", "assert apps_run1(2, [(1, 2, 3, 0), (0, 0, 0, 2)]) == ['Ya Ya Tidak Tidak', 'Tidak Tidak Tidak Ya']"], "new_problem": "Chaneka has a hobby of playing with animal toys. Every toy has a different fun value, a real number. Chaneka has four boxes to store the toys with specification: The first box stores toys with fun values in range of $(-\\infty,-1]$. The second box stores toys with fun values in range of $(-1, 0)$. The third box stores toys with fun values in range of $(0, 1)$. The fourth box stores toys with fun value in range of $[1, \\infty)$. Chaneka has $A$, $B$, $C$, $D$ toys in the first, second, third, and fourth box, respectively. One day she decides that she only wants one toy, a super toy. So she begins to create this super toy by sewing all the toys she has. While the number of toys Chaneka has is more than 1, she takes two different toys randomly and then sews them together, creating a new toy. The fun value of this new toy is equal to the multiplication of fun values of the sewn toys. She then puts this new toy in the appropriate box. She repeats this process until she only has one toy. This last toy is the super toy, and the box that stores this toy is the special box. As an observer, you only know the number of toys in each box initially but do not know their fun values. You also don't see the sequence of Chaneka's sewing. Determine which boxes can be the special box after Chaneka found her super toy. However, this time, the toys are stored in a dictionary where the keys are the box numbers (1 to 4) and the values are lists of integers representing the number of toys in each box. Additionally, the number of toys in each box must be a prime number.", "new_solution": "def apps_run2(t, test_cases):\n    result=[]\n    for i in range(t):\n        a, b, c, d = test_cases[1][i], test_cases[2][i], test_cases[3][i], test_cases[4][i]\n        sgn = (a+b)%2\n        small = False\n        large = False\n        if a == 0 and d == 0:\n            small = True\n        if b == 0 and c == 0:\n            large = True\n        okay = [True] * 4\n        if sgn == 0:\n            okay[0] = False\n            okay[1] = False\n        else:\n            okay[2] = False\n            okay[3] = False\n        if small:\n            okay[0] = False\n            okay[3] = False\n        if large:\n            okay[1] = False\n            okay[2] = False\n\n        result.append([\"Ya\" if okay[i] else \"Tidak\" for i in range(4)])\n    return result", "input_format": "The first parameter is an integer T (1 \u2264 T \u2264 5 * 10^4), the number of test cases. The second parameter is a dictionary with the keys (int) 1, 2, 3, and 4 representing the first, second, third, and fourth boxes respectively, whose values are the number of toys in the different test cases for the corresponding boxes. ", "output_format": "The result returns a two-dimensional list, with the inner list being the output of each round of test cases. For each box, print ',Ya' if that box can be the special box. Print 'Tidak' otherwise.", "test_input": ["assert apps_run2(2, {1: [2,1], 2: [3,3], 3: [0,1], 4: [5,2]}) == [['Ya', 'Ya', 'Tidak', 'Tidak'], ['Tidak', 'Tidak', 'Ya', 'Ya']]", "assert apps_run2(1,{1: [0], 2: [3], 3: [0], 4: [0]}) == [['Tidak', 'Ya', 'Tidak', 'Tidak']]", "assert apps_run2(1,{1: [2], 2: [3], 3: [5], 4: [7]}) == [['Ya', 'Ya', 'Tidak', 'Tidak']]", "assert apps_run2(1,{1: [0], 2: [0], 3: [0], 4: [11]}) == [['Tidak', 'Tidak', 'Tidak', 'Ya']]", "assert apps_run2(1,{1: [13], 2: [17], 3: [19], 4: [23]}) == [['Tidak', 'Tidak', 'Ya', 'Ya']]"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "APPS/0107-4", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nChaneka has a hobby of playing with animal toys. Every toy has a different fun value, a real number. Chaneka has four boxes to store the toys with specification:   The first box stores toys with fun values in range of $(-\\infty,-1]$.  The second box stores toys with fun values in range of $(-1, 0)$.  The third box stores toys with fun values in range of $(0, 1)$.  The fourth box stores toys with fun value in range of $[1, \\infty)$. \n\nChaneka has $A$, $B$, $C$, $D$ toys in the first, second, third, and fourth box, respectively. One day she decides that she only wants one toy, a super toy. So she begins to create this super toy by sewing all the toys she has.\n\nWhile the number of toys Chaneka has is more than 1, she takes two different toys randomly and then sews them together, creating a new toy. The fun value of this new toy is equal to the multiplication of fun values of the sewn toys. She then puts this new toy in the appropriate box. She repeats this process until she only has one toy. This last toy is the super toy, and the box that stores this toy is the special box.\n\nAs an observer, you only know the number of toys in each box initially but do not know their fun values. You also don't see the sequence of Chaneka's sewing. Determine which boxes can be the special box after Chaneka found her super toy.\n\n\n-----Input-----\n\nThe first line has an integer $T$ $(1 \\le T \\le 5 \\cdot 10^4)$, the number of test cases.\n\nEvery case contains a line with four space-separated integers $A$ $B$ $C$ $D$ $(0 \\le A, B, C, D \\le 10^6, A + B + C + D > 0)$, which denotes the number of toys in the first, second, third, and fourth box, respectively.\n\n\n-----Output-----\n\nFor each case, print four space-separated strings. Each string represents the possibility that the first, second, third, and fourth box can be the special box from left to right.\n\nFor each box, print \"Ya\" (Without quotes, Indonesian for yes) if that box can be the special box. Print \"Tidak\" (Without quotes, Indonesian for No) otherwise.\n\n\n-----Example-----\nInput\n2\n1 2 0 1\n0 1 0 0\n\nOutput\nYa Ya Tidak Tidak\nTidak Ya Tidak Tidak\n\n\n\n-----Note-----\n\nFor the first case, here is a scenario where the first box is the special box:   The first box had toys with fun values $\\{-3\\}$.  The second box had toys with fun values $\\{ -0.5, -0.5 \\}$  The fourth box had toys with fun values $\\{ 3 \\}$ \n\nThe sewing sequence:   Chaneka sews the toy with fun $-0.5$ and $-0.5$ to a toy with fun $0.25$ and then put it in the third box.  Chaneka sews the toy with fun $-3$ and $0.25$ to a toy with fun $-0.75$ and then put it in the second box.  Chaneka sews the toy with fun $-0.75$ and $3$ to a toy with fun $-1.25$ and then put it in the first box, which then became the special box. \n\nHere is a scenario where the second box ends up being the special box:   The first box had toys with fun values $\\{-3\\}$  The second box had toys with fun values $\\{ -0.33, -0.25 \\}$.  The fourth box had toys with fun values $\\{ 3 \\}$. \n\nThe sewing sequence:   Chaneka sews the toy with fun $-3$ and $-0.33$ to a toy with fun $0.99$ and then put it in the third box.  Chaneka sews the toy with fun $0.99$ and $3$ to a toy with fun $2.97$ and then put in it the fourth box.  Chaneka sews the toy with fun $2.97$ and $-0.25$ to a toy with fun $-0.7425$ and then put it in the second box, which then became the special box.  There is only one toy for the second case, so Chaneka does not have to sew anything because that toy, by definition, is the super toy.", "raw_solution": "def apps_run1(t, test_cases):\n    results = []\n    for i in range(t):\n        a, b, c, d = test_cases[i]\n        sgn = (a + b) % 2\n        small = False\n        large = False\n        if a == 0 and d == 0:\n            small = True\n        if b == 0 and c == 0:\n            large = True\n        okay = [True] * 4\n        if sgn == 0:\n            okay[0] = False\n            okay[1] = False\n        else:\n            okay[2] = False\n            okay[3] = False\n        if small:\n            okay[0] = False\n            okay[3] = False\n        if large:\n            okay[1] = False\n            okay[2] = False\n        results.append(' '.join(['Ya' if okay[i] else 'Tidak' for i in range(4)]))\n    return results", "raw_test_input": ["assert apps_run1(2, [(1, 2, 0, 1), (0, 1, 0, 0)]) == ['Ya Ya Tidak Tidak', 'Tidak Ya Tidak Tidak']", "assert apps_run1(3, [(2, 0, 1, 1), (0, 0, 1, 3), (1, 1, 1, 1)]) == ['Tidak Tidak Ya Ya', 'Tidak Tidak Ya Ya', 'Tidak Tidak Ya Ya']", "assert apps_run1(2, [(0, 2, 2, 0), (3, 0, 0, 1)]) == ['Tidak Tidak Ya Tidak', 'Ya Tidak Tidak Tidak']", "assert apps_run1(1, [(1, 1, 1, 0)]) == ['Tidak Tidak Ya Ya']", "assert apps_run1(4, [(0, 0, 0, 1), (1, 0, 0, 0), (0, 1, 1, 1), (1, 2, 1, 0)]) == ['Tidak Tidak Tidak Ya', 'Ya Tidak Tidak Tidak', 'Ya Ya Tidak Tidak', 'Ya Ya Tidak Tidak']", "assert apps_run1(2, [(1, 2, 3, 0), (0, 0, 0, 2)]) == ['Ya Ya Tidak Tidak', 'Tidak Tidak Tidak Ya']"], "new_problem": "Chaneka's toy sewing process has been automated, but the system needs to handle potential errors in the input data. Write a function that determines which boxes can be the special box after Chaneka finds her super toy. The function should handle the following errors: 1. Invalid number of test cases (T < 1 or T > 5 * 10^4). 2. Invalid number of toys in any box (A, B, C, D < 0 or A, B, C, D > 10^6). 3. Sum of toys in all boxes is zero (A + B + C + D == 0). 4. Non-integer input values. Define specific error types for these scenarios and ensure meaningful error messages are provided. The function should propagate errors appropriately and maintain type hints.", "new_solution": "from typing import List, Tuple\n\nclass InvalidTestCaseError(Exception):\n    pass\n\nclass InvalidToyCountError(Exception):\n    pass\n\nclass ZeroToySumError(Exception):\n    pass\n\nclass NonIntegerInputError(Exception):\n    pass\n\ndef apps_run2(t: int, cases: List[Tuple[int, int, int, int]]) -> List[str]:\n    if not (1 <= t <= 5 * 10**4):\n        raise InvalidTestCaseError(\"Number of test cases must be between 1 and 50,000.\")\n    results = []\n    for case in cases:\n        if len(case) != 4:\n            raise NonIntegerInputError(\"Each case must contain exactly four integers.\")\n        a, b, c, d = case\n        if not all(isinstance(x, int) for x in (a, b, c, d)):\n            raise NonIntegerInputError(\"All inputs must be integers.\")\n        if not (0 <= a <= 10**6 and 0 <= b <= 10**6 and 0 <= c <= 10**6 and 0 <= d <= 10**6):\n            raise InvalidToyCountError(\"Each toy count must be between 0 and 1,000,000.\")\n        if a + b + c + d == 0:\n            raise ZeroToySumError(\"The sum of toys in all boxes must be greater than zero.\")\n        sgn = (a + b) % 2\n        small = False\n        large = False\n        if a == 0 and d == 0:\n            small = True\n        if b == 0 and c == 0:\n            large = True\n        okay = [True] * 4\n        if sgn == 0:\n            okay[0] = False\n            okay[1] = False\n        else:\n            okay[2] = False\n            okay[3] = False\n        if small:\n            okay[0] = False\n            okay[3] = False\n        if large:\n            okay[1] = False\n            okay[2] = False\n        results.append(\" \".join([\"Ya\" if okay[i] else \"Tidak\" for i in range(4)]))\n    return results", "input_format": "parameters: - t: Integer (1 \u2264 t \u2264 5*10^4) representing number of test cases - test_cases: List of tuples (a, b, c, d, n) where: - a: Integer (0 \u2264 a \u2264 10^6) number of toys in first box (range (-\u221e,-1]) - b: Integer (0 \u2264 b \u2264 10^6) number of toys in second box (range (-1,0)) - c: Integer (0 \u2264 c \u2264 10^6) number of toys in third box (range (0,1)) - d: Integer (0 \u2264 d \u2264 10^6) number of toys in fourth box (range [1,\u221e)) - n: Integer (1 \u2264 n \u2264 10^6) number of simulation days - Sum of a + b + c + d must be greater than 0", "output_format": "For each case, print four space-separated strings. Each string represents the possibility that the first, second, third, and fourth box can be the special box from left to right. For each box, print 'Ya' if that box can be the special box. Print 'Tidak' otherwise.", "test_input": ["assert apps_run2(2, [(1, 2, 0, 1), (0, 1, 0, 0)]) == ['Ya Ya Tidak Tidak', 'Tidak Ya Tidak Tidak']", "try:\n    apps_run2(0, [(1, 2, 0, 1)])\nexcept InvalidTestCaseError as e:\n    assert str(e) == 'Number of test cases must be between 1 and 50,000.'", "try:\n    apps_run2(1, [(1, 2, 0, 1000001)])\nexcept InvalidToyCountError as e:\n    assert str(e) == 'Each toy count must be between 0 and 1,000,000.'", "try:\n    apps_run2(1, [(0, 0, 0, 0)])\nexcept ZeroToySumError as e:\n    assert str(e) == 'The sum of toys in all boxes must be greater than zero.'", "try:\n    apps_run2(1, [(1, 2, 'a', 1)])\nexcept NonIntegerInputError as e:\n    assert str(e) == 'All inputs must be integers.'"], "requirement_type": "PROMPT_ERROR_HANDLING"}
{"task_id": "APPS/0106-1", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nThere are $n$ segments $[l_i, r_i]$ for $1 \\le i \\le n$. You should divide all segments into two non-empty groups in such way that there is no pair of segments from different groups which have at least one common point, or say that it's impossible to do it. Each segment should belong to exactly one group.\n\nTo optimize testing process you will be given multitest.\n\n\n-----Input-----\n\nThe first line contains one integer $T$ ($1 \\le T \\le 50000$) \u2014 the number of queries. Each query contains description of the set of segments. Queries are independent.\n\nFirst line of each query contains single integer $n$ ($2 \\le n \\le 10^5$) \u2014 number of segments. It is guaranteed that $\\sum{n}$ over all queries does not exceed $10^5$.\n\nThe next $n$ lines contains two integers $l_i$, $r_i$ per line ($1 \\le l_i \\le r_i \\le 2 \\cdot 10^5$) \u2014 the $i$-th segment.\n\n\n-----Output-----\n\nFor each query print $n$ integers $t_1, t_2, \\dots, t_n$ ($t_i \\in \\{1, 2\\}$) \u2014 for each segment (in the same order as in the input) $t_i$ equals $1$ if the $i$-th segment will belongs to the first group and $2$ otherwise.\n\nIf there are multiple answers, you can print any of them. If there is no answer, print $-1$.\n\n\n-----Example-----\nInput\n3\n2\n5 5\n2 3\n3\n3 5\n2 3\n2 3\n3\n3 3\n4 4\n5 5\n\nOutput\n2 1 \n-1\n1 1 2 \n\n\n\n-----Note-----\n\nIn the first query the first and the second segments should be in different groups, but exact numbers don't matter.\n\nIn the second query the third segment intersects with the first and the second segments, so they should be in the same group, but then the other group becomes empty, so answer is $-1$.\n\nIn the third query we can distribute segments in any way that makes groups non-empty, so any answer of $6$ possible is correct.", "raw_solution": "def apps_run1(t, test_cases):\n    results = []\n    for ti in range(t):\n        n = test_cases[ti][0]\n        lri = [None for _ in range(n)]\n        for i in range(n):\n            li, ri = test_cases[ti][1][i]\n            lri[i] = (li, ri, i)\n        lri.sort()\n        t = [None for _ in range(n)]\n        ct, t[lri[0][2]], eg = 1, 1, lri[0][1]\n        for i in range(1, n):\n            if lri[i][0] <= eg:\n                t[lri[i][2]] = ct\n                eg = max(eg, lri[i][1])\n            else:\n                ct = 3 - ct\n                t[lri[i][2]] = ct\n                eg = lri[i][1]\n        if all(ti == 1 for ti in t):\n            results.append(-1)\n        else:\n            results.append(t)\n    return results", "raw_test_input": ["assert apps_run1(3, [(2, [(5, 5), (2, 3)]), (3, [(3, 5), (2, 3), (2, 3)]), (3, [(3, 3), (4, 4), (5, 5)])]) == [[2, 1], -1, [1, 2, 1]]", "assert apps_run1(2, [(3, [(1, 2), (3, 4), (5, 6)]), (4, [(1, 3), (2, 5), (6, 7), (8, 9)])]) == [[1, 2, 1], [1, 1, 2, 1]]", "assert apps_run1(1, [(4, [(1, 4), (2, 3), (5, 6), (7, 8)])]) == [[1, 1, 2, 1]]", "assert apps_run1(2, [(5, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)]), (3, [(1, 2), (1, 3), (2, 4)])]) == [-1, -1]", "assert apps_run1(1, [(6, [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)])]) == [[1, 2, 1, 2, 1, 2]]", "assert apps_run1(3, [(2, [(1, 3), (4, 5)]), (3, [(1, 1), (2, 2), (3, 3)]), (4, [(1, 2), (2, 3), (3, 4), (4, 5)])]) == [[1, 2], [1, 2, 1], -1]"], "new_problem": "In a scheduling system, you have a set of time segments and a set of events. Each segment represents a time period during which a resource is occupied. You need to divide these segments into two non-empty groups such that no segments from different groups overlap. Additionally, for each event, determine which group can accommodate the event without overlapping with any segment in that group. If an event cannot be accommodated in either group, return -1 for that event. Each event has a start time and a duration, and it should not overlap with any segment in the group it is assigned to.", "new_solution": "def divide_segments(n, segments):\n    segments.sort()\n    t = [None for _ in range(n)]\n    ct, t[segments[0][2]], eg = 1, 1, segments[0][1]\n    for i in range(1, n):\n        if segments[i][0] <= eg:\n            t[segments[i][2]] = ct\n            eg = max(eg, segments[i][1])\n        else:\n            ct = 3 - ct\n            t[segments[i][2]] = ct\n            eg = segments[i][1]\n    if all(ti == 1 for ti in t):\n        return -1\n    else:\n        return t\n\ndef can_accommodate_event(event, group_segments):\n    e_start, e_duration = event\n    e_end = e_start + e_duration\n    for seg_start, seg_end in group_segments:\n        if not (e_end <= seg_start or e_start >= seg_end):\n            return False\n    return True\n\ndef apps_run2(T, queries):\n    results = []\n    for query in queries:\n        n, segments, m, events = query\n        indexed_segments = [(l, r, i) for i, (l, r) in enumerate(segments)]\n        group_assignment = divide_segments(n, indexed_segments)\n        if group_assignment == -1:\n            results.append((-1, [-1] * m))\n            continue\n        group1 = [segments[i] for i in range(n) if group_assignment[i] == 1]\n        group2 = [segments[i] for i in range(n) if group_assignment[i] == 2]\n        event_results = []\n        for event in events:\n            if can_accommodate_event(event, group1):\n                event_results.append(1)\n            elif can_accommodate_event(event, group2):\n                event_results.append(2)\n            else:\n                event_results.append(-1)\n        results.append((group_assignment, event_results))\n    return results", "input_format": "The first parameter is one integer T (1 \u2264 T \u2264 50000) \u2014 the number of queries.  The second parameter is a list of tuples, where each tuple represents a single query. Each query tuple contains the following elements \u2014 n: An integer representing the number of segments; segments: A list of tuples, where each tuple represents a segment. Each segment tuple contains two integers: the start time (l_i) and the end time (r_i) of the segment; m: An integer representing the number of events; events: A list of tuples, where each tuple represents an event. Each event tuple contains two integers: the start time (e_i) and the duration (d_i) of the event.", "output_format": "The function returns a list of results, where each result corresponds to a query. Each result is a tuple containing:\\n1. A list of integers (1 or 2) indicating the group assignment for each segment, or -1 if no valid assignment is possible.\\n2. A list of integers (1, 2, or -1) indicating which group can accommodate each event, or -1 if the event cannot be accommodated in either group.", "test_input": ["assert apps_run2(1, [(3, [(1, 3), (4, 6), (7, 9)], 2, [(2, 1), (5, 1)])]) == [([1, 2, 1], [2, 1])]", "assert apps_run2(1, [(2, [(1, 5), (6, 10)], 1, [(3, 2)])]) == [([1, 2], [2])]", "assert apps_run2(1, [(4, [(1, 2), (3, 4), (5, 6), (7, 8)], 3, [(2, 1), (4, 1), (6, 1)])]) == [([1, 2, 1, 2], [1, 1, 1])]", "assert apps_run2(1, [(2, [(1, 10), (2, 9)], 1, [(5, 1)])]) == [(-1, [-1])]", "assert apps_run2(1, [(3, [(1, 3), (4, 6), (5, 7)], 2, [(2, 1), (6, 1)])]) == [([1, 2, 2], [2, 1])]"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "APPS/0106-2", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nThere are $n$ segments $[l_i, r_i]$ for $1 \\le i \\le n$. You should divide all segments into two non-empty groups in such way that there is no pair of segments from different groups which have at least one common point, or say that it's impossible to do it. Each segment should belong to exactly one group.\n\nTo optimize testing process you will be given multitest.\n\n\n-----Input-----\n\nThe first line contains one integer $T$ ($1 \\le T \\le 50000$) \u2014 the number of queries. Each query contains description of the set of segments. Queries are independent.\n\nFirst line of each query contains single integer $n$ ($2 \\le n \\le 10^5$) \u2014 number of segments. It is guaranteed that $\\sum{n}$ over all queries does not exceed $10^5$.\n\nThe next $n$ lines contains two integers $l_i$, $r_i$ per line ($1 \\le l_i \\le r_i \\le 2 \\cdot 10^5$) \u2014 the $i$-th segment.\n\n\n-----Output-----\n\nFor each query print $n$ integers $t_1, t_2, \\dots, t_n$ ($t_i \\in \\{1, 2\\}$) \u2014 for each segment (in the same order as in the input) $t_i$ equals $1$ if the $i$-th segment will belongs to the first group and $2$ otherwise.\n\nIf there are multiple answers, you can print any of them. If there is no answer, print $-1$.\n\n\n-----Example-----\nInput\n3\n2\n5 5\n2 3\n3\n3 5\n2 3\n2 3\n3\n3 3\n4 4\n5 5\n\nOutput\n2 1 \n-1\n1 1 2 \n\n\n\n-----Note-----\n\nIn the first query the first and the second segments should be in different groups, but exact numbers don't matter.\n\nIn the second query the third segment intersects with the first and the second segments, so they should be in the same group, but then the other group becomes empty, so answer is $-1$.\n\nIn the third query we can distribute segments in any way that makes groups non-empty, so any answer of $6$ possible is correct.", "raw_solution": "def apps_run1(t, test_cases):\n    results = []\n    for ti in range(t):\n        n = test_cases[ti][0]\n        lri = [None for _ in range(n)]\n        for i in range(n):\n            li, ri = test_cases[ti][1][i]\n            lri[i] = (li, ri, i)\n        lri.sort()\n        t = [None for _ in range(n)]\n        ct, t[lri[0][2]], eg = 1, 1, lri[0][1]\n        for i in range(1, n):\n            if lri[i][0] <= eg:\n                t[lri[i][2]] = ct\n                eg = max(eg, lri[i][1])\n            else:\n                ct = 3 - ct\n                t[lri[i][2]] = ct\n                eg = lri[i][1]\n        if all(ti == 1 for ti in t):\n            results.append(-1)\n        else:\n            results.append(t)\n    return results", "raw_test_input": ["assert apps_run1(3, [(2, [(5, 5), (2, 3)]), (3, [(3, 5), (2, 3), (2, 3)]), (3, [(3, 3), (4, 4), (5, 5)])]) == [[2, 1], -1, [1, 2, 1]]", "assert apps_run1(2, [(3, [(1, 2), (3, 4), (5, 6)]), (4, [(1, 3), (2, 5), (6, 7), (8, 9)])]) == [[1, 2, 1], [1, 1, 2, 1]]", "assert apps_run1(1, [(4, [(1, 4), (2, 3), (5, 6), (7, 8)])]) == [[1, 1, 2, 1]]", "assert apps_run1(2, [(5, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)]), (3, [(1, 2), (1, 3), (2, 4)])]) == [-1, -1]", "assert apps_run1(1, [(6, [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)])]) == [[1, 2, 1, 2, 1, 2]]", "assert apps_run1(3, [(2, [(1, 3), (4, 5)]), (3, [(1, 1), (2, 2), (3, 3)]), (4, [(1, 2), (2, 3), (3, 4), (4, 5)])]) == [[1, 2], [1, 2, 1], -1]"], "new_problem": "Enhance the function to support an optional parameter that allows specifying a preferred group for segments that can belong to either group. The function should maintain backward compatibility, meaning it should work without the optional parameter as before. The new parameter should be a list of integers where each integer is either 1 or 2, indicating the preferred group for the corresponding segment. If the preferred group is not possible due to constraints, the function should still find a valid grouping if possible.", "new_solution": "from typing import List, Tuple, Optional\n\ndef apps_run2(t: int, queries: List[Tuple[int, List[Tuple[int, int]]]], preferred_groups: Optional[List[List[int]]] = None) -> List[List[int]]:\n    results = []\n    for ti in range(t):\n        n = queries[ti][0]\n        lri = [(li, ri, idx) for idx, (li, ri) in enumerate(queries[ti][1])]\n        lri.sort()\n\n        t = [None for _ in range(n)]\n        ct, t[lri[0][2]], eg = 1, 1, lri[0][1]\n\n        for i in range(1, n):\n            if lri[i][0] <= eg:\n                t[lri[i][2]] = ct\n                eg = max(eg, lri[i][1])\n            else:\n                ct = 3 - ct\n                t[lri[i][2]] = ct\n                eg = lri[i][1]\n\n        if all(ti == 1 for ti in t):\n            results.append([-1])\n        else:\n            if preferred_groups and preferred_groups[ti]:\n                for idx, pref in enumerate(preferred_groups[ti]):\n                    if t[idx] != pref:\n                        # Try to swap if possible\n                        if t[idx] == 1 and 2 in t:\n                            t[idx] = 2\n                        elif t[idx] == 2 and 1 in t:\n                            t[idx] = 1\n            results.append(t)\n    return results", "input_format": "1. the first parameter (int):  \n   - Represents the number of queries.  \n   - Constraints: 1 \u2264 t \u2264 50000.\n\n2. the second parameter (List[Tuple[int, List[Tuple[int, int]]]):  \n   - A list of queries, where each query is a tuple containing:  \n     - n (int): The number of segments in the query.  \n     - segments (List[Tuple[int, int]]): A list of tuples, where each tuple represents a segment. Each segment tuple contains two integers:  \n       - l_i: The start time of the segment.  \n       - r_i: The end time of the segment.  \n   - Constraints:  \n     - 2 \u2264 n \u2264 10^5 for each query.  \n     - The sum of n across all queries does not exceed 10^5.  \n     - 1 \u2264 l_i \u2264 r_i \u2264 2 * 10^5 for each segment.\n\n3. the third parameter (Optional[List[List[int]]]):  \n   - An optional parameter that allows specifying preferred groups for each segment.  \n   - If provided, it should be a list of lists, where each inner list corresponds to a query and contains integers 1 or 2 indicating the preferred group for each segment in that query.  \n   - If not provided, the function behaves as before, assigning groups without considering preferences.  \n   - Constraints:  \n     - The length of preferred_groups must match the number of queries.  \n     - Each inner list must have a length equal to the number of segments in the corresponding query.", "output_format": "The function returns a list of results, where each result corresponds to a query. Each result is a list of integers (1, 2, or -1), indicating the group assignment for each segment or -1 if no valid assignment is possible.", "test_input": ["assert apps_run2(3, [(2, [(5, 5), (2, 3)]), (3, [(3, 5), (2, 3), (2, 3)]), (3, [(3, 3), (4, 4), (5, 5)])]) == [[2, 1], [-1], [1, 2, 1]]", "assert apps_run2(1, [(3, [(1, 2), (3, 4), (5, 6)])], [[1, 2, 1]]) == [[1, 2, 1]]", "assert apps_run2(1, [(3, [(1, 2), (2, 3), (3, 4)])], [[1, 1, 2]]) == [[-1]]", "assert apps_run2(1, [(4, [(1, 3), (2, 4), (5, 6), (7, 8)])], [[1, 2, 1, 2]]) == [[1, 2, 1, 2]]", "assert apps_run2(1, [(2, [(1, 5), (6, 10)])], [[2, 1]]) == [[2, 2]]"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "APPS/0106-3", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nThere are $n$ segments $[l_i, r_i]$ for $1 \\le i \\le n$. You should divide all segments into two non-empty groups in such way that there is no pair of segments from different groups which have at least one common point, or say that it's impossible to do it. Each segment should belong to exactly one group.\n\nTo optimize testing process you will be given multitest.\n\n\n-----Input-----\n\nThe first line contains one integer $T$ ($1 \\le T \\le 50000$) \u2014 the number of queries. Each query contains description of the set of segments. Queries are independent.\n\nFirst line of each query contains single integer $n$ ($2 \\le n \\le 10^5$) \u2014 number of segments. It is guaranteed that $\\sum{n}$ over all queries does not exceed $10^5$.\n\nThe next $n$ lines contains two integers $l_i$, $r_i$ per line ($1 \\le l_i \\le r_i \\le 2 \\cdot 10^5$) \u2014 the $i$-th segment.\n\n\n-----Output-----\n\nFor each query print $n$ integers $t_1, t_2, \\dots, t_n$ ($t_i \\in \\{1, 2\\}$) \u2014 for each segment (in the same order as in the input) $t_i$ equals $1$ if the $i$-th segment will belongs to the first group and $2$ otherwise.\n\nIf there are multiple answers, you can print any of them. If there is no answer, print $-1$.\n\n\n-----Example-----\nInput\n3\n2\n5 5\n2 3\n3\n3 5\n2 3\n2 3\n3\n3 3\n4 4\n5 5\n\nOutput\n2 1 \n-1\n1 1 2 \n\n\n\n-----Note-----\n\nIn the first query the first and the second segments should be in different groups, but exact numbers don't matter.\n\nIn the second query the third segment intersects with the first and the second segments, so they should be in the same group, but then the other group becomes empty, so answer is $-1$.\n\nIn the third query we can distribute segments in any way that makes groups non-empty, so any answer of $6$ possible is correct.", "raw_solution": "def apps_run1(t, test_cases):\n    results = []\n    for ti in range(t):\n        n = test_cases[ti][0]\n        lri = [None for _ in range(n)]\n        for i in range(n):\n            li, ri = test_cases[ti][1][i]\n            lri[i] = (li, ri, i)\n        lri.sort()\n        t = [None for _ in range(n)]\n        ct, t[lri[0][2]], eg = 1, 1, lri[0][1]\n        for i in range(1, n):\n            if lri[i][0] <= eg:\n                t[lri[i][2]] = ct\n                eg = max(eg, lri[i][1])\n            else:\n                ct = 3 - ct\n                t[lri[i][2]] = ct\n                eg = lri[i][1]\n        if all(ti == 1 for ti in t):\n            results.append(-1)\n        else:\n            results.append(t)\n    return results", "raw_test_input": ["assert apps_run1(3, [(2, [(5, 5), (2, 3)]), (3, [(3, 5), (2, 3), (2, 3)]), (3, [(3, 3), (4, 4), (5, 5)])]) == [[2, 1], -1, [1, 2, 1]]", "assert apps_run1(2, [(3, [(1, 2), (3, 4), (5, 6)]), (4, [(1, 3), (2, 5), (6, 7), (8, 9)])]) == [[1, 2, 1], [1, 1, 2, 1]]", "assert apps_run1(1, [(4, [(1, 4), (2, 3), (5, 6), (7, 8)])]) == [[1, 1, 2, 1]]", "assert apps_run1(2, [(5, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)]), (3, [(1, 2), (1, 3), (2, 4)])]) == [-1, -1]", "assert apps_run1(1, [(6, [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)])]) == [[1, 2, 1, 2, 1, 2]]", "assert apps_run1(3, [(2, [(1, 3), (4, 5)]), (3, [(1, 1), (2, 2), (3, 3)]), (4, [(1, 2), (2, 3), (3, 4), (4, 5)])]) == [[1, 2], [1, 2, 1], -1]"], "new_problem": "You are given a set of n segments [l_i, r_i] for 1 \u2264 i \u2264 n. Your task is to divide all segments into two non-empty groups such that there is no pair of segments from different groups that have at least one common point, or state that it's impossible to do so. Each segment should belong to exactly one group. However, this time, the segments are stored in a dictionary where the keys are the segment indices and the values are tuples representing the segment endpoints. Additionally, you must ensure that the segments in each group are sorted by their starting points. Use type hints in your solution.", "new_solution": "from typing import List, Dict, Tuple\n\ndef apps_run2(t: int, queries: List[Dict[int, Tuple[int, int]]]) -> List[List[int]]:\n    results = []\n    for query in queries:\n        n = len(query)\n        lri = [(li, ri, idx) for idx, (li, ri) in query.items()]\n        lri.sort()\n\n        t = [None for _ in range(n)]\n\n        ct, t[lri[0][2]], eg = 1, 1, lri[0][1]\n\n        for i in range(1, n):\n            if lri[i][0] <= eg:\n                t[lri[i][2]] = ct\n                eg = max(eg, lri[i][1])\n            else:\n                ct = 3 - ct\n                t[lri[i][2]] = ct\n                eg = lri[i][1]\n\n        if all(ti == 1 for ti in t):\n            results.append([-1])\n        else:\n            results.append(t)\n    return results", "input_format": "The first parameter t is an integer, 1 \u2264 t \u2264 50000, representing the number of queries. The second parameter is a list of length t, where each element is a dictionary. Each dictionary has n key-value pairs, where n is the number of segments in that query. The keys are integers (segment indices), and the values are tuples (l_i, r_i) representing the segment endpoints.", "output_format": "The function returns a list of lists, where each inner list corresponds to the result of a query. Each inner list contains either:- A list of integers `1` or `2` indicating the group assignment for each segment, or- `[-1]` if it's impossible to divide the segments into two non-empty groups without overlapping segments from different groups.", "test_input": ["assert apps_run2(3, [{0: (5, 5), 1: (2, 3)}, {0: (3, 5), 1: (2, 3), 2: (2, 3)}, {0: (3, 3), 1: (4, 4), 2: (5, 5)}]) == [[2, 1], [-1], [1, 2, 1]]", "assert apps_run2(1, [{0: (1, 2), 1: (3, 4), 2: (5, 6)}]) == [[1, 2, 1]]", "assert apps_run2(1, [{0: (1, 5), 1: (2, 6), 2: (7, 8)}]) == [[1, 1, 2]]", "assert apps_run2(2, [{0: (1, 3), 1: (4, 6)}, {0: (1, 2), 1: (2, 3), 2: (3, 4)}]) == [[1, 2], [-1]]", "assert apps_run2(1, [{0: (1, 10), 1: (2, 9), 2: (3, 8), 3: (4, 7), 4: (5, 6)}]) == [[-1]]"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "APPS/0106-4", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nThere are $n$ segments $[l_i, r_i]$ for $1 \\le i \\le n$. You should divide all segments into two non-empty groups in such way that there is no pair of segments from different groups which have at least one common point, or say that it's impossible to do it. Each segment should belong to exactly one group.\n\nTo optimize testing process you will be given multitest.\n\n\n-----Input-----\n\nThe first line contains one integer $T$ ($1 \\le T \\le 50000$) \u2014 the number of queries. Each query contains description of the set of segments. Queries are independent.\n\nFirst line of each query contains single integer $n$ ($2 \\le n \\le 10^5$) \u2014 number of segments. It is guaranteed that $\\sum{n}$ over all queries does not exceed $10^5$.\n\nThe next $n$ lines contains two integers $l_i$, $r_i$ per line ($1 \\le l_i \\le r_i \\le 2 \\cdot 10^5$) \u2014 the $i$-th segment.\n\n\n-----Output-----\n\nFor each query print $n$ integers $t_1, t_2, \\dots, t_n$ ($t_i \\in \\{1, 2\\}$) \u2014 for each segment (in the same order as in the input) $t_i$ equals $1$ if the $i$-th segment will belongs to the first group and $2$ otherwise.\n\nIf there are multiple answers, you can print any of them. If there is no answer, print $-1$.\n\n\n-----Example-----\nInput\n3\n2\n5 5\n2 3\n3\n3 5\n2 3\n2 3\n3\n3 3\n4 4\n5 5\n\nOutput\n2 1 \n-1\n1 1 2 \n\n\n\n-----Note-----\n\nIn the first query the first and the second segments should be in different groups, but exact numbers don't matter.\n\nIn the second query the third segment intersects with the first and the second segments, so they should be in the same group, but then the other group becomes empty, so answer is $-1$.\n\nIn the third query we can distribute segments in any way that makes groups non-empty, so any answer of $6$ possible is correct.", "raw_solution": "def apps_run1(t, test_cases):\n    results = []\n    for ti in range(t):\n        n = test_cases[ti][0]\n        lri = [None for _ in range(n)]\n        for i in range(n):\n            li, ri = test_cases[ti][1][i]\n            lri[i] = (li, ri, i)\n        lri.sort()\n        t = [None for _ in range(n)]\n        ct, t[lri[0][2]], eg = 1, 1, lri[0][1]\n        for i in range(1, n):\n            if lri[i][0] <= eg:\n                t[lri[i][2]] = ct\n                eg = max(eg, lri[i][1])\n            else:\n                ct = 3 - ct\n                t[lri[i][2]] = ct\n                eg = lri[i][1]\n        if all(ti == 1 for ti in t):\n            results.append(-1)\n        else:\n            results.append(t)\n    return results", "raw_test_input": ["assert apps_run1(3, [(2, [(5, 5), (2, 3)]), (3, [(3, 5), (2, 3), (2, 3)]), (3, [(3, 3), (4, 4), (5, 5)])]) == [[2, 1], -1, [1, 2, 1]]", "assert apps_run1(2, [(3, [(1, 2), (3, 4), (5, 6)]), (4, [(1, 3), (2, 5), (6, 7), (8, 9)])]) == [[1, 2, 1], [1, 1, 2, 1]]", "assert apps_run1(1, [(4, [(1, 4), (2, 3), (5, 6), (7, 8)])]) == [[1, 1, 2, 1]]", "assert apps_run1(2, [(5, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)]), (3, [(1, 2), (1, 3), (2, 4)])]) == [-1, -1]", "assert apps_run1(1, [(6, [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)])]) == [[1, 2, 1, 2, 1, 2]]", "assert apps_run1(3, [(2, [(1, 3), (4, 5)]), (3, [(1, 1), (2, 2), (3, 3)]), (4, [(1, 2), (2, 3), (3, 4), (4, 5)])]) == [[1, 2], [1, 2, 1], -1]"], "new_problem": "You are tasked with dividing segments into two non-empty groups such that no pair of segments from different groups have at least one common point. However, you must handle potential errors in the input data. Specifically, handle the following errors: 1. Invalid number of segments (n < 2). 2. Invalid segment range (l_i > r_i). 3. Input data exceeding constraints. Implement error handling using custom exceptions and ensure meaningful error messages are provided. Propagate errors appropriately and maintain type hints.", "new_solution": "from typing import List, Tuple\n\nclass SegmentError(Exception):\n    pass\n\nclass InvalidSegmentCountError(SegmentError):\n    def __init__(self, message=\"Number of segments must be at least 2.\"):\n        self.message = message\n        super().__init__(self.message)\n\nclass InvalidSegmentRangeError(SegmentError):\n    def __init__(self, message=\"Segment start must be less than or equal to end.\"):\n        self.message = message\n        super().__init__(self.message)\n\nclass InputConstraintError(SegmentError):\n    def __init__(self, message=\"Input constraints exceeded.\"):\n        self.message = message\n        super().__init__(self.message)\n\n\ndef apps_run2(t: int, queries: List[Tuple[int, List[Tuple[int, int]]]]) -> List[List[int]]:\n    results = []\n    total_segments = 0\n\n    for n, segments in queries:\n        if n < 2:\n            raise InvalidSegmentCountError()\n\n        total_segments += n\n        if total_segments > 100000:\n            raise InputConstraintError()\n\n        lri = []\n        for idx, (li, ri) in enumerate(segments):\n            if li > ri:\n                raise InvalidSegmentRangeError()\n            lri.append((li, ri, idx))\n\n        lri.sort()\n\n        t = [None for _ in range(n)]\n\n        ct, t[lri[0][2]], eg = 1, 1, lri[0][1]\n\n        for i in range(1, n):\n            if lri[i][0] <= eg:\n                t[lri[i][2]] = ct\n                eg = max(eg, lri[i][1])\n            else:\n                ct = 3 - ct\n                t[lri[i][2]] = ct\n                eg = lri[i][1]\n\n        if all(ti == 1 for ti in t):\n            results.append([-1])\n        else:\n            results.append(t)\n\n    return results\n", "input_format": "The first parameter `t`: An integer, 1 \u2264 t \u2264 50000, representing the number of queries.\nThe Second parameter `queries`: A list of length `t`, where each element is a tuple. Each tuple contains:\\n  - An integer `n` (`2 \u2264 n \u2264 10^5`), representing the number of segments in the query.\\n  - A list of `n` tuples, where each tuple is (l_i, r_i) representing the segment endpoints.", "output_format": "For each query print n integers t_1, t_2, ..., t_n (t_i \u2208 {1, 2}) \u2014 for each segment (in the same order as in the input) t_i equals 1 if the i-th segment belongs to the first group and 2 otherwise. If there is no answer, print -1.", "test_input": ["assert apps_run2(1, [(2, [(5, 5), (2, 3)])]) == [[2, 1]]", "assert apps_run2(1, [(3, [(3, 5), (2, 3), (2, 3)])]) == [[-1]]", "assert apps_run2(1, [(3, [(3, 3), (4, 4), (5, 5)])]) == [[1, 2, 1]]", "try:\n    apps_run2(1, [(1, [(3, 5)])])\nexcept InvalidSegmentCountError as e:\n    assert str(e) == \"Number of segments must be at least 2.\"\n", "try:\n    apps_run2(1, [(2, [(5, 3), (2, 3)])])\nexcept InvalidSegmentRangeError as e:\n    assert str(e) == \"Segment start must be less than or equal to end.\"\n"], "requirement_type": "PROMPT_ERROR_HANDLING"}
{"task_id": "APPS/0101-1", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nPolycarp lives on the coordinate axis $Ox$ and travels from the point $x=a$ to $x=b$. It moves uniformly rectilinearly at a speed of one unit of distance per minute.\n\nOn the axis $Ox$ at the point $x=c$ the base station of the mobile operator is placed. It is known that the radius of its coverage is $r$. Thus, if Polycarp is at a distance less than or equal to $r$ from the point $x=c$, then he is in the network coverage area, otherwise\u00a0\u2014 no. The base station can be located both on the route of Polycarp and outside it.\n\nPrint the time in minutes during which Polycarp will not be in the coverage area of the network, with a rectilinear uniform movement from $x=a$ to $x=b$. His speed\u00a0\u2014 one unit of distance per minute.\n\n\n-----Input-----\n\nThe first line contains a positive integer $t$ ($1 \\le t \\le 1000$)\u00a0\u2014 the number of test cases. In the following lines are written $t$ test cases.\n\nThe description of each test case is one line, which contains four integers $a$, $b$, $c$ and $r$ ($-10^8 \\le a,b,c \\le 10^8$, $0 \\le r \\le 10^8$)\u00a0\u2014 the coordinates of the starting and ending points of the path, the base station, and its coverage radius, respectively.\n\nAny of the numbers $a$, $b$ and $c$ can be equal (either any pair or all three numbers). The base station can be located both on the route of Polycarp and outside it.\n\n\n-----Output-----\n\nPrint $t$ numbers\u00a0\u2014 answers to given test cases in the order they are written in the test. Each answer is an integer\u00a0\u2014 the number of minutes during which Polycarp will be unavailable during his movement.\n\n\n-----Example-----\nInput\n9\n1 10 7 1\n3 3 3 0\n8 2 10 4\n8 2 10 100\n-10 20 -17 2\n-3 2 2 0\n-3 1 2 0\n2 3 2 3\n-1 3 -2 2\n\nOutput\n7\n0\n4\n0\n30\n5\n4\n0\n3\n\n\n\n-----Note-----\n\nThe following picture illustrates the first test case.  [Image] Polycarp goes from $1$ to $10$. The yellow area shows the coverage area of the station with a radius of coverage of $1$, which is located at the point of $7$. The green area shows a part of the path when Polycarp is out of coverage area.", "raw_solution": "def apps_run1(test_cases):\n    results = []\n    for case in test_cases:\n        a, b, c, r = case\n        a, b = min(a, b), max(a, b)\n        left = max(c - r, a)\n        right = min(c + r, b)\n        if right >= a and left <= right:\n            results.append(b - a - (right - left))\n        else:\n            results.append(b - a)\n    return results", "raw_test_input": ["assert apps_run1([(1, 10, 7, 1), (3, 3, 3, 0), (8, 2, 10, 4), (8, 2, 10, 100), (-10, 20, -17, 2), (-3, 2, 2, 0), (-3, 1, 2, 0), (2, 3, 2, 3), (-1, 3, -2, 2)]) == [7, 0, 4, 0, 30, 5, 4, 0, 3]", "assert apps_run1([(0, 5, 2, 1), (-5, 5, 0, 3), (1, 1, 1, 1), (-10, -5, -7, 2), (-4, 4, 0, 5)]) == [3, 4, 0, 1, 0]", "assert apps_run1([(-1, 1, 0, 1), (2, 5, 3, 1), (-3, -1, -2, 0), (10, 15, 12, 2), (-20, -10, -15, 10), (0, 0, 0, 0)]) == [0, 1, 2, 1, 0, 0]"], "new_problem": "In a city, multiple mobile operators have their base stations along a major highway. Each operator has a different coverage radius. Polycarp needs to travel from point x=a to x=b on this highway. For each operator, determine the total time Polycarp will be out of coverage during his journey. The input consists of multiple test cases, each specifying the journey and the details of multiple operators. For each test case, output the total time Polycarp is out of coverage for each operator.", "new_solution": "def time_out_of_coverage(a, b, c, r):\n    a, b = min(a, b), max(a, b)\n    left = max(c - r, a)\n    right = min(c + r, b)\n    if right >= a and left <= right:\n        return b - a - (right - left)\n    else:\n        return b - a\n\n\ndef apps_run2(t, journeys):\n    results = []\n    for journey in journeys:\n        a, b, operators = journey\n        operator_results = []\n        for operator in operators:\n            c, r = operator\n            operator_results.append(time_out_of_coverage(a, b, c, r))\n        results.append(operator_results)\n    return results", "input_format": "The first parameter t: A positive integer representing the number of test cases.\\n The second parameter journeys: A list of t elements, each representing a test case. Each test case is a tuple (a, b, operators) where:\\n\ta: An integer representing the starting coordinates of Polycarp.\\n\tb: An integer representing the endpoint coordinates of Polycarp.\\n\toperators: A list that contains multiple tuples (c, r), each of which represents information about a mobile operator:\\n\t\tc: An integer representing the coordinates of the base station.\\n\t\tr: An integer indicating the coverage radius of the base station.", "output_format": "The function returns a list of t elements, each of which is a list of times when Polycarp was not in the coverage area for each mobile carrier in the corresponding test case.", "test_input": ["assert apps_run2(1, [(1, 10, [(7, 1), (5, 2)])]) == [[7, 5]]", "assert apps_run2(1, [(3, 3, [(3, 0)])]) == [[0]]", "assert apps_run2(1, [(8, 2, [(10, 4), (0, 5)])]) == [[4, 3]]", "assert apps_run2(1, [(-10, 20, [(-17, 2), (0, 10)])]) == [[30, 10]]", "assert apps_run2(1, [(2, 3, [(2, 3), (1, 1)])]) == [[0, 1]]"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "APPS/0101-2", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nPolycarp lives on the coordinate axis $Ox$ and travels from the point $x=a$ to $x=b$. It moves uniformly rectilinearly at a speed of one unit of distance per minute.\n\nOn the axis $Ox$ at the point $x=c$ the base station of the mobile operator is placed. It is known that the radius of its coverage is $r$. Thus, if Polycarp is at a distance less than or equal to $r$ from the point $x=c$, then he is in the network coverage area, otherwise\u00a0\u2014 no. The base station can be located both on the route of Polycarp and outside it.\n\nPrint the time in minutes during which Polycarp will not be in the coverage area of the network, with a rectilinear uniform movement from $x=a$ to $x=b$. His speed\u00a0\u2014 one unit of distance per minute.\n\n\n-----Input-----\n\nThe first line contains a positive integer $t$ ($1 \\le t \\le 1000$)\u00a0\u2014 the number of test cases. In the following lines are written $t$ test cases.\n\nThe description of each test case is one line, which contains four integers $a$, $b$, $c$ and $r$ ($-10^8 \\le a,b,c \\le 10^8$, $0 \\le r \\le 10^8$)\u00a0\u2014 the coordinates of the starting and ending points of the path, the base station, and its coverage radius, respectively.\n\nAny of the numbers $a$, $b$ and $c$ can be equal (either any pair or all three numbers). The base station can be located both on the route of Polycarp and outside it.\n\n\n-----Output-----\n\nPrint $t$ numbers\u00a0\u2014 answers to given test cases in the order they are written in the test. Each answer is an integer\u00a0\u2014 the number of minutes during which Polycarp will be unavailable during his movement.\n\n\n-----Example-----\nInput\n9\n1 10 7 1\n3 3 3 0\n8 2 10 4\n8 2 10 100\n-10 20 -17 2\n-3 2 2 0\n-3 1 2 0\n2 3 2 3\n-1 3 -2 2\n\nOutput\n7\n0\n4\n0\n30\n5\n4\n0\n3\n\n\n\n-----Note-----\n\nThe following picture illustrates the first test case.  [Image] Polycarp goes from $1$ to $10$. The yellow area shows the coverage area of the station with a radius of coverage of $1$, which is located at the point of $7$. The green area shows a part of the path when Polycarp is out of coverage area.", "raw_solution": "def apps_run1(test_cases):\n    results = []\n    for a, b, c, r in test_cases:\n        a, b = min(a, b), max(a, b)\n        left = max(c - r, a)\n        right = min(c + r, b)\n        if right >= a and left <= right:\n            results.append(b - a - (right - left))\n        else:\n            results.append(b - a)\n    return results", "raw_test_input": ["assert apps_run1([(1, 10, 7, 1), (3, 3, 3, 0), (8, 2, 10, 4), (8, 2, 10, 100), (-10, 20, -17, 2), (-3, 2, 2, 0), (-3, 1, 2, 0), (2, 3, 2, 3), (-1, 3, -2, 2)]) == [7, 0, 4, 0, 30, 5, 4, 0, 3]", "assert apps_run1([(0, 5, 2, 1), (-5, 5, 0, 3), (1, 1, 1, 1), (-10, -5, -7, 2), (-4, 4, 0, 5)]) == [3, 4, 0, 1, 0]", "assert apps_run1([(-1, 1, 0, 1), (2, 5, 3, 1), (-3, -1, -2, 0), (10, 15, 12, 2), (-20, -10, -15, 10), (0, 0, 0, 0)]) == [0, 1, 2, 1, 0, 0]", "assert apps_run1([(-10, 0, -5, 5), (5, 10, 8, 1), (-3, 3, 0, 2), (-1, 1, 0, 0)]) == [0, 3, 2, 2]", "assert apps_run1([(1, 6, 3, 2), (-2, -1, -1, 0), (0, 10, 5, 3)]) == [1, 1, 4]", "assert apps_run1([(-5, 5, -3, 1), (0, 0, 0, 0), (-10, -5, -7, 3), (1, 10, 5, 2), (-2, 2, 0, 1), (-1, 1, 1, 1), (-3, 3, 3, 3)]) == [8, 0, 0, 5, 2, 1, 3]"], "new_problem": "Polycarp lives on the coordinate axis Ox and travels from the point x=a to x=b. He moves uniformly rectilinearly at a speed of one unit of distance per minute by default, but this speed can be adjusted. On the axis Ox at the point x=c, the base station of the mobile operator is placed. It is known that the radius of its coverage is r. Thus, if Polycarp is at a distance less than or equal to r from the point x=c, then he is in the network coverage area, otherwise \u2014 no. The base station can be located both on the route of Polycarp and outside it. Print the time in minutes during which Polycarp will not be in the coverage area of the network, with a rectilinear uniform movement from x=a to x=b. His speed is one unit of distance per minute by default, but can be specified as an optional parameter.", "new_solution": "from typing import List, Tuple\n\ndef apps_run2(t: int, test_cases: List[Tuple[int, int, int, int, int]]) -> List[int]:\n    results = []\n    for i in range(t):\n        a, b, c, r, speed = test_cases[i]\n        a, b = min(a, b), max(a, b)\n        left = max(c - r, a)\n        right = min(c + r, b)\n        if right >= a and left <= right:\n            unavailable_time = (b - a - (right - left)) // speed\n        else:\n            unavailable_time = (b - a) // speed\n        results.append(unavailable_time)\n    return results", "input_format": "The first parameter t: A positive integer representing the number of test cases. The value ranges from 1 to t to 1000.\\nThe second parameter test_cases: A list of t tuples, each representing a test case. Each tuple contains the following five integers: \\n\\ta: Coordinates of the starting point, the value range is -10^8 \u2264 a \u2264 10^8. \\n\\tb: Coordinates of the end point, with values ranging from -10^8 \u2264 b \u2264 10^8. \\n\\tc: The position coordinate of the base station. The value range is -10^8 \u2264 c \u2264 10^8. \\n\\tr: The coverage radius of the base station. The value range is 0 \u2264 r \u2264 10^8. \\n\\tspeed: indicates the movement speed of Polycarp. The value ranges from 1 to 1000. This is an optional parameter, if not provided, the default value is 1.", "output_format": "Returns a list of t integers representing the amount of time in minutes that Polycarp was out of the network coverage area in each test case.", "test_input": ["assert apps_run2(1, [(1, 10, 7, 1, 1)]) == [7]", "assert apps_run2(1, [(3, 3, 3, 0, 1)]) == [0]", "assert apps_run2(1, [(8, 2, 10, 4, 1)]) == [4]", "assert apps_run2(1, [(8, 2, 10, 100, 1)]) == [0]", "assert apps_run2(1, [(-10, 20, -17, 2, 2)]) == [15]"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "APPS/0101-3", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nPolycarp lives on the coordinate axis $Ox$ and travels from the point $x=a$ to $x=b$. It moves uniformly rectilinearly at a speed of one unit of distance per minute.\n\nOn the axis $Ox$ at the point $x=c$ the base station of the mobile operator is placed. It is known that the radius of its coverage is $r$. Thus, if Polycarp is at a distance less than or equal to $r$ from the point $x=c$, then he is in the network coverage area, otherwise\u00a0\u2014 no. The base station can be located both on the route of Polycarp and outside it.\n\nPrint the time in minutes during which Polycarp will not be in the coverage area of the network, with a rectilinear uniform movement from $x=a$ to $x=b$. His speed\u00a0\u2014 one unit of distance per minute.\n\n\n-----Input-----\n\nThe first line contains a positive integer $t$ ($1 \\le t \\le 1000$)\u00a0\u2014 the number of test cases. In the following lines are written $t$ test cases.\n\nThe description of each test case is one line, which contains four integers $a$, $b$, $c$ and $r$ ($-10^8 \\le a,b,c \\le 10^8$, $0 \\le r \\le 10^8$)\u00a0\u2014 the coordinates of the starting and ending points of the path, the base station, and its coverage radius, respectively.\n\nAny of the numbers $a$, $b$ and $c$ can be equal (either any pair or all three numbers). The base station can be located both on the route of Polycarp and outside it.\n\n\n-----Output-----\n\nPrint $t$ numbers\u00a0\u2014 answers to given test cases in the order they are written in the test. Each answer is an integer\u00a0\u2014 the number of minutes during which Polycarp will be unavailable during his movement.\n\n\n-----Example-----\nInput\n9\n1 10 7 1\n3 3 3 0\n8 2 10 4\n8 2 10 100\n-10 20 -17 2\n-3 2 2 0\n-3 1 2 0\n2 3 2 3\n-1 3 -2 2\n\nOutput\n7\n0\n4\n0\n30\n5\n4\n0\n3\n\n\n\n-----Note-----\n\nThe following picture illustrates the first test case.  [Image] Polycarp goes from $1$ to $10$. The yellow area shows the coverage area of the station with a radius of coverage of $1$, which is located at the point of $7$. The green area shows a part of the path when Polycarp is out of coverage area.", "raw_solution": "def apps_run1(test_cases):\n    results = []\n    for case in test_cases:\n        a, b, c, r = case\n        a, b = min(a, b), max(a, b)\n        left = max(c - r, a)\n        right = min(c + r, b)\n        if right >= a and left <= right:\n            results.append(b - a - (right - left))\n        else:\n            results.append(b - a)\n    return results", "raw_test_input": ["assert apps_run1([(1, 10, 7, 1), (3, 3, 3, 0), (8, 2, 10, 4), (8, 2, 10, 100), (-10, 20, -17, 2), (-3, 2, 2, 0), (-3, 1, 2, 0), (2, 3, 2, 3), (-1, 3, -2, 2)]) == [7, 0, 4, 0, 30, 5, 4, 0, 3]", "assert apps_run1([(0, 5, 2, 1), (-5, 5, 0, 3), (1, 1, 1, 1), (-10, -5, -7, 2), (-4, 4, 0, 5)]) == [3, 4, 0, 1, 0]", "assert apps_run1([(-1, 1, 0, 1), (2, 5, 3, 1), (-3, -1, -2, 0), (10, 15, 12, 2), (-20, -10, -15, 10), (0, 0, 0, 0)]) == [0, 1, 2, 1, 0, 0]"], "new_problem": "Polycarp lives on the coordinate axis Ox and travels from the point x=a to x=b. It moves uniformly rectilinearly at a speed of one unit of distance per minute. On the axis Ox at the point x=c, there are multiple base stations of the mobile operator, each with a different radius of coverage. The input is given as a JSON object for each test case, where each base station is represented as a dictionary with keys 'c' and 'r'. Determine the time in minutes during which Polycarp will not be in the coverage area of any network, with a rectilinear uniform movement from x=a to x=b. His speed is one unit of distance per minute. The base stations can be located both on the route of Polycarp and outside it. The input format is a JSON object for each test case, and the output should be the number of minutes Polycarp is out of coverage.", "new_solution": "from typing import List, Dict\n\ndef apps_run2(test_cases: List[Dict[str, int]]) -> List[int]:\n    results = []\n    for case in test_cases:\n        a, b = case['a'], case['b']\n        base_stations = case['base_stations']\n        a, b = min(a, b), max(a, b)\n        total_covered = 0\n        for station in base_stations:\n            c, r = station['c'], station['r']\n            left = max(c - r, a)\n            right = min(c + r, b)\n            if right >= a and left <= right:\n                total_covered += (right - left)\n        total_covered = min(total_covered, b - a)\n        results.append(b - a - total_covered)\n    return results", "input_format": "The function receive a list of multiple test cases, each of which is a dictionary. Each test case dictionary contains the following keys:\\n\\ta: integer, indicating the starting coordinates of Polycarp.\\n\\tb: integer, indicating the end coordinates of Polycarp.\\n\\tbase_stations: A list of multiple dictionaries, each representing a base station.Each base station dictionary contains the following keys:\\n\\t\\tc: integer, indicating the coordinates of the base station.\\n\\t\\tr: integer, indicating the coverage radius of the base station.", "output_format": "Returns a list of integers representing the time (minutes) in each test case that Polycarp was not in coverage of any base station.", "test_input": ["assert apps_run2([{'a': 1, 'b': 10, 'base_stations': [{'c': 7, 'r': 1}]}]) == [7]", "assert apps_run2([{'a': 3, 'b': 3, 'base_stations': [{'c': 3, 'r': 0}]}]) == [0]", "assert apps_run2([{'a': 8, 'b': 2, 'base_stations': [{'c': 10, 'r': 4}]}]) == [4]", "assert apps_run2([{'a': -10, 'b': 20, 'base_stations': [{'c': -17, 'r': 2}]}]) == [30]", "assert apps_run2([{'a': -1, 'b': 3, 'base_stations': [{'c': -2, 'r': 2}]}]) == [3]"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "APPS/0101-4", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nPolycarp lives on the coordinate axis $Ox$ and travels from the point $x=a$ to $x=b$. It moves uniformly rectilinearly at a speed of one unit of distance per minute.\n\nOn the axis $Ox$ at the point $x=c$ the base station of the mobile operator is placed. It is known that the radius of its coverage is $r$. Thus, if Polycarp is at a distance less than or equal to $r$ from the point $x=c$, then he is in the network coverage area, otherwise\u00a0\u2014 no. The base station can be located both on the route of Polycarp and outside it.\n\nPrint the time in minutes during which Polycarp will not be in the coverage area of the network, with a rectilinear uniform movement from $x=a$ to $x=b$. His speed\u00a0\u2014 one unit of distance per minute.\n\n\n-----Input-----\n\nThe first line contains a positive integer $t$ ($1 \\le t \\le 1000$)\u00a0\u2014 the number of test cases. In the following lines are written $t$ test cases.\n\nThe description of each test case is one line, which contains four integers $a$, $b$, $c$ and $r$ ($-10^8 \\le a,b,c \\le 10^8$, $0 \\le r \\le 10^8$)\u00a0\u2014 the coordinates of the starting and ending points of the path, the base station, and its coverage radius, respectively.\n\nAny of the numbers $a$, $b$ and $c$ can be equal (either any pair or all three numbers). The base station can be located both on the route of Polycarp and outside it.\n\n\n-----Output-----\n\nPrint $t$ numbers\u00a0\u2014 answers to given test cases in the order they are written in the test. Each answer is an integer\u00a0\u2014 the number of minutes during which Polycarp will be unavailable during his movement.\n\n\n-----Example-----\nInput\n9\n1 10 7 1\n3 3 3 0\n8 2 10 4\n8 2 10 100\n-10 20 -17 2\n-3 2 2 0\n-3 1 2 0\n2 3 2 3\n-1 3 -2 2\n\nOutput\n7\n0\n4\n0\n30\n5\n4\n0\n3\n\n\n\n-----Note-----\n\nThe following picture illustrates the first test case.  [Image] Polycarp goes from $1$ to $10$. The yellow area shows the coverage area of the station with a radius of coverage of $1$, which is located at the point of $7$. The green area shows a part of the path when Polycarp is out of coverage area.", "raw_solution": "def apps_run1(test_cases):\n    results = []\n    for case in test_cases:\n        a, b, c, r = case\n        a, b = min(a, b), max(a, b)\n        left = max(c - r, a)\n        right = min(c + r, b)\n        if right >= a and left <= right:\n            results.append(b - a - (right - left))\n        else:\n            results.append(b - a)\n    return results", "raw_test_input": ["assert apps_run1([(1, 10, 7, 1), (3, 3, 3, 0), (8, 2, 10, 4), (8, 2, 10, 100), (-10, 20, -17, 2), (-3, 2, 2, 0), (-3, 1, 2, 0), (2, 3, 2, 3), (-1, 3, -2, 2)]) == [7, 0, 4, 0, 30, 5, 4, 0, 3]", "assert apps_run1([(0, 5, 2, 1), (-5, 5, 0, 3), (1, 1, 1, 1), (-10, -5, -7, 2), (-4, 4, 0, 5)]) == [3, 4, 0, 1, 0]", "assert apps_run1([(-1, 1, 0, 1), (2, 5, 3, 1), (-3, -1, -2, 0), (10, 15, 12, 2), (-20, -10, -15, 10), (0, 0, 0, 0)]) == [0, 1, 2, 1, 0, 0]"], "new_problem": "Polycarp's journey is now part of a larger system that logs his travel data. The system must handle various errors that can occur during data processing. Implement a function that calculates the time Polycarp is out of network coverage, but also handles the following errors: 1) Invalid input format (e.g., non-integer values), 2) Out-of-bounds coordinates (e.g., values outside the specified range), 3) Negative radius values, 4) Propagation of unexpected errors with meaningful messages. Use custom exceptions to handle these errors and ensure the function is robust against invalid data.", "new_solution": "from typing import List, Tuple\n\nclass InvalidInputError(Exception):\n    pass\n\nclass OutOfBoundsError(Exception):\n    pass\n\nclass NegativeRadiusError(Exception):\n    pass\n\ndef apps_run2(t: int, test_cases: List[Tuple[int, int, int, int]]) -> List[int]:\n    results = []\n    for i in range(t):\n        try:\n            a, b, c, r = test_cases[i]\n            if not all(isinstance(x, int) for x in (a, b, c, r)):\n                raise InvalidInputError(\"All inputs must be integers.\")\n            if not (-10**8 <= a <= 10**8 and -10**8 <= b <= 10**8 and -10**8 <= c <= 10**8):\n                raise OutOfBoundsError(\"Coordinates must be within the range -10^8 to 10^8.\")\n            if r < 0:\n                raise NegativeRadiusError(\"Radius cannot be negative.\")\n            a, b = min(a, b), max(a, b)\n            left = max(c - r, a)\n            right = min(c + r, b)\n            if right >= a and left <= right:\n                results.append(b - a - (right - left))\n            else:\n                results.append(b - a)\n        except (InvalidInputError, OutOfBoundsError, NegativeRadiusError) as e:\n            print(f\"Error in test case {i+1}: {e}\")\n            results.append(-1)  # Indicate an error occurred\n        except Exception as e:\n            print(f\"Unexpected error in test case {i+1}: {e}\")\n            results.append(-1)  # Indicate an error occurred\n    return results", "input_format": "The first parameter `t`: An integer representing the number of test cases. This parameter is required and must be a positive integer between 1 and 1000, inclusive. The second parameter `test_cases`: A list of tuples, where each tuple contains four integers representing the coordinates of the starting point (`a`), the ending point (`b`), the base station (`c`), and the coverage radius (`r`). Each tuple in the list corresponds to a single test case.", "output_format": "The function returns a list of integers, where each integer represents the time Polycarp is out of network coverage for the corresponding test case. If an error occurs for a specific test case, the function appends\u00a0-1\u00a0to the results list to indicate an error.", "test_input": ["assert apps_run2(9, [(1, 10, 7, 1), (3, 3, 3, 0), (8, 2, 10, 4), (8, 2, 10, 100), (-10, 20, -17, 2), (-3, 2, 2, 0), (-3, 1, 2, 0), (2, 3, 2, 3), (-1, 3, -2, 2)]) == [7, 0, 4, 0, 30, 5, 4, 0, 3]", "assert apps_run2(1, [(1, 10, 7, 1)]) == [7]", "assert apps_run2(1, [(3, 3, 3, 0)]) == [0]", "assert apps_run2(1, [(8, 2, 10, 4)]) == [4]", "assert apps_run2(1, [(8, 2, 10, 100)]) == [0]", "assert apps_run2(1, [(1, 10, 7, -1)]) == [-1]"], "requirement_type": "PROMPT_ERROR_HANDLING"}
{"task_id": "APPS/0108-1", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nYou're given an array $a_1, \\ldots, a_n$ of $n$ non-negative integers.\n\nLet's call it sharpened if and only if there exists an integer $1 \\le k \\le n$ such that $a_1 < a_2 < \\ldots < a_k$ and $a_k > a_{k+1} > \\ldots > a_n$. In particular, any strictly increasing or strictly decreasing array is sharpened. For example:  The arrays $[4]$, $[0, 1]$, $[12, 10, 8]$ and $[3, 11, 15, 9, 7, 4]$ are sharpened;  The arrays $[2, 8, 2, 8, 6, 5]$, $[0, 1, 1, 0]$ and $[2, 5, 6, 9, 8, 8]$ are not sharpened. \n\nYou can do the following operation as many times as you want: choose any strictly positive element of the array, and decrease it by one. Formally, you can choose any $i$ ($1 \\le i \\le n$) such that $a_i>0$ and assign $a_i := a_i - 1$.\n\nTell if it's possible to make the given array sharpened using some number (possibly zero) of these operations.\n\n\n-----Input-----\n\nThe input consists of multiple test cases. The first line contains a single integer $t$ ($1 \\le t \\le 15\\ 000$) \u00a0\u2014 the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($1 \\le n \\le 3 \\cdot 10^5$).\n\nThe second line of each test case contains a sequence of $n$ non-negative integers $a_1, \\ldots, a_n$ ($0 \\le a_i \\le 10^9$).\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $3 \\cdot 10^5$.\n\n\n-----Output-----\n\nFor each test case, output a single line containing \"Yes\" (without quotes) if it's possible to make the given array sharpened using the described operations, or \"No\" (without quotes) otherwise.\n\n\n-----Example-----\nInput\n10\n1\n248618\n3\n12 10 8\n6\n100 11 15 9 7 8\n4\n0 1 1 0\n2\n0 0\n2\n0 1\n2\n1 0\n2\n1 1\n3\n0 1 0\n3\n1 0 1\n\nOutput\nYes\nYes\nYes\nNo\nNo\nYes\nYes\nYes\nYes\nNo\n\n\n\n-----Note-----\n\nIn the first and the second test case of the first test, the given array is already sharpened.\n\nIn the third test case of the first test, we can transform the array into $[3, 11, 15, 9, 7, 4]$ (decrease the first element $97$ times and decrease the last element $4$ times). It is sharpened because $3 < 11 < 15$ and $15 > 9 > 7 > 4$.\n\nIn the fourth test case of the first test, it's impossible to make the given array sharpened.", "raw_solution": "def apps_run1(test_cases):\n    results = []\n    for n, li in test_cases:\n        ans = 0\n        for i in range(n):\n            if li[i] >= i:\n                ans += 1\n            else:\n                break\n        for i in range(n):\n            if li[n - 1 - i] >= i:\n                ans += 1\n            else:\n                break\n        if ans > n:\n            results.append('Yes')\n        else:\n            results.append('No')\n    return results\n", "raw_test_input": ["assert apps_run1([(1, [248618]), (3, [12, 10, 8]), (6, [100, 11, 15, 9, 7, 8]), (4, [0, 1, 1, 0]), (2, [0, 0]), (2, [0, 1]), (2, [1, 0]), (2, [1, 1]), (3, [0, 1, 0]), (3, [1, 0, 1])]) == ['Yes', 'Yes', 'Yes', 'No', 'No', 'Yes', 'Yes', 'Yes', 'Yes', 'No']", "assert apps_run1([(1, [5]), (3, [1, 2, 3]), (5, [5, 4, 3, 2, 1]), (4, [0, 2, 2, 0]), (3, [3, 3, 3])]) == ['Yes', 'Yes', 'Yes', 'Yes', 'Yes']", "assert apps_run1([(2, [1, 0]), (3, [0, 0, 0]), (4, [1, 2, 3, 4]), (5, [10, 9, 8, 7, 6]), (3, [2, 2, 2])]) == ['Yes', 'No', 'Yes', 'Yes', 'Yes']", "assert apps_run1([(1, [0]), (2, [1, 1]), (3, [2, 1, 0]), (5, [1, 2, 3, 4, 5])]) == ['Yes', 'Yes', 'Yes', 'Yes']", "assert apps_run1([(2, [3, 2]), (3, [0, 1, 2]), (4, [5, 5, 5, 5])]) == ['Yes', 'Yes', 'Yes']", "assert apps_run1([(1, [1]), (2, [2, 2]), (3, [1, 2, 3]), (4, [3, 2, 1, 0]), (5, [0, 0, 0, 0, 0]), (3, [1, 0, 1])]) == ['Yes', 'Yes', 'Yes', 'Yes', 'No', 'No']"], "new_problem": "In a logistics company, you are tasked with optimizing the delivery routes. Each route is represented by an array of non-negative integers, where each integer represents the delivery time in minutes to a specific location. A route is considered optimal if it is 'sharpened', meaning there exists a peak delivery time after which the times decrease. You can reduce the delivery time of any location by one minute any number of times. Given multiple routes, determine if each route can be optimized to be 'sharpened'.", "new_solution": "def is_sharpened_possible(n, li):\n    ans = 0\n    for i in range(n):\n        if li[i] >= i:\n            ans += 1\n        else:\n            break\n    for i in range(n):\n        if li[n - 1 - i] >= i:\n            ans += 1\n        else:\n            break\n    return ans > n\n\ndef apps_run2(test_cases):\n    results = []\n    for n, route in test_cases:\n        if is_sharpened_possible(n, route):\n            results.append('Yes')\n        else:\n            results.append('No')\n    return results", "input_format": "The parameter is a list of tuples. Each tuple within the list represents a test case. In each tuple, the first element is an integer\u00a0n\u00a0which indicates the number of elements in the delivery - route array, and the second element is a list of non - negative integers\u00a0route\u00a0representing the delivery times for each location in that particular route.", "output_format": "The function returns a list of strings with each element in the list corresponding to the result of a test case. For each test case, if the corresponding array can be sharpened by a given operation (that is, there is a peak and then the elements are decrement), the result is 'Yes'; Otherwise, the result is 'No'.", "test_input": ["assert apps_run2([(1, [248618]), (3, [12, 10, 8]), (6, [100, 11, 15, 9, 7, 8]), (4, [0, 1, 1, 0]), (2, [0, 0])]) == ['Yes', 'Yes', 'Yes', 'No', 'No']", "assert apps_run2([(2, [0, 1]), (2, [1, 0]), (2, [1, 1]), (3, [0, 1, 0]), (3, [1, 0, 1])]) == ['Yes', 'Yes', 'Yes', 'Yes', 'No']", "assert apps_run2([(5, [1, 2, 3, 4, 5]), (5, [5, 4, 3, 2, 1]), (5, [1, 3, 5, 3, 1]), (5, [1, 1, 1, 1, 1]), (5, [0, 0, 0, 0, 0])]) == ['Yes', 'Yes', 'Yes', 'No', 'No']", "assert apps_run2([(4, [10, 20, 30, 40]), (4, [40, 30, 20, 10]), (4, [10, 30, 20, 10]), (4, [10, 10, 10, 10]), (4, [0, 1, 2, 3])]) == ['Yes', 'Yes', 'Yes', 'Yes', 'Yes']", "assert apps_run2([(3, [5, 10, 5]), (3, [5, 5, 5]), (3, [0, 5, 0]), (3, [1, 2, 1]), (3, [2, 1, 2])]) == ['Yes', 'Yes', 'Yes', 'Yes', 'Yes']"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "APPS/0108-2", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nYou're given an array $a_1, \\ldots, a_n$ of $n$ non-negative integers.\n\nLet's call it sharpened if and only if there exists an integer $1 \\le k \\le n$ such that $a_1 < a_2 < \\ldots < a_k$ and $a_k > a_{k+1} > \\ldots > a_n$. In particular, any strictly increasing or strictly decreasing array is sharpened. For example:  The arrays $[4]$, $[0, 1]$, $[12, 10, 8]$ and $[3, 11, 15, 9, 7, 4]$ are sharpened;  The arrays $[2, 8, 2, 8, 6, 5]$, $[0, 1, 1, 0]$ and $[2, 5, 6, 9, 8, 8]$ are not sharpened. \n\nYou can do the following operation as many times as you want: choose any strictly positive element of the array, and decrease it by one. Formally, you can choose any $i$ ($1 \\le i \\le n$) such that $a_i>0$ and assign $a_i := a_i - 1$.\n\nTell if it's possible to make the given array sharpened using some number (possibly zero) of these operations.\n\n\n-----Input-----\n\nThe input consists of multiple test cases. The first line contains a single integer $t$ ($1 \\le t \\le 15\\ 000$) \u00a0\u2014 the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($1 \\le n \\le 3 \\cdot 10^5$).\n\nThe second line of each test case contains a sequence of $n$ non-negative integers $a_1, \\ldots, a_n$ ($0 \\le a_i \\le 10^9$).\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $3 \\cdot 10^5$.\n\n\n-----Output-----\n\nFor each test case, output a single line containing \"Yes\" (without quotes) if it's possible to make the given array sharpened using the described operations, or \"No\" (without quotes) otherwise.\n\n\n-----Example-----\nInput\n10\n1\n248618\n3\n12 10 8\n6\n100 11 15 9 7 8\n4\n0 1 1 0\n2\n0 0\n2\n0 1\n2\n1 0\n2\n1 1\n3\n0 1 0\n3\n1 0 1\n\nOutput\nYes\nYes\nYes\nNo\nNo\nYes\nYes\nYes\nYes\nNo\n\n\n\n-----Note-----\n\nIn the first and the second test case of the first test, the given array is already sharpened.\n\nIn the third test case of the first test, we can transform the array into $[3, 11, 15, 9, 7, 4]$ (decrease the first element $97$ times and decrease the last element $4$ times). It is sharpened because $3 < 11 < 15$ and $15 > 9 > 7 > 4$.\n\nIn the fourth test case of the first test, it's impossible to make the given array sharpened.", "raw_solution": "def apps_run1(test_cases):\n    results = []\n    for n, li in test_cases:\n        ans = 0\n        for i in range(n):\n            if li[i] >= i:\n                ans += 1\n            else:\n                break\n        for i in range(n):\n            if li[n - 1 - i] >= i:\n                ans += 1\n            else:\n                break\n        if ans > n:\n            results.append('Yes')\n        else:\n            results.append('No')\n    return results\n", "raw_test_input": ["assert apps_run1([(1, [248618]), (3, [12, 10, 8]), (6, [100, 11, 15, 9, 7, 8]), (4, [0, 1, 1, 0]), (2, [0, 0]), (2, [0, 1]), (2, [1, 0]), (2, [1, 1]), (3, [0, 1, 0]), (3, [1, 0, 1])]) == ['Yes', 'Yes', 'Yes', 'No', 'No', 'Yes', 'Yes', 'Yes', 'Yes', 'No']", "assert apps_run1([(1, [5]), (3, [1, 2, 3]), (5, [5, 4, 3, 2, 1]), (4, [0, 2, 2, 0]), (3, [3, 3, 3])]) == ['Yes', 'Yes', 'Yes', 'Yes', 'Yes']", "assert apps_run1([(2, [1, 0]), (3, [0, 0, 0]), (4, [1, 2, 3, 4]), (5, [10, 9, 8, 7, 6]), (3, [2, 2, 2])]) == ['Yes', 'No', 'Yes', 'Yes', 'Yes']", "assert apps_run1([(1, [0]), (2, [1, 1]), (3, [2, 1, 0]), (5, [1, 2, 3, 4, 5])]) == ['Yes', 'Yes', 'Yes', 'Yes']", "assert apps_run1([(2, [3, 2]), (3, [0, 1, 2]), (4, [5, 5, 5, 5])]) == ['Yes', 'Yes', 'Yes']", "assert apps_run1([(1, [1]), (2, [2, 2]), (3, [1, 2, 3]), (4, [3, 2, 1, 0]), (5, [0, 0, 0, 0, 0]), (3, [1, 0, 1])]) == ['Yes', 'Yes', 'Yes', 'Yes', 'No', 'No']"], "new_problem": "Enhance the function to determine if an array can be made sharpened, with an optional parameter to specify a maximum number of operations allowed. The function should maintain backward compatibility, meaning it should work without the optional parameter as before. If the optional parameter is provided, the function should return 'Yes' only if the array can be made sharpened within the specified number of operations.", "new_solution": "from typing import List, Optional\n\ndef apps_run2(t: int, test_cases: List[List[int]], max_operations: Optional[int] = None) -> List[str]:\n    results = []\n    for case in test_cases:\n        n = case[0]\n        li = case[1:]\n        ans = 0\n        for i in range(n):\n            if li[i] >= i:\n                ans += 1\n            else:\n                break\n        for i in range(n):\n            if li[n - 1 - i] >= i:\n                ans += 1\n            else:\n                break\n        if ans > n:\n            if max_operations is not None:\n                # Calculate the number of operations needed\n                operations = sum(max(0, li[i] - i) for i in range(n)) + sum(max(0, li[n - 1 - i] - i) for i in range(n))\n                if operations <= max_operations:\n                    results.append('Yes')\n                else:\n                    results.append('No')\n            else:\n                results.append('Yes')\n        else:\n            results.append('No')\n    return results", "input_format": "The first parameter t is an integer in the range of 1 \u2264 t \u2264 15000, which represents the number of test cases. The second parameter test_cases is a two - dimensional list of integers (List[List[int]]), where each inner list corresponds to a test case. The first element of each inner list is an integer n (1 \u2264 n \u2264 3 * 10^5) indicating the length of the array, followed by n non - negative integers a_1, ..., a_n (0 \u2264 a_i \u2264 10^9). The third parameter max_operations is an optional integer (Optional[int]), specifying the maximum number of operations allowed; if not provided, no operation limit is considered.", "output_format": "The function returns a list of strings (List[str]), where each string corresponds to the result of a test case. It is 'Yes' if the array can be made sharpened (within the operation limit if max_operations is given), and 'No' otherwise, with the length of the list equal to the number of test cases.", "test_input": ["assert apps_run2(1, [[1, 248618]]) == ['Yes']", "assert apps_run2(1, [[3, 12, 10, 8]]) == ['Yes']", "assert apps_run2(1, [[4, 0, 1, 1, 0]]) == ['No']", "assert apps_run2(1, [[3, 1, 0, 1]], max_operations=1) == ['No']", "assert apps_run2(1, [[6, 100, 11, 15, 9, 7, 8]], max_operations=100) == ['No']"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "APPS/0108-3", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nYou're given an array $a_1, \\ldots, a_n$ of $n$ non-negative integers.\n\nLet's call it sharpened if and only if there exists an integer $1 \\le k \\le n$ such that $a_1 < a_2 < \\ldots < a_k$ and $a_k > a_{k+1} > \\ldots > a_n$. In particular, any strictly increasing or strictly decreasing array is sharpened. For example:  The arrays $[4]$, $[0, 1]$, $[12, 10, 8]$ and $[3, 11, 15, 9, 7, 4]$ are sharpened;  The arrays $[2, 8, 2, 8, 6, 5]$, $[0, 1, 1, 0]$ and $[2, 5, 6, 9, 8, 8]$ are not sharpened. \n\nYou can do the following operation as many times as you want: choose any strictly positive element of the array, and decrease it by one. Formally, you can choose any $i$ ($1 \\le i \\le n$) such that $a_i>0$ and assign $a_i := a_i - 1$.\n\nTell if it's possible to make the given array sharpened using some number (possibly zero) of these operations.\n\n\n-----Input-----\n\nThe input consists of multiple test cases. The first line contains a single integer $t$ ($1 \\le t \\le 15\\ 000$) \u00a0\u2014 the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($1 \\le n \\le 3 \\cdot 10^5$).\n\nThe second line of each test case contains a sequence of $n$ non-negative integers $a_1, \\ldots, a_n$ ($0 \\le a_i \\le 10^9$).\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $3 \\cdot 10^5$.\n\n\n-----Output-----\n\nFor each test case, output a single line containing \"Yes\" (without quotes) if it's possible to make the given array sharpened using the described operations, or \"No\" (without quotes) otherwise.\n\n\n-----Example-----\nInput\n10\n1\n248618\n3\n12 10 8\n6\n100 11 15 9 7 8\n4\n0 1 1 0\n2\n0 0\n2\n0 1\n2\n1 0\n2\n1 1\n3\n0 1 0\n3\n1 0 1\n\nOutput\nYes\nYes\nYes\nNo\nNo\nYes\nYes\nYes\nYes\nNo\n\n\n\n-----Note-----\n\nIn the first and the second test case of the first test, the given array is already sharpened.\n\nIn the third test case of the first test, we can transform the array into $[3, 11, 15, 9, 7, 4]$ (decrease the first element $97$ times and decrease the last element $4$ times). It is sharpened because $3 < 11 < 15$ and $15 > 9 > 7 > 4$.\n\nIn the fourth test case of the first test, it's impossible to make the given array sharpened.", "raw_solution": "def apps_run1(test_cases):\n    results = []\n    for n, li in test_cases:\n        ans = 0\n        for i in range(n):\n            if li[i] >= i:\n                ans += 1\n            else:\n                break\n        for i in range(n):\n            if li[n - 1 - i] >= i:\n                ans += 1\n            else:\n                break\n        if ans > n:\n            results.append('Yes')\n        else:\n            results.append('No')\n    return results\n", "raw_test_input": ["assert apps_run1([(1, [248618]), (3, [12, 10, 8]), (6, [100, 11, 15, 9, 7, 8]), (4, [0, 1, 1, 0]), (2, [0, 0]), (2, [0, 1]), (2, [1, 0]), (2, [1, 1]), (3, [0, 1, 0]), (3, [1, 0, 1])]) == ['Yes', 'Yes', 'Yes', 'No', 'No', 'Yes', 'Yes', 'Yes', 'Yes', 'No']", "assert apps_run1([(1, [5]), (3, [1, 2, 3]), (5, [5, 4, 3, 2, 1]), (4, [0, 2, 2, 0]), (3, [3, 3, 3])]) == ['Yes', 'Yes', 'Yes', 'Yes', 'Yes']", "assert apps_run1([(2, [1, 0]), (3, [0, 0, 0]), (4, [1, 2, 3, 4]), (5, [10, 9, 8, 7, 6]), (3, [2, 2, 2])]) == ['Yes', 'No', 'Yes', 'Yes', 'Yes']", "assert apps_run1([(1, [0]), (2, [1, 1]), (3, [2, 1, 0]), (5, [1, 2, 3, 4, 5])]) == ['Yes', 'Yes', 'Yes', 'Yes']", "assert apps_run1([(2, [3, 2]), (3, [0, 1, 2]), (4, [5, 5, 5, 5])]) == ['Yes', 'Yes', 'Yes']", "assert apps_run1([(1, [1]), (2, [2, 2]), (3, [1, 2, 3]), (4, [3, 2, 1, 0]), (5, [0, 0, 0, 0, 0]), (3, [1, 0, 1])]) == ['Yes', 'Yes', 'Yes', 'Yes', 'No', 'No']"], "new_problem": "You're given a dictionary where keys are indices and values are non-negative integers representing an array. Let's call it sharpened if and only if there exists an integer 1 \u2264 k \u2264 n such that a_1 < a_2 < ... < a_k and a_k > a_{k+1} > ... > a_n. You can perform the following operation as many times as you want: choose any strictly positive element of the array, and decrease it by one. Formally, you can choose any i (1 \u2264 i \u2264 n) such that a_i > 0 and assign a_i := a_i - 1. Tell if it's possible to make the given array sharpened using some number (possibly zero) of these operations. Additionally, the array must have at least one element greater than zero.", "new_solution": "from typing import Dict, List\n\ndef apps_run2(t: int, test_cases: List[Dict[int, int]]) -> List[str]:\n    results = []\n    for case in test_cases:\n        n = len(case)\n        ans = 0\n        for i in range(n):\n            if case[i] >= i:\n                ans += 1\n            else:\n                break\n        for i in range(n):\n            if case[n - 1 - i] >= i:\n                ans += 1\n            else:\n                break\n        if ans > n:\n            results.append(\"Yes\")\n        else:\n            results.append(\"No\")\n    return results", "input_format": "The first parameter t is an integer in the range of 1 \u2264 t \u2264 15000, representing the number of test cases. The second parameter test_cases is a list of dictionaries (List[Dict[int, int]]), where each dictionary in the list corresponds to a test case. In each dictionary, the keys are indices and the values are non - negative integers that form an array. ", "output_format": "The function returns a list of strings (List[str]). Each string in the list corresponds to the result of a test case. If it is possible to make the array in the test case sharpened using the described operations and the array has at least one element greater than zero, the string is 'Yes'; otherwise, it is 'No'. The length of the returned list is equal to the number of test cases", "test_input": ["assert apps_run2(1, [{0: 248618}]) == ['Yes']", "assert apps_run2(1, [{0: 12, 1: 10, 2: 8}]) == ['Yes']", "assert apps_run2(1, [{0: 100, 1: 11, 2: 15, 3: 9, 4: 7, 5: 8}]) == ['Yes']", "assert apps_run2(1, [{0: 0, 1: 1, 2: 1, 3: 0}]) == ['No']", "assert apps_run2(1, [{0: 0, 1: 0}]) == ['No']"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "APPS/0108-4", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nYou're given an array $a_1, \\ldots, a_n$ of $n$ non-negative integers.\n\nLet's call it sharpened if and only if there exists an integer $1 \\le k \\le n$ such that $a_1 < a_2 < \\ldots < a_k$ and $a_k > a_{k+1} > \\ldots > a_n$. In particular, any strictly increasing or strictly decreasing array is sharpened. For example:  The arrays $[4]$, $[0, 1]$, $[12, 10, 8]$ and $[3, 11, 15, 9, 7, 4]$ are sharpened;  The arrays $[2, 8, 2, 8, 6, 5]$, $[0, 1, 1, 0]$ and $[2, 5, 6, 9, 8, 8]$ are not sharpened. \n\nYou can do the following operation as many times as you want: choose any strictly positive element of the array, and decrease it by one. Formally, you can choose any $i$ ($1 \\le i \\le n$) such that $a_i>0$ and assign $a_i := a_i - 1$.\n\nTell if it's possible to make the given array sharpened using some number (possibly zero) of these operations.\n\n\n-----Input-----\n\nThe input consists of multiple test cases. The first line contains a single integer $t$ ($1 \\le t \\le 15\\ 000$) \u00a0\u2014 the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($1 \\le n \\le 3 \\cdot 10^5$).\n\nThe second line of each test case contains a sequence of $n$ non-negative integers $a_1, \\ldots, a_n$ ($0 \\le a_i \\le 10^9$).\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $3 \\cdot 10^5$.\n\n\n-----Output-----\n\nFor each test case, output a single line containing \"Yes\" (without quotes) if it's possible to make the given array sharpened using the described operations, or \"No\" (without quotes) otherwise.\n\n\n-----Example-----\nInput\n10\n1\n248618\n3\n12 10 8\n6\n100 11 15 9 7 8\n4\n0 1 1 0\n2\n0 0\n2\n0 1\n2\n1 0\n2\n1 1\n3\n0 1 0\n3\n1 0 1\n\nOutput\nYes\nYes\nYes\nNo\nNo\nYes\nYes\nYes\nYes\nNo\n\n\n\n-----Note-----\n\nIn the first and the second test case of the first test, the given array is already sharpened.\n\nIn the third test case of the first test, we can transform the array into $[3, 11, 15, 9, 7, 4]$ (decrease the first element $97$ times and decrease the last element $4$ times). It is sharpened because $3 < 11 < 15$ and $15 > 9 > 7 > 4$.\n\nIn the fourth test case of the first test, it's impossible to make the given array sharpened.", "raw_solution": "def apps_run1(test_cases):\n    results = []\n    for n, li in test_cases:\n        ans = 0\n        for i in range(n):\n            if li[i] >= i:\n                ans += 1\n            else:\n                break\n        for i in range(n):\n            if li[n - 1 - i] >= i:\n                ans += 1\n            else:\n                break\n        if ans > n:\n            results.append('Yes')\n        else:\n            results.append('No')\n    return results\n", "raw_test_input": ["assert apps_run1([(1, [248618]), (3, [12, 10, 8]), (6, [100, 11, 15, 9, 7, 8]), (4, [0, 1, 1, 0]), (2, [0, 0]), (2, [0, 1]), (2, [1, 0]), (2, [1, 1]), (3, [0, 1, 0]), (3, [1, 0, 1])]) == ['Yes', 'Yes', 'Yes', 'No', 'No', 'Yes', 'Yes', 'Yes', 'Yes', 'No']", "assert apps_run1([(1, [5]), (3, [1, 2, 3]), (5, [5, 4, 3, 2, 1]), (4, [0, 2, 2, 0]), (3, [3, 3, 3])]) == ['Yes', 'Yes', 'Yes', 'Yes', 'Yes']", "assert apps_run1([(2, [1, 0]), (3, [0, 0, 0]), (4, [1, 2, 3, 4]), (5, [10, 9, 8, 7, 6]), (3, [2, 2, 2])]) == ['Yes', 'No', 'Yes', 'Yes', 'Yes']", "assert apps_run1([(1, [0]), (2, [1, 1]), (3, [2, 1, 0]), (5, [1, 2, 3, 4, 5])]) == ['Yes', 'Yes', 'Yes', 'Yes']", "assert apps_run1([(2, [3, 2]), (3, [0, 1, 2]), (4, [5, 5, 5, 5])]) == ['Yes', 'Yes', 'Yes']", "assert apps_run1([(1, [1]), (2, [2, 2]), (3, [1, 2, 3]), (4, [3, 2, 1, 0]), (5, [0, 0, 0, 0, 0]), (3, [1, 0, 1])]) == ['Yes', 'Yes', 'Yes', 'Yes', 'No', 'No']"], "new_problem": "You are given an array of non-negative integers and need to determine if it can be transformed into a 'sharpened' array using a series of operations. However, the input data may contain errors such as negative numbers, non-integer values, or arrays that exceed the specified size limits. Implement a function that handles these errors gracefully by raising appropriate exceptions. The function should also handle cases where the input format is incorrect, such as missing values or extra data. Define custom exceptions for these scenarios and ensure that meaningful error messages are provided. The function should propagate errors up the call stack if they cannot be handled locally.", "new_solution": "from typing import List\n\nclass InvalidInputError(Exception):\n    pass\n\nclass ArraySizeError(Exception):\n    pass\n\nclass NegativeValueError(Exception):\n    pass\n\nclass NonIntegerValueError(Exception):\n    pass\n\ndef apps_run2(t: int, test_cases: List[List[int]]) -> List[str]:\n    results = []\n    for case in test_cases:\n        try:\n            n = case[0]\n            if not isinstance(n, int) or n < 1 or n > 300000:\n                raise ArraySizeError(\"Array size must be between 1 and 300,000.\")\n            li = case[1:]\n            if len(li) != n:\n                raise InvalidInputError(\"The number of elements does not match the specified size.\")\n            for value in li:\n                if not isinstance(value, int):\n                    raise NonIntegerValueError(\"All elements must be integers.\")\n                if value < 0:\n                    raise NegativeValueError(\"All elements must be non-negative.\")\n            ans = 0\n            for i in range(n):\n                if li[i] >= i:\n                    ans += 1\n                else:\n                    break\n            for i in range(n):\n                if li[n - 1 - i] >= i:\n                    ans += 1\n                else:\n                    break\n            if ans > n:\n                results.append(\"Yes\")\n            else:\n                results.append(\"No\")\n        except (InvalidInputError, ArraySizeError, NegativeValueError, NonIntegerValueError) as e:\n            results.append(f\"Error: {str(e)}\")\n    return results", "input_format": "The first parameter t is an integer within the range of 1 \u2264 t \u2264 15000, which represents the number of test cases. The second parameter test_cases is a list of lists (List[List[int]]), where each inner list represents a test case. The first element of each inner list should be an integer n in the range of 1 \u2264 n \u2264 300000, indicating the size of the array, followed by n non - negative integers that form the array.", "output_format": "The function returns a list of strings (List[str]). For each test case, if the input is valid and it's possible to make the given array sharpened using the described operations, the corresponding string in the result list will be 'Yes'; if the input is valid but the array cannot be made sharpened, the string will be 'No'. If there are errors in the input such as incorrect array size, negative values, non - integer values, or a mismatch between the specified size and the actual number of elements, the corresponding string will contain an error message in the format 'Error: [specific error message]'. The length of the returned list is equal to the number of test cases. ", "test_input": ["assert apps_run2(1, [[1, 248618]]) == ['Yes']", "assert apps_run2(1, [[3, 12, 10, 8]]) == ['Yes']", "assert apps_run2(1, [[6, 100, 11, 15, 9, 7, 8]]) == ['Yes']", "assert apps_run2(1, [[4, 0, 1, 1, 0]]) == ['No']", "assert apps_run2(1, [[2, -1, 0]]) == ['Error: All elements must be non-negative.']", "assert apps_run2(1, [[2, 0, 'a']]) == ['Error: All elements must be integers.']", "assert apps_run2(1, [[2, 0]]) == ['Error: The number of elements does not match the specified size.']", "assert apps_run2(1, [[300001] + [0]*300001]) == ['Error: Array size must be between 1 and 300,000.']"], "requirement_type": "PROMPT_ERROR_HANDLING"}
{"task_id": "APPS/0111-1", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nYou are given an image, that can be represented with a 2-d n by m grid of pixels. Each pixel of the image is either on or off, denoted by the characters \"0\" or \"1\", respectively. You would like to compress this image. You want to choose an integer k > 1 and split the image into k by k blocks. If n and m are not divisible by k, the image is padded with only zeros on the right and bottom so that they are divisible by k. Each pixel in each individual block must have the same value. The given image may not be compressible in its current state. Find the minimum number of pixels you need to toggle (after padding) in order for the image to be compressible for some k. More specifically, the steps are to first choose k, then the image is padded with zeros, then, we can toggle the pixels so it is compressible for this k. The image must be compressible in that state.\n\n\n-----Input-----\n\nThe first line of input will contain two integers n, m (2 \u2264 n, m \u2264 2 500), the dimensions of the image.\n\nThe next n lines of input will contain a binary string with exactly m characters, representing the image.\n\n\n-----Output-----\n\nPrint a single integer, the minimum number of pixels needed to toggle to make the image compressible.\n\n\n-----Example-----\nInput\n3 5\n00100\n10110\n11001\n\nOutput\n5\n\n\n\n-----Note-----\n\nWe first choose k = 2.\n\nThe image is padded as follows: \n\n001000\n\n101100\n\n110010\n\n000000\n\n\n\nWe can toggle the image to look as follows: \n\n001100\n\n001100\n\n000000\n\n000000\n\n\n\nWe can see that this image is compressible for k = 2.", "raw_solution": "def apps_run1(n, m, pixels):\n    ans = 1 << 30\n\n    acc = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(n):\n        for j in range(m):\n            acc[i + 1][j + 1] = acc[i + 1][j] + int(pixels[i][j])\n        for j in range(m):\n            acc[i + 1][j + 1] += acc[i][j + 1]\n\n    for k in range(2, max(n, m) + 1):\n        r, c = (n + k - 1) // k, (m + k - 1) // k\n        res = 0\n        for i in range(r):\n            for j in range(c):\n                x, y = i * k, j * k\n                x2, y2 = min(x + k - 1, n - 1), min(y + k - 1, m - 1)\n                zero = acc[x2 + 1][y2 + 1] - acc[x][y2 + 1] - acc[x2 + 1][y] + acc[x][y]\n                res += min(zero, k * k - zero)\n        ans = min(ans, res)\n    return ans\n", "raw_test_input": ["assert apps_run1(3, 5, ['00100', '10110', '11001']) == 5", "assert apps_run1(4, 4, ['1111', '0000', '1111', '0000']) == 5", "assert apps_run1(2, 3, ['110', '101']) == 2", "assert apps_run1(5, 7, ['1010101', '0101010', '1010101', '0101010', '1010101']) == 17", "assert apps_run1(6, 6, ['111000', '111000', '111000', '000111', '000111', '000111']) == 0", "assert apps_run1(7, 8, ['00000000', '00000000', '11111111', '11111111', '00000000', '00000000', '11111111']) == 8"], "new_problem": "You are given an image represented as a 2-d n by m grid of pixels, where each pixel is either on or off, denoted by '0' or '1'. You want to compress this image by applying a series of transformations. Each transformation involves choosing a block size a by b and toggling pixels to make the image compressible for that block size. After applying all transformations, find the minimum number of pixels you need to toggle to make the image compressible for any of the given block sizes. This problem simulates a scenario where an image processing system needs to optimize storage by applying multiple compression strategies.", "new_solution": "def run(n, m, pixels):\n    ans = 1 << 30\n\n    acc = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(n):\n        for j in range(m):\n            acc[i + 1][j + 1] = acc[i + 1][j] + int(pixels[i][j])\n        for j in range(m):\n            acc[i + 1][j + 1] += acc[i][j + 1]\n\n    for k in range(2, max(n, m) + 1):\n        r, c = (n + k - 1) // k, (m + k - 1) // k\n        res = 0\n        for i in range(r):\n            for j in range(c):\n                x, y = i * k, j * k\n                x2, y2 = min(x + k - 1, n - 1), min(y + k - 1, m - 1)\n                zero = acc[x2 + 1][y2 + 1] - acc[x][y2 + 1] - acc[x2 + 1][y] + acc[x][y]\n                res += min(zero, k * k - zero)\n        ans = min(ans, res)\n    return ans\n\ndef apps_run2(n, m, pixels, transformations):\n    min_toggles = float('inf')\n    for a, b in transformations:\n        # Create a padded image for each transformation\n        padded_pixels = [row + '0' * ((b - len(row) % b) % b) for row in pixels]\n        padded_pixels += ['0' * len(padded_pixels[0])] * ((a - len(padded_pixels) % a) % a)\n        # Calculate toggles needed for this transformation\n        toggles = run(len(padded_pixels), len(padded_pixels[0]), padded_pixels)\n        min_toggles = min(min_toggles, toggles)\n    return min_toggles", "input_format": "The first parameter n is an integer in the range of 2 \u2264 n \u2264 2500, representing the number of rows in the image. The second parameter m is also an integer within the range of 2 \u2264 m \u2264 2500, indicating the number of columns in the image. The third parameter pixels is a list of strings, where each string consists of m characters, either '0' or '1', representing the pixels of each row in the image. The fourth parameter transformations is a list of tuples, where each tuple contains two integers a and b in the range of 1 \u2264 a, b \u2264 100, representing the dimensions of a transformation block.", "output_format": "The function returns a single integer, which is the minimum number of pixels needed to toggle to make the image compressible after applying all the given transformations. This integer represents the optimal result of the compression process under all the specified block - size transformations.", "test_input": ["assert apps_run2(3, 5, ['00100', '10110', '11001'], [(2, 2), (3, 3)]) == 5", "assert apps_run2(4, 4, ['1111', '1111', '1111', '1111'], [(2, 2), (4, 4)]) == 0", "assert apps_run2(2, 2, ['01', '10'], [(2, 2)]) == 2", "assert apps_run2(5, 5, ['00000', '00000', '00000', '00000', '00000'], [(3, 3), (5, 5)]) == 0", "assert apps_run2(3, 3, ['010', '101', '010'], [(2, 2), (3, 3)]) == 4"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "APPS/0111-2", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nYou are given an image, that can be represented with a 2-d n by m grid of pixels. Each pixel of the image is either on or off, denoted by the characters \"0\" or \"1\", respectively. You would like to compress this image. You want to choose an integer k > 1 and split the image into k by k blocks. If n and m are not divisible by k, the image is padded with only zeros on the right and bottom so that they are divisible by k. Each pixel in each individual block must have the same value. The given image may not be compressible in its current state. Find the minimum number of pixels you need to toggle (after padding) in order for the image to be compressible for some k. More specifically, the steps are to first choose k, then the image is padded with zeros, then, we can toggle the pixels so it is compressible for this k. The image must be compressible in that state.\n\n\n-----Input-----\n\nThe first line of input will contain two integers n, m (2 \u2264 n, m \u2264 2 500), the dimensions of the image.\n\nThe next n lines of input will contain a binary string with exactly m characters, representing the image.\n\n\n-----Output-----\n\nPrint a single integer, the minimum number of pixels needed to toggle to make the image compressible.\n\n\n-----Example-----\nInput\n3 5\n00100\n10110\n11001\n\nOutput\n5\n\n\n\n-----Note-----\n\nWe first choose k = 2.\n\nThe image is padded as follows: \n\n001000\n\n101100\n\n110010\n\n000000\n\n\n\nWe can toggle the image to look as follows: \n\n001100\n\n001100\n\n000000\n\n000000\n\n\n\nWe can see that this image is compressible for k = 2.", "raw_solution": "def apps_run1(n, m, pixels):\n    ans = 1 << 30\n\n    acc = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(n):\n        for j in range(m):\n            acc[i + 1][j + 1] = acc[i + 1][j] + int(pixels[i][j])\n        for j in range(m):\n            acc[i + 1][j + 1] += acc[i][j + 1]\n\n    for k in range(2, max(n, m) + 1):\n        r, c = (n + k - 1) // k, (m + k - 1) // k\n        res = 0\n        for i in range(r):\n            for j in range(c):\n                x, y = i * k, j * k\n                x2, y2 = min(x + k - 1, n - 1), min(y + k - 1, m - 1)\n                zero = acc[x2 + 1][y2 + 1] - acc[x][y2 + 1] - acc[x2 + 1][y] + acc[x][y]\n                res += min(zero, k * k - zero)\n        ans = min(ans, res)\n    return ans\n", "raw_test_input": ["assert apps_run1(3, 5, ['00100', '10110', '11001']) == 5", "assert apps_run1(4, 4, ['1111', '0000', '1111', '0000']) == 5", "assert apps_run1(2, 3, ['110', '101']) == 2", "assert apps_run1(5, 7, ['1010101', '0101010', '1010101', '0101010', '1010101']) == 17", "assert apps_run1(6, 6, ['111000', '111000', '111000', '000111', '000111', '000111']) == 0", "assert apps_run1(7, 8, ['00000000', '00000000', '11111111', '11111111', '00000000', '00000000', '11111111']) == 8"], "new_problem": "You are given an image, represented as a 2-d n by m grid of pixels. Each pixel is either on or off, denoted by '0' or '1'. You want to compress this image by choosing an integer k > 1 and splitting the image into k by k blocks. If n and m are not divisible by k, the image is padded with zeros on the right and bottom. Each pixel in each block must have the same value. The image may not be compressible in its current state. Find the minimum number of pixels you need to toggle (after padding) to make the image compressible for some k. Additionally, you can specify a preferred block size k. If specified, the function should prioritize this k, but still find the minimum toggles needed. The function should maintain backward compatibility, support original parameters, include type hints, and add new optional parameters.", "new_solution": "def apps_run2(n: int, m: int, pixels: list[str], preferred_k: int = None) -> int:\n    ans = 1 << 30\n\n    acc = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(n):\n        for j in range(m):\n            acc[i + 1][j + 1] = acc[i + 1][j] + int(pixels[i][j])\n        for j in range(m):\n            acc[i + 1][j + 1] += acc[i][j + 1]\n\n    k_range = range(2, max(n, m) + 1)\n    if preferred_k and 2 <= preferred_k <= max(n, m):\n        k_range = [preferred_k] + [k for k in k_range if k != preferred_k]\n\n    for k in k_range:\n        r, c = (n + k - 1) // k, (m + k - 1) // k\n        res = 0\n        for i in range(r):\n            for j in range(c):\n                x, y = i * k, j * k\n                x2, y2 = min(x + k - 1, n - 1), min(y + k - 1, m - 1)\n                zero = acc[x2 + 1][y2 + 1] - acc[x][y2 + 1] - acc[x2 + 1][y] + acc[x][y]\n                res += min(zero, k * k - zero)\n        ans = min(ans, res)\n    return ans", "input_format": "The function takes four parameters, with the last one being optional. The first parameter n is an integer in the range of 2 \u2264 n \u2264 2500, which represents the number of rows in the 2D image grid. The second parameter m is also an integer within the same range 2 \u2264 m \u2264 2500, denoting the number of columns in the image grid. The third parameter pixels is a list of strings, where each string has exactly m characters, and these characters are either '0' or '1', representing the on - off state of each pixel in the image. The fourth parameter preferred_k is an optional integer. If provided, it should be in the range of 2 \u2264 preferred_k \u2264 max(n, m), and it indicates a preferred block size for the image compression.", "output_format": "The function returns a single integer. This integer represents the minimum number of pixels that need to be toggled (after padding the image with zeros if necessary) to make the image compressible for some block size k. If a preferred_k is given, the function will prioritize considering this block size but still find the overall minimum toggles required.", "test_input": ["assert apps_run2(3, 5, ['00100', '10110', '11001']) == 5", "assert apps_run2(3, 5, ['00100', '10110', '11001'], preferred_k=3) == 5", "assert apps_run2(4, 4, ['1111', '1111', '1111', '1111']) == 0", "assert apps_run2(2, 2, ['01', '10']) == 2", "assert apps_run2(5, 5, ['00000', '00000', '00000', '00000', '00000'], preferred_k=2) == 0"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "APPS/0111-3", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nYou are given an image, that can be represented with a 2-d n by m grid of pixels. Each pixel of the image is either on or off, denoted by the characters \"0\" or \"1\", respectively. You would like to compress this image. You want to choose an integer k > 1 and split the image into k by k blocks. If n and m are not divisible by k, the image is padded with only zeros on the right and bottom so that they are divisible by k. Each pixel in each individual block must have the same value. The given image may not be compressible in its current state. Find the minimum number of pixels you need to toggle (after padding) in order for the image to be compressible for some k. More specifically, the steps are to first choose k, then the image is padded with zeros, then, we can toggle the pixels so it is compressible for this k. The image must be compressible in that state.\n\n\n-----Input-----\n\nThe first line of input will contain two integers n, m (2 \u2264 n, m \u2264 2 500), the dimensions of the image.\n\nThe next n lines of input will contain a binary string with exactly m characters, representing the image.\n\n\n-----Output-----\n\nPrint a single integer, the minimum number of pixels needed to toggle to make the image compressible.\n\n\n-----Example-----\nInput\n3 5\n00100\n10110\n11001\n\nOutput\n5\n\n\n\n-----Note-----\n\nWe first choose k = 2.\n\nThe image is padded as follows: \n\n001000\n\n101100\n\n110010\n\n000000\n\n\n\nWe can toggle the image to look as follows: \n\n001100\n\n001100\n\n000000\n\n000000\n\n\n\nWe can see that this image is compressible for k = 2.", "raw_solution": "def apps_run1(n, m, pixels):\n    ans = 1 << 30\n\n    acc = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(n):\n        for j in range(m):\n            acc[i + 1][j + 1] = acc[i + 1][j] + int(pixels[i][j])\n        for j in range(m):\n            acc[i + 1][j + 1] += acc[i][j + 1]\n\n    for k in range(2, max(n, m) + 1):\n        r, c = (n + k - 1) // k, (m + k - 1) // k\n        res = 0\n        for i in range(r):\n            for j in range(c):\n                x, y = i * k, j * k\n                x2, y2 = min(x + k - 1, n - 1), min(y + k - 1, m - 1)\n                zero = acc[x2 + 1][y2 + 1] - acc[x][y2 + 1] - acc[x2 + 1][y] + acc[x][y]\n                res += min(zero, k * k - zero)\n        ans = min(ans, res)\n    return ans\n", "raw_test_input": ["assert apps_run1(3, 5, ['00100', '10110', '11001']) == 5", "assert apps_run1(4, 4, ['1111', '0000', '1111', '0000']) == 5", "assert apps_run1(2, 3, ['110', '101']) == 2", "assert apps_run1(5, 7, ['1010101', '0101010', '1010101', '0101010', '1010101']) == 17", "assert apps_run1(6, 6, ['111000', '111000', '111000', '000111', '000111', '000111']) == 0", "assert apps_run1(7, 8, ['00000000', '00000000', '11111111', '11111111', '00000000', '00000000', '11111111']) == 8"], "new_problem": "You are given an image, represented as a 2-d n by m grid of pixels. Each pixel is either on or off, denoted by the characters '0' or '1'. You want to compress this image by choosing an integer k > 1 and splitting the image into k by k blocks. If n and m are not divisible by k, the image is padded with zeros on the right and bottom. Each pixel in each block must have the same value. The image may not be compressible in its current state. Find the minimum number of pixels you need to toggle (after padding) to make the image compressible for some k. However, this time, the image is represented as a dictionary where keys are tuples (i, j) representing pixel coordinates, and values are the pixel values ('0' or '1'). Additionally, the image can have 'holes' (missing pixels), which are represented by the absence of a key in the dictionary. You must handle these missing pixels by treating them as '0'.", "new_solution": "from typing import Dict, Tuple\n\ndef apps_run2(n: int, m: int, pixels: Dict[Tuple[int, int], str]) -> int:\n    ans = 1 << 30\n\n    acc = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(n):\n        for j in range(m):\n            pixel_value = int(pixels.get((i, j), '0'))\n            acc[i + 1][j + 1] = acc[i + 1][j] + pixel_value\n        for j in range(m):\n            acc[i + 1][j + 1] += acc[i][j + 1]\n\n    for k in range(2, max(n, m) + 1):\n        r, c = (n + k - 1) // k, (m + k - 1) // k\n        res = 0\n        for i in range(r):\n            for j in range(c):\n                x, y = i * k, j * k\n                x2, y2 = min(x + k - 1, n - 1), min(y + k - 1, m - 1)\n                zero = acc[x2 + 1][y2 + 1] - acc[x][y2 + 1] - acc[x2 + 1][y] + acc[x][y]\n                res += min(zero, k * k - zero)\n        ans = min(ans, res)\n    return ans", "input_format": "The first parameter n is an integer in the range of 2 \u2264 n \u2264 2500, which represents the number of rows of the 2D image. The second parameter m is also an integer within the same range 2 \u2264 m \u2264 2500, indicating the number of columns of the image. The third parameter pixels is a dictionary where the keys are tuples of integers (i, j) representing the coordinates of pixels in the image, and the values are strings '0' or '1' representing the on - off state of the corresponding pixels. Missing keys in the dictionary are treated as pixels with a value of '0'.", "output_format": "The function returns a single integer. This integer represents the minimum number of pixels that need to be toggled (after padding the image with zeros on the right and bottom if n and m are not divisible by k) to make the image compressible for some integer k > 1, where the image is split into k by k blocks and each block has pixels with the same value.", "test_input": ["assert apps_run2(3, 5, {(0, 0): '0', (0, 1): '0', (0, 2): '1', (0, 3): '0', (0, 4): '0', (1, 0): '1', (1, 1): '0', (1, 2): '1', (1, 3): '1', (1, 4): '0', (2, 0): '1', (2, 1): '1', (2, 2): '0', (2, 3): '0', (2, 4): '1'}) == 5", "assert apps_run2(4, 4, {(0, 0): '1', (0, 1): '1', (0, 2): '0', (0, 3): '0', (1, 0): '1', (1, 1): '1', (1, 2): '0', (1, 3): '0', (2, 0): '0', (2, 1): '0', (2, 2): '1', (2, 3): '1', (3, 0): '0', (3, 1): '0', (3, 2): '1', (3, 3): '1'}) == 0", "assert apps_run2(2, 2, {(0, 0): '1', (0, 1): '0', (1, 0): '0', (1, 1): '1'}) == 2", "assert apps_run2(3, 3, {(0, 0): '1', (0, 1): '1', (0, 2): '1', (1, 0): '1', (1, 1): '0', (1, 2): '1', (2, 0): '1', (2, 1): '1', (2, 2): '1'}) == 1", "assert apps_run2(5, 5, {(0, 0): '0', (0, 1): '0', (0, 2): '0', (0, 3): '0', (0, 4): '0', (1, 0): '0', (1, 1): '0', (1, 2): '0', (1, 3): '0', (1, 4): '0', (2, 0): '0', (2, 1): '0', (2, 2): '0', (2, 3): '0', (2, 4): '0', (3, 0): '0', (3, 1): '0', (3, 2): '0', (3, 3): '0', (3, 4): '0', (4, 0): '0', (4, 1): '0', (4, 2): '0', (4, 3): '0', (4, 4): '0'}) == 0"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "APPS/0111-4", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nYou are given an image, that can be represented with a 2-d n by m grid of pixels. Each pixel of the image is either on or off, denoted by the characters \"0\" or \"1\", respectively. You would like to compress this image. You want to choose an integer k > 1 and split the image into k by k blocks. If n and m are not divisible by k, the image is padded with only zeros on the right and bottom so that they are divisible by k. Each pixel in each individual block must have the same value. The given image may not be compressible in its current state. Find the minimum number of pixels you need to toggle (after padding) in order for the image to be compressible for some k. More specifically, the steps are to first choose k, then the image is padded with zeros, then, we can toggle the pixels so it is compressible for this k. The image must be compressible in that state.\n\n\n-----Input-----\n\nThe first line of input will contain two integers n, m (2 \u2264 n, m \u2264 2 500), the dimensions of the image.\n\nThe next n lines of input will contain a binary string with exactly m characters, representing the image.\n\n\n-----Output-----\n\nPrint a single integer, the minimum number of pixels needed to toggle to make the image compressible.\n\n\n-----Example-----\nInput\n3 5\n00100\n10110\n11001\n\nOutput\n5\n\n\n\n-----Note-----\n\nWe first choose k = 2.\n\nThe image is padded as follows: \n\n001000\n\n101100\n\n110010\n\n000000\n\n\n\nWe can toggle the image to look as follows: \n\n001100\n\n001100\n\n000000\n\n000000\n\n\n\nWe can see that this image is compressible for k = 2.", "raw_solution": "def apps_run1(n, m, pixels):\n    ans = 1 << 30\n\n    acc = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(n):\n        for j in range(m):\n            acc[i + 1][j + 1] = acc[i + 1][j] + int(pixels[i][j])\n        for j in range(m):\n            acc[i + 1][j + 1] += acc[i][j + 1]\n\n    for k in range(2, max(n, m) + 1):\n        r, c = (n + k - 1) // k, (m + k - 1) // k\n        res = 0\n        for i in range(r):\n            for j in range(c):\n                x, y = i * k, j * k\n                x2, y2 = min(x + k - 1, n - 1), min(y + k - 1, m - 1)\n                zero = acc[x2 + 1][y2 + 1] - acc[x][y2 + 1] - acc[x2 + 1][y] + acc[x][y]\n                res += min(zero, k * k - zero)\n        ans = min(ans, res)\n    return ans\n", "raw_test_input": ["assert apps_run1(3, 5, ['00100', '10110', '11001']) == 5", "assert apps_run1(4, 4, ['1111', '0000', '1111', '0000']) == 5", "assert apps_run1(2, 3, ['110', '101']) == 2", "assert apps_run1(5, 7, ['1010101', '0101010', '1010101', '0101010', '1010101']) == 17", "assert apps_run1(6, 6, ['111000', '111000', '111000', '000111', '000111', '000111']) == 0", "assert apps_run1(7, 8, ['00000000', '00000000', '11111111', '11111111', '00000000', '00000000', '11111111']) == 8"], "new_problem": "You are given an image represented by a 2-d n by m grid of pixels. Each pixel is either on or off, denoted by '0' or '1'. You want to compress this image by choosing an integer k > 1 and splitting the image into k by k blocks. If n and m are not divisible by k, the image is padded with zeros on the right and bottom. Each pixel in each block must have the same value. The image may not be compressible in its current state. Find the minimum number of pixels you need to toggle (after padding) to make the image compressible for some k. Implement error handling for the following scenarios: 1. Invalid input dimensions (e.g., n or m not within the specified range). 2. Non-binary characters in the image. 3. Inconsistent row lengths. 4. Handle file reading errors if the input is from a file. 5. Propagate errors with meaningful messages.", "new_solution": "from typing import List\n\nclass ImageCompressionError(Exception):\n    pass\n\nclass InvalidDimensionsError(ImageCompressionError):\n    pass\n\nclass NonBinaryCharacterError(ImageCompressionError):\n    pass\n\nclass InconsistentRowLengthError(ImageCompressionError):\n    pass\n\ndef apps_run2(n: int, m: int, pixels: List[str]) -> int:\n    if not (2 <= n <= 2500) or not (2 <= m <= 2500):\n        raise InvalidDimensionsError(\"Dimensions n and m must be between 2 and 2500.\")\n    if any(len(row) != m for row in pixels):\n        raise InconsistentRowLengthError(\"All rows must have the same length as specified by m.\")\n    if any(char not in '01' for row in pixels for char in row):\n        raise NonBinaryCharacterError(\"Pixels must be either '0' or '1'.\")\n\n    ans = 1 << 30\n    acc = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(n):\n        for j in range(m):\n            acc[i + 1][j + 1] = acc[i + 1][j] + int(pixels[i][j])\n        for j in range(m):\n            acc[i + 1][j + 1] += acc[i][j + 1]\n\n    for k in range(2, max(n, m) + 1):\n        r, c = (n + k - 1) // k, (m + k - 1) // k\n        res = 0\n        for i in range(r):\n            for j in range(c):\n                x, y = i * k, j * k\n                x2, y2 = min(x + k - 1, n - 1), min(y + k - 1, m - 1)\n                zero = acc[x2 + 1][y2 + 1] - acc[x][y2 + 1] - acc[x2 + 1][y] + acc[x][y]\n                res += min(zero, k * k - zero)\n        ans = min(ans, res)\n    return ans", "input_format": "The first parameter n is an integer that must satisfy 2 \u2264 n \u2264 2500, representing the number of rows in the 2D image grid. The second parameter m is also an integer within the range 2 \u2264 m \u2264 2500, denoting the number of columns in the image grid. The third parameter pixels is a list of strings, where each string in the list corresponds to a row in the image, and each string must have exactly m characters, which can only be either '0' or '1' to represent the on - off state of each pixel.", "output_format": "The function returns a single integer. This integer represents the minimum number of pixels that need to be toggled (after padding the image with zeros on the right and bottom if n and m are not divisible by k) to make the image compressible for some integer k > 1, where the image is split into k by k blocks and all pixels within each block have the same value. If there are issues with the input such as invalid dimensions, non - binary characters in the pixel strings, or inconsistent row lengths, the function will raise custom exceptions with meaningful error messages.", "test_input": ["assert apps_run2(3, 5, ['00100', '10110', '11001']) == 5", "try:\n    apps_run2(1, 5, ['00100'])\nexcept InvalidDimensionsError as e:\n    assert str(e) == 'Dimensions n and m must be between 2 and 2500.'", "try:\n    apps_run2(3, 5, ['0010', '10110', '11001'])\nexcept InconsistentRowLengthError as e:\n    assert str(e) == 'All rows must have the same length as specified by m.'", "assert apps_run2(2, 3, ['001', '110']) == 3", "assert apps_run2(2, 2, ['00', '11']) == 2"], "requirement_type": "PROMPT_ERROR_HANDLING"}
{"task_id": "APPS/0110-1", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nOn February 14 Denis decided to give Valentine to Nastya and did not come up with anything better than to draw a huge red heart on the door of the length $k$ ($k \\ge 3$). Nastya was very confused by this present, so she decided to break the door, throwing it on the mountains.\n\nMountains are described by a sequence of heights $a_1, a_2, \\dots, a_n$ in order from left to right ($k \\le n$). It is guaranteed that neighboring heights are not equal to each other (that is, $a_i \\ne a_{i+1}$ for all $i$ from $1$ to $n-1$).\n\nPeaks of mountains on the segment $[l,r]$ (from $l$ to $r$) are called indexes $i$ such that $l < i < r$, $a_{i - 1} < a_i$ and $a_i > a_{i + 1}$. It is worth noting that the boundary indexes $l$ and $r$ for the segment are not peaks. For example, if $n=8$ and $a=[3,1,4,1,5,9,2,6]$, then the segment $[1,8]$ has only two peaks (with indexes $3$ and $6$), and there are no peaks on the segment $[3, 6]$.\n\nTo break the door, Nastya throws it to a segment $[l,l+k-1]$ of consecutive mountains of length $k$ ($1 \\le l \\le n-k+1$). When the door touches the peaks of the mountains, it breaks into two parts, after that these parts will continue to fall in different halves and also break into pieces when touching the peaks of the mountains, and so on. Formally, the number of parts that the door will break into will be equal to $p+1$, where $p$ is the number of peaks on the segment $[l,l+k-1]$.\n\nNastya wants to break it into as many pieces as possible. Help her choose such a segment of mountains $[l, l+k-1]$ that the number of peaks on it is maximum. If there are several optimal segments, Nastya wants to find one for which the value $l$ is minimal.\n\nFormally, you need to choose a segment of mountains $[l, l+k-1]$ that has the maximum number of peaks. Among all such segments, you need to find the segment that has the minimum possible value $l$.\n\n\n-----Input-----\n\nThe first line contains an integer $t$ ($1 \\leq t \\leq 10^4$) \u00a0\u2014 the number of test cases. Then the descriptions of the test cases follow.\n\nThe first line of each test case contains two integers $n$ and $k$ ($3 \\leq k \\leq n \\leq 2 \\cdot 10^5$) \u00a0\u2014 the number of mountains and the length of the door.\n\nThe second line of the input data set contains $n$ integers $a_1, a_2, \\dots, a_n$ ($0 \\leq a_i \\leq 10 ^ 9$, $a_i \\neq a_{i + 1}$) \u00a0\u2014 the heights of mountains.\n\nIt is guaranteed that the sum of $n$ over all the test cases will not exceed $2 \\cdot 10^5$.\n\n\n-----Output-----\n\nFor each test case, output two integers $t$ and $l$ \u00a0\u2014 the maximum number of parts that the door can split into, and the left border of the segment of length $k$ that the door should be reset to.\n\n\n-----Example-----\nInput\n5\n8 6\n1 2 4 1 2 4 1 2\n5 3\n3 2 3 2 1\n10 4\n4 3 4 3 2 3 2 1 0 1\n15 7\n3 7 4 8 2 3 4 5 21 2 3 4 2 1 3\n7 5\n1 2 3 4 5 6 1\n\nOutput\n3 2\n2 2\n2 1\n3 1\n2 3\n\n\n\n-----Note-----\n\nIn the first example, you need to select a segment of mountains from $2$ to $7$. In this segment, the indexes $3$ and $6$ are peaks, so the answer is $3$ (only $2$ peaks, so the door will break into $3$ parts). It is not difficult to notice that the mountain segments $[1, 6]$ and $[3, 8]$ are not suitable since they only have a $1$ peak (for the first segment, the $6$ index is not a peak, and for the second segment, the $3$ index is not a peak).\n\nIn the second example, you need to select a segment of mountains from $2$ to $4$. In this segment, the index $3$ is a peak, so the answer is $2$ (only $1$ peak, so the door will break into $2$ parts).\n\nIn the third example, you need to select a segment of mountains from $1$ to $4$. In this segment, the index $3$ is a peak, so the answer is $2$ (only $1$ peak, so the door will break into $2$ parts). You can see that on the segments $[2, 5]$, $[4, 7]$ and $[5, 8]$ the number of peaks is also $1$, but these segments have a left border greater than the segment $[1, 4]$, so they are not the correct answer.", "raw_solution": "def apps_run1(test_cases):\n    results = []\n    for n, k, arr in test_cases:\n        peaks = [0 for i in range(n)]\n        for i in range(1, n - 1):\n            if arr[i] > arr[i - 1] and arr[i] > arr[i + 1]:\n                peaks[i] = 1\n\n        cnt = 0\n        max_peaks = 0\n        answer = 0\n\n        for i in range(k - 1):\n            cnt += peaks[i]\n            max_peaks += peaks[i]\n\n        for i in range(k - 1, n - 1):\n            cnt -= peaks[i - k + 2]\n            cnt += peaks[i]\n            if cnt > max_peaks:\n                max_peaks = cnt\n                answer = i - k + 2\n\n        results.append((max_peaks + 1, answer + 1))\n    return results", "raw_test_input": ["assert apps_run1([(8, 6, [1, 2, 4, 1, 2, 4, 1, 2]), (5, 3, [3, 2, 3, 2, 1]), (10, 4, [4, 3, 4, 3, 2, 3, 2, 1, 0, 1]), (15, 7, [3, 7, 4, 8, 2, 3, 4, 5, 21, 2, 3, 4, 2, 1, 3]), (7, 5, [1, 2, 3, 4, 5, 6, 1])]) == [(3, 2), (2, 2), (2, 1), (3, 1), (2, 3)]", "assert apps_run1([(10, 5, [1, 3, 2, 5, 4, 6, 7, 8, 3, 2]), (6, 4, [10, 20, 10, 30, 20, 10]), (12, 6, [5, 1, 6, 2, 7, 3, 8, 4, 9, 5, 10, 6])]) == [(3, 1), (2, 1), (3, 1)]", "assert apps_run1([(7, 4, [1, 2, 1, 3, 1, 4, 1]), (5, 3, [1, 3, 2, 4, 1]), (8, 5, [2, 1, 3, 1, 4, 1, 5, 1]), (9, 6, [1, 2, 3, 1, 4, 1, 5, 1, 6])]) == [(2, 1), (2, 1), (3, 2), (3, 1)]", "assert apps_run1([(12, 8, [1, 2, 3, 4, 5, 6, 5, 4, 3, 2, 1, 0]), (15, 5, [5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5])]) == [(2, 1), (3, 2)]", "assert apps_run1([(9, 3, [1, 3, 2, 5, 4, 6, 5, 8, 7]), (11, 7, [1, 2, 3, 4, 5, 6, 5, 4, 3, 2, 1]), (10, 4, [2, 1, 3, 1, 4, 1, 5, 1, 6, 1])]) == [(2, 1), (2, 1), (2, 1)]", "assert apps_run1([(8, 5, [1, 2, 3, 2, 4, 1, 5, 1])]) == [(3, 2)]"], "new_problem": "In a mountainous region, a new transportation system is being planned to optimize the delivery of goods. The system involves deploying drones that can carry packages over mountain ranges. Each drone can carry a package over a segment of mountains of length k. The efficiency of the drone's journey is determined by the number of peaks it encounters, as each peak requires additional energy to navigate. The goal is to find the segment of mountains that maximizes the number of peaks, thus allowing the drone to use its energy reserves optimally. Given multiple test cases, each describing a sequence of mountain heights, determine the segment of length k that contains the maximum number of peaks for each test case. If there are multiple such segments, choose the one with the smallest starting index. This will help in planning the most energy-efficient routes for the drones.", "new_solution": "def find_max_peaks(n, k, arr):\n    peaks = [0 for i in range(n)]\n    for i in range(1, n - 1):\n        if arr[i] > arr[i - 1] and arr[i] > arr[i + 1]:\n            peaks[i] = 1\n\n    cnt = 0\n    max_peaks = 0\n    answer = 0\n\n    for i in range(k - 1):\n        cnt += peaks[i]\n        max_peaks += peaks[i]\n\n    for i in range(k - 1, n - 1):\n        cnt -= peaks[i - k + 2]\n        cnt += peaks[i]\n        if cnt > max_peaks:\n            max_peaks = cnt\n            answer = i - k + 2\n\n    return max_peaks + 1, answer + 1\n\n\ndef apps_run2(test_cases):\n    results = []\n    for n, k, arr in test_cases:\n        result = find_max_peaks(n, k, arr)\n        results.append(result)\n    return results", "input_format": "\u00a0The parameter is a list where each element represents a distinct test case. Each test - case element is a tuple that consists of three components:1. An integer\u00a0n\u00a0in the range\u00a03 \u2264 k \u2264 n \u2264 2 * 10^5, which represents the total number of mountains in a given sequence. 2.An integer\u00a0k\u00a0also in the range\u00a03 \u2264 k \u2264 n \u2264 2 * 10^5, denoting the length of the segment that a drone can cover while flying over the mountains. 3. A list\u00a0arr\u00a0of\u00a0n\u00a0integers, where each integer\u00a0a_i\u00a0satisfies\u00a00 \u2264 a_i \u2264 10^9\u00a0and\u00a0a_i \u2260 a_{i + 1}. This list represents the heights of the mountains in the sequence from left to right.", "output_format": "The function returns a list of tuples. Each tuple in the returned list corresponds to a test case in the input. The first integer in each result tuple represents the maximum number of \"parts\" (the number of peaks in the segment plus one) that the drone will encounter when flying over the most optimal segment of length k, which is an efficiency - related metric for the drone's journey. The second integer represents the left - hand index (starting from 1) of the segment of length k that the drone should follow to achieve the maximum number of peak encounters. ", "test_input": ["assert apps_run2([(8, 6, [1, 2, 4, 1, 2, 4, 1, 2])]) == [(3, 2)]", "assert apps_run2([(5, 3, [3, 2, 3, 2, 1])]) == [(2, 2)]", "assert apps_run2([(10, 4, [4, 3, 4, 3, 2, 3, 2, 1, 0, 1])]) == [(2, 1)]", "assert apps_run2([(15, 7, [3, 7, 4, 8, 2, 3, 4, 5, 21, 2, 3, 4, 2, 1, 3])]) == [(3, 1)]", "assert apps_run2([(7, 5, [1, 2, 3, 4, 5, 6, 1])]) == [(2, 3)]"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "APPS/0110-2", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nOn February 14 Denis decided to give Valentine to Nastya and did not come up with anything better than to draw a huge red heart on the door of the length $k$ ($k \\ge 3$). Nastya was very confused by this present, so she decided to break the door, throwing it on the mountains.\n\nMountains are described by a sequence of heights $a_1, a_2, \\dots, a_n$ in order from left to right ($k \\le n$). It is guaranteed that neighboring heights are not equal to each other (that is, $a_i \\ne a_{i+1}$ for all $i$ from $1$ to $n-1$).\n\nPeaks of mountains on the segment $[l,r]$ (from $l$ to $r$) are called indexes $i$ such that $l < i < r$, $a_{i - 1} < a_i$ and $a_i > a_{i + 1}$. It is worth noting that the boundary indexes $l$ and $r$ for the segment are not peaks. For example, if $n=8$ and $a=[3,1,4,1,5,9,2,6]$, then the segment $[1,8]$ has only two peaks (with indexes $3$ and $6$), and there are no peaks on the segment $[3, 6]$.\n\nTo break the door, Nastya throws it to a segment $[l,l+k-1]$ of consecutive mountains of length $k$ ($1 \\le l \\le n-k+1$). When the door touches the peaks of the mountains, it breaks into two parts, after that these parts will continue to fall in different halves and also break into pieces when touching the peaks of the mountains, and so on. Formally, the number of parts that the door will break into will be equal to $p+1$, where $p$ is the number of peaks on the segment $[l,l+k-1]$.\n\nNastya wants to break it into as many pieces as possible. Help her choose such a segment of mountains $[l, l+k-1]$ that the number of peaks on it is maximum. If there are several optimal segments, Nastya wants to find one for which the value $l$ is minimal.\n\nFormally, you need to choose a segment of mountains $[l, l+k-1]$ that has the maximum number of peaks. Among all such segments, you need to find the segment that has the minimum possible value $l$.\n\n\n-----Input-----\n\nThe first line contains an integer $t$ ($1 \\leq t \\leq 10^4$) \u00a0\u2014 the number of test cases. Then the descriptions of the test cases follow.\n\nThe first line of each test case contains two integers $n$ and $k$ ($3 \\leq k \\leq n \\leq 2 \\cdot 10^5$) \u00a0\u2014 the number of mountains and the length of the door.\n\nThe second line of the input data set contains $n$ integers $a_1, a_2, \\dots, a_n$ ($0 \\leq a_i \\leq 10 ^ 9$, $a_i \\neq a_{i + 1}$) \u00a0\u2014 the heights of mountains.\n\nIt is guaranteed that the sum of $n$ over all the test cases will not exceed $2 \\cdot 10^5$.\n\n\n-----Output-----\n\nFor each test case, output two integers $t$ and $l$ \u00a0\u2014 the maximum number of parts that the door can split into, and the left border of the segment of length $k$ that the door should be reset to.\n\n\n-----Example-----\nInput\n5\n8 6\n1 2 4 1 2 4 1 2\n5 3\n3 2 3 2 1\n10 4\n4 3 4 3 2 3 2 1 0 1\n15 7\n3 7 4 8 2 3 4 5 21 2 3 4 2 1 3\n7 5\n1 2 3 4 5 6 1\n\nOutput\n3 2\n2 2\n2 1\n3 1\n2 3\n\n\n\n-----Note-----\n\nIn the first example, you need to select a segment of mountains from $2$ to $7$. In this segment, the indexes $3$ and $6$ are peaks, so the answer is $3$ (only $2$ peaks, so the door will break into $3$ parts). It is not difficult to notice that the mountain segments $[1, 6]$ and $[3, 8]$ are not suitable since they only have a $1$ peak (for the first segment, the $6$ index is not a peak, and for the second segment, the $3$ index is not a peak).\n\nIn the second example, you need to select a segment of mountains from $2$ to $4$. In this segment, the index $3$ is a peak, so the answer is $2$ (only $1$ peak, so the door will break into $2$ parts).\n\nIn the third example, you need to select a segment of mountains from $1$ to $4$. In this segment, the index $3$ is a peak, so the answer is $2$ (only $1$ peak, so the door will break into $2$ parts). You can see that on the segments $[2, 5]$, $[4, 7]$ and $[5, 8]$ the number of peaks is also $1$, but these segments have a left border greater than the segment $[1, 4]$, so they are not the correct answer.", "raw_solution": "def apps_run1(test_cases):\n    results = []\n    for n, k, arr in test_cases:\n        peaks = [0 for i in range(n)]\n        for i in range(1, n - 1):\n            if arr[i] > arr[i - 1] and arr[i] > arr[i + 1]:\n                peaks[i] = 1\n\n        cnt = 0\n        max_peaks = 0\n        answer = 0\n\n        for i in range(k - 1):\n            cnt += peaks[i]\n            max_peaks += peaks[i]\n\n        for i in range(k - 1, n - 1):\n            cnt -= peaks[i - k + 2]\n            cnt += peaks[i]\n            if cnt > max_peaks:\n                max_peaks = cnt\n                answer = i - k + 2\n\n        results.append((max_peaks + 1, answer + 1))\n    return results", "raw_test_input": ["assert apps_run1([(8, 6, [1, 2, 4, 1, 2, 4, 1, 2]), (5, 3, [3, 2, 3, 2, 1]), (10, 4, [4, 3, 4, 3, 2, 3, 2, 1, 0, 1]), (15, 7, [3, 7, 4, 8, 2, 3, 4, 5, 21, 2, 3, 4, 2, 1, 3]), (7, 5, [1, 2, 3, 4, 5, 6, 1])]) == [(3, 2), (2, 2), (2, 1), (3, 1), (2, 3)]", "assert apps_run1([(10, 5, [1, 3, 2, 5, 4, 6, 7, 8, 3, 2]), (6, 4, [10, 20, 10, 30, 20, 10]), (12, 6, [5, 1, 6, 2, 7, 3, 8, 4, 9, 5, 10, 6])]) == [(3, 1), (2, 1), (3, 1)]", "assert apps_run1([(7, 4, [1, 2, 1, 3, 1, 4, 1]), (5, 3, [1, 3, 2, 4, 1]), (8, 5, [2, 1, 3, 1, 4, 1, 5, 1]), (9, 6, [1, 2, 3, 1, 4, 1, 5, 1, 6])]) == [(2, 1), (2, 1), (3, 2), (3, 1)]", "assert apps_run1([(12, 8, [1, 2, 3, 4, 5, 6, 5, 4, 3, 2, 1, 0]), (15, 5, [5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5])]) == [(2, 1), (3, 2)]", "assert apps_run1([(9, 3, [1, 3, 2, 5, 4, 6, 5, 8, 7]), (11, 7, [1, 2, 3, 4, 5, 6, 5, 4, 3, 2, 1]), (10, 4, [2, 1, 3, 1, 4, 1, 5, 1, 6, 1])]) == [(2, 1), (2, 1), (2, 1)]", "assert apps_run1([(8, 5, [1, 2, 3, 2, 4, 1, 5, 1])]) == [(3, 2)]"], "new_problem": "Denis wants to enhance the functionality of the mountain peak problem by adding an optional parameter that allows specifying a minimum peak height difference. This parameter will ensure that only peaks with a height difference greater than or equal to this value are considered valid peaks. The function should maintain backward compatibility, meaning it should work as before if this parameter is not provided. Implement this enhancement while ensuring the original function parameters are supported and include type hints.", "new_solution": "from typing import List, Tuple, Optional\n\ndef apps_run2(t: int, test_cases: List[Tuple[int, int, List[int]]], min_peak_diff: Optional[int] = None) -> List[Tuple[int, int]]:\n    results = []\n    for case in test_cases:\n        n, k, arr = case\n\n        peaks = [0 for _ in range(n)]\n        for i in range(1, n - 1):\n            if arr[i] > arr[i - 1] and arr[i] > arr[i + 1]:\n                if min_peak_diff is None or (arr[i] - arr[i - 1] >= min_peak_diff and arr[i] - arr[i + 1] >= min_peak_diff):\n                    peaks[i] = 1\n\n        cnt = 0\n        max_peaks = 0\n        answer = 0\n\n        for i in range(k - 1):\n            cnt += peaks[i]\n            max_peaks += peaks[i]\n\n        for i in range(k - 1, n - 1):\n            cnt -= peaks[i - k + 2]\n            cnt += peaks[i]\n            if cnt > max_peaks:\n                max_peaks = cnt\n                answer = i - k + 2\n\n        results.append((max_peaks + 1, answer + 1))\n\n    return results", "input_format": "The function accepts three parameters, with the last one being optional. The first parameter t is an integer within the range of 1 \u2264 t \u2264 10^4, indicating the number of test cases. The second parameter test_cases is a list of tuples. Each tuple in this list represents a test case and consists of three elements: an integer n (3 \u2264 k \u2264 n \u2264 2 * 10^5), which is the number of mountains; an integer k (3 \u2264 k \u2264 n \u2264 2 * 10^5), representing the length of the segment; and a list of integers arr, where each integer a_i meets the conditions 0 \u2264 a_i \u2264 10^9 and a_i \u2260 a_{i + 1}, representing the heights of the mountains from left to right. The third parameter min_peak_diff is an optional integer. If it is provided, it specifies the minimum height difference that a peak must have compared to its neighboring mountains to be regarded as a valid peak. If it is not provided, all peaks that meet the basic condition (a_{i - 1} < a_i and a_i > a_{i + 1}) are considered valid. ", "output_format": "The function returns a list of tuples. Each tuple in the returned list corresponds to a test case. Each tuple contains two integers: the first integer represents the maximum number of parts that the \"door\" (or relevant operation) can split into, which is calculated as the number of valid peaks in the optimal segment plus one; the second integer represents the left - hand index (starting from 1) of the segment of length k that should be chosen to obtain the maximum number of valid peaks.", "test_input": ["assert apps_run2(5, [(8, 6, [1, 2, 4, 1, 2, 4, 1, 2]), (5, 3, [3, 2, 3, 2, 1]), (10, 4, [4, 3, 4, 3, 2, 3, 2, 1, 0, 1]), (15, 7, [3, 7, 4, 8, 2, 3, 4, 5, 21, 2, 3, 4, 2, 1, 3]), (7, 5, [1, 2, 3, 4, 5, 6, 1])]) == [(3, 2), (2, 2), (2, 1), (3, 1), (2, 3)]", "assert apps_run2(1, [(8, 6, [1, 2, 4, 1, 2, 4, 1, 2])], min_peak_diff=2) == [(3, 2)]", "assert apps_run2(1, [(8, 6, [1, 2, 4, 1, 2, 4, 1, 2])], min_peak_diff=3) == [(1, 1)]", "assert apps_run2(1, [(5, 3, [3, 2, 3, 2, 1])], min_peak_diff=1) == [(2, 2)]", "assert apps_run2(1, [(10, 4, [4, 3, 4, 3, 2, 3, 2, 1, 0, 1])], min_peak_diff=0) == [(2, 1)]"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "APPS/0110-3", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nOn February 14 Denis decided to give Valentine to Nastya and did not come up with anything better than to draw a huge red heart on the door of the length $k$ ($k \\ge 3$). Nastya was very confused by this present, so she decided to break the door, throwing it on the mountains.\n\nMountains are described by a sequence of heights $a_1, a_2, \\dots, a_n$ in order from left to right ($k \\le n$). It is guaranteed that neighboring heights are not equal to each other (that is, $a_i \\ne a_{i+1}$ for all $i$ from $1$ to $n-1$).\n\nPeaks of mountains on the segment $[l,r]$ (from $l$ to $r$) are called indexes $i$ such that $l < i < r$, $a_{i - 1} < a_i$ and $a_i > a_{i + 1}$. It is worth noting that the boundary indexes $l$ and $r$ for the segment are not peaks. For example, if $n=8$ and $a=[3,1,4,1,5,9,2,6]$, then the segment $[1,8]$ has only two peaks (with indexes $3$ and $6$), and there are no peaks on the segment $[3, 6]$.\n\nTo break the door, Nastya throws it to a segment $[l,l+k-1]$ of consecutive mountains of length $k$ ($1 \\le l \\le n-k+1$). When the door touches the peaks of the mountains, it breaks into two parts, after that these parts will continue to fall in different halves and also break into pieces when touching the peaks of the mountains, and so on. Formally, the number of parts that the door will break into will be equal to $p+1$, where $p$ is the number of peaks on the segment $[l,l+k-1]$.\n\nNastya wants to break it into as many pieces as possible. Help her choose such a segment of mountains $[l, l+k-1]$ that the number of peaks on it is maximum. If there are several optimal segments, Nastya wants to find one for which the value $l$ is minimal.\n\nFormally, you need to choose a segment of mountains $[l, l+k-1]$ that has the maximum number of peaks. Among all such segments, you need to find the segment that has the minimum possible value $l$.\n\n\n-----Input-----\n\nThe first line contains an integer $t$ ($1 \\leq t \\leq 10^4$) \u00a0\u2014 the number of test cases. Then the descriptions of the test cases follow.\n\nThe first line of each test case contains two integers $n$ and $k$ ($3 \\leq k \\leq n \\leq 2 \\cdot 10^5$) \u00a0\u2014 the number of mountains and the length of the door.\n\nThe second line of the input data set contains $n$ integers $a_1, a_2, \\dots, a_n$ ($0 \\leq a_i \\leq 10 ^ 9$, $a_i \\neq a_{i + 1}$) \u00a0\u2014 the heights of mountains.\n\nIt is guaranteed that the sum of $n$ over all the test cases will not exceed $2 \\cdot 10^5$.\n\n\n-----Output-----\n\nFor each test case, output two integers $t$ and $l$ \u00a0\u2014 the maximum number of parts that the door can split into, and the left border of the segment of length $k$ that the door should be reset to.\n\n\n-----Example-----\nInput\n5\n8 6\n1 2 4 1 2 4 1 2\n5 3\n3 2 3 2 1\n10 4\n4 3 4 3 2 3 2 1 0 1\n15 7\n3 7 4 8 2 3 4 5 21 2 3 4 2 1 3\n7 5\n1 2 3 4 5 6 1\n\nOutput\n3 2\n2 2\n2 1\n3 1\n2 3\n\n\n\n-----Note-----\n\nIn the first example, you need to select a segment of mountains from $2$ to $7$. In this segment, the indexes $3$ and $6$ are peaks, so the answer is $3$ (only $2$ peaks, so the door will break into $3$ parts). It is not difficult to notice that the mountain segments $[1, 6]$ and $[3, 8]$ are not suitable since they only have a $1$ peak (for the first segment, the $6$ index is not a peak, and for the second segment, the $3$ index is not a peak).\n\nIn the second example, you need to select a segment of mountains from $2$ to $4$. In this segment, the index $3$ is a peak, so the answer is $2$ (only $1$ peak, so the door will break into $2$ parts).\n\nIn the third example, you need to select a segment of mountains from $1$ to $4$. In this segment, the index $3$ is a peak, so the answer is $2$ (only $1$ peak, so the door will break into $2$ parts). You can see that on the segments $[2, 5]$, $[4, 7]$ and $[5, 8]$ the number of peaks is also $1$, but these segments have a left border greater than the segment $[1, 4]$, so they are not the correct answer.", "raw_solution": "def apps_run1(test_cases):\n    results = []\n    for n, k, arr in test_cases:\n        peaks = [0 for i in range(n)]\n        for i in range(1, n - 1):\n            if arr[i] > arr[i - 1] and arr[i] > arr[i + 1]:\n                peaks[i] = 1\n\n        cnt = 0\n        max_peaks = 0\n        answer = 0\n\n        for i in range(k - 1):\n            cnt += peaks[i]\n            max_peaks += peaks[i]\n\n        for i in range(k - 1, n - 1):\n            cnt -= peaks[i - k + 2]\n            cnt += peaks[i]\n            if cnt > max_peaks:\n                max_peaks = cnt\n                answer = i - k + 2\n\n        results.append((max_peaks + 1, answer + 1))\n    return results", "raw_test_input": ["assert apps_run1([(8, 6, [1, 2, 4, 1, 2, 4, 1, 2]), (5, 3, [3, 2, 3, 2, 1]), (10, 4, [4, 3, 4, 3, 2, 3, 2, 1, 0, 1]), (15, 7, [3, 7, 4, 8, 2, 3, 4, 5, 21, 2, 3, 4, 2, 1, 3]), (7, 5, [1, 2, 3, 4, 5, 6, 1])]) == [(3, 2), (2, 2), (2, 1), (3, 1), (2, 3)]", "assert apps_run1([(10, 5, [1, 3, 2, 5, 4, 6, 7, 8, 3, 2]), (6, 4, [10, 20, 10, 30, 20, 10]), (12, 6, [5, 1, 6, 2, 7, 3, 8, 4, 9, 5, 10, 6])]) == [(3, 1), (2, 1), (3, 1)]", "assert apps_run1([(7, 4, [1, 2, 1, 3, 1, 4, 1]), (5, 3, [1, 3, 2, 4, 1]), (8, 5, [2, 1, 3, 1, 4, 1, 5, 1]), (9, 6, [1, 2, 3, 1, 4, 1, 5, 1, 6])]) == [(2, 1), (2, 1), (3, 2), (3, 1)]", "assert apps_run1([(12, 8, [1, 2, 3, 4, 5, 6, 5, 4, 3, 2, 1, 0]), (15, 5, [5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5])]) == [(2, 1), (3, 2)]", "assert apps_run1([(9, 3, [1, 3, 2, 5, 4, 6, 5, 8, 7]), (11, 7, [1, 2, 3, 4, 5, 6, 5, 4, 3, 2, 1]), (10, 4, [2, 1, 3, 1, 4, 1, 5, 1, 6, 1])]) == [(2, 1), (2, 1), (2, 1)]", "assert apps_run1([(8, 5, [1, 2, 3, 2, 4, 1, 5, 1])]) == [(3, 2)]"], "new_problem": "Denis decided to give a more complex gift to Nastya by drawing a huge red heart on a door of length k (k \u2265 3). Nastya, confused by this present, decided to break the door by throwing it on the mountains. The mountains are described by a sequence of heights a_1, a_2, ..., a_n in order from left to right (k \u2264 n). Each mountain also has a unique identifier id_i. It is guaranteed that neighboring heights are not equal to each other (a_i \u2260 a_{i+1} for all i from 1 to n-1). Peaks of mountains on the segment [l,r] (from l to r) are called indexes i such that l < i < r, a_{i - 1} < a_i and a_i > a_{i + 1}. The boundary indexes l and r for the segment are not peaks. To break the door, Nastya throws it to a segment [l,l+k-1] of consecutive mountains of length k (1 \u2264 l \u2264 n-k+1). When the door touches the peaks of the mountains, it breaks into two parts, after that these parts will continue to fall in different halves and also break into pieces when touching the peaks of the mountains, and so on. Formally, the number of parts that the door will break into will be equal to p+1, where p is the number of peaks on the segment [l,l+k-1]. Nastya wants to break it into as many pieces as possible. Help her choose such a segment of mountains [l, l+k-1] that the number of peaks on it is maximum. If there are several optimal segments, Nastya wants to find one for which the value l is minimal. Additionally, the solution should use a dictionary to map each mountain's unique identifier to its height, and the solution should include type hints.", "new_solution": "from typing import List, Tuple, Dict\n\ndef apps_run2(t: int, test_cases: List[Tuple[int, int, Dict[int, int]]]) -> List[Tuple[int, int]]:\n    results = []\n    for n, k, mountains in test_cases:\n        ids = list(mountains.keys())\n        heights = list(mountains.values())\n\n        peaks = [0] * n\n        for i in range(1, n - 1):\n            if heights[i] > heights[i - 1] and heights[i] > heights[i + 1]:\n                peaks[i] = 1\n\n        cnt = 0\n        max_peaks = 0\n        answer = 0\n\n        for i in range(k - 1):\n            cnt += peaks[i]\n            max_peaks += peaks[i]\n\n        for i in range(k - 1, n - 1):\n            cnt -= peaks[i - k + 2]\n            cnt += peaks[i]\n            if cnt > max_peaks:\n                max_peaks = cnt\n                answer = i - k + 2\n\n        results.append((max_peaks + 1, ids[answer]))\n    return results", "input_format": "The function accepts two parameters. The first parameter t is an integer within the range of 1 \u2264 t \u2264 10^4, indicating the number of test cases. The second parameter test_cases is a list of tuples. Each tuple in this list represents a test case and consists of three elements: an integer n (3 \u2264 k \u2264 n \u2264 2 * 10^5), which is the number of mountains; an integer k (3 \u2264 k \u2264 n \u2264 2 * 10^5), representing the length of the segment; and a dictionary mountains where the keys are the unique identifiers id_i (1 \u2264 id_i \u2264 10^9) of the mountains and the values are the corresponding heights a_i (0 \u2264 a_i \u2264 10^9), with the guarantee that neighboring heights are not equal (a_i \u2260 a_{i + 1}).", "output_format": "The function returns a list of tuples. Each tuple in the returned list corresponds to a test case. Each tuple contains two integers: the first integer represents the maximum number of parts that the door can split into, which is computed as the number of peaks in the optimal segment plus one; the second integer represents the unique identifier of the left - hand mountain of the segment of length k that should be chosen to obtain the maximum number of peaks.", "test_input": ["assert apps_run2(1, [(8, 6, {1: 1, 2: 2, 3: 4, 4: 1, 5: 2, 6: 4, 7: 1, 8: 2})]) == [(3, 2)]", "assert apps_run2(1, [(5, 3, {1: 3, 2: 2, 3: 3, 4: 2, 5: 1})]) == [(2, 2)]", "assert apps_run2(1, [(10, 4, {1: 4, 2: 3, 3: 4, 4: 3, 5: 2, 6: 3, 7: 2, 8: 1, 9: 0, 10: 1})]) == [(2, 1)]", "assert apps_run2(1, [(15, 7, {1: 3, 2: 7, 3: 4, 4: 8, 5: 2, 6: 3, 7: 4, 8: 5, 9: 21, 10: 2, 11: 3, 12: 4, 13: 2, 14: 1, 15: 3})]) == [(3, 1)]", "assert apps_run2(1, [(7, 5, {1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 1})]) == [(2, 3)]"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "APPS/0110-4", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nOn February 14 Denis decided to give Valentine to Nastya and did not come up with anything better than to draw a huge red heart on the door of the length $k$ ($k \\ge 3$). Nastya was very confused by this present, so she decided to break the door, throwing it on the mountains.\n\nMountains are described by a sequence of heights $a_1, a_2, \\dots, a_n$ in order from left to right ($k \\le n$). It is guaranteed that neighboring heights are not equal to each other (that is, $a_i \\ne a_{i+1}$ for all $i$ from $1$ to $n-1$).\n\nPeaks of mountains on the segment $[l,r]$ (from $l$ to $r$) are called indexes $i$ such that $l < i < r$, $a_{i - 1} < a_i$ and $a_i > a_{i + 1}$. It is worth noting that the boundary indexes $l$ and $r$ for the segment are not peaks. For example, if $n=8$ and $a=[3,1,4,1,5,9,2,6]$, then the segment $[1,8]$ has only two peaks (with indexes $3$ and $6$), and there are no peaks on the segment $[3, 6]$.\n\nTo break the door, Nastya throws it to a segment $[l,l+k-1]$ of consecutive mountains of length $k$ ($1 \\le l \\le n-k+1$). When the door touches the peaks of the mountains, it breaks into two parts, after that these parts will continue to fall in different halves and also break into pieces when touching the peaks of the mountains, and so on. Formally, the number of parts that the door will break into will be equal to $p+1$, where $p$ is the number of peaks on the segment $[l,l+k-1]$.\n\nNastya wants to break it into as many pieces as possible. Help her choose such a segment of mountains $[l, l+k-1]$ that the number of peaks on it is maximum. If there are several optimal segments, Nastya wants to find one for which the value $l$ is minimal.\n\nFormally, you need to choose a segment of mountains $[l, l+k-1]$ that has the maximum number of peaks. Among all such segments, you need to find the segment that has the minimum possible value $l$.\n\n\n-----Input-----\n\nThe first line contains an integer $t$ ($1 \\leq t \\leq 10^4$) \u00a0\u2014 the number of test cases. Then the descriptions of the test cases follow.\n\nThe first line of each test case contains two integers $n$ and $k$ ($3 \\leq k \\leq n \\leq 2 \\cdot 10^5$) \u00a0\u2014 the number of mountains and the length of the door.\n\nThe second line of the input data set contains $n$ integers $a_1, a_2, \\dots, a_n$ ($0 \\leq a_i \\leq 10 ^ 9$, $a_i \\neq a_{i + 1}$) \u00a0\u2014 the heights of mountains.\n\nIt is guaranteed that the sum of $n$ over all the test cases will not exceed $2 \\cdot 10^5$.\n\n\n-----Output-----\n\nFor each test case, output two integers $t$ and $l$ \u00a0\u2014 the maximum number of parts that the door can split into, and the left border of the segment of length $k$ that the door should be reset to.\n\n\n-----Example-----\nInput\n5\n8 6\n1 2 4 1 2 4 1 2\n5 3\n3 2 3 2 1\n10 4\n4 3 4 3 2 3 2 1 0 1\n15 7\n3 7 4 8 2 3 4 5 21 2 3 4 2 1 3\n7 5\n1 2 3 4 5 6 1\n\nOutput\n3 2\n2 2\n2 1\n3 1\n2 3\n\n\n\n-----Note-----\n\nIn the first example, you need to select a segment of mountains from $2$ to $7$. In this segment, the indexes $3$ and $6$ are peaks, so the answer is $3$ (only $2$ peaks, so the door will break into $3$ parts). It is not difficult to notice that the mountain segments $[1, 6]$ and $[3, 8]$ are not suitable since they only have a $1$ peak (for the first segment, the $6$ index is not a peak, and for the second segment, the $3$ index is not a peak).\n\nIn the second example, you need to select a segment of mountains from $2$ to $4$. In this segment, the index $3$ is a peak, so the answer is $2$ (only $1$ peak, so the door will break into $2$ parts).\n\nIn the third example, you need to select a segment of mountains from $1$ to $4$. In this segment, the index $3$ is a peak, so the answer is $2$ (only $1$ peak, so the door will break into $2$ parts). You can see that on the segments $[2, 5]$, $[4, 7]$ and $[5, 8]$ the number of peaks is also $1$, but these segments have a left border greater than the segment $[1, 4]$, so they are not the correct answer.", "raw_solution": "def apps_run1(test_cases):\n    results = []\n    for n, k, arr in test_cases:\n        peaks = [0 for i in range(n)]\n        for i in range(1, n - 1):\n            if arr[i] > arr[i - 1] and arr[i] > arr[i + 1]:\n                peaks[i] = 1\n\n        cnt = 0\n        max_peaks = 0\n        answer = 0\n\n        for i in range(k - 1):\n            cnt += peaks[i]\n            max_peaks += peaks[i]\n\n        for i in range(k - 1, n - 1):\n            cnt -= peaks[i - k + 2]\n            cnt += peaks[i]\n            if cnt > max_peaks:\n                max_peaks = cnt\n                answer = i - k + 2\n\n        results.append((max_peaks + 1, answer + 1))\n    return results", "raw_test_input": ["assert apps_run1([(8, 6, [1, 2, 4, 1, 2, 4, 1, 2]), (5, 3, [3, 2, 3, 2, 1]), (10, 4, [4, 3, 4, 3, 2, 3, 2, 1, 0, 1]), (15, 7, [3, 7, 4, 8, 2, 3, 4, 5, 21, 2, 3, 4, 2, 1, 3]), (7, 5, [1, 2, 3, 4, 5, 6, 1])]) == [(3, 2), (2, 2), (2, 1), (3, 1), (2, 3)]", "assert apps_run1([(10, 5, [1, 3, 2, 5, 4, 6, 7, 8, 3, 2]), (6, 4, [10, 20, 10, 30, 20, 10]), (12, 6, [5, 1, 6, 2, 7, 3, 8, 4, 9, 5, 10, 6])]) == [(3, 1), (2, 1), (3, 1)]", "assert apps_run1([(7, 4, [1, 2, 1, 3, 1, 4, 1]), (5, 3, [1, 3, 2, 4, 1]), (8, 5, [2, 1, 3, 1, 4, 1, 5, 1]), (9, 6, [1, 2, 3, 1, 4, 1, 5, 1, 6])]) == [(2, 1), (2, 1), (3, 2), (3, 1)]", "assert apps_run1([(12, 8, [1, 2, 3, 4, 5, 6, 5, 4, 3, 2, 1, 0]), (15, 5, [5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5])]) == [(2, 1), (3, 2)]", "assert apps_run1([(9, 3, [1, 3, 2, 5, 4, 6, 5, 8, 7]), (11, 7, [1, 2, 3, 4, 5, 6, 5, 4, 3, 2, 1]), (10, 4, [2, 1, 3, 1, 4, 1, 5, 1, 6, 1])]) == [(2, 1), (2, 1), (2, 1)]", "assert apps_run1([(8, 5, [1, 2, 3, 2, 4, 1, 5, 1])]) == [(3, 2)]"], "new_problem": "Denis is developing a software to simulate the breaking of a door on mountain peaks. However, the software must handle various errors that can occur during the simulation. The function should handle the following errors: 1. Invalid input format (e.g., non-integer values, missing values). 2. Out of bounds errors (e.g., k > n, n < 3). 3. Logical errors (e.g., peaks not being calculated correctly). 4. Propagation of errors with meaningful messages. Implement error handling in the function to ensure robustness against these scenarios.", "new_solution": "from typing import List, Tuple\n\nclass MountainError(Exception):\n    pass\n\nclass InputFormatError(MountainError):\n    pass\n\nclass OutOfBoundsError(MountainError):\n    pass\n\nclass LogicalError(MountainError):\n    pass\n\ndef apps_run2(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[Tuple[int, int]]:\n    results = []\n    for case in test_cases:\n        try:\n            n, k, arr = case\n            if not (3 <= k <= n):\n                raise OutOfBoundsError(f\"Invalid k or n: k={k}, n={n}\")\n            if len(arr) != n:\n                raise InputFormatError(\"Array length does not match n\")\n\n            peaks = [0 for _ in range(n)]\n            for i in range(1, n - 1):\n                if arr[i] > arr[i - 1] and arr[i] > arr[i + 1]:\n                    peaks[i] = 1\n\n            cnt = 0\n            max_peaks = 0\n            answer = 0\n\n            for i in range(k - 1):\n                cnt += peaks[i]\n                max_peaks += peaks[i]\n\n            for i in range(k - 1, n - 1):\n                cnt -= peaks[i - k + 2]\n                cnt += peaks[i]\n                if cnt > max_peaks:\n                    max_peaks = cnt\n                    answer = i - k + 2\n\n            results.append((max_peaks + 1, answer + 1))\n        except (InputFormatError, OutOfBoundsError, LogicalError) as e:\n            print(f\"Error in test case {case}: {e}\")\n            results.append((0, 0))\n    return results", "input_format": "The function accepts two parameters. The first parameter t is an integer within the range of 1 \u2264 t \u2264 10^4, indicating the number of test cases. The second parameter test_cases is a list of tuples. Each tuple in this list represents a test case and is composed of three elements: an integer n (3 \u2264 k \u2264 n \u2264 2 * 10^5), which is the number of mountains; an integer k (3 \u2264 k \u2264 n \u2264 2 * 10^5), representing the length of the segment; and a list of integers arr, where each integer a_i meets the conditions 0 \u2264 a_i \u2264 10^9 and a_i \u2260 a_{i + 1}, representing the heights of the mountains from left to right.", "output_format": "The function returns a list of tuples. Each tuple in the returned list corresponds to a test case in the input test_cases. Each tuple contains two integers: the first integer represents the maximum number of parts that the door can split into, which is computed as the number of peaks in the optimal segment plus one; the second integer represents the left - hand index (starting from 1) of the segment of length k that should be chosen to obtain the maximum number of peaks.If an error occurs during the processing of a test case, such as an invalid input format (e.g., non - integer values, array length not matching n), an out - of - bounds error (e.g., k > n or n < 3), or a logical error, the function will print a meaningful error message and append a tuple (0, 0) to the results list for that test case.", "test_input": ["assert apps_run2(1, [(8, 6, [1, 2, 4, 1, 2, 4, 1, 2])]) == [(3, 2)]", "assert apps_run2(1, [(5, 3, [3, 2, 3, 2, 1])]) == [(2, 2)]", "assert apps_run2(1, [(10, 4, [4, 3, 4, 3, 2, 3, 2, 1, 0, 1])]) == [(2, 1)]", "assert apps_run2(1, [(15, 7, [3, 7, 4, 8, 2, 3, 4, 5, 21, 2, 3, 4, 2, 1, 3])]) == [(3, 1)]", "assert apps_run2(1, [(7, 5, [1, 2, 3, 4, 5, 6, 1])]) == [(2, 3)]"], "requirement_type": "PROMPT_ERROR_HANDLING"}
{"task_id": "APPS/0104-1", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nYou are given a colored permutation $p_1, p_2, \\dots, p_n$. The $i$-th element of the permutation has color $c_i$.\n\nLet's define an infinite path as infinite sequence $i, p[i], p[p[i]], p[p[p[i]]] \\dots$ where all elements have same color ($c[i] = c[p[i]] = c[p[p[i]]] = \\dots$).\n\nWe can also define a multiplication of permutations $a$ and $b$ as permutation $c = a \\times b$ where $c[i] = b[a[i]]$. Moreover, we can define a power $k$ of permutation $p$ as $p^k=\\underbrace{p \\times p \\times \\dots \\times p}_{k \\text{ times}}$.\n\nFind the minimum $k > 0$ such that $p^k$ has at least one infinite path (i.e. there is a position $i$ in $p^k$ such that the sequence starting from $i$ is an infinite path).\n\nIt can be proved that the answer always exists.\n\n\n-----Input-----\n\nThe first line contains single integer $T$ ($1 \\le T \\le 10^4$) \u2014 the number of test cases.\n\nNext $3T$ lines contain test cases \u2014 one per three lines. The first line contains single integer $n$ ($1 \\le n \\le 2 \\cdot 10^5$) \u2014 the size of the permutation.\n\nThe second line contains $n$ integers $p_1, p_2, \\dots, p_n$ ($1 \\le p_i \\le n$, $p_i \\neq p_j$ for $i \\neq j$) \u2014 the permutation $p$.\n\nThe third line contains $n$ integers $c_1, c_2, \\dots, c_n$ ($1 \\le c_i \\le n$) \u2014 the colors of elements of the permutation.\n\nIt is guaranteed that the total sum of $n$ doesn't exceed $2 \\cdot 10^5$.\n\n\n-----Output-----\n\nPrint $T$ integers \u2014 one per test case. For each test case print minimum $k > 0$ such that $p^k$ has at least one infinite path.\n\n\n-----Example-----\nInput\n3\n4\n1 3 4 2\n1 2 2 3\n5\n2 3 4 5 1\n1 2 3 4 5\n8\n7 4 5 6 1 8 3 2\n5 3 6 4 7 5 8 4\n\nOutput\n1\n5\n2\n\n\n\n-----Note-----\n\nIn the first test case, $p^1 = p = [1, 3, 4, 2]$ and the sequence starting from $1$: $1, p[1] = 1, \\dots$ is an infinite path.\n\nIn the second test case, $p^5 = [1, 2, 3, 4, 5]$ and it obviously contains several infinite paths.\n\nIn the third test case, $p^2 = [3, 6, 1, 8, 7, 2, 5, 4]$ and the sequence starting from $4$: $4, p^2[4]=8, p^2[8]=4, \\dots$ is an infinite path since $c_4 = c_8 = 4$.", "raw_solution": "def apps_run1(q, test_cases):\n    results = []\n    for rwerew in range(q):\n        n = test_cases[rwerew][0]\n        p = test_cases[rwerew][1]\n        c = test_cases[rwerew][2]\n        for i in range(n):\n            p[i] -= 1\n        przyn = [0] * n\n        grupa = []\n        i = 0\n        while i < n:\n            if przyn[i] == 1:\n                i += 1\n            else:\n                nowa_grupa = [i]\n                j = p[i]\n                przyn[i] = 1\n                while j != i:\n                    przyn[j] = 1\n                    nowa_grupa.append(j)\n                    j = p[j]\n                grupa.append(nowa_grupa)\n        grupacol = []\n        for i in grupa:\n            cyk = []\n            for j in i:\n                cyk.append(c[j])\n            grupacol.append(cyk)\n        mini = 234283742834\n        for cykl in grupacol:\n            dziel = []\n            d =  1\n            while d**2 <= len(cykl):\n                if len(cykl)%d == 0:\n                    dziel.append(d)\n                d += 1\n            dodat = []\n            for d in dziel:\n                dodat.append(len(cykl)/d)\n            dziel_ost = list(map(int,dziel + dodat))\n            for dzielnik in dziel_ost:\n                for i in range(dzielnik):\n                    indeks = i\n                    secik = set()\n                    chuj = True\n                    while indeks < len(cykl):\n                        secik.add(cykl[indeks])\n                        indeks += dzielnik\n                        if len(secik) > 1:\n                            chuj = False\n                            break\n                    if chuj:\n                        mini = min(mini, dzielnik)\n        results.append(mini)\n    return results", "raw_test_input": ["assert apps_run1(3, [(4, [1, 3, 4, 2], [1, 2, 2, 3]), (5, [2, 3, 4, 5, 1], [1, 2, 3, 4, 5]), (8, [7, 4, 5, 6, 1, 8, 3, 2], [5, 3, 6, 4, 7, 5, 8, 4])]) == [1, 5, 2]", "assert apps_run1(2, [(3, [2, 1, 3], [1, 1, 2]), (6, [1, 2, 3, 4, 5, 6], [2, 2, 2, 1, 1, 1])]) == [1, 1]", "assert apps_run1(1, [(5, [5, 4, 3, 2, 1], [1, 2, 3, 4, 5])]) == [1]", "assert apps_run1(3, [(2, [1, 2], [1, 2]), (4, [2, 1, 4, 3], [3, 4, 3, 2]), (7, [3, 1, 2, 4, 5, 6, 7], [1, 2, 2, 3, 3, 3, 1])]) == [1, 2, 1]", "assert apps_run1(2, [(4, [4, 3, 2, 1], [1, 1, 2, 2]), (3, [2, 3, 1], [3, 3, 3])]) == [2, 1]", "assert apps_run1(1, [(6, [1, 2, 3, 4, 5, 6], [1, 2, 1, 2, 1, 2])]) == [1]"], "new_problem": "You are given a colored permutation p_1, p_2, ..., p_n and a series of queries. Each query asks whether there exists an infinite path starting from a given position a and ending at another position b in the permutation. For each query, determine the minimum k > 0 such that p^k has at least one infinite path starting from a to b.", "new_solution": "def find_minimum_k_for_infinite_path(n, p, c):\n    for i in range(n):\n        p[i] -= 1\n    przyn = [0] * n\n    grupa = []\n    i = 0\n    while i < n:\n        if przyn[i] == 1:\n            i += 1\n        else:\n            nowa_grupa = [i]\n            j = p[i]\n            przyn[i] = 1\n            while j != i:\n                przyn[j] = 1\n                nowa_grupa.append(j)\n                j = p[j]\n            grupa.append(nowa_grupa)\n    grupacol = []\n    for i in grupa:\n        cyk = []\n        for j in i:\n            cyk.append(c[j])\n        grupacol.append(cyk)\n    mini = 234283742834\n    for cykl in grupacol:\n        dziel = []\n        d =  1\n        while d**2 <= len(cykl):\n            if len(cykl)%d == 0:\n                dziel.append(d)\n            d += 1\n        dodat = []\n        for d in dziel:\n            dodat.append(len(cykl)/d)\n        dziel_ost = list(map(int,dziel + dodat))\n        for dzielnik in dziel_ost:\n            for i in range(dzielnik):\n                indeks = i\n                secik = set()\n                chuj = True\n                while indeks < len(cykl):\n                    secik.add(cykl[indeks])\n                    indeks += dzielnik\n                    if len(secik) > 1:\n                        chuj = False\n                        break\n                if chuj:\n                    mini = min(mini, dzielnik)\n    return mini\n\ndef apps_run2(T, test_cases):\n    results = []\n    for t in range(T):\n        n, p, c, m, queries = test_cases[t]\n        min_k = find_minimum_k_for_infinite_path(n, p, c)\n        for a, b in queries:\n            if c[a-1] == c[b-1]:\n                results.append(min_k)\n            else:\n                results.append(-1)  # No infinite path possible if colors don't match\n    return results", "input_format": "The function accepts two parameters. The first parameter T is an integer within the range of 1 \u2264 T \u2264 10^4, denoting the number of test cases. The second parameter test_cases is a list, and each element in this list represents a test case. Each test - case element is a tuple with five components: an integer n (1 \u2264 n \u2264 2 * 10^5), which is the size of the permutation; a list p of n integers, where each p_i meets the conditions 1 \u2264 p_i \u2264 n and p_i \u2260 p_j for i \u2260 j, representing the permutation; a list c of n integers, with each c_i in the range 1 \u2264 c_i \u2264 n, representing the colors of the permutation elements; an integer m (1 \u2264 m \u2264 10^3), indicating the number of queries for this test case; and a list of tuples queries, where each tuple contains two integers a and b (1 \u2264 a, b \u2264 n), representing a query about the existence of an infinite path from position a to position b in the permutation.", "output_format": "The function returns a list of integers. Each integer in the returned list corresponds to a query in the input test_cases. If there is an infinite path from a to b in p^k for some k > 0, the integer is the minimum such k. If the colors of the elements at positions a and b are different, meaning there can be no infinite path between them, the integer is -1.", "test_input": ["assert apps_run2(1, [(4, [1, 3, 4, 2], [1, 2, 2, 3], 2, [(1, 1), (2, 3)])]) == [1, 1]", "assert apps_run2(1, [(5, [2, 3, 4, 5, 1], [1, 2, 3, 4, 5], 1, [(1, 5)])]) == [-1]", "assert apps_run2(1, [(8, [7, 4, 5, 6, 1, 8, 3, 2], [5, 3, 6, 4, 7, 5, 8, 4], 1, [(4, 8)])]) == [2]", "assert apps_run2(1, [(3, [2, 3, 1], [1, 1, 1], 1, [(1, 3)])]) == [1]", "assert apps_run2(1, [(6, [6, 5, 4, 3, 2, 1], [1, 2, 3, 4, 5, 6], 1, [(1, 6)])]) == [-1]"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "APPS/0104-2", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nYou are given a colored permutation $p_1, p_2, \\dots, p_n$. The $i$-th element of the permutation has color $c_i$.\n\nLet's define an infinite path as infinite sequence $i, p[i], p[p[i]], p[p[p[i]]] \\dots$ where all elements have same color ($c[i] = c[p[i]] = c[p[p[i]]] = \\dots$).\n\nWe can also define a multiplication of permutations $a$ and $b$ as permutation $c = a \\times b$ where $c[i] = b[a[i]]$. Moreover, we can define a power $k$ of permutation $p$ as $p^k=\\underbrace{p \\times p \\times \\dots \\times p}_{k \\text{ times}}$.\n\nFind the minimum $k > 0$ such that $p^k$ has at least one infinite path (i.e. there is a position $i$ in $p^k$ such that the sequence starting from $i$ is an infinite path).\n\nIt can be proved that the answer always exists.\n\n\n-----Input-----\n\nThe first line contains single integer $T$ ($1 \\le T \\le 10^4$) \u2014 the number of test cases.\n\nNext $3T$ lines contain test cases \u2014 one per three lines. The first line contains single integer $n$ ($1 \\le n \\le 2 \\cdot 10^5$) \u2014 the size of the permutation.\n\nThe second line contains $n$ integers $p_1, p_2, \\dots, p_n$ ($1 \\le p_i \\le n$, $p_i \\neq p_j$ for $i \\neq j$) \u2014 the permutation $p$.\n\nThe third line contains $n$ integers $c_1, c_2, \\dots, c_n$ ($1 \\le c_i \\le n$) \u2014 the colors of elements of the permutation.\n\nIt is guaranteed that the total sum of $n$ doesn't exceed $2 \\cdot 10^5$.\n\n\n-----Output-----\n\nPrint $T$ integers \u2014 one per test case. For each test case print minimum $k > 0$ such that $p^k$ has at least one infinite path.\n\n\n-----Example-----\nInput\n3\n4\n1 3 4 2\n1 2 2 3\n5\n2 3 4 5 1\n1 2 3 4 5\n8\n7 4 5 6 1 8 3 2\n5 3 6 4 7 5 8 4\n\nOutput\n1\n5\n2\n\n\n\n-----Note-----\n\nIn the first test case, $p^1 = p = [1, 3, 4, 2]$ and the sequence starting from $1$: $1, p[1] = 1, \\dots$ is an infinite path.\n\nIn the second test case, $p^5 = [1, 2, 3, 4, 5]$ and it obviously contains several infinite paths.\n\nIn the third test case, $p^2 = [3, 6, 1, 8, 7, 2, 5, 4]$ and the sequence starting from $4$: $4, p^2[4]=8, p^2[8]=4, \\dots$ is an infinite path since $c_4 = c_8 = 4$.", "raw_solution": "def apps_run1(q, test_cases):\n    results = []\n    for rwerew in range(q):\n        n = test_cases[rwerew][0]\n        p = test_cases[rwerew][1]\n        c = test_cases[rwerew][2]\n        for i in range(n):\n            p[i] -= 1\n        przyn = [0] * n\n        grupa = []\n        i = 0\n        while i < n:\n            if przyn[i] == 1:\n                i += 1\n            else:\n                nowa_grupa = [i]\n                j = p[i]\n                przyn[i] = 1\n                while j != i:\n                    przyn[j] = 1\n                    nowa_grupa.append(j)\n                    j = p[j]\n                grupa.append(nowa_grupa)\n        grupacol = []\n        for i in grupa:\n            cyk = []\n            for j in i:\n                cyk.append(c[j])\n            grupacol.append(cyk)\n        mini = 234283742834\n        for cykl in grupacol:\n            dziel = []\n            d =  1\n            while d**2 <= len(cykl):\n                if len(cykl)%d == 0:\n                    dziel.append(d)\n                d += 1\n            dodat = []\n            for d in dziel:\n                dodat.append(len(cykl)/d)\n            dziel_ost = list(map(int,dziel + dodat))\n            for dzielnik in dziel_ost:\n                for i in range(dzielnik):\n                    indeks = i\n                    secik = set()\n                    chuj = True\n                    while indeks < len(cykl):\n                        secik.add(cykl[indeks])\n                        indeks += dzielnik\n                        if len(secik) > 1:\n                            chuj = False\n                            break\n                    if chuj:\n                        mini = min(mini, dzielnik)\n        results.append(mini)\n    return results", "raw_test_input": ["assert apps_run1(3, [(4, [1, 3, 4, 2], [1, 2, 2, 3]), (5, [2, 3, 4, 5, 1], [1, 2, 3, 4, 5]), (8, [7, 4, 5, 6, 1, 8, 3, 2], [5, 3, 6, 4, 7, 5, 8, 4])]) == [1, 5, 2]", "assert apps_run1(2, [(3, [2, 1, 3], [1, 1, 2]), (6, [1, 2, 3, 4, 5, 6], [2, 2, 2, 1, 1, 1])]) == [1, 1]", "assert apps_run1(1, [(5, [5, 4, 3, 2, 1], [1, 2, 3, 4, 5])]) == [1]", "assert apps_run1(3, [(2, [1, 2], [1, 2]), (4, [2, 1, 4, 3], [3, 4, 3, 2]), (7, [3, 1, 2, 4, 5, 6, 7], [1, 2, 2, 3, 3, 3, 1])]) == [1, 2, 1]", "assert apps_run1(2, [(4, [4, 3, 2, 1], [1, 1, 2, 2]), (3, [2, 3, 1], [3, 3, 3])]) == [2, 1]", "assert apps_run1(1, [(6, [1, 2, 3, 4, 5, 6], [1, 2, 1, 2, 1, 2])]) == [1]"], "new_problem": "You are given a colored permutation p_1, p_2, ..., p_n. The i-th element of the permutation has color c_i. Define an infinite path as an infinite sequence i, p[i], p[p[i]], p[p[p[i]]] ... where all elements have the same color (c[i] = c[p[i]] = c[p[p[i]]] = ...). We can also define a multiplication of permutations a and b as permutation c = a \u00d7 b where c[i] = b[a[i]]. Moreover, we can define a power k of permutation p as p^k = p \u00d7 p \u00d7 ... \u00d7 p (k times). Find the minimum k > 0 such that p^k has at least one infinite path. Additionally, enhance the function to support an optional parameter `return_paths` (default to False). If `return_paths` is True, the function should also return the indices of the infinite path found for each test case.", "new_solution": "from typing import List, Tuple, Union\n\ndef apps_run2(T: int, test_cases: List[Tuple[int, List[int], List[int]]], return_paths: bool = False) -> Union[List[int], List[Tuple[int, List[int]]]]:\n    results = []\n    for n, p, c in test_cases:\n        for i in range(n):\n            p[i] -= 1\n        przyn = [0] * n\n        grupa = []\n        i = 0\n        while i < n:\n            if przyn[i] == 1:\n                i += 1\n            else:\n                nowa_grupa = [i]\n                j = p[i]\n                przyn[i] = 1\n                while j != i:\n                    przyn[j] = 1\n                    nowa_grupa.append(j)\n                    j = p[j]\n                grupa.append(nowa_grupa)\n        grupacol = []\n        for i in grupa:\n            cyk = []\n            for j in i:\n                cyk.append(c[j])\n            grupacol.append(cyk)\n        mini = 234283742834\n        path_indices = []\n        for cykl in grupacol:\n            dziel = []\n            d =  1\n            while d**2 <= len(cykl):\n                if len(cykl) % d == 0:\n                    dziel.append(d)\n                d += 1\n            dodat = []\n            for d in dziel:\n                dodat.append(len(cykl) // d)\n            dziel_ost = list(map(int, dziel + dodat))\n            for dzielnik in dziel_ost:\n                for i in range(dzielnik):\n                    indeks = i\n                    secik = set()\n                    chuj = True\n                    while indeks < len(cykl):\n                        secik.add(cykl[indeks])\n                        indeks += dzielnik\n                        if len(secik) > 1:\n                            chuj = False\n                            break\n                    if chuj:\n                        if mini > dzielnik:\n                            mini = dzielnik\n                            path_indices = [i for i in range(len(cykl)) if i % dzielnik == 0]\n        if return_paths:\n            results.append((mini, path_indices))\n        else:\n            results.append(mini)\n    return results", "input_format": "The function accepts three parameters, with the last one being optional. The first parameter T is an integer within the range of 1 \u2264 T \u2264 10^4, indicating the number of test cases. The second parameter test_cases is a list of tuples. Each tuple in this list represents a test case and consists of three elements: an integer n (1 \u2264 n \u2264 2 * 10^5), which is the size of the permutation; a list p of n integers, where each p_i meets the conditions 1 \u2264 p_i \u2264 n and p_i \u2260 p_j for i \u2260 j, representing the permutation; and a list c of n integers, with each c_i in the range 1 \u2264 c_i \u2264 n, representing the colors of the permutation elements. The third parameter return_paths is a boolean with a default value of False. If set to True, the function will not only return the minimum k values but also the indices of the infinite path found for each test case.", "output_format": "The return format of the function depends on the value of return_paths. If return_paths is False, the function returns a list of integers. Each integer in the list corresponds to a test case and represents the minimum k > 0 such that p^k has at least one infinite path for that test case. If return_paths is True, the function returns a list of tuples. Each tuple contains two elements: the first element is the minimum k value for the corresponding test case, and the second element is a list of integers representing the indices of the infinite path found for that test case.", "test_input": ["assert apps_run2(3, [(4, [1, 3, 4, 2], [1, 2, 2, 3]), (5, [2, 3, 4, 5, 1], [1, 2, 3, 4, 5]), (8, [7, 4, 5, 6, 1, 8, 3, 2], [5, 3, 6, 4, 7, 5, 8, 4])]) == [1, 5, 2]", "assert apps_run2(1, [(4, [1, 3, 4, 2], [1, 2, 2, 3])], return_paths=True) == [(1, [0])]", "assert apps_run2(1, [(5, [2, 3, 4, 5, 1], [1, 2, 3, 4, 5])], return_paths=True) == [(5, [0])]", "assert apps_run2(1, [(8, [7, 4, 5, 6, 1, 8, 3, 2], [5, 3, 6, 4, 7, 5, 8, 4])], return_paths=True) == [(2, [0, 2])]", "assert apps_run2(2, [(3, [2, 3, 1], [1, 1, 1]), (3, [3, 1, 2], [2, 2, 2])]) == [1, 1]"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "APPS/0104-3", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nYou are given a colored permutation $p_1, p_2, \\dots, p_n$. The $i$-th element of the permutation has color $c_i$.\n\nLet's define an infinite path as infinite sequence $i, p[i], p[p[i]], p[p[p[i]]] \\dots$ where all elements have same color ($c[i] = c[p[i]] = c[p[p[i]]] = \\dots$).\n\nWe can also define a multiplication of permutations $a$ and $b$ as permutation $c = a \\times b$ where $c[i] = b[a[i]]$. Moreover, we can define a power $k$ of permutation $p$ as $p^k=\\underbrace{p \\times p \\times \\dots \\times p}_{k \\text{ times}}$.\n\nFind the minimum $k > 0$ such that $p^k$ has at least one infinite path (i.e. there is a position $i$ in $p^k$ such that the sequence starting from $i$ is an infinite path).\n\nIt can be proved that the answer always exists.\n\n\n-----Input-----\n\nThe first line contains single integer $T$ ($1 \\le T \\le 10^4$) \u2014 the number of test cases.\n\nNext $3T$ lines contain test cases \u2014 one per three lines. The first line contains single integer $n$ ($1 \\le n \\le 2 \\cdot 10^5$) \u2014 the size of the permutation.\n\nThe second line contains $n$ integers $p_1, p_2, \\dots, p_n$ ($1 \\le p_i \\le n$, $p_i \\neq p_j$ for $i \\neq j$) \u2014 the permutation $p$.\n\nThe third line contains $n$ integers $c_1, c_2, \\dots, c_n$ ($1 \\le c_i \\le n$) \u2014 the colors of elements of the permutation.\n\nIt is guaranteed that the total sum of $n$ doesn't exceed $2 \\cdot 10^5$.\n\n\n-----Output-----\n\nPrint $T$ integers \u2014 one per test case. For each test case print minimum $k > 0$ such that $p^k$ has at least one infinite path.\n\n\n-----Example-----\nInput\n3\n4\n1 3 4 2\n1 2 2 3\n5\n2 3 4 5 1\n1 2 3 4 5\n8\n7 4 5 6 1 8 3 2\n5 3 6 4 7 5 8 4\n\nOutput\n1\n5\n2\n\n\n\n-----Note-----\n\nIn the first test case, $p^1 = p = [1, 3, 4, 2]$ and the sequence starting from $1$: $1, p[1] = 1, \\dots$ is an infinite path.\n\nIn the second test case, $p^5 = [1, 2, 3, 4, 5]$ and it obviously contains several infinite paths.\n\nIn the third test case, $p^2 = [3, 6, 1, 8, 7, 2, 5, 4]$ and the sequence starting from $4$: $4, p^2[4]=8, p^2[8]=4, \\dots$ is an infinite path since $c_4 = c_8 = 4$.", "raw_solution": "def apps_run1(q, test_cases):\n    results = []\n    for rwerew in range(q):\n        n = test_cases[rwerew][0]\n        p = test_cases[rwerew][1]\n        c = test_cases[rwerew][2]\n        for i in range(n):\n            p[i] -= 1\n        przyn = [0] * n\n        grupa = []\n        i = 0\n        while i < n:\n            if przyn[i] == 1:\n                i += 1\n            else:\n                nowa_grupa = [i]\n                j = p[i]\n                przyn[i] = 1\n                while j != i:\n                    przyn[j] = 1\n                    nowa_grupa.append(j)\n                    j = p[j]\n                grupa.append(nowa_grupa)\n        grupacol = []\n        for i in grupa:\n            cyk = []\n            for j in i:\n                cyk.append(c[j])\n            grupacol.append(cyk)\n        mini = 234283742834\n        for cykl in grupacol:\n            dziel = []\n            d =  1\n            while d**2 <= len(cykl):\n                if len(cykl)%d == 0:\n                    dziel.append(d)\n                d += 1\n            dodat = []\n            for d in dziel:\n                dodat.append(len(cykl)/d)\n            dziel_ost = list(map(int,dziel + dodat))\n            for dzielnik in dziel_ost:\n                for i in range(dzielnik):\n                    indeks = i\n                    secik = set()\n                    chuj = True\n                    while indeks < len(cykl):\n                        secik.add(cykl[indeks])\n                        indeks += dzielnik\n                        if len(secik) > 1:\n                            chuj = False\n                            break\n                    if chuj:\n                        mini = min(mini, dzielnik)\n        results.append(mini)\n    return results", "raw_test_input": ["assert apps_run1(3, [(4, [1, 3, 4, 2], [1, 2, 2, 3]), (5, [2, 3, 4, 5, 1], [1, 2, 3, 4, 5]), (8, [7, 4, 5, 6, 1, 8, 3, 2], [5, 3, 6, 4, 7, 5, 8, 4])]) == [1, 5, 2]", "assert apps_run1(2, [(3, [2, 1, 3], [1, 1, 2]), (6, [1, 2, 3, 4, 5, 6], [2, 2, 2, 1, 1, 1])]) == [1, 1]", "assert apps_run1(1, [(5, [5, 4, 3, 2, 1], [1, 2, 3, 4, 5])]) == [1]", "assert apps_run1(3, [(2, [1, 2], [1, 2]), (4, [2, 1, 4, 3], [3, 4, 3, 2]), (7, [3, 1, 2, 4, 5, 6, 7], [1, 2, 2, 3, 3, 3, 1])]) == [1, 2, 1]", "assert apps_run1(2, [(4, [4, 3, 2, 1], [1, 1, 2, 2]), (3, [2, 3, 1], [3, 3, 3])]) == [2, 1]", "assert apps_run1(1, [(6, [1, 2, 3, 4, 5, 6], [1, 2, 1, 2, 1, 2])]) == [1]"], "new_problem": "You are given a colored permutation p_1, p_2, ..., p_n with associated weights w_1, w_2, ..., w_n. The i-th element of the permutation has color c_i and weight w_i. Define an infinite path as an infinite sequence i, p[i], p[p[i]], p[p[p[i]]] ... where all elements have the same color (c[i] = c[p[i]] = c[p[p[i]]] = ...). Find the minimum k > 0 such that p^k has at least one infinite path with the same color and the sum of weights in the path is maximized. Use dictionaries to store and manage the permutation and color data.", "new_solution": "from typing import List, Dict\n\ndef apps_run2(T: int, test_cases: List[Dict[str, List[int]]]) -> List[int]:\n    results = []\n    for case in test_cases:\n        n = case['n']\n        p = case['p']\n        c = case['c']\n        w = case['w']\n        p = [x - 1 for x in p]  # Convert to 0-based index\n        visited = [False] * n\n        max_weight = 0\n        min_k = float('inf')\n        for start in range(n):\n            if not visited[start]:\n                cycle = []\n                colors = []\n                weights = []\n                x = start\n                while not visited[x]:\n                    visited[x] = True\n                    cycle.append(x)\n                    colors.append(c[x])\n                    weights.append(w[x])\n                    x = p[x]\n                cycle_length = len(cycle)\n                for d in range(1, cycle_length + 1):\n                    if cycle_length % d == 0:\n                        for offset in range(d):\n                            if all(colors[i] == colors[offset] for i in range(offset, cycle_length, d)):\n                                path_weight = sum(weights[i] for i in range(offset, cycle_length, d))\n                                if path_weight > max_weight or (path_weight == max_weight and d < min_k):\n                                    max_weight = path_weight\n                                    min_k = d\n        results.append(min_k)\n    return results", "input_format": "The function accepts two parameters. The first parameter T is an integer within the range of 1 \u2264 T \u2264 10^4, indicating the number of test cases. The second parameter test_cases is a list of dictionaries. Each dictionary in this list represents a test case and contains four key - value pairs. The key 'n' is mapped to an integer n (1 \u2264 n \u2264 2 * 10^5), which is the size of the permutation. The key 'p' is mapped to a list of n integers, where each p_i meets the conditions 1 \u2264 p_i \u2264 n and p_i \u2260 p_j for i \u2260 j, representing the permutation. The key 'c' is mapped to a list of n integers, with each c_i in the range 1 \u2264 c_i \u2264 n, representing the colors of the permutation elements. The key 'w' is mapped to a list of n integers, where each w_i is in the range 1 \u2264 w_i \u2264 10^9, representing the weights of the permutation elements.", "output_format": "The function returns a list of integers. Each integer in the returned list corresponds to a test case in the input test_cases. It represents the minimum k > 0 such that p^k has at least one infinite path with the same color and the sum of weights in the path is maximized.\n", "test_input": ["assert apps_run2(1, [{'n': 4, 'p': [1, 3, 4, 2], 'c': [1, 2, 2, 3], 'w': [10, 20, 30, 40]}]) == [3]", "assert apps_run2(1, [{'n': 5, 'p': [2, 3, 4, 5, 1], 'c': [1, 2, 3, 4, 5], 'w': [5, 10, 15, 20, 25]}]) == [5]", "assert apps_run2(1, [{'n': 8, 'p': [7, 4, 5, 6, 1, 8, 3, 2], 'c': [5, 3, 6, 4, 7, 5, 8, 4], 'w': [1, 2, 3, 4, 5, 6, 7, 8]}]) == [2]", "assert apps_run2(1, [{'n': 3, 'p': [2, 3, 1], 'c': [1, 1, 1], 'w': [100, 200, 300]}]) == [1]", "assert apps_run2(1, [{'n': 6, 'p': [6, 5, 4, 3, 2, 1], 'c': [1, 2, 1, 2, 1, 2], 'w': [10, 20, 30, 40, 50, 60]}]) == [2]"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "APPS/0104-4", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nYou are given a colored permutation $p_1, p_2, \\dots, p_n$. The $i$-th element of the permutation has color $c_i$.\n\nLet's define an infinite path as infinite sequence $i, p[i], p[p[i]], p[p[p[i]]] \\dots$ where all elements have same color ($c[i] = c[p[i]] = c[p[p[i]]] = \\dots$).\n\nWe can also define a multiplication of permutations $a$ and $b$ as permutation $c = a \\times b$ where $c[i] = b[a[i]]$. Moreover, we can define a power $k$ of permutation $p$ as $p^k=\\underbrace{p \\times p \\times \\dots \\times p}_{k \\text{ times}}$.\n\nFind the minimum $k > 0$ such that $p^k$ has at least one infinite path (i.e. there is a position $i$ in $p^k$ such that the sequence starting from $i$ is an infinite path).\n\nIt can be proved that the answer always exists.\n\n\n-----Input-----\n\nThe first line contains single integer $T$ ($1 \\le T \\le 10^4$) \u2014 the number of test cases.\n\nNext $3T$ lines contain test cases \u2014 one per three lines. The first line contains single integer $n$ ($1 \\le n \\le 2 \\cdot 10^5$) \u2014 the size of the permutation.\n\nThe second line contains $n$ integers $p_1, p_2, \\dots, p_n$ ($1 \\le p_i \\le n$, $p_i \\neq p_j$ for $i \\neq j$) \u2014 the permutation $p$.\n\nThe third line contains $n$ integers $c_1, c_2, \\dots, c_n$ ($1 \\le c_i \\le n$) \u2014 the colors of elements of the permutation.\n\nIt is guaranteed that the total sum of $n$ doesn't exceed $2 \\cdot 10^5$.\n\n\n-----Output-----\n\nPrint $T$ integers \u2014 one per test case. For each test case print minimum $k > 0$ such that $p^k$ has at least one infinite path.\n\n\n-----Example-----\nInput\n3\n4\n1 3 4 2\n1 2 2 3\n5\n2 3 4 5 1\n1 2 3 4 5\n8\n7 4 5 6 1 8 3 2\n5 3 6 4 7 5 8 4\n\nOutput\n1\n5\n2\n\n\n\n-----Note-----\n\nIn the first test case, $p^1 = p = [1, 3, 4, 2]$ and the sequence starting from $1$: $1, p[1] = 1, \\dots$ is an infinite path.\n\nIn the second test case, $p^5 = [1, 2, 3, 4, 5]$ and it obviously contains several infinite paths.\n\nIn the third test case, $p^2 = [3, 6, 1, 8, 7, 2, 5, 4]$ and the sequence starting from $4$: $4, p^2[4]=8, p^2[8]=4, \\dots$ is an infinite path since $c_4 = c_8 = 4$.", "raw_solution": "def apps_run1(q, test_cases):\n    results = []\n    for rwerew in range(q):\n        n = test_cases[rwerew][0]\n        p = test_cases[rwerew][1]\n        c = test_cases[rwerew][2]\n        for i in range(n):\n            p[i] -= 1\n        przyn = [0] * n\n        grupa = []\n        i = 0\n        while i < n:\n            if przyn[i] == 1:\n                i += 1\n            else:\n                nowa_grupa = [i]\n                j = p[i]\n                przyn[i] = 1\n                while j != i:\n                    przyn[j] = 1\n                    nowa_grupa.append(j)\n                    j = p[j]\n                grupa.append(nowa_grupa)\n        grupacol = []\n        for i in grupa:\n            cyk = []\n            for j in i:\n                cyk.append(c[j])\n            grupacol.append(cyk)\n        mini = 234283742834\n        for cykl in grupacol:\n            dziel = []\n            d =  1\n            while d**2 <= len(cykl):\n                if len(cykl)%d == 0:\n                    dziel.append(d)\n                d += 1\n            dodat = []\n            for d in dziel:\n                dodat.append(len(cykl)/d)\n            dziel_ost = list(map(int,dziel + dodat))\n            for dzielnik in dziel_ost:\n                for i in range(dzielnik):\n                    indeks = i\n                    secik = set()\n                    chuj = True\n                    while indeks < len(cykl):\n                        secik.add(cykl[indeks])\n                        indeks += dzielnik\n                        if len(secik) > 1:\n                            chuj = False\n                            break\n                    if chuj:\n                        mini = min(mini, dzielnik)\n        results.append(mini)\n    return results", "raw_test_input": ["assert apps_run1(3, [(4, [1, 3, 4, 2], [1, 2, 2, 3]), (5, [2, 3, 4, 5, 1], [1, 2, 3, 4, 5]), (8, [7, 4, 5, 6, 1, 8, 3, 2], [5, 3, 6, 4, 7, 5, 8, 4])]) == [1, 5, 2]", "assert apps_run1(2, [(3, [2, 1, 3], [1, 1, 2]), (6, [1, 2, 3, 4, 5, 6], [2, 2, 2, 1, 1, 1])]) == [1, 1]", "assert apps_run1(1, [(5, [5, 4, 3, 2, 1], [1, 2, 3, 4, 5])]) == [1]", "assert apps_run1(3, [(2, [1, 2], [1, 2]), (4, [2, 1, 4, 3], [3, 4, 3, 2]), (7, [3, 1, 2, 4, 5, 6, 7], [1, 2, 2, 3, 3, 3, 1])]) == [1, 2, 1]", "assert apps_run1(2, [(4, [4, 3, 2, 1], [1, 1, 2, 2]), (3, [2, 3, 1], [3, 3, 3])]) == [2, 1]", "assert apps_run1(1, [(6, [1, 2, 3, 4, 5, 6], [1, 2, 1, 2, 1, 2])]) == [1]"], "new_problem": "You are given a colored permutation p_1, p_2, ..., p_n. The i-th element of the permutation has color c_i. Define an infinite path as an infinite sequence i, p[i], p[p[i]], p[p[p[i]]] ... where all elements have the same color (c[i] = c[p[i]] = c[p[p[i]]] = ...). Find the minimum k > 0 such that p^k has at least one infinite path. Implement error handling for the following scenarios: 1. Invalid permutation (e.g., duplicate elements). 2. Invalid color values (e.g., out of range). 3. Propagation of errors with meaningful messages. 4. Handle cases where the input size exceeds constraints. 5. Ensure type hints are used throughout the solution.", "new_solution": "from typing import List, Tuple\n\nclass PermutationError(Exception):\n    pass\n\nclass InvalidPermutationError(PermutationError):\n    def __init__(self, message: str):\n        super().__init__(message)\n\nclass InvalidColorError(PermutationError):\n    def __init__(self, message: str):\n        super().__init__(message)\n\nclass InputSizeError(PermutationError):\n    def __init__(self, message: str):\n        super().__init__(message)\n\n\ndef apps_run2(T: int, test_cases: List[Tuple[int, List[int], List[int]]]) -> List[int]:\n    results = []\n    for n, p, c in test_cases:\n        if n > 2 * 10**5:\n            raise InputSizeError(\"Input size exceeds the allowed limit.\")\n        if len(set(p)) != n:\n            raise InvalidPermutationError(\"Permutation contains duplicate elements.\")\n        if any(ci < 1 or ci > n for ci in c):\n            raise InvalidColorError(\"Color values are out of range.\")\n\n        for i in range(n):\n            p[i] -= 1\n        przyn = [0] * n\n        grupa = []\n        i = 0\n        while i < n:\n            if przyn[i] == 1:\n                i += 1\n            else:\n                nowa_grupa = [i]\n                j = p[i]\n                przyn[i] = 1\n                while j != i:\n                    przyn[j] = 1\n                    nowa_grupa.append(j)\n                    j = p[j]\n                grupa.append(nowa_grupa)\n        grupacol = []\n        for i in grupa:\n            cyk = []\n            for j in i:\n                cyk.append(c[j])\n            grupacol.append(cyk)\n        mini = float('inf')\n        for cykl in grupacol:\n            dziel = []\n            d =  1\n            while d**2 <= len(cykl):\n                if len(cykl) % d == 0:\n                    dziel.append(d)\n                d += 1\n            dodat = []\n            for d in dziel:\n                dodat.append(len(cykl) // d)\n            dziel_ost = list(set(dziel + dodat))\n            for dzielnik in dziel_ost:\n                for i in range(dzielnik):\n                    indeks = i\n                    secik = set()\n                    chuj = True\n                    while indeks < len(cykl):\n                        secik.add(cykl[indeks])\n                        indeks += dzielnik\n                        if len(secik) > 1:\n                            chuj = False\n                            break\n                    if chuj:\n                        mini = min(mini, dzielnik)\n        results.append(mini)\n    return results\n", "input_format": "The function takes two parameters. The first parameter, T, is an integer in the range of 1 \u2264 T \u2264 10^4, which represents the number of test cases. The second parameter, test_cases, is a list. Each element in this list is a tuple representing a test case. Each tuple contains three elements: the first is an integer n in the range of 1 \u2264 n \u2264 2 * 10^5, indicating the size of the permutation; the second is a list of integers p of length n, where each integer p_i satisfies 1 \u2264 p_i \u2264 n and p_i \u2260 p_j for i \u2260 j, representing the permutation; the third is a list of integers c of length n, where each integer c_i satisfies 1 \u2264 c_i \u2264 n, representing the colors of the elements in the permutation.", "output_format": "The function returns a list of integers. The length of this list is equal to the number of test cases T. Each integer in the list corresponds to a test case and represents the minimum k > 0 such that p^k has at least one infinite path.", "test_input": ["assert apps_run2(1, [(4, [1, 3, 4, 2], [1, 2, 2, 3])]) == [1]", "assert apps_run2(1, [(5, [2, 3, 4, 5, 1], [1, 2, 3, 4, 5])]) == [5]", "assert apps_run2(1, [(8, [7, 4, 5, 6, 1, 8, 3, 2], [5, 3, 6, 4, 7, 5, 8, 4])]) == [2]", "try:\n    apps_run2(1, [(4, [1, 3, 3, 2], [1, 2, 2, 3])])\nexcept InvalidPermutationError as e:\n    assert str(e) == 'Permutation contains duplicate elements.'", "try:\n    apps_run2(1, [(4, [1, 3, 4, 2], [1, 2, 2, 6])])\nexcept InvalidColorError as e:\n    assert str(e) == 'Color values are out of range.'"], "requirement_type": "PROMPT_ERROR_HANDLING"}
{"task_id": "APPS/0103-1", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nAshish and Vivek play a game on a matrix consisting of $n$ rows and $m$ columns, where they take turns claiming cells. Unclaimed cells are represented by $0$, while claimed cells are represented by $1$. The initial state of the matrix is given. There can be some claimed cells in the initial state.\n\nIn each turn, a player must claim a cell. A cell may be claimed if it is unclaimed and does not share a row or column with any other already claimed cells. When a player is unable to make a move, he loses and the game ends.\n\nIf Ashish and Vivek take turns to move and Ashish goes first, determine the winner of the game if both of them are playing optimally.\n\nOptimal play between two players means that both players choose the best possible strategy to achieve the best possible outcome for themselves.\n\n\n-----Input-----\n\nThe first line consists of a single integer $t$ $(1 \\le t \\le 50)$\u00a0\u2014 the number of test cases. The description of the test cases follows.\n\nThe first line of each test case consists of two space-separated integers $n$, $m$ $(1 \\le n, m \\le 50)$\u00a0\u2014 the number of rows and columns in the matrix.\n\nThe following $n$ lines consist of $m$ integers each, the $j$-th integer on the $i$-th line denoting $a_{i,j}$ $(a_{i,j} \\in \\{0, 1\\})$.\n\n\n-----Output-----\n\nFor each test case if Ashish wins the game print \"Ashish\" otherwise print \"Vivek\" (without quotes).\n\n\n-----Example-----\nInput\n4\n2 2\n0 0\n0 0\n2 2\n0 0\n0 1\n2 3\n1 0 1\n1 1 0\n3 3\n1 0 0\n0 0 0\n1 0 0\n\nOutput\nVivek\nAshish\nVivek\nAshish\n\n\n\n-----Note-----\n\nFor the first case: One possible scenario could be: Ashish claims cell $(1, 1)$, Vivek then claims cell $(2, 2)$. Ashish can neither claim cell $(1, 2)$, nor cell $(2, 1)$ as cells $(1, 1)$ and $(2, 2)$ are already claimed. Thus Ashish loses. It can be shown that no matter what Ashish plays in this case, Vivek will win. \n\nFor the second case: Ashish claims cell $(1, 1)$, the only cell that can be claimed in the first move. After that Vivek has no moves left.\n\nFor the third case: Ashish cannot make a move, so Vivek wins.\n\nFor the fourth case: If Ashish claims cell $(2, 3)$, Vivek will have no moves left.", "raw_solution": "def apps_run1(t, test_cases):\n    results = []\n    for case in test_cases:\n        n, m, grid = case['n'], case['m'], case['grid']\n        rows = sum(1 for x in grid if all(y == 0 for y in x))\n        cols = sum(1 for j in range(m) if all(grid[i][j] == 0 for i in range(n)))\n        res = min(rows, cols)\n        results.append(\"Ashish\" if res % 2 else \"Vivek\")\n    return results\n", "raw_test_input": ["assert apps_run1(4, [{'n': 2, 'm': 2, 'grid': [[0, 0], [0, 0]]}, {'n': 2, 'm': 2, 'grid': [[0, 0], [0, 1]]}, {'n': 2, 'm': 3, 'grid': [[1, 0, 1], [1, 1, 0]]}, {'n': 3, 'm': 3, 'grid': [[1, 0, 0], [0, 0, 0], [1, 0, 0]]}]) == ['Vivek', 'Ashish', 'Vivek', 'Ashish']", "assert apps_run1(3, [{'n': 3, 'm': 3, 'grid': [[0, 0, 0], [0, 1, 0], [0, 0, 0]]}, {'n': 2, 'm': 2, 'grid': [[1, 0], [0, 0]]}, {'n': 4, 'm': 4, 'grid': [[0, 0, 0, 0], [0, 0, 1, 0], [0, 0, 0, 0], [0, 0, 0, 1]]}]) == ['Vivek', 'Ashish', 'Vivek']", "assert apps_run1(2, [{'n': 1, 'm': 5, 'grid': [[0, 0, 0, 0, 0]]}, {'n': 3, 'm': 3, 'grid': [[1, 0, 0], [0, 0, 0], [0, 1, 0]]}]) == ['Ashish', 'Ashish']", "assert apps_run1(5, [{'n': 2, 'm': 2, 'grid': [[1, 1], [1, 1]]}, {'n': 3, 'm': 2, 'grid': [[0, 0], [0, 1], [1, 0]]}, {'n': 1, 'm': 1, 'grid': [[0]]}, {'n': 4, 'm': 4, 'grid': [[0, 1, 0, 0], [0, 0, 0, 0], [1, 0, 0, 0], [0, 0, 0, 0]]}]) == ['Vivek', 'Vivek', 'Ashish', 'Vivek']", "assert apps_run1(1, [{'n': 5, 'm': 5, 'grid': [[0, 0, 0, 0, 0], [0, 0, 0, 0, 1], [0, 0, 0, 0, 0], [1, 0, 0, 0, 0], [0, 0, 0, 0, 0]]}]) == ['Ashish']", "assert apps_run1(4, [{'n': 1, 'm': 1, 'grid': [[0]]}, {'n': 1, 'm': 1, 'grid': [[1]]}, {'n': 3, 'm': 4, 'grid': [[0, 0, 0, 0], [1, 0, 0, 0], [0, 0, 0, 0]]}, {'n': 2, 'm': 3, 'grid': [[0, 1, 0], [0, 0, 0]]}]) == ['Ashish', 'Vivek', 'Vivek', 'Ashish']"], "new_problem": "In a competitive gaming scenario, Ashish and Vivek are playing a series of games on a matrix. The matrix represents a strategic map where each cell can be claimed. The game rules are the same as before, but now, after the initial state of the matrix is given, a series of potential moves (queries) are provided. Each query represents a move that Ashish can make, and you need to determine the winner of the game after each move. This scenario can be applied in a strategic planning system where each move represents a decision point in a larger strategy, such as resource allocation in a logistics network.", "new_solution": "def determine_winner(n, m, grid):\n    rows = sum(1 for x in grid if all(y == 0 for y in x))\n    cols = sum(1 for j in range(m) if all(grid[i][j] == 0 for i in range(n)))\n    res = min(rows, cols)\n    return \"Ashish\" if res % 2 else \"Vivek\"\n\n\ndef apply_query_and_determine_winner(n, m, grid, queries):\n    results = []\n    for x, y in queries:\n        if grid[x][y] == 0:\n            grid[x][y] = 1\n        results.append(determine_winner(n, m, grid))\n    return results\n\n\ndef apps_run2(t, scenarios):\n    results = []\n    for scenario in scenarios:\n        n, m, grid, queries = scenario\n        results.append(apply_query_and_determine_winner(n, m, grid, queries))\n    return results", "input_format": "The function takes two parameters. The first parameter, t, is an integer in the range of 1 \u2264 t \u2264 50, which represents the number of test cases. The second parameter, scenarios, is a list. Each element in this list represents a test case and is a tuple containing four elements: the first is an integer n in the range of 1 \u2264 n \u2264 50, indicating the number of rows in the matrix; the second is an integer m in the range of 1 \u2264 m \u2264 50, indicating the number of columns in the matrix; the third is a two - dimensional list grid representing the game matrix, where elements are either 0 (unclaimed cells) or 1 (claimed cells); the fourth is a list queries, where each element is a tuple (x, y) representing a potential move, with x being the row index and y being the column index within the valid range of the matrix.", "output_format": "The function returns a list whose length is equal to the number of test cases t. Each element in this list is a sub - list, and the length of the sub - list is equal to the number of queries in the corresponding test case. Each element in the sub - list is a string, either \"Ashish\" or \"Vivek\", indicating the winner of the game after applying the corresponding query move.", "test_input": ["assert apps_run2(1, [\n    (2, 2, [[0, 0], [0, 0]], [(0, 0), (1, 1)])\n]) == [['Ashish', 'Vivek']]", "assert apps_run2(1, [\n    (3, 3, [[1, 0, 0], [0, 0, 0], [1, 0, 0]], [(1, 1), (2, 2)])\n]) == [['Vivek', 'Vivek']]", "assert apps_run2(1, [\n    (2, 3, [[1, 0, 1], [1, 1, 0]], [(1, 2)])\n]) == [['Vivek']]", "assert apps_run2(1, [\n    (3, 3, [[0, 0, 0], [0, 0, 0], [0, 0, 0]], [(0, 0), (1, 1), (2, 2)])\n]) == [['Vivek', 'Ashish', 'Vivek']]", "assert apps_run2(1, [\n    (2, 2, [[0, 1], [1, 0]], [(0, 0)])\n]) == [['Vivek']]"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "APPS/0103-2", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nAshish and Vivek play a game on a matrix consisting of $n$ rows and $m$ columns, where they take turns claiming cells. Unclaimed cells are represented by $0$, while claimed cells are represented by $1$. The initial state of the matrix is given. There can be some claimed cells in the initial state.\n\nIn each turn, a player must claim a cell. A cell may be claimed if it is unclaimed and does not share a row or column with any other already claimed cells. When a player is unable to make a move, he loses and the game ends.\n\nIf Ashish and Vivek take turns to move and Ashish goes first, determine the winner of the game if both of them are playing optimally.\n\nOptimal play between two players means that both players choose the best possible strategy to achieve the best possible outcome for themselves.\n\n\n-----Input-----\n\nThe first line consists of a single integer $t$ $(1 \\le t \\le 50)$ \u2014 the number of test cases. The description of the test cases follows.\n\nThe first line of each test case consists of two space-separated integers $n$, $m$ $(1 \\le n, m \\le 50)$ \u2014 the number of rows and columns in the matrix.\n\nThe following $n$ lines consist of $m$ integers each, the $j$-th integer on the $i$-th line denoting $a_{i,j}$ $(a_{i,j} \\in \\{0, 1\\})$.\n\n\n-----Output-----\n\nFor each test case if Ashish wins the game print \"Ashish\" otherwise print \"Vivek\" (without quotes).\n\n\n-----Example-----\nInput\n4\n2 2\n0 0\n0 0\n2 2\n0 0\n0 1\n2 3\n1 0 1\n1 1 0\n3 3\n1 0 0\n0 0 0\n1 0 0\n\nOutput\nVivek\nAshish\nVivek\nAshish\n\n\n\n-----Note-----\n\nFor the first case: One possible scenario could be: Ashish claims cell $(1, 1)$, Vivek then claims cell $(2, 2)$. Ashish can neither claim cell $(1, 2)$, nor cell $(2, 1)$ as cells $(1, 1)$ and $(2, 2)$ are already claimed. Thus Ashish loses. It can be shown that no matter what Ashish plays in this case, Vivek will win. \n\nFor the second case: Ashish claims cell $(1, 1)$, the only cell that can be claimed in the first move. After that Vivek has no moves left.\n\nFor the third case: Ashish cannot make a move, so Vivek wins.\n\nFor the fourth case: If Ashish claims cell $(2, 3)$, Vivek will have no moves left.", "raw_solution": "def apps_run1(t, test_cases):\n    results = []\n    for case in test_cases:\n        n, m, grid = case['n'], case['m'], case['grid']\n        rows = sum(1 for x in grid if all(y == 0 for y in x))\n        cols = sum(1 for j in range(m) if all(grid[i][j] == 0 for i in range(n)))\n        res = min(rows, cols)\n        results.append(\"Ashish\" if res % 2 else \"Vivek\")\n    return results\n", "raw_test_input": ["assert apps_run1(4, [{'n': 2, 'm': 2, 'grid': [[0, 0], [0, 0]]}, {'n': 2, 'm': 2, 'grid': [[0, 0], [0, 1]]}, {'n': 2, 'm': 3, 'grid': [[1, 0, 1], [1, 1, 0]]}, {'n': 3, 'm': 3, 'grid': [[1, 0, 0], [0, 0, 0], [1, 0, 0]]}]) == ['Vivek', 'Ashish', 'Vivek', 'Ashish']", "assert apps_run1(3, [{'n': 3, 'm': 3, 'grid': [[0, 0, 0], [0, 1, 0], [0, 0, 0]]}, {'n': 2, 'm': 2, 'grid': [[1, 0], [0, 0]]}, {'n': 4, 'm': 4, 'grid': [[0, 0, 0, 0], [0, 0, 1, 0], [0, 0, 0, 0], [0, 0, 0, 1]]}]) == ['Vivek', 'Ashish', 'Vivek']", "assert apps_run1(2, [{'n': 1, 'm': 5, 'grid': [[0, 0, 0, 0, 0]]}, {'n': 3, 'm': 3, 'grid': [[1, 0, 0], [0, 0, 0], [0, 1, 0]]}]) == ['Ashish', 'Ashish']"], "new_problem": "Enhance the game between Ashish and Vivek by introducing a new optional parameter that allows specifying a 'blocked' state for certain cells. These blocked cells cannot be claimed by either player. The function should maintain backward compatibility, meaning it should work with the original input format without the new parameter. The new parameter is a list of tuples, where each tuple contains two integers representing the row and column of a blocked cell. The function should determine the winner of the game if both players are playing optimally, considering the blocked cells.", "new_solution": "from typing import List, Tuple, Optional\n\ndef apps_run2(t: int, test_cases: List[Tuple[int, int, List[List[int]], Optional[List[Tuple[int, int]]]]]) -> List[str]:\n    results = []\n    for case in test_cases:\n        n, m, grid, blocked = case\n        if blocked:\n            for r, c in blocked:\n                grid[r][c] = 1\n\n        rows = sum(1 for x in grid if all(y == 0 for y in x))\n        cols = sum(1 for j in range(m) if all(grid[i][j] == 0 for i in range(n)))\n\n        res = min(rows, cols)\n\n        results.append(\"Ashish\" if res % 2 else \"Vivek\")\n    return results\n\n# Original function for backward compatibility\n\ndef original_apps_run2(t: int, test_cases: List[Tuple[int, int, List[List[int]]]]) -> List[str]:\n    return apps_run2(t, [(n, m, grid, None) for n, m, grid in test_cases])", "input_format": "The function takes two parameters. The first parameter, t, is an integer in the range of 1 \u2264 t \u2264 50, which represents the number of test cases. The second parameter, test_cases, is a list. Each element in this list is a tuple representing a test case. Each tuple contains four elements: the first is an integer n in the range of 1 \u2264 n \u2264 50, indicating the number of rows in the matrix; the second is an integer m in the range of 1 \u2264 m \u2264 50, indicating the number of columns in the matrix; the third is a two - dimensional list grid where elements are either 0 (unclaimed cells) or 1 (claimed cells); the fourth is an optional parameter blocked, which is a list of tuples. Each tuple in this list contains two integers representing the row and column of a blocked cell. This parameter can be None to maintain backward compatibility with the original input format.", "output_format": "The function returns a list of strings. The length of this list is equal to the number of test cases t. Each string in the list is either \"Ashish\" or \"Vivek\", indicating the winner of the game for the corresponding test case.", "test_input": ["assert apps_run2(4, [(2, 2, [[0, 0], [0, 0]], None), (2, 2, [[0, 0], [0, 1]], None), (2, 3, [[1, 0, 1], [1, 1, 0]], None), (3, 3, [[1, 0, 0], [0, 0, 0], [1, 0, 0]], None)]) == ['Vivek', 'Ashish', 'Vivek', 'Ashish']", "assert apps_run2(1, [(3, 3, [[0, 0, 0], [0, 0, 0], [0, 0, 0]], [(1, 1)])]) == ['Vivek']", "assert apps_run2(1, [(3, 3, [[0, 0, 0], [0, 0, 0], [0, 0, 0]], [(0, 0), (1, 1), (2, 2)])]) == ['Vivek']", "assert apps_run2(1, [(2, 2, [[0, 0], [0, 0]], [(0, 1), (1, 0)])]) == ['Vivek']", "assert apps_run2(1, [(2, 2, [[0, 0], [0, 0]], [(0, 0), (1, 1)])]) == ['Vivek']"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "APPS/0103-3", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nAshish and Vivek play a game on a matrix consisting of $n$ rows and $m$ columns, where they take turns claiming cells. Unclaimed cells are represented by $0$, while claimed cells are represented by $1$. The initial state of the matrix is given. There can be some claimed cells in the initial state.\n\nIn each turn, a player must claim a cell. A cell may be claimed if it is unclaimed and does not share a row or column with any other already claimed cells. When a player is unable to make a move, he loses and the game ends.\n\nIf Ashish and Vivek take turns to move and Ashish goes first, determine the winner of the game if both of them are playing optimally.\n\nOptimal play between two players means that both players choose the best possible strategy to achieve the best possible outcome for themselves.\n\n\n-----Input-----\n\nThe first line consists of a single integer $t$ $(1 \\le t \\le 50)$\u00a0\u2014 the number of test cases. The description of the test cases follows.\n\nThe first line of each test case consists of two space-separated integers $n$, $m$ $(1 \\le n, m \\le 50)$\u00a0\u2014 the number of rows and columns in the matrix.\n\nThe following $n$ lines consist of $m$ integers each, the $j$-th integer on the $i$-th line denoting $a_{i,j}$ $(a_{i,j} \\in \\{0, 1\\})$.\n\n\n-----Output-----\n\nFor each test case if Ashish wins the game print \"Ashish\" otherwise print \"Vivek\" (without quotes).\n\n\n-----Example-----\nInput\n4\n2 2\n0 0\n0 0\n2 2\n0 0\n0 1\n2 3\n1 0 1\n1 1 0\n3 3\n1 0 0\n0 0 0\n1 0 0\n\nOutput\nVivek\nAshish\nVivek\nAshish\n\n\n\n-----Note-----\n\nFor the first case: One possible scenario could be: Ashish claims cell $(1, 1)$, Vivek then claims cell $(2, 2)$. Ashish can neither claim cell $(1, 2)$, nor cell $(2, 1)$ as cells $(1, 1)$ and $(2, 2)$ are already claimed. Thus Ashish loses. It can be shown that no matter what Ashish plays in this case, Vivek will win. \n\nFor the second case: Ashish claims cell $(1, 1)$, the only cell that can be claimed in the first move. After that Vivek has no moves left.\n\nFor the third case: Ashish cannot make a move, so Vivek wins.\n\nFor the fourth case: If Ashish claims cell $(2, 3)$, Vivek will have no moves left.", "raw_solution": "def apps_run1(t, test_cases):\n    results = []\n    for case in test_cases:\n        n, m, grid = case['n'], case['m'], case['grid']\n        rows = sum(1 for x in grid if all(y == 0 for y in x))\n        cols = sum(1 for j in range(m) if all(grid[i][j] == 0 for i in range(n)))\n        res = min(rows, cols)\n        results.append(\"Ashish\" if res % 2 else \"Vivek\")\n    return results\n", "raw_test_input": ["assert apps_run1(4, [{'n': 2, 'm': 2, 'grid': [[0, 0], [0, 0]]}, {'n': 2, 'm': 2, 'grid': [[0, 0], [0, 1]]}, {'n': 2, 'm': 3, 'grid': [[1, 0, 1], [1, 1, 0]]}, {'n': 3, 'm': 3, 'grid': [[1, 0, 0], [0, 0, 0], [1, 0, 0]]}]) == ['Vivek', 'Ashish', 'Vivek', 'Ashish']", "assert apps_run1(3, [{'n': 3, 'm': 3, 'grid': [[0, 0, 0], [0, 1, 0], [0, 0, 0]]}, {'n': 2, 'm': 2, 'grid': [[1, 0], [0, 0]]}, {'n': 4, 'm': 4, 'grid': [[0, 0, 0, 0], [0, 0, 1, 0], [0, 0, 0, 0], [0, 0, 0, 1]]}]) == ['Vivek', 'Ashish', 'Vivek']", "assert apps_run1(2, [{'n': 1, 'm': 5, 'grid': [[0, 0, 0, 0, 0]]}, {'n': 3, 'm': 3, 'grid': [[1, 0, 0], [0, 0, 0], [0, 1, 0]]}]) == ['Ashish', 'Ashish']"], "new_problem": "Ashish and Vivek play a game on a matrix consisting of n rows and m columns, where they take turns claiming cells. Unclaimed cells are represented by 0, while claimed cells are represented by 1. The initial state of the matrix is given. There can be some claimed cells in the initial state. In each turn, a player must claim a cell. A cell may be claimed if it is unclaimed and does not share a row or column with any other already claimed cells. When a player is unable to make a move, he loses and the game ends. If Ashish and Vivek take turns to move and Ashish goes first, determine the winner of the game if both of them are playing optimally. Optimal play between two players means that both players choose the best possible strategy to achieve the best possible outcome for themselves. However, the matrix is now represented as a dictionary where keys are tuples representing the coordinates of the cells, and values are integers (0 or 1) representing the state of the cell. Additionally, the matrix can have up to 100 rows and columns.", "new_solution": "from typing import Dict, Tuple, List\n\ndef apps_run2(t: int, test_cases: Dict[int, Tuple[int, int, Dict[Tuple[int, int], int]]]) -> List[str]:\n    results = []\n    for case in range(t):\n        n, m, grid = test_cases[case]\n        row_claimed = {i: False for i in range(n)}\n        col_claimed = {j: False for j in range(m)}\n\n        for (i, j), value in grid.items():\n            if value == 1:\n                row_claimed[i] = True\n                col_claimed[j] = True\n\n        free_rows = sum(1 for claimed in row_claimed.values() if not claimed)\n        free_cols = sum(1 for claimed in col_claimed.values() if not claimed)\n\n        res = min(free_rows, free_cols)\n        results.append(\"Ashish\" if res % 2 else \"Vivek\")\n\n    return results", "input_format": "The function takes two parameters. The first parameter, t, is an integer in the range of 1 \u2264 t \u2264 50, which represents the number of test cases. The second parameter, test_cases, is a dictionary. The keys of the dictionary are integers ranging from 0 to t - 1, and each key corresponds to a test case. Each test case is a tuple containing three elements: the first is an integer n in the range of 1 \u2264 n \u2264 100, indicating the number of rows in the matrix; the second is an integer m in the range of 1 \u2264 m \u2264 100, indicating the number of columns in the matrix; the third is a dictionary grid, where the keys are tuples, each tuple containing two integers representing the coordinates (i, j) of a cell in the matrix, and the values are integers 0 or 1, with 0 indicating an unclaimed cell and 1 indicating a claimed cell.", "output_format": "The function returns a list of strings. The length of this list is equal to the number of test cases t. Each string in the list is either \"Ashish\" or \"Vivek\", indicating the winner of the game for the corresponding test case.", "test_input": ["assert apps_run2(1, {0: (2, 2, {(0, 0): 0, (0, 1): 0, (1, 0): 0, (1, 1): 0})}) == ['Vivek']", "assert apps_run2(1, {0: (2, 2, {(0, 0): 0, (0, 1): 0, (1, 0): 0, (1, 1): 1})}) == ['Ashish']", "assert apps_run2(1, {0: (2, 3, {(0, 0): 1, (0, 1): 0, (0, 2): 1, (1, 0): 1, (1, 1): 1, (1, 2): 0})}) == ['Vivek']", "assert apps_run2(1, {0: (3, 3, {(0, 0): 1, (0, 1): 0, (0, 2): 0, (1, 0): 0, (1, 1): 0, (1, 2): 0, (2, 0): 1, (2, 1): 0, (2, 2): 0})}) == ['Ashish']", "assert apps_run2(1, {0: (3, 3, {(0, 0): 0, (0, 1): 0, (0, 2): 0, (1, 0): 0, (1, 1): 0, (1, 2): 0, (2, 0): 0, (2, 1): 0, (2, 2): 0})}) == ['Ashish']"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "APPS/0103-4", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nAshish and Vivek play a game on a matrix consisting of $n$ rows and $m$ columns, where they take turns claiming cells. Unclaimed cells are represented by $0$, while claimed cells are represented by $1$. The initial state of the matrix is given. There can be some claimed cells in the initial state.\n\nIn each turn, a player must claim a cell. A cell may be claimed if it is unclaimed and does not share a row or column with any other already claimed cells. When a player is unable to make a move, he loses and the game ends.\n\nIf Ashish and Vivek take turns to move and Ashish goes first, determine the winner of the game if both of them are playing optimally.\n\nOptimal play between two players means that both players choose the best possible strategy to achieve the best possible outcome for themselves.\n\n\n-----Input-----\n\nThe first line consists of a single integer $t$ $(1 \\le t \\le 50)$\u00a0\u2014 the number of test cases. The description of the test cases follows.\n\nThe first line of each test case consists of two space-separated integers $n$, $m$ $(1 \\le n, m \\le 50)$\u00a0\u2014 the number of rows and columns in the matrix.\n\nThe following $n$ lines consist of $m$ integers each, the $j$-th integer on the $i$-th line denoting $a_{i,j}$ $(a_{i,j} \\in \\{0, 1\\})$.\n\n\n-----Output-----\n\nFor each test case if Ashish wins the game print \"Ashish\" otherwise print \"Vivek\" (without quotes).\n\n\n-----Example-----\nInput\n4\n2 2\n0 0\n0 0\n2 2\n0 0\n0 1\n2 3\n1 0 1\n1 1 0\n3 3\n1 0 0\n0 0 0\n1 0 0\n\nOutput\nVivek\nAshish\nVivek\nAshish\n\n\n\n-----Note-----\n\nFor the first case: One possible scenario could be: Ashish claims cell $(1, 1)$, Vivek then claims cell $(2, 2)$. Ashish can neither claim cell $(1, 2)$, nor cell $(2, 1)$ as cells $(1, 1)$ and $(2, 2)$ are already claimed. Thus Ashish loses. It can be shown that no matter what Ashish plays in this case, Vivek will win. \n\nFor the second case: Ashish claims cell $(1, 1)$, the only cell that can be claimed in the first move. After that Vivek has no moves left.\n\nFor the third case: Ashish cannot make a move, so Vivek wins.\n\nFor the fourth case: If Ashish claims cell $(2, 3)$, Vivek will have no moves left.", "raw_solution": "def apps_run1(t, test_cases):\n    results = []\n    for case in test_cases:\n        n, m, grid = case['n'], case['m'], case['grid']\n        rows = sum(1 for x in grid if all(y == 0 for y in x))\n        cols = sum(1 for j in range(m) if all(grid[i][j] == 0 for i in range(n)))\n        res = min(rows, cols)\n        results.append(\"Ashish\" if res % 2 else \"Vivek\")\n    return results\n", "raw_test_input": ["assert apps_run1(4, [{'n': 2, 'm': 2, 'grid': [[0, 0], [0, 0]]}, {'n': 2, 'm': 2, 'grid': [[0, 0], [0, 1]]}, {'n': 2, 'm': 3, 'grid': [[1, 0, 1], [1, 1, 0]]}, {'n': 3, 'm': 3, 'grid': [[1, 0, 0], [0, 0, 0], [1, 0, 0]]}]) == ['Vivek', 'Ashish', 'Vivek', 'Ashish']", "assert apps_run1(3, [{'n': 3, 'm': 3, 'grid': [[0, 0, 0], [0, 1, 0], [0, 0, 0]]}, {'n': 2, 'm': 2, 'grid': [[1, 0], [0, 0]]}, {'n': 4, 'm': 4, 'grid': [[0, 0, 0, 0], [0, 0, 1, 0], [0, 0, 0, 0], [0, 0, 0, 1]]}]) == ['Vivek', 'Ashish', 'Vivek']", "assert apps_run1(2, [{'n': 1, 'm': 5, 'grid': [[0, 0, 0, 0, 0]]}, {'n': 3, 'm': 3, 'grid': [[1, 0, 0], [0, 0, 0], [0, 1, 0]]}]) == ['Ashish', 'Ashish']"], "new_problem": "Ashish and Vivek play a game on a matrix consisting of n rows and m columns, where they take turns claiming cells. Unclaimed cells are represented by 0, while claimed cells are represented by 1. The initial state of the matrix is given. There can be some claimed cells in the initial state. In each turn, a player must claim a cell. A cell may be claimed if it is unclaimed and does not share a row or column with any other already claimed cells. When a player is unable to make a move, he loses and the game ends. If Ashish and Vivek take turns to move and Ashish goes first, determine the winner of the game if both of them are playing optimally. However, the input may contain errors such as invalid matrix dimensions, non-binary values in the matrix, or inconsistent row lengths. Implement error handling to manage these scenarios. Define specific error types for invalid input, and ensure meaningful error messages are provided. Handle error propagation and maintain type hints.", "new_solution": "from typing import List\n\nclass InvalidMatrixError(Exception):\n    pass\n\nclass NonBinaryValueError(Exception):\n    pass\n\nclass InconsistentRowLengthError(Exception):\n    pass\n\ndef apps_run2(t: int, test_cases: List[List[List[int]]]) -> List[str]:\n    results = []\n    for case in test_cases:\n        n = len(case)\n        if n == 0:\n            raise InvalidMatrixError(\"Matrix must have at least one row.\")\n        m = len(case[0])\n        if any(len(row) != m for row in case):\n            raise InconsistentRowLengthError(\"All rows must have the same length.\")\n        if any(cell not in {0, 1} for row in case for cell in row):\n            raise NonBinaryValueError(\"Matrix can only contain binary values (0 or 1).\")\n\n        rows = sum(1 for x in case if all(y == 0 for y in x))\n        cols = sum(1 for j in range(m) if all(case[i][j] == 0 for i in range(n)))\n\n        res = min(rows, cols)\n\n        results.append(\"Ashish\" if res % 2 else \"Vivek\")\n    return results", "input_format": "The function takes two parameters. The first parameter, t, is an integer in the range of 1 \u2264 t \u2264 50, which represents the number of test cases. The second parameter, test_cases, is a list where each element represents a test case. Each test case is a two - dimensional list representing the game matrix. The elements in the matrix should be either 0 or 1, with 0 indicating an unclaimed cell and 1 indicating a claimed cell. The number of rows and columns in the matrix should satisfy 1 \u2264 n, m \u2264 50, and all rows must have the same length.", "output_format": "The function returns a list of strings. The length of this list is equal to the number of test cases t. Each string in the list is either \"Ashish\" or \"Vivek\", indicating the winner of the game for the corresponding test case. If there are errors in the input, such as invalid matrix dimensions, non - binary values in the matrix, or inconsistent row lengths, the function will raise corresponding custom exceptions, such as InvalidMatrixError, NonBinaryValueError, or InconsistentRowLengthError, along with meaningful error messages.", "test_input": ["assert apps_run2(1, [[[0, 0], [0, 0]]]) == ['Vivek']", "assert apps_run2(1, [[[0, 0], [0, 1]]]) == ['Ashish']", "try:\n    apps_run2(1, [[[0, 0], [0, 2]]])\nexcept NonBinaryValueError as e:\n    assert str(e) == 'Matrix can only contain binary values (0 or 1).'", "try:\n    apps_run2(1, [[[0, 0], [0]]])\nexcept InconsistentRowLengthError as e:\n    assert str(e) == 'All rows must have the same length.'", "try:\n    apps_run2(1, [[]])\nexcept InvalidMatrixError as e:\n    assert str(e) == 'Matrix must have at least one row.'"], "requirement_type": "PROMPT_ERROR_HANDLING"}
{"task_id": "APPS/0102-1", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nHooray! Polycarp turned $n$ years old! The Technocup Team sincerely congratulates Polycarp!\n\nPolycarp celebrated all of his $n$ birthdays: from the $1$-th to the $n$-th. At the moment, he is wondering: how many times he turned beautiful number of years?\n\nAccording to Polycarp, a positive integer is beautiful if it consists of only one digit repeated one or more times. For example, the following numbers are beautiful: $1$, $77$, $777$, $44$ and $999999$. The following numbers are not beautiful: $12$, $11110$, $6969$ and $987654321$.\n\nOf course, Polycarpus uses the decimal numeral system (i.e. radix is 10).\n\nHelp Polycarpus to find the number of numbers from $1$ to $n$ (inclusive) that are beautiful.\n\n\n-----Input-----\n\nThe first line contains an integer $t$ ($1 \\le t \\le 10^4$) \u2014 the number of test cases in the input. Then $t$ test cases follow.\n\nEach test case consists of one line, which contains a positive integer $n$ ($1 \\le n \\le 10^9$) \u2014 how many years Polycarp has turned.\n\n\n-----Output-----\n\nPrint $t$ integers \u2014 the answers to the given test cases in the order they are written in the test. Each answer is an integer: the number of beautiful years between $1$ and $n$, inclusive.\n\n\n-----Example-----\nInput\n6\n18\n1\n9\n100500\n33\n1000000000\n\nOutput\n10\n1\n9\n45\n12\n81\n\n\n\n-----Note-----\n\nIn the first test case of the example beautiful years are $1$, $2$, $3$, $4$, $5$, $6$, $7$, $8$, $9$ and $11$.", "raw_solution": "def apps_run1(q, queries):\n    s = []\n    for i in range(1, 10):\n        k = 0\n        for l in range(1, 10):\n            k *= 10\n            k += i\n            s.append(k)\n    s.sort()\n    results = []\n    for _ in range(q):\n        n = queries[_]\n        l = 0\n        r = len(s)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if s[m] <= n:\n                l = m\n            else:\n                r = m\n        results.append(r)\n    return results", "raw_test_input": ["assert apps_run1(6, [18, 1, 9, 100500, 33, 1000000000]) == [10, 1, 9, 45, 12, 81]", "assert apps_run1(5, [25, 50, 75, 100, 200]) == [11, 13, 15, 18, 19]", "assert apps_run1(4, [10, 15, 30, 999999999]) == [9, 10, 11, 81]", "assert apps_run1(3, [5, 20, 1000]) == [5, 10, 27]", "assert apps_run1(2, [1, 999999999]) == [1, 81]", "assert apps_run1(7, [12, 22, 33, 44, 55, 66, 77]) == [10, 11, 12, 13, 14, 15, 16]"], "new_problem": "In a birthday planning application, you need to determine how many beautiful years Polycarp has celebrated, but with a constraint. For each test case, given the number of years Polycarp has turned (n) and a maximum number of beautiful years allowed (m), calculate how many beautiful years Polycarp has celebrated that do not exceed m. This can help in planning events where only a certain number of beautiful years can be celebrated.", "new_solution": "def count_beautiful_numbers(n):\n    s = []\n    for i in range(1, 10):\n        k = 0\n        for l in range(1, 10):\n            k *= 10\n            k += i\n            s.append(k)\n    s.sort()\n    l = 0\n    r = len(s)\n    while l + 1 < r:\n        m = (l + r) // 2\n        if s[m] <= n:\n            l = m\n        else:\n            r = m\n    return r\n\ndef apps_run2(t, test_cases):\n    results = []\n    for n, m in test_cases:\n        beautiful_count = count_beautiful_numbers(n)\n        results.append(min(beautiful_count, m))\n    return results", "input_format": "The function takes two parameters. The first parameter, t, is an integer in the range of 1 \u2264 t \u2264 10^4, which represents the number of test cases. The second parameter, test_cases, is a list. Each element in this list is a tuple containing two integers. The first integer n in the range of 1 \u2264 n \u2264 10^9 indicates the number of years Polycarp has turned. The second integer m in the range of 1 \u2264 m \u2264 10^9 represents the maximum number of beautiful years allowed.", "output_format": "The function returns a list of integers. The length of this list is equal to the number of test cases t. Each integer in the list corresponds to a test case and represents the number of beautiful years between 1 and n (inclusive) that do not exceed m.", "test_input": ["assert apps_run2(1, [(18, 5)]) == [5]", "assert apps_run2(1, [(100500, 50)]) == [45]", "assert apps_run2(1, [(33, 10)]) == [10]", "assert apps_run2(1, [(1000000000, 100)]) == [81]", "assert apps_run2(1, [(9, 9)]) == [9]"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "APPS/0102-2", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nHooray! Polycarp turned $n$ years old! The Technocup Team sincerely congratulates Polycarp!\n\nPolycarp celebrated all of his $n$ birthdays: from the $1$-th to the $n$-th. At the moment, he is wondering: how many times he turned beautiful number of years?\n\nAccording to Polycarp, a positive integer is beautiful if it consists of only one digit repeated one or more times. For example, the following numbers are beautiful: $1$, $77$, $777$, $44$ and $999999$. The following numbers are not beautiful: $12$, $11110$, $6969$ and $987654321$.\n\nOf course, Polycarpus uses the decimal numeral system (i.e. radix is 10).\n\nHelp Polycarpus to find the number of numbers from $1$ to $n$ (inclusive) that are beautiful.\n\n\n-----Input-----\n\nThe first line contains an integer $t$ ($1 \\le t \\le 10^4$) \u2014 the number of test cases in the input. Then $t$ test cases follow.\n\nEach test case consists of one line, which contains a positive integer $n$ ($1 \\le n \\le 10^9$) \u2014 how many years Polycarp has turned.\n\n\n-----Output-----\n\nPrint $t$ integers \u2014 the answers to the given test cases in the order they are written in the test. Each answer is an integer: the number of beautiful years between $1$ and $n$, inclusive.\n\n\n-----Example-----\nInput\n6\n18\n1\n9\n100500\n33\n1000000000\n\nOutput\n10\n1\n9\n45\n12\n81\n\n\n\n-----Note-----\n\nIn the first test case of the example beautiful years are $1$, $2$, $3$, $4$, $5$, $6$, $7$, $8$, $9$ and $11$.", "raw_solution": "def apps_run1(q, queries):\n    s = []\n    for i in range(1, 10):\n        k = 0\n        for l in range(1, 10):\n            k *= 10\n            k += i\n            s.append(k)\n    s.sort()\n    results = []\n    for _ in range(q):\n        n = queries[_]\n        l = 0\n        r = len(s)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if s[m] <= n:\n                l = m\n            else:\n                r = m\n        results.append(r)\n    return results", "raw_test_input": ["assert apps_run1(6, [18, 1, 9, 100500, 33, 1000000000]) == [10, 1, 9, 45, 12, 81]", "assert apps_run1(5, [25, 50, 75, 100, 200]) == [11, 13, 15, 18, 19]", "assert apps_run1(4, [10, 15, 30, 999999999]) == [9, 10, 11, 81]", "assert apps_run1(3, [5, 20, 1000]) == [5, 10, 27]", "assert apps_run1(2, [1, 999999999]) == [1, 81]", "assert apps_run1(7, [12, 22, 33, 44, 55, 66, 77]) == [10, 11, 12, 13, 14, 15, 16]"], "new_problem": "Polycarp is curious not only about how many beautiful years he has celebrated but also wants to know which specific years were beautiful. Modify the function to optionally return the list of beautiful numbers between 1 and n, inclusive. The function should maintain backward compatibility by defaulting to returning the count of beautiful numbers. Add an optional parameter 'detailed' that, when set to True, returns the list of beautiful numbers instead of just the count.", "new_solution": "from typing import List, Union\n\ndef apps_run2(t: int, test_cases: List[int], detailed: bool = False) -> List[Union[int, List[int]]]:\n    s = []\n    for i in range(1, 10):\n        k = 0\n        for l in range(1, 10):\n            k *= 10\n            k += i\n            s.append(k)\n    s.sort()\n    results = []\n    for n in test_cases:\n        l = 0\n        r = len(s)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if s[m] <= n:\n                l = m\n            else:\n                r = m\n        if detailed:\n            results.append(s[:r])\n        else:\n            results.append(r)\n    return results", "input_format": "The function takes three parameters, with the third one being optional. The first parameter, t, is an integer in the range of 1 \u2264 t \u2264 10^4, which represents the number of test cases. The second parameter, test_cases, is a list of integers. Each integer n in the list, with a range of 1 \u2264 n \u2264 10^9, represents a test case indicating the number of years Polycarp has lived. The third parameter, detailed, is an optional boolean parameter with a default value of False. When detailed is True, the function returns a list of beautiful years; when detailed is False, the function returns the count of beautiful years.", "output_format": "The function returns a list whose length is equal to the number of test cases t. The type of elements in the list depends on the value of the detailed parameter. When detailed is False (the default), each element in the list is an integer representing the count of beautiful years between 1 and n (inclusive) for the corresponding test case. When detailed is True, each element in the list is a list of integers representing the beautiful years between 1 and n (inclusive) for the corresponding test case.", "test_input": ["assert apps_run2(6, [18, 1, 9, 100500, 33, 1000000000]) == [10, 1, 9, 45, 12, 81]", "assert apps_run2(1, [18], detailed=True) == [[1, 2, 3, 4, 5, 6, 7, 8, 9, 11]]", "assert apps_run2(1, [1], detailed=True) == [[1]]", "assert apps_run2(1, [9], detailed=True) == [[1, 2, 3, 4, 5, 6, 7, 8, 9]]", "assert apps_run2(1, [100500], detailed=True) == [[1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 22, 33, 44, 55, 66, 77, 88, 99, 111, 222, 333, 444, 555, 666, 777, 888, 999, 1111, 2222, 3333, 4444, 5555, 6666, 7777, 8888, 9999, 11111, 22222, 33333, 44444, 55555, 66666, 77777, 88888, 99999]]"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "APPS/0102-3", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nHooray! Polycarp turned $n$ years old! The Technocup Team sincerely congratulates Polycarp!\n\nPolycarp celebrated all of his $n$ birthdays: from the $1$-th to the $n$-th. At the moment, he is wondering: how many times he turned beautiful number of years?\n\nAccording to Polycarp, a positive integer is beautiful if it consists of only one digit repeated one or more times. For example, the following numbers are beautiful: $1$, $77$, $777$, $44$ and $999999$. The following numbers are not beautiful: $12$, $11110$, $6969$ and $987654321$.\n\nOf course, Polycarpus uses the decimal numeral system (i.e. radix is 10).\n\nHelp Polycarpus to find the number of numbers from $1$ to $n$ (inclusive) that are beautiful.\n\n\n-----Input-----\n\nThe first line contains an integer $t$ ($1 \\le t \\le 10^4$) \u2014 the number of test cases in the input. Then $t$ test cases follow.\n\nEach test case consists of one line, which contains a positive integer $n$ ($1 \\le n \\le 10^9$) \u2014 how many years Polycarp has turned.\n\n\n-----Output-----\n\nPrint $t$ integers \u2014 the answers to the given test cases in the order they are written in the test. Each answer is an integer: the number of beautiful years between $1$ and $n$, inclusive.\n\n\n-----Example-----\nInput\n6\n18\n1\n9\n100500\n33\n1000000000\n\nOutput\n10\n1\n9\n45\n12\n81\n\n\n\n-----Note-----\n\nIn the first test case of the example beautiful years are $1$, $2$, $3$, $4$, $5$, $6$, $7$, $8$, $9$ and $11$.", "raw_solution": "def apps_run1(q, queries):\n    s = []\n    for i in range(1, 10):\n        k = 0\n        for l in range(1, 10):\n            k *= 10\n            k += i\n            s.append(k)\n    s.sort()\n    results = []\n    for _ in range(q):\n        n = queries[_]\n        l = 0\n        r = len(s)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if s[m] <= n:\n                l = m\n            else:\n                r = m\n        results.append(r)\n    return results", "raw_test_input": ["assert apps_run1(6, [18, 1, 9, 100500, 33, 1000000000]) == [10, 1, 9, 45, 12, 81]", "assert apps_run1(5, [25, 50, 75, 100, 200]) == [11, 13, 15, 18, 19]", "assert apps_run1(4, [10, 15, 30, 999999999]) == [9, 10, 11, 81]", "assert apps_run1(3, [5, 20, 1000]) == [5, 10, 27]", "assert apps_run1(2, [1, 999999999]) == [1, 81]", "assert apps_run1(7, [12, 22, 33, 44, 55, 66, 77]) == [10, 11, 12, 13, 14, 15, 16]"], "new_problem": "Polycarp is now interested in not only counting the beautiful years but also categorizing them by the digit they are composed of. For each test case, output a dictionary where the keys are the digits (1 to 9) and the values are the counts of beautiful numbers composed of that digit from 1 to n. Use a dictionary to store the beautiful numbers and their counts for each digit. Additionally, ensure that the solution is efficient enough to handle up to 10^4 test cases with n as large as 10^9.", "new_solution": "from typing import List, Dict\n\ndef apps_run2(t: int, test_cases: List[int]) -> List[Dict[int, int]]:\n    beautiful_numbers = {i: [] for i in range(1, 10)}\n    for i in range(1, 10):\n        k = 0\n        for l in range(1, 10):\n            k = k * 10 + i\n            beautiful_numbers[i].append(k)\n    results = []\n    for n in test_cases:\n        result = {i: 0 for i in range(1, 10)}\n        for digit, numbers in beautiful_numbers.items():\n            for number in numbers:\n                if number <= n:\n                    result[digit] += 1\n                else:\n                    break\n        results.append(result)\n    return results", "input_format": "The function takes two parameters. The first parameter, t, is an integer in the range of 1 \u2264 t \u2264 10^4, which represents the number of test cases. It indicates how many different values of n in the test_cases list need to be calculated. The second parameter, test_cases, is a list of integers. Each integer n in the list is in the range of 1 \u2264 n \u2264 10^9. Each n corresponds to a test case, representing the number of years Polycarp has lived. The function will calculate the situation of beautiful years from 1 to n for each n.", "output_format": "The function returns a list whose length is equal to the number of test cases t. Each element in the list is a dictionary. The keys of the dictionary are integers from 1 to 9, representing the single digits that compose the beautiful numbers. The values of the dictionary are integers, indicating the count of beautiful numbers composed of the corresponding key digit between 1 and n in the corresponding test case.", "test_input": ["assert apps_run2(1, [18]) == [{1: 2, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1, 7: 1, 8: 1, 9: 1}]", "assert apps_run2(1, [1]) == [{1: 1, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0, 9: 0}]", "assert apps_run2(1, [9]) == [{1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1, 7: 1, 8: 1, 9: 1}]", "assert apps_run2(1, [100500]) == [{1: 5, 2: 5, 3: 5, 4: 5, 5: 5, 6: 5, 7: 5, 8: 5, 9: 5}]", "assert apps_run2(1, [33]) == [{1: 2, 2: 2, 3: 2, 4: 1, 5: 1, 6: 1, 7: 1, 8: 1, 9: 1}]"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "APPS/0102-4", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nHooray! Polycarp turned $n$ years old! The Technocup Team sincerely congratulates Polycarp!\n\nPolycarp celebrated all of his $n$ birthdays: from the $1$-th to the $n$-th. At the moment, he is wondering: how many times he turned beautiful number of years?\n\nAccording to Polycarp, a positive integer is beautiful if it consists of only one digit repeated one or more times. For example, the following numbers are beautiful: $1$, $77$, $777$, $44$ and $999999$. The following numbers are not beautiful: $12$, $11110$, $6969$ and $987654321$.\n\nOf course, Polycarpus uses the decimal numeral system (i.e. radix is 10).\n\nHelp Polycarpus to find the number of numbers from $1$ to $n$ (inclusive) that are beautiful.\n\n\n-----Input-----\n\nThe first line contains an integer $t$ ($1 \\le t \\le 10^4$) \u2014 the number of test cases in the input. Then $t$ test cases follow.\n\nEach test case consists of one line, which contains a positive integer $n$ ($1 \\le n \\le 10^9$) \u2014 how many years Polycarp has turned.\n\n\n-----Output-----\n\nPrint $t$ integers \u2014 the answers to the given test cases in the order they are written in the test. Each answer is an integer: the number of beautiful years between $1$ and $n$, inclusive.\n\n\n-----Example-----\nInput\n6\n18\n1\n9\n100500\n33\n1000000000\n\nOutput\n10\n1\n9\n45\n12\n81\n\n\n\n-----Note-----\n\nIn the first test case of the example beautiful years are $1$, $2$, $3$, $4$, $5$, $6$, $7$, $8$, $9$ and $11$.", "raw_solution": "def apps_run1(q, queries):\n    s = []\n    for i in range(1, 10):\n        k = 0\n        for l in range(1, 10):\n            k *= 10\n            k += i\n            s.append(k)\n    s.sort()\n    results = []\n    for _ in range(q):\n        n = queries[_]\n        l = 0\n        r = len(s)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if s[m] <= n:\n                l = m\n            else:\n                r = m\n        results.append(r)\n    return results", "raw_test_input": ["assert apps_run1(6, [18, 1, 9, 100500, 33, 1000000000]) == [10, 1, 9, 45, 12, 81]", "assert apps_run1(5, [25, 50, 75, 100, 200]) == [11, 13, 15, 18, 19]", "assert apps_run1(4, [10, 15, 30, 999999999]) == [9, 10, 11, 81]", "assert apps_run1(3, [5, 20, 1000]) == [5, 10, 27]", "assert apps_run1(2, [1, 999999999]) == [1, 81]", "assert apps_run1(7, [12, 22, 33, 44, 55, 66, 77]) == [10, 11, 12, 13, 14, 15, 16]"], "new_problem": "Polycarp is curious about how many beautiful years he has celebrated. A beautiful year is defined as a number consisting of only one digit repeated one or more times. However, due to a recent bug in the system, the input data might be corrupted. You need to handle the following errors: 1) Input value for n is not an integer. 2) Input value for n is out of the specified range (1 \u2264 n \u2264 10^9). 3) The number of test cases t is not an integer or is out of range (1 \u2264 t \u2264 10^4). Implement error handling to manage these scenarios and provide meaningful error messages.", "new_solution": "from typing import List\n\nclass InvalidInputError(Exception):\n    pass\n\nclass OutOfRangeError(Exception):\n    pass\n\ndef apps_run2(t: int, test_cases: List[int]) -> List[int]:\n    if not isinstance(t, int) or t < 1 or t > 10000:\n        raise InvalidInputError(\"The number of test cases must be an integer between 1 and 10,000.\")\n    \n    beautiful_numbers = []\n    for i in range(1, 10):\n        k = 0\n        for l in range(1, 10):\n            k *= 10\n            k += i\n            beautiful_numbers.append(k)\n    beautiful_numbers.sort()\n\n    results = []\n    for n in test_cases:\n        if not isinstance(n, int):\n            raise InvalidInputError(\"Each test case must be an integer.\")\n        if n < 1 or n > 1000000000:\n            raise OutOfRangeError(\"Each test case must be between 1 and 1,000,000,000.\")\n\n        l = 0\n        r = len(beautiful_numbers)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if beautiful_numbers[m] <= n:\n                l = m\n            else:\n                r = m\n        results.append(r)\n    return results", "input_format": "The function takes two parameters. The first parameter, t, is an integer that must be in the range of 1 \u2264 t \u2264 10^4. It represents the number of test cases. If the provided t is not an integer or is out of this range, the function will raise an InvalidInputError exception. The second parameter, test_cases, is a list of integers. Each integer n in the list represents a test case, and the value of n must be in the range of 1 \u2264 n \u2264 10^9. If an element in the list is not an integer, the function will raise an InvalidInputError exception. If an integer is out of the specified range, the function will raise an OutOfRangeError exception.", "output_format": "The function returns a list of integers. The length of the list is equal to the number of test cases t. Each integer in the list corresponds to a test case and represents the number of beautiful years between 1 and n (inclusive) for that test case.", "test_input": ["assert apps_run2(1, [18]) == [10]", "assert apps_run2(2, [1, 9]) == [1, 9]", "assert apps_run2(1, [100500]) == [45]", "assert apps_run2(1, [33]) == [12]", "assert apps_run2(1, [1000000000]) == [81]"], "requirement_type": "PROMPT_ERROR_HANDLING"}
{"task_id": "APPS/2011-1", "raw_problem": "Eighth-grader Vova is on duty today in the class. After classes, he went into the office to wash the board, and found on it the number n. He asked what is this number and the teacher of mathematics Inna Petrovna answered Vova that n is the answer to the arithmetic task for first-graders. In the textbook, a certain positive integer x was given. The task was to add x to the sum of the digits of the number x written in decimal numeral system.\n\nSince the number n on the board was small, Vova quickly guessed which x could be in the textbook. Now he wants to get a program which will search for arbitrary values of the number n for all suitable values of x or determine that such x does not exist. Write such a program for Vova.\n\n\n-----Input-----\n\nThe first line contains integer n (1 \u2264 n \u2264 10^9).\n\n\n-----Output-----\n\nIn the first line print one integer k\u00a0\u2014 number of different values of x satisfying the condition. \n\nIn next k lines print these values in ascending order.\n\n\n-----Examples-----\nInput\n21\n\nOutput\n1\n15\n\nInput\n20\n\nOutput\n0\n\n\n\n-----Note-----\n\nIn the first test case x = 15 there is only one variant: 15 + 1 + 5 = 21.\n\nIn the second test case there are no such x.", "raw_solution": "def apps_run1(n):\n    q=[]\n    for i in range(max(0,n-100),n+1):\n        j=i\n        res=i\n        while j:\n            res+=j%10\n            j//=10\n        if res==n:\n            q.append(i)\n    return len(q), q\n", "raw_test_input": ["assert apps_run1(21) == (1, [15])", "assert apps_run1(20) == (0, [])", "assert apps_run1(1) == (0, [])", "assert apps_run1(2) == (1, [1])", "assert apps_run1(3) == (0, [])", "assert apps_run1(100000001) == (2, [99999937, 100000000])", "assert apps_run1(1000000000) == (1, [999999932])", "assert apps_run1(999999979) == (2, [999999899, 999999908])", "assert apps_run1(9) == (0, [])", "assert apps_run1(10) == (1, [5])", "assert apps_run1(11) == (1, [10])", "assert apps_run1(39) == (1, [33])", "assert apps_run1(66) == (1, [60])", "assert apps_run1(75) == (0, [])", "assert apps_run1(100) == (1, [86])", "assert apps_run1(101) == (2, [91, 100])", "assert apps_run1(2014) == (2, [1988, 2006])", "assert apps_run1(999999994) == (0, [])"], "new_problem": "In a financial auditing system, a report contains multiple arithmetic tasks, each represented by a number n. Each task corresponds to a hidden integer x, which when added to the sum of its digits, results in n. The system needs to verify these tasks by finding all possible values of x for each n. Write a program that processes multiple tasks and outputs the possible values of x for each task.", "new_solution": "def find_possible_x(n):\n    q = []\n    for i in range(max(0, n - 100), n + 1):\n        j = i\n        res = i\n        while j:\n            res += j % 10\n            j //= 10\n        if res == n:\n            q.append(i)\n    return q\n\ndef apps_run2(m, tasks):\n    results = []\n    for n in tasks:\n        possible_x = find_possible_x(n)\n        results.append((len(possible_x), possible_x))\n    return results", "input_format": "The first line contains an integer m (1 \u2264 m \u2264 1000) representing the number of different arithmetic tasks. Each of the next m lines contains an integer n (1 \u2264 n \u2264 10^9) representing the result of an arithmetic task.", "output_format": "For each task, output the number of different values of x satisfying the condition, followed by these values in ascending order.", "test_input": ["assert apps_run2(2, [21, 20]) == [(1, [15]), (0, [])]", "assert apps_run2(1, [30]) == [(1, [24])]", "assert apps_run2(3, [100, 101, 102]) == [(1, [86]), (2, [91, 100]), (1, [87])]", "assert apps_run2(2, [1, 2]) == [(0, []), (1, [1])]", "assert apps_run2(1, [11]) == [(1, [10])]"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "APPS/2011-2", "raw_problem": "Eighth-grader Vova is on duty today in the class. After classes, he went into the office to wash the board, and found on it the number n. He asked what is this number and the teacher of mathematics Inna Petrovna answered Vova that n is the answer to the arithmetic task for first-graders. In the textbook, a certain positive integer x was given. The task was to add x to the sum of the digits of the number x written in decimal numeral system.\n\nSince the number n on the board was small, Vova quickly guessed which x could be in the textbook. Now he wants to get a program which will search for arbitrary values of the number n for all suitable values of x or determine that such x does not exist. Write such a program for Vova.\n\n\n-----Input-----\n\nThe first line contains integer n (1 \u2264 n \u2264 10^9).\n\n\n-----Output-----\n\nIn the first line print one integer k\u00a0\u2014 number of different values of x satisfying the condition. \n\nIn next k lines print these values in ascending order.\n\n\n-----Examples-----\nInput\n21\n\nOutput\n1\n15\n\nInput\n20\n\nOutput\n0\n\n\n\n-----Note-----\n\nIn the first test case x = 15 there is only one variant: 15 + 1 + 5 = 21.\n\nIn the second test case there are no such x.", "raw_solution": "def apps_run1(n):\n    q=[]\n    for i in range(max(0,n-100),n+1):\n        j=i\n        res=i\n        while j:\n            res+=j%10\n            j//=10\n        if res==n:\n            q.append(i)\n    return len(q), q\n", "raw_test_input": ["assert apps_run1(21) == (1, [15])", "assert apps_run1(20) == (0, [])", "assert apps_run1(1) == (0, [])", "assert apps_run1(2) == (1, [1])", "assert apps_run1(3) == (0, [])", "assert apps_run1(100000001) == (2, [99999937, 100000000])", "assert apps_run1(1000000000) == (1, [999999932])", "assert apps_run1(999999979) == (2, [999999899, 999999908])", "assert apps_run1(9) == (0, [])", "assert apps_run1(10) == (1, [5])", "assert apps_run1(11) == (1, [10])", "assert apps_run1(39) == (1, [33])", "assert apps_run1(66) == (1, [60])", "assert apps_run1(75) == (0, [])", "assert apps_run1(100) == (1, [86])", "assert apps_run1(101) == (2, [91, 100])", "assert apps_run1(2014) == (2, [1988, 2006])", "assert apps_run1(999999994) == (0, [])"], "new_problem": "Eighth-grader Vova is on duty today in the class. After classes, he went into the office to wash the board, and found on it the number n. He asked what is this number and the teacher of mathematics Inna Petrovna answered Vova that n is the answer to the arithmetic task for first-graders. In the textbook, a certain positive integer x was given. The task was to add x to the sum of the digits of the number x written in decimal numeral system. Since the number n on the board was small, Vova quickly guessed which x could be in the textbook. Now he wants to get a program which will search for arbitrary values of the number n for all suitable values of x or determine that such x does not exist. Write such a program for Vova. Additionally, the program should allow for an optional parameter m, which limits the number of digits to consider in the sum of digits. If m is not provided, the program should consider all digits.", "new_solution": "def apps_run2(n: int, m: int = None) -> list[int]:\n    q = []\n    for i in range(max(0, n - 100), n + 1):\n        j = i\n        res = i\n        digit_count = 0\n        while j:\n            if m is not None and digit_count >= m:\n                break\n            res += j % 10\n            j //= 10\n            digit_count += 1\n        if res == n:\n            q.append(i)\n    return q\n\ndef main(n: int, m: int = None) -> None:\n    q = apps_run2(n, m)\n    print(len(q))\n    for i in q:\n        print(i)", "input_format": "The first line contains integer n (1 \u2264 n \u2264 10^9). Optionally, a second line may contain an integer m (1 \u2264 m \u2264 100) representing the maximum number of digits to consider in the sum of digits.", "output_format": "In the first line print one integer k \u2014 number of different values of x satisfying the condition. In the next k lines print these values in ascending order.", "test_input": ["assert apps_run2(21) == [15]", "assert apps_run2(20) == []", "assert apps_run2(21, 1) == []", "assert apps_run2(21, 2) == [15]", "assert apps_run2(100) == [86]"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "APPS/2011-3", "raw_problem": "Eighth-grader Vova is on duty today in the class. After classes, he went into the office to wash the board, and found on it the number n. He asked what is this number and the teacher of mathematics Inna Petrovna answered Vova that n is the answer to the arithmetic task for first-graders. In the textbook, a certain positive integer x was given. The task was to add x to the sum of the digits of the number x written in decimal numeral system.\n\nSince the number n on the board was small, Vova quickly guessed which x could be in the textbook. Now he wants to get a program which will search for arbitrary values of the number n for all suitable values of x or determine that such x does not exist. Write such a program for Vova.\n\n\n-----Input-----\n\nThe first line contains integer n (1 \u2264 n \u2264 10^9).\n\n\n-----Output-----\n\nIn the first line print one integer k\u00a0\u2014 number of different values of x satisfying the condition. \n\nIn next k lines print these values in ascending order.\n\n\n-----Examples-----\nInput\n21\n\nOutput\n1\n15\n\nInput\n20\n\nOutput\n0\n\n\n\n-----Note-----\n\nIn the first test case x = 15 there is only one variant: 15 + 1 + 5 = 21.\n\nIn the second test case there are no such x.", "raw_solution": "def apps_run1(n):\n    q=[]\n    for i in range(max(0,n-100),n+1):\n        j=i\n        res=i\n        while j:\n            res+=j%10\n            j//=10\n        if res==n:\n            q.append(i)\n    return len(q), q\n", "raw_test_input": ["assert apps_run1(21) == (1, [15])", "assert apps_run1(20) == (0, [])", "assert apps_run1(1) == (0, [])", "assert apps_run1(2) == (1, [1])", "assert apps_run1(3) == (0, [])", "assert apps_run1(100000001) == (2, [99999937, 100000000])", "assert apps_run1(1000000000) == (1, [999999932])", "assert apps_run1(999999979) == (2, [999999899, 999999908])", "assert apps_run1(9) == (0, [])", "assert apps_run1(10) == (1, [5])", "assert apps_run1(11) == (1, [10])", "assert apps_run1(39) == (1, [33])", "assert apps_run1(66) == (1, [60])", "assert apps_run1(75) == (0, [])", "assert apps_run1(100) == (1, [86])", "assert apps_run1(101) == (2, [91, 100])", "assert apps_run1(2014) == (2, [1988, 2006])", "assert apps_run1(999999994) == (0, [])"], "new_problem": "Vova is now tasked with a more complex problem. He is given a number n and a sequence of numbers. For each number x in the sequence, he needs to determine if adding x to the sum of its digits equals n. However, the sequence of numbers is stored in a dictionary where the keys are indices and the values are the numbers. Write a program that finds all such x values from the dictionary that satisfy the condition or determine that no such x exists.", "new_solution": "from typing import Dict, List\n\ndef apps_run2(n: int, numbers: Dict[int, int]) -> List[int]:\n    q = []\n    for key, i in numbers.items():\n        j = i\n        res = i\n        while j:\n            res += j % 10\n            j //= 10\n        if res == n:\n            q.append(i)\n    q.sort()\n    return q\n", "input_format": "The first line contains an integer n (1 \u2264 n \u2264 10^9) and the second line contains a list of integers representing a sequence of numbers.", "output_format": "In the first line, print one integer k \u2014 the number of different values of x satisfying the condition. In the next k lines, print these values in ascending order.", "test_input": ["assert apps_run2(21, {0: 15, 1: 10, 2: 5}) == [15]", "assert apps_run2(20, {0: 10, 1: 5, 2: 3}) == []", "assert apps_run2(30, {0: 25, 1: 20, 2: 15}) == []", "assert apps_run2(18, {0: 9, 1: 8, 2: 7}) == [9]", "assert apps_run2(100, {0: 91, 1: 89, 2: 99}) == []"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "APPS/2011-4", "raw_problem": "Eighth-grader Vova is on duty today in the class. After classes, he went into the office to wash the board, and found on it the number n. He asked what is this number and the teacher of mathematics Inna Petrovna answered Vova that n is the answer to the arithmetic task for first-graders. In the textbook, a certain positive integer x was given. The task was to add x to the sum of the digits of the number x written in decimal numeral system.\n\nSince the number n on the board was small, Vova quickly guessed which x could be in the textbook. Now he wants to get a program which will search for arbitrary values of the number n for all suitable values of x or determine that such x does not exist. Write such a program for Vova.\n\n\n-----Input-----\n\nThe first line contains integer n (1 \u2264 n \u2264 10^9).\n\n\n-----Output-----\n\nIn the first line print one integer k\u00a0\u2014 number of different values of x satisfying the condition. \n\nIn next k lines print these values in ascending order.\n\n\n-----Examples-----\nInput\n21\n\nOutput\n1\n15\n\nInput\n20\n\nOutput\n0\n\n\n\n-----Note-----\n\nIn the first test case x = 15 there is only one variant: 15 + 1 + 5 = 21.\n\nIn the second test case there are no such x.", "raw_solution": "def apps_run1(n):\n    q=[]\n    for i in range(max(0,n-100),n+1):\n        j=i\n        res=i\n        while j:\n            res+=j%10\n            j//=10\n        if res==n:\n            q.append(i)\n    return len(q), q\n", "raw_test_input": ["assert apps_run1(21) == (1, [15])", "assert apps_run1(20) == (0, [])", "assert apps_run1(1) == (0, [])", "assert apps_run1(2) == (1, [1])", "assert apps_run1(3) == (0, [])", "assert apps_run1(100000001) == (2, [99999937, 100000000])", "assert apps_run1(1000000000) == (1, [999999932])", "assert apps_run1(999999979) == (2, [999999899, 999999908])", "assert apps_run1(9) == (0, [])", "assert apps_run1(10) == (1, [5])", "assert apps_run1(11) == (1, [10])", "assert apps_run1(39) == (1, [33])", "assert apps_run1(66) == (1, [60])", "assert apps_run1(75) == (0, [])", "assert apps_run1(100) == (1, [86])", "assert apps_run1(101) == (2, [91, 100])", "assert apps_run1(2014) == (2, [1988, 2006])", "assert apps_run1(999999994) == (0, [])"], "new_problem": "Vova is now tasked with a more complex problem. He needs to find the number x such that when added to the sum of its digits, it equals a given number n. However, this time, the input might be erroneous due to various reasons such as non-integer input, negative numbers, or numbers exceeding the allowed range. Vova needs a program that not only finds the correct x but also handles these errors gracefully. The program should raise specific exceptions for each type of error and provide meaningful error messages. The errors to handle include: 1. Non-integer input (ValueError) 2. Negative numbers (ValueError) 3. Numbers exceeding the range (ValueError) 4. General input/output errors (IOError).", "new_solution": "def apps_run2(n: int) -> list[int]:\n    if not isinstance(n, int):\n        raise ValueError(\"Input must be an integer.\")\n    if n < 1 or n > 10**9:\n        raise ValueError(\"Input must be within the range 1 to 10^9.\")\n    q = []\n    for i in range(max(0, n - 100), n + 1):\n        j = i\n        res = i\n        while j:\n            res += j % 10\n            j //= 10\n        if res == n:\n            q.append(i)\n    return q\n\n", "input_format": "The first line contains integer n (1 \u2264 n \u2264 10^9).", "output_format": "In the first line print one integer k \u2014 number of different values of x satisfying the condition. In next k lines print these values in ascending order.", "test_input": ["assert apps_run2(21) == [15]", "assert apps_run2(20) == []", "try:\n    apps_run2(-5)\nexcept ValueError as e:\n    assert str(e) == \"Input must be within the range 1 to 10^9.\"", "try:\n    apps_run2(10**10)\nexcept ValueError as e:\n    assert str(e) == \"Input must be within the range 1 to 10^9.\"", "try:\n    apps_run2(\"twenty\")\nexcept ValueError as e:\n    assert str(e) == \"Input must be an integer.\""], "requirement_type": "PROMPT_ERROR_HANDLING"}
{"task_id": "APPS/2012-1", "raw_problem": "A permutation p of size n is the sequence p_1, p_2, ..., p_{n}, consisting of n distinct integers, each of them is from 1 to n (1 \u2264 p_{i} \u2264 n).\n\nA lucky permutation is such permutation p, that any integer i (1 \u2264 i \u2264 n) meets this condition p_{p}_{i} = n - i + 1.\n\nYou have integer n. Find some lucky permutation p of size n.\n\n\n-----Input-----\n\nThe first line contains integer n (1 \u2264 n \u2264 10^5) \u2014 the required permutation size.\n\n\n-----Output-----\n\nPrint \"-1\" (without the quotes) if the lucky permutation p of size n doesn't exist.\n\nOtherwise, print n distinct integers p_1, p_2, ..., p_{n} (1 \u2264 p_{i} \u2264 n) after a space \u2014 the required permutation.\n\nIf there are multiple answers, you can print any of them.\n\n\n-----Examples-----\nInput\n1\n\nOutput\n1 \n\nInput\n2\n\nOutput\n-1\n\nInput\n4\n\nOutput\n2 4 1 3 \n\nInput\n5\n\nOutput\n2 5 3 1 4.", "raw_solution": "def apps_run1(n):\n    if n % 4 > 1:\n        return '-1'\n    else:\n        a = [n + 1 >> 1] * n\n        for i in range(n // 4):\n            j = i * 2\n            a[j], a[j + 1], a[-2 - j], a[-1 - j] = j + 2, n - j, j + 1, n - 1 - j\n        return ' '.join(map(str, a)) + ' '\n", "raw_test_input": ["assert apps_run1(1) == '1 '", "assert apps_run1(2) == '-1'", "assert apps_run1(4) == '2 4 1 3 '", "assert apps_run1(5) == '2 5 3 1 4 '", "assert apps_run1(3) == '-1'", "assert apps_run1(6) == '-1'", "assert apps_run1(7) == '-1'", "assert apps_run1(8) == '2 8 4 6 3 5 1 7 '", "assert apps_run1(9) == '2 9 4 7 5 3 6 1 8 '", "assert apps_run1(10002) == '-1'", "assert apps_run1(10003) == '-1'", "assert apps_run1(25) == '2 25 4 23 6 21 8 19 10 17 12 15 13 11 14 9 16 7 18 5 20 3 22 1 24 '", "assert apps_run1(29) == '2 29 4 27 6 25 8 23 10 21 12 19 14 17 15 13 16 11 18 9 20 7 22 5 24 3 26 1 28 '", "assert apps_run1(33) == '2 33 4 31 6 29 8 27 10 25 12 23 14 21 16 19 17 15 18 13 20 11 22 9 24 7 26 5 28 3 30 1 32 '", "assert apps_run1(9) == '2 9 4 7 5 3 6 1 8 '", "assert apps_run1(13) == '2 13 4 11 6 9 7 5 8 3 10 1 12 '", "assert apps_run1(17) == '2 17 4 15 6 13 8 11 9 7 10 5 12 3 14 1 16 '", "assert apps_run1(99999) == '-1'"], "new_problem": "In a logistics company, you are tasked with optimizing the loading sequence of containers onto ships. Each container has a unique ID from 1 to n, and the loading sequence must be a 'lucky permutation' to ensure balance and stability during transport. Given multiple test cases, determine the lucky permutation for each container set size n, or determine if such a permutation is not possible.", "new_solution": "def find_lucky_permutation(n):\n    if n % 4 > 1:\n        return -1\n    else:\n        a = [n + 1 >> 1] * n\n        for i in range(n // 4):\n            j = i * 2\n            a[j], a[j + 1], a[-2 - j], a[-1 - j] = j + 2, n - j, j + 1, n - 1 - j\n        return a\n\ndef apps_run2(test_cases):\n    results = []\n    for n in test_cases:\n        result = find_lucky_permutation(n)\n        if result == -1:\n            results.append('-1')\n        else:\n            results.append(' '.join(map(str, result)))\n    return results", "input_format": "The first line contains an integer t (1 \u2264 t \u2264 100), the number of test cases. Each of the next t lines contains an integer n (1 \u2264 n \u2264 10^5), representing the required permutation size for each test case.", "output_format": "For each test case, print '-1' if the lucky permutation p of size n doesn't exist. Otherwise, print n distinct integers p_1, p_2, ..., p_{n} (1 \u2264 p_{i} \u2264 n) after a space \u2014 the required permutation. If there are multiple answers, you can print any of them.", "test_input": ["assert apps_run2([1]) == ['1']", "assert apps_run2([2]) == ['-1']", "assert apps_run2([4]) == ['2 4 1 3']", "assert apps_run2([5]) == ['2 5 3 1 4']", "assert apps_run2([6, 8]) == ['-1', '2 8 4 6 3 5 1 7']"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "APPS/2012-2", "raw_problem": "A permutation p of size n is the sequence p_1, p_2, ..., p_{n}, consisting of n distinct integers, each of them is from 1 to n (1 \u2264 p_{i} \u2264 n).\n\nA lucky permutation is such permutation p, that any integer i (1 \u2264 i \u2264 n) meets this condition p_{p}_{i} = n - i + 1.\n\nYou have integer n. Find some lucky permutation p of size n.\n\n\n-----Input-----\n\nThe first line contains integer n (1 \u2264 n \u2264 10^5) \u2014 the required permutation size.\n\n\n-----Output-----\n\nPrint \"-1\" (without the quotes) if the lucky permutation p of size n doesn't exist.\n\nOtherwise, print n distinct integers p_1, p_2, ..., p_{n} (1 \u2264 p_{i} \u2264 n) after a space \u2014 the required permutation.\n\nIf there are multiple answers, you can print any of them.\n\n\n-----Examples-----\nInput\n1\n\nOutput\n1 \n\nInput\n2\n\nOutput\n-1\n\nInput\n4\n\nOutput\n2 4 1 3 \n\nInput\n5\n\nOutput\n2 5 3 1 4.", "raw_solution": "def apps_run1(n):\n    if n % 4 > 1:\n        return '-1'\n    else:\n        a = [n + 1 >> 1] * n\n        for i in range(n // 4):\n            j = i * 2\n            a[j], a[j + 1], a[-2 - j], a[-1 - j] = j + 2, n - j, j + 1, n - 1 - j\n        return ' '.join(map(str, a)) + ' '\n", "raw_test_input": ["assert apps_run1(1) == '1 '", "assert apps_run1(2) == '-1'", "assert apps_run1(4) == '2 4 1 3 '", "assert apps_run1(5) == '2 5 3 1 4 '", "assert apps_run1(3) == '-1'", "assert apps_run1(6) == '-1'", "assert apps_run1(7) == '-1'", "assert apps_run1(8) == '2 8 4 6 3 5 1 7 '", "assert apps_run1(9) == '2 9 4 7 5 3 6 1 8 '", "assert apps_run1(10002) == '-1'", "assert apps_run1(10003) == '-1'", "assert apps_run1(25) == '2 25 4 23 6 21 8 19 10 17 12 15 13 11 14 9 16 7 18 5 20 3 22 1 24 '", "assert apps_run1(29) == '2 29 4 27 6 25 8 23 10 21 12 19 14 17 15 13 16 11 18 9 20 7 22 5 24 3 26 1 28 '", "assert apps_run1(33) == '2 33 4 31 6 29 8 27 10 25 12 23 14 21 16 19 17 15 18 13 20 11 22 9 24 7 26 5 28 3 30 1 32 '", "assert apps_run1(9) == '2 9 4 7 5 3 6 1 8 '", "assert apps_run1(13) == '2 13 4 11 6 9 7 5 8 3 10 1 12 '", "assert apps_run1(17) == '2 17 4 15 6 13 8 11 9 7 10 5 12 3 14 1 16 '", "assert apps_run1(99999) == '-1'"], "new_problem": "A permutation p of size n is the sequence p_1, p_2, ..., p_{n}, consisting of n distinct integers, each of them is from 1 to n (1 \u2264 p_{i} \u2264 n). A lucky permutation is such permutation p, that any integer i (1 \u2264 i \u2264 n) meets this condition p_{p}_{i} = n - i + 1. You have integer n and an optional parameter 'reverse'. Find some lucky permutation p of size n. If 'reverse' is provided, return the permutation in reverse order. The solution must maintain backward compatibility with existing implementations.", "new_solution": "def apps_run2(n: int, reverse: bool = False) -> str:\n    if n % 4 > 1:\n        return '-1'\n    else:\n        a = [n + 1 >> 1] * n\n        for i in range(n // 4):\n            j = i * 2\n            a[j], a[j + 1], a[-2 - j], a[-1 - j] = j + 2, n - j, j + 1, n - 1 - j\n        if reverse:\n            a.reverse()\n        return ' '.join(map(str, a))", "input_format": "The first line contains integer n (1 \u2264 n \u2264 10^5) \u2014 the required permutation size. Optionally, a second line may contain a string 'reverse' to indicate the permutation should be reversed.", "output_format": "Print '-1' (without the quotes) if the lucky permutation p of size n doesn't exist. Otherwise, print n distinct integers p_1, p_2, ..., p_{n} (1 \u2264 p_{i} \u2264 n) after a space \u2014 the required permutation. If the 'reverse' option is provided, print the permutation in reverse order.", "test_input": ["assert apps_run2(1) == '1'", "assert apps_run2(2) == '-1'", "assert apps_run2(4) == '2 4 1 3'", "assert apps_run2(4, reverse=True) == '3 1 4 2'", "assert apps_run2(5) == '2 5 3 1 4'", "assert apps_run2(8) == '2 8 4 6 3 5 1 7'", "assert apps_run2(8, reverse=True) == '7 1 5 3 6 4 8 2'"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "APPS/2012-3", "raw_problem": "A permutation p of size n is the sequence p_1, p_2, ..., p_{n}, consisting of n distinct integers, each of them is from 1 to n (1 \u2264 p_{i} \u2264 n).\n\nA lucky permutation is such permutation p, that any integer i (1 \u2264 i \u2264 n) meets this condition p_{p}_{i} = n - i + 1.\n\nYou have integer n. Find some lucky permutation p of size n.\n\n\n-----Input-----\n\nThe first line contains integer n (1 \u2264 n \u2264 10^5) \u2014 the required permutation size.\n\n\n-----Output-----\n\nPrint \"-1\" (without the quotes) if the lucky permutation p of size n doesn't exist.\n\nOtherwise, print n distinct integers p_1, p_2, ..., p_{n} (1 \u2264 p_{i} \u2264 n) after a space \u2014 the required permutation.\n\nIf there are multiple answers, you can print any of them.\n\n\n-----Examples-----\nInput\n1\n\nOutput\n1 \n\nInput\n2\n\nOutput\n-1\n\nInput\n4\n\nOutput\n2 4 1 3 \n\nInput\n5\n\nOutput\n2 5 3 1 4.", "raw_solution": "def apps_run1(n):\n    if n % 4 > 1:\n        return '-1'\n    else:\n        a = [n + 1 >> 1] * n\n        for i in range(n // 4):\n            j = i * 2\n            a[j], a[j + 1], a[-2 - j], a[-1 - j] = j + 2, n - j, j + 1, n - 1 - j\n        return ' '.join(map(str, a)) + ' '\n", "raw_test_input": ["assert apps_run1(1) == '1 '", "assert apps_run1(2) == '-1'", "assert apps_run1(4) == '2 4 1 3 '", "assert apps_run1(5) == '2 5 3 1 4 '", "assert apps_run1(3) == '-1'", "assert apps_run1(6) == '-1'", "assert apps_run1(7) == '-1'", "assert apps_run1(8) == '2 8 4 6 3 5 1 7 '", "assert apps_run1(9) == '2 9 4 7 5 3 6 1 8 '", "assert apps_run1(10002) == '-1'", "assert apps_run1(10003) == '-1'", "assert apps_run1(25) == '2 25 4 23 6 21 8 19 10 17 12 15 13 11 14 9 16 7 18 5 20 3 22 1 24 '", "assert apps_run1(29) == '2 29 4 27 6 25 8 23 10 21 12 19 14 17 15 13 16 11 18 9 20 7 22 5 24 3 26 1 28 '", "assert apps_run1(33) == '2 33 4 31 6 29 8 27 10 25 12 23 14 21 16 19 17 15 18 13 20 11 22 9 24 7 26 5 28 3 30 1 32 '", "assert apps_run1(9) == '2 9 4 7 5 3 6 1 8 '", "assert apps_run1(13) == '2 13 4 11 6 9 7 5 8 3 10 1 12 '", "assert apps_run1(17) == '2 17 4 15 6 13 8 11 9 7 10 5 12 3 14 1 16 '", "assert apps_run1(99999) == '-1'"], "new_problem": "In a city, there are n intersections, each labeled from 1 to n. A lucky route is a sequence of intersections such that for any intersection i (1 \u2264 i \u2264 n), the intersection at position i in the route is connected to the intersection at position n-i+1. You are given an integer n, representing the number of intersections. Find a lucky route of size n using a dictionary to represent the connections between intersections. If no such route exists, return \"-1\".", "new_solution": "from typing import Dict, List\n\ndef apps_run2(n: int) -> List[int]:\n    if n % 4 > 1:\n        return [-1]\n    else:\n        connections: Dict[int, int] = {}\n        route: List[int] = [0] * n\n        for i in range(n // 4):\n            j = i * 2\n            connections[j + 1] = j + 2\n            connections[j + 2] = n - j\n            connections[n - j] = j + 1\n            connections[n - 1 - j] = n - j\n        for i in range(n):\n            route[i] = connections.get(i + 1, i + 1)\n        return route\n", "input_format": "The first line contains integer n (1 \u2264 n \u2264 10^5) \u2014 the required permutation size.", "output_format": "Print \"-1\" (without the quotes) if the lucky permutation p of size n doesn't exist. Otherwise, print n distinct integers p_1, p_2, ..., p_{n} (1 \u2264 p_{i} \u2264 n) after a space \u2014 the required permutation. If there are multiple answers, you can print any of them.", "test_input": ["assert apps_run2(1) == [1]", "assert apps_run2(2) == [-1]", "assert apps_run2(4) == [2, 4, 4, 1]", "assert apps_run2(5) == [2, 5, 3, 5, 1]", "assert apps_run2(8) == [2, 8, 4, 6, 6, 3, 8, 1]"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "APPS/2012-4", "raw_problem": "A permutation p of size n is the sequence p_1, p_2, ..., p_{n}, consisting of n distinct integers, each of them is from 1 to n (1 \u2264 p_{i} \u2264 n).\n\nA lucky permutation is such permutation p, that any integer i (1 \u2264 i \u2264 n) meets this condition p_{p}_{i} = n - i + 1.\n\nYou have integer n. Find some lucky permutation p of size n.\n\n\n-----Input-----\n\nThe first line contains integer n (1 \u2264 n \u2264 10^5) \u2014 the required permutation size.\n\n\n-----Output-----\n\nPrint \"-1\" (without the quotes) if the lucky permutation p of size n doesn't exist.\n\nOtherwise, print n distinct integers p_1, p_2, ..., p_{n} (1 \u2264 p_{i} \u2264 n) after a space \u2014 the required permutation.\n\nIf there are multiple answers, you can print any of them.\n\n\n-----Examples-----\nInput\n1\n\nOutput\n1 \n\nInput\n2\n\nOutput\n-1\n\nInput\n4\n\nOutput\n2 4 1 3 \n\nInput\n5\n\nOutput\n2 5 3 1 4.", "raw_solution": "def apps_run1(n):\n    if n % 4 > 1:\n        return '-1'\n    else:\n        a = [n + 1 >> 1] * n\n        for i in range(n // 4):\n            j = i * 2\n            a[j], a[j + 1], a[-2 - j], a[-1 - j] = j + 2, n - j, j + 1, n - 1 - j\n        return ' '.join(map(str, a)) + ' '\n", "raw_test_input": ["assert apps_run1(1) == '1 '", "assert apps_run1(2) == '-1'", "assert apps_run1(4) == '2 4 1 3 '", "assert apps_run1(5) == '2 5 3 1 4 '", "assert apps_run1(3) == '-1'", "assert apps_run1(6) == '-1'", "assert apps_run1(7) == '-1'", "assert apps_run1(8) == '2 8 4 6 3 5 1 7 '", "assert apps_run1(9) == '2 9 4 7 5 3 6 1 8 '", "assert apps_run1(10002) == '-1'", "assert apps_run1(10003) == '-1'", "assert apps_run1(25) == '2 25 4 23 6 21 8 19 10 17 12 15 13 11 14 9 16 7 18 5 20 3 22 1 24 '", "assert apps_run1(29) == '2 29 4 27 6 25 8 23 10 21 12 19 14 17 15 13 16 11 18 9 20 7 22 5 24 3 26 1 28 '", "assert apps_run1(33) == '2 33 4 31 6 29 8 27 10 25 12 23 14 21 16 19 17 15 18 13 20 11 22 9 24 7 26 5 28 3 30 1 32 '", "assert apps_run1(9) == '2 9 4 7 5 3 6 1 8 '", "assert apps_run1(13) == '2 13 4 11 6 9 7 5 8 3 10 1 12 '", "assert apps_run1(17) == '2 17 4 15 6 13 8 11 9 7 10 5 12 3 14 1 16 '", "assert apps_run1(99999) == '-1'"], "new_problem": "You are tasked with generating a lucky permutation of size n. However, in a real-world scenario, the input might not always be valid. You need to handle the following errors: \n1. Input is not an integer. \n2. Input is out of the specified range (1 \u2264 n \u2264 10^5). \n3. Input is missing or None. \n\nImplement error handling to manage these scenarios and propagate meaningful error messages. Define custom exceptions for invalid input and out-of-range errors. Ensure that the function returns a string with the error message if an error occurs.", "new_solution": "class InvalidInputError(Exception):\n    pass\n\nclass OutOfRangeError(Exception):\n    pass\n\ndef apps_run2(n: int) -> str:\n    if n is None:\n        raise InvalidInputError(\"Input cannot be None.\")\n    if not isinstance(n, int):\n        raise InvalidInputError(\"Input must be an integer.\")\n    if n < 1 or n > 100000:\n        raise OutOfRangeError(\"Input must be in the range 1 to 100000.\")\n\n    if n % 4 > 1:\n        return \"-1\"\n    else:\n        a = [n + 1 >> 1] * n\n        for i in range(n // 4):\n            j = i * 2\n            a[j], a[j + 1], a[-2 - j], a[-1 - j] = j + 2, n - j, j + 1, n - 1 - j\n        return ' '.join(map(str, a))", "input_format": "The first line contains an integer n (1 \u2264 n \u2264 10^5) \u2014 the required permutation size.", "output_format": "Print \"-1\" (without the quotes) if the lucky permutation p of size n doesn't exist. Otherwise, print n distinct integers p_1, p_2, ..., p_{n} (1 \u2264 p_{i} \u2264 n) after a space \u2014 the required permutation.", "test_input": ["try:\n    apps_run2(1) == '1'\nexcept Exception as e:\n    print(e)", "try:\n    apps_run2(2) == '-1'\nexcept Exception as e:\n    print(e)", "try:\n    apps_run2(4) == '2 4 1 3'\nexcept Exception as e:\n    print(e)", "try:\n    apps_run2(5) == '-1'\nexcept Exception as e:\n    print(e)", "try:\n    apps_run2(None) == 'Input cannot be None.'\nexcept InvalidInputError as e:\n    print(e)", "try:\n    apps_run2('a') == 'Input must be an integer.'\nexcept InvalidInputError as e:\n    print(e)", "try:\n    apps_run2(100001) == 'Input must be in the range 1 to 100000.'\nexcept OutOfRangeError as e:\n    print(e)"], "requirement_type": "PROMPT_ERROR_HANDLING"}
{"task_id": "APPS/2013-1", "raw_problem": "You are given a non-empty string s consisting of lowercase English letters. You have to pick exactly one non-empty substring of s and shift all its letters 'z' $\\rightarrow$ 'y' $\\rightarrow$ 'x' $\\rightarrow \\ldots \\rightarrow$ 'b' $\\rightarrow$ 'a' $\\rightarrow$ 'z'. In other words, each character is replaced with the previous character of English alphabet and 'a' is replaced with 'z'.\n\nWhat is the lexicographically minimum string that can be obtained from s by performing this shift exactly once?\n\n\n-----Input-----\n\nThe only line of the input contains the string s (1 \u2264 |s| \u2264 100 000) consisting of lowercase English letters.\n\n\n-----Output-----\n\nPrint the lexicographically minimum string that can be obtained from s by shifting letters of exactly one non-empty substring.\n\n\n-----Examples-----\nInput\ncodeforces\n\nOutput\nbncdenqbdr\n\nInput\nabacaba\n\nOutput\naaacaba\n\n\n\n-----Note-----\n\nString s is lexicographically smaller than some other string t of the same length if there exists some 1 \u2264 i \u2264 |s|, such that s_1 = t_1, s_2 = t_2, ..., s_{i} - 1 = t_{i} - 1, and s_{i} < t_{i}.", "raw_solution": "def apps_run1(s):\n    import re\n    m = re.search(r\"[^a]\", s)\n    if m is None:\n        return s[:-1] + \"z\"\n    else:\n        j = s.find('a', m.end())\n        if j == -1:\n            j = len(s)\n        result = s[:m.start()]\n        for i in range(m.start(), j):\n            result += chr((ord(s[i]) - 98) % 26 + 97)\n        result += s[j:]\n        return result", "raw_test_input": ["assert apps_run1('codeforces\\n') == 'bncdenqbdrq'", "assert apps_run1('abacaba\\n') == 'aaacaba\\n'", "assert apps_run1('babbbabaababbaa\\n') == 'aabbbabaababbaa\\n'", "assert apps_run1('bcbacaabcababaccccaaaabacbbcbbaa\\n') == 'abaacaabcababaccccaaaabacbbcbbaa\\n'", "assert apps_run1('cabaccaacccabaacdbdcbcdbccbccbabbdadbdcdcdbdbcdcdbdadcbcda\\n') == 'babaccaacccabaacdbdcbcdbccbccbabbdadbdcdcdbdbcdcdbdadcbcda\\n'", "assert apps_run1('a\\n') == 'aq'", "assert apps_run1('eeeedddccbceaabdaecaebaeaecccbdeeeaadcecdbeacecdcdcceabaadbcbbadcdaeddbcccaaeebccecaeeeaebcaaccbdaccbdcadadaaeacbbdcbaeeaecedeeeedadec\\n') == 'ddddcccbbabdaabdaecaebaeaecccbdeeeaadcecdbeacecdcdcceabaadbcbbadcdaeddbcccaaeebccecaeeeaebcaaccbdaccbdcadadaaeacbbdcbaeeaecedeeeedadec\\n'", "assert apps_run1('fddfbabadaadaddfbfecadfaefaefefabcccdbbeeabcbbddefbafdcafdfcbdffeeaffcaebbbedabddeaecdddffcbeaafffcddccccfffdbcddcfccefafdbeaacbdeeebdeaaacdfdecadfeafaeaefbfdfffeeaefebdceebcebbfeaccfafdccdcecedeedadcadbfefccfdedfaaefabbaeebdebeecaadbebcfeafbfeeefcfaecadfe\\n') == 'ecceaabadaadaddfbfecadfaefaefefabcccdbbeeabcbbddefbafdcafdfcbdffeeaffcaebbbedabddeaecdddffcbeaafffcddccccfffdbcddcfccefafdbeaacbdeeebdeaaacdfdecadfeafaeaefbfdfffeeaefebdceebcebbfeaccfafdccdcecedeedadcadbfefccfdedfaaefabbaeebdebeecaadbebcfeafbfeeefcfaecadfe\\n'", "assert apps_run1('aaaaaaaaaa\\n') == 'aaaaaaaaaaq'", "assert apps_run1('abbabaaaaa\\n') == 'aaaabaaaaa\\n'", "assert apps_run1('bbbbbbbbbbbb\\n') == 'aaaaaaaaaaaaq'", "assert apps_run1('aabaaaaaaaaaaaa\\n') == 'aaaaaaaaaaaaaaa\\n'", "assert apps_run1('aaaaaaaaaaaaaaaaaaaa\\n') == 'aaaaaaaaaaaaaaaaaaaaq'", "assert apps_run1('abaabaaaaaabbaaaaaaabaaaaaaaaabaaaabaaaaaaabaaaaaaaaaabaaaaaaaaaaaaaaabaaaabbaaaaabaaaaaaaabaaaaaaaa\\n') == 'aaaabaaaaaabbaaaaaaabaaaaaaaaabaaaabaaaaaaabaaaaaaaaaabaaaaaaaaaaaaaaabaaaabbaaaaabaaaaaaaabaaaaaaaa\\n'", "assert apps_run1('abbbbbbbabbbbbbbbbbbbbbbbbbbbbbbabbabbbbbabbbbbbbbbbbabbbbbbbbabbabbbbbbbbbbbbbbabbabbbaababbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbabbabbbbbbbbbbbbbbbbabbbbabbbbbbbbbbbbbbbabbbbbbbbbaababbbbbbbbabbbbbbbbbbbbbbbbbbbbbbbbbbbbabbbbbbbbbbbbbbbbbbbbabbabbbbbbbbbbbbbbbbabbbabbbbbaabbabbbbbbbbbbbbbbbbbbbbbbbbbbbbbabbbbbbbbbbbbbbbbaabbbbbbbbbbbbababbabbbbbbbbbbbbbbbbbbbbbbbbabbbbbbbbbbbbbbbabbbbbbbbbbbabbbbbbbbbbbbbbbbbbbbbbabbbbbbbabbbbbbb\\n') == 'aaaaaaaaabbbbbbbbbbbbbbbbbbbbbbbabbabbbbbabbbbbbbbbbbabbbbbbbbabbabbbbbbbbbbbbbbabbabbbaababbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbabbabbbbbbbbbbbbbbbbabbbbabbbbbbbbbbbbbbbabbbbbbbbbaababbbbbbbbabbbbbbbbbbbbbbbbbbbbbbbbbbbbabbbbbbbbbbbbbbbbbbbbabbabbbbbbbbbbbbbbbbabbbabbbbbaabbabbbbbbbbbbbbbbbbbbbbbbbbbbbbbabbbbbbbbbbbbbbbbaabbbbbbbbbbbbababbabbbbbbbbbbbbbbbbbbbbbbbbabbbbbbbbbbbbbbbabbbbbbbbbbbabbbbbbbbbbbbbbbbbbbbbbabbbbbbbabbbbbbb\\n'", "assert apps_run1('aaaaa\\n') == 'aaaaaq'", "assert apps_run1('aaa\\n') == 'aaaq'", "assert apps_run1('aa\\n') == 'aaq'"], "new_problem": "In a text processing system, you are tasked with optimizing a list of strings by making them lexicographically minimal. You have a function that can shift the letters of a substring of a string to the previous letter in the alphabet, with 'a' wrapping around to 'z'. Given a list of strings, apply this function to each string to obtain the lexicographically smallest version of each string. This is useful in scenarios such as data compression or text normalization where minimizing the lexicographical order can lead to more efficient storage or processing.", "new_solution": "def lexicographically_minimal_string(s):\n    import re\n    m = re.search(r\"[^a]\", s)\n    if m is None:\n        return s[:-1] + \"z\"\n    else:\n        j = s.find('a', m.end())\n        if j == -1:\n            j = len(s)\n        result = s[:m.start()]\n        for i in range(m.start(), j):\n            result += chr((ord(s[i]) - 98) % 26 + 97)\n        result += s[j:]\n        return result\n\ndef apps_run2(n, strings):\n    results = []\n    for s in strings:\n        results.append(lexicographically_minimal_string(s))\n    return results", "input_format": "The input consists of multiple lines. The first line contains an integer n (1 \u2264 n \u2264 1000), the number of strings. The next n lines each contain a non-empty string s_i (1 \u2264 |s_i| \u2264 100 000) consisting of lowercase English letters.", "output_format": "Output n lines, each containing the lexicographically minimum string that can be obtained from the corresponding input string by performing the shift operation on exactly one non-empty substring.", "test_input": ["assert apps_run2(2, ['codeforces', 'abacaba']) == ['bncdenqbdr', 'aaacaba']", "assert apps_run2(3, ['zzzz', 'aaaa', 'azazaz']) == ['yyyy', 'aaaz', 'ayazaz']", "assert apps_run2(1, ['xyz']) == ['wxy']", "assert apps_run2(2, ['abc', 'def']) == ['aab', 'cde']", "assert apps_run2(1, ['a']) == ['z']"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "APPS/2013-2", "raw_problem": "You are given a non-empty string s consisting of lowercase English letters. You have to pick exactly one non-empty substring of s and shift all its letters 'z' $\\rightarrow$ 'y' $\\rightarrow$ 'x' $\\rightarrow \\ldots \\rightarrow$ 'b' $\\rightarrow$ 'a' $\\rightarrow$ 'z'. In other words, each character is replaced with the previous character of English alphabet and 'a' is replaced with 'z'.\n\nWhat is the lexicographically minimum string that can be obtained from s by performing this shift exactly once?\n\n\n-----Input-----\n\nThe only line of the input contains the string s (1 \u2264 |s| \u2264 100 000) consisting of lowercase English letters.\n\n\n-----Output-----\n\nPrint the lexicographically minimum string that can be obtained from s by shifting letters of exactly one non-empty substring.\n\n\n-----Examples-----\nInput\ncodeforces\n\nOutput\nbncdenqbdr\n\nInput\nabacaba\n\nOutput\naaacaba\n\n\n\n-----Note-----\n\nString s is lexicographically smaller than some other string t of the same length if there exists some 1 \u2264 i \u2264 |s|, such that s_1 = t_1, s_2 = t_2, ..., s_{i} - 1 = t_{i} - 1, and s_{i} < t_{i}.", "raw_solution": "def apps_run1(s):\n    import re\n    m = re.search(r\"[^a]\", s)\n    if m is None:\n        return s[:-1] + \"z\"\n    else:\n        j = s.find('a', m.end())\n        if j == -1:\n            j = len(s)\n        result = s[:m.start()]\n        for i in range(m.start(), j):\n            result += chr((ord(s[i]) - 98) % 26 + 97)\n        result += s[j:]\n        return result", "raw_test_input": ["assert apps_run1('codeforces\\n') == 'bncdenqbdrq'", "assert apps_run1('abacaba\\n') == 'aaacaba\\n'", "assert apps_run1('babbbabaababbaa\\n') == 'aabbbabaababbaa\\n'", "assert apps_run1('bcbacaabcababaccccaaaabacbbcbbaa\\n') == 'abaacaabcababaccccaaaabacbbcbbaa\\n'", "assert apps_run1('cabaccaacccabaacdbdcbcdbccbccbabbdadbdcdcdbdbcdcdbdadcbcda\\n') == 'babaccaacccabaacdbdcbcdbccbccbabbdadbdcdcdbdbcdcdbdadcbcda\\n'", "assert apps_run1('a\\n') == 'aq'", "assert apps_run1('eeeedddccbceaabdaecaebaeaecccbdeeeaadcecdbeacecdcdcceabaadbcbbadcdaeddbcccaaeebccecaeeeaebcaaccbdaccbdcadadaaeacbbdcbaeeaecedeeeedadec\\n') == 'ddddcccbbabdaabdaecaebaeaecccbdeeeaadcecdbeacecdcdcceabaadbcbbadcdaeddbcccaaeebccecaeeeaebcaaccbdaccbdcadadaaeacbbdcbaeeaecedeeeedadec\\n'", "assert apps_run1('fddfbabadaadaddfbfecadfaefaefefabcccdbbeeabcbbddefbafdcafdfcbdffeeaffcaebbbedabddeaecdddffcbeaafffcddccccfffdbcddcfccefafdbeaacbdeeebdeaaacdfdecadfeafaeaefbfdfffeeaefebdceebcebbfeaccfafdccdcecedeedadcadbfefccfdedfaaefabbaeebdebeecaadbebcfeafbfeeefcfaecadfe\\n') == 'ecceaabadaadaddfbfecadfaefaefefabcccdbbeeabcbbddefbafdcafdfcbdffeeaffcaebbbedabddeaecdddffcbeaafffcddccccfffdbcddcfccefafdbeaacbdeeebdeaaacdfdecadfeafaeaefbfdfffeeaefebdceebcebbfeaccfafdccdcecedeedadcadbfefccfdedfaaefabbaeebdebeecaadbebcfeafbfeeefcfaecadfe\\n'", "assert apps_run1('aaaaaaaaaa\\n') == 'aaaaaaaaaaq'", "assert apps_run1('abbabaaaaa\\n') == 'aaaabaaaaa\\n'", "assert apps_run1('bbbbbbbbbbbb\\n') == 'aaaaaaaaaaaaq'", "assert apps_run1('aabaaaaaaaaaaaa\\n') == 'aaaaaaaaaaaaaaa\\n'", "assert apps_run1('aaaaaaaaaaaaaaaaaaaa\\n') == 'aaaaaaaaaaaaaaaaaaaaq'", "assert apps_run1('abaabaaaaaabbaaaaaaabaaaaaaaaabaaaabaaaaaaabaaaaaaaaaabaaaaaaaaaaaaaaabaaaabbaaaaabaaaaaaaabaaaaaaaa\\n') == 'aaaabaaaaaabbaaaaaaabaaaaaaaaabaaaabaaaaaaabaaaaaaaaaabaaaaaaaaaaaaaaabaaaabbaaaaabaaaaaaaabaaaaaaaa\\n'", "assert apps_run1('abbbbbbbabbbbbbbbbbbbbbbbbbbbbbbabbabbbbbabbbbbbbbbbbabbbbbbbbabbabbbbbbbbbbbbbbabbabbbaababbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbabbabbbbbbbbbbbbbbbbabbbbabbbbbbbbbbbbbbbabbbbbbbbbaababbbbbbbbabbbbbbbbbbbbbbbbbbbbbbbbbbbbabbbbbbbbbbbbbbbbbbbbabbabbbbbbbbbbbbbbbbabbbabbbbbaabbabbbbbbbbbbbbbbbbbbbbbbbbbbbbbabbbbbbbbbbbbbbbbaabbbbbbbbbbbbababbabbbbbbbbbbbbbbbbbbbbbbbbabbbbbbbbbbbbbbbabbbbbbbbbbbabbbbbbbbbbbbbbbbbbbbbbabbbbbbbabbbbbbb\\n') == 'aaaaaaaaabbbbbbbbbbbbbbbbbbbbbbbabbabbbbbabbbbbbbbbbbabbbbbbbbabbabbbbbbbbbbbbbbabbabbbaababbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbabbabbbbbbbbbbbbbbbbabbbbabbbbbbbbbbbbbbbabbbbbbbbbaababbbbbbbbabbbbbbbbbbbbbbbbbbbbbbbbbbbbabbbbbbbbbbbbbbbbbbbbabbabbbbbbbbbbbbbbbbabbbabbbbbaabbabbbbbbbbbbbbbbbbbbbbbbbbbbbbbabbbbbbbbbbbbbbbbaabbbbbbbbbbbbababbabbbbbbbbbbbbbbbbbbbbbbbbabbbbbbbbbbbbbbbabbbbbbbbbbbabbbbbbbbbbbbbbbbbbbbbbabbbbbbbabbbbbbb\\n'", "assert apps_run1('aaaaa\\n') == 'aaaaaq'", "assert apps_run1('aaa\\n') == 'aaaq'", "assert apps_run1('aa\\n') == 'aaq'"], "new_problem": "You are given a non-empty string s consisting of lowercase English letters. You have to pick exactly one non-empty substring of s and shift all its letters 'z' \u2192 'y' \u2192 'x' \u2192 ... \u2192 'b' \u2192 'a' \u2192 'z'. In other words, each character is replaced with the previous character of the English alphabet and 'a' is replaced with 'z'. Additionally, you are given an optional integer k which represents the number of times the shift operation can be applied to the substring. If k is not provided, assume k = 1. What is the lexicographically minimum string that can be obtained from s by performing this shift up to k times?", "new_solution": "def apps_run2(s: str, k: int = 1) -> str:\n    import re\n\n    m = re.search(r\"[^a]\", s)\n    if m is None:\n        return s[:-1] + 'z'\n    else:\n        j = s.find('a', m.end())\n        if j == -1:\n            j = len(s)\n        result = s[:m.start()]\n        for i in range(m.start(), j):\n            shift_amount = min(k, ord(s[i]) - 97)\n            result += chr((ord(s[i]) - 97 - shift_amount) % 26 + 97)\n        result += s[j:]\n        return result", "input_format": "The input consists of a string s (1 \u2264 |s| \u2264 100 000) consisting of lowercase English letters, and an optional integer k (0 \u2264 k \u2264 100 000) which represents the number of times the shift operation can be applied to the substring.", "output_format": "Print the lexicographically minimum string that can be obtained from s by shifting letters of exactly one non-empty substring up to k times.", "test_input": ["assert apps_run2('codeforces') == 'bncdenqbdr'", "assert apps_run2('abacaba') == 'aaacaba'", "assert apps_run2('zzzz', 2) == 'xxxx'", "assert apps_run2('abc', 3) == 'aaa'", "assert apps_run2('a', 5) == 'z'"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "APPS/2013-3", "raw_problem": "You are given a non-empty string s consisting of lowercase English letters. You have to pick exactly one non-empty substring of s and shift all its letters 'z' $\\rightarrow$ 'y' $\\rightarrow$ 'x' $\\rightarrow \\ldots \\rightarrow$ 'b' $\\rightarrow$ 'a' $\\rightarrow$ 'z'. In other words, each character is replaced with the previous character of English alphabet and 'a' is replaced with 'z'.\n\nWhat is the lexicographically minimum string that can be obtained from s by performing this shift exactly once?\n\n\n-----Input-----\n\nThe only line of the input contains the string s (1 \u2264 |s| \u2264 100 000) consisting of lowercase English letters.\n\n\n-----Output-----\n\nPrint the lexicographically minimum string that can be obtained from s by shifting letters of exactly one non-empty substring.\n\n\n-----Examples-----\nInput\ncodeforces\n\nOutput\nbncdenqbdr\n\nInput\nabacaba\n\nOutput\naaacaba\n\n\n\n-----Note-----\n\nString s is lexicographically smaller than some other string t of the same length if there exists some 1 \u2264 i \u2264 |s|, such that s_1 = t_1, s_2 = t_2, ..., s_{i} - 1 = t_{i} - 1, and s_{i} < t_{i}.", "raw_solution": "def apps_run1(s):\n    import re\n    m = re.search(r\"[^a]\", s)\n    if m is None:\n        return s[:-1] + \"z\"\n    else:\n        j = s.find('a', m.end())\n        if j == -1:\n            j = len(s)\n        result = s[:m.start()]\n        for i in range(m.start(), j):\n            result += chr((ord(s[i]) - 98) % 26 + 97)\n        result += s[j:]\n        return result", "raw_test_input": ["assert apps_run1('codeforces\\n') == 'bncdenqbdrq'", "assert apps_run1('abacaba\\n') == 'aaacaba\\n'", "assert apps_run1('babbbabaababbaa\\n') == 'aabbbabaababbaa\\n'", "assert apps_run1('bcbacaabcababaccccaaaabacbbcbbaa\\n') == 'abaacaabcababaccccaaaabacbbcbbaa\\n'", "assert apps_run1('cabaccaacccabaacdbdcbcdbccbccbabbdadbdcdcdbdbcdcdbdadcbcda\\n') == 'babaccaacccabaacdbdcbcdbccbccbabbdadbdcdcdbdbcdcdbdadcbcda\\n'", "assert apps_run1('a\\n') == 'aq'", "assert apps_run1('eeeedddccbceaabdaecaebaeaecccbdeeeaadcecdbeacecdcdcceabaadbcbbadcdaeddbcccaaeebccecaeeeaebcaaccbdaccbdcadadaaeacbbdcbaeeaecedeeeedadec\\n') == 'ddddcccbbabdaabdaecaebaeaecccbdeeeaadcecdbeacecdcdcceabaadbcbbadcdaeddbcccaaeebccecaeeeaebcaaccbdaccbdcadadaaeacbbdcbaeeaecedeeeedadec\\n'", "assert apps_run1('fddfbabadaadaddfbfecadfaefaefefabcccdbbeeabcbbddefbafdcafdfcbdffeeaffcaebbbedabddeaecdddffcbeaafffcddccccfffdbcddcfccefafdbeaacbdeeebdeaaacdfdecadfeafaeaefbfdfffeeaefebdceebcebbfeaccfafdccdcecedeedadcadbfefccfdedfaaefabbaeebdebeecaadbebcfeafbfeeefcfaecadfe\\n') == 'ecceaabadaadaddfbfecadfaefaefefabcccdbbeeabcbbddefbafdcafdfcbdffeeaffcaebbbedabddeaecdddffcbeaafffcddccccfffdbcddcfccefafdbeaacbdeeebdeaaacdfdecadfeafaeaefbfdfffeeaefebdceebcebbfeaccfafdccdcecedeedadcadbfefccfdedfaaefabbaeebdebeecaadbebcfeafbfeeefcfaecadfe\\n'", "assert apps_run1('aaaaaaaaaa\\n') == 'aaaaaaaaaaq'", "assert apps_run1('abbabaaaaa\\n') == 'aaaabaaaaa\\n'", "assert apps_run1('bbbbbbbbbbbb\\n') == 'aaaaaaaaaaaaq'", "assert apps_run1('aabaaaaaaaaaaaa\\n') == 'aaaaaaaaaaaaaaa\\n'", "assert apps_run1('aaaaaaaaaaaaaaaaaaaa\\n') == 'aaaaaaaaaaaaaaaaaaaaq'", "assert apps_run1('abaabaaaaaabbaaaaaaabaaaaaaaaabaaaabaaaaaaabaaaaaaaaaabaaaaaaaaaaaaaaabaaaabbaaaaabaaaaaaaabaaaaaaaa\\n') == 'aaaabaaaaaabbaaaaaaabaaaaaaaaabaaaabaaaaaaabaaaaaaaaaabaaaaaaaaaaaaaaabaaaabbaaaaabaaaaaaaabaaaaaaaa\\n'", "assert apps_run1('abbbbbbbabbbbbbbbbbbbbbbbbbbbbbbabbabbbbbabbbbbbbbbbbabbbbbbbbabbabbbbbbbbbbbbbbabbabbbaababbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbabbabbbbbbbbbbbbbbbbabbbbabbbbbbbbbbbbbbbabbbbbbbbbaababbbbbbbbabbbbbbbbbbbbbbbbbbbbbbbbbbbbabbbbbbbbbbbbbbbbbbbbabbabbbbbbbbbbbbbbbbabbbabbbbbaabbabbbbbbbbbbbbbbbbbbbbbbbbbbbbbabbbbbbbbbbbbbbbbaabbbbbbbbbbbbababbabbbbbbbbbbbbbbbbbbbbbbbbabbbbbbbbbbbbbbbabbbbbbbbbbbabbbbbbbbbbbbbbbbbbbbbbabbbbbbbabbbbbbb\\n') == 'aaaaaaaaabbbbbbbbbbbbbbbbbbbbbbbabbabbbbbabbbbbbbbbbbabbbbbbbbabbabbbbbbbbbbbbbbabbabbbaababbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbabbabbbbbbbbbbbbbbbbabbbbabbbbbbbbbbbbbbbabbbbbbbbbaababbbbbbbbabbbbbbbbbbbbbbbbbbbbbbbbbbbbabbbbbbbbbbbbbbbbbbbbabbabbbbbbbbbbbbbbbbabbbabbbbbaabbabbbbbbbbbbbbbbbbbbbbbbbbbbbbbabbbbbbbbbbbbbbbbaabbbbbbbbbbbbababbabbbbbbbbbbbbbbbbbbbbbbbbabbbbbbbbbbbbbbbabbbbbbbbbbbabbbbbbbbbbbbbbbbbbbbbbabbbbbbbabbbbbbb\\n'", "assert apps_run1('aaaaa\\n') == 'aaaaaq'", "assert apps_run1('aaa\\n') == 'aaaq'", "assert apps_run1('aa\\n') == 'aaq'"], "new_problem": "You are given a non-empty string s consisting of lowercase English letters and a list of tuples, where each tuple contains two integers (l, r) representing the start and end indices of substrings. You have to pick exactly one non-empty substring from the list of tuples and shift all its letters 'z' \u2192 'y' \u2192 'x' \u2192 ... \u2192 'b' \u2192 'a' \u2192 'z'. In other words, each character is replaced with the previous character of the English alphabet and 'a' is replaced with 'z'. What is the lexicographically minimum string that can be obtained from s by performing this shift exactly once on one of the specified substrings? Use a dictionary to store the substrings and their shifted versions to optimize the solution.", "new_solution": "def apps_run2(s: str, substrings: list[tuple[int, int]]) -> str:\n    def shift_char(c: str) -> str:\n        return chr((ord(c) - 98) % 26 + 97)\n\n    def shift_substring(s: str, l: int, r: int) -> str:\n        return s[:l] + ''.join(shift_char(c) for c in s[l:r]) + s[r:]\n\n    shifted_versions = {}\n    for l, r in substrings:\n        shifted_versions[(l, r)] = shift_substring(s, l, r)\n\n    return min(shifted_versions.values())", "input_format": "The input consists of a single line containing a string s (1 \u2264 |s| \u2264 100,000) and a list of tuples, where each tuple contains two integers (l, r) representing the start and end indices of substrings.", "output_format": "Print the lexicographically minimum string that can be obtained from s by shifting letters of exactly one non-empty substring as specified by the list of tuples.", "test_input": ["assert apps_run2('codeforces', [(0, 4), (1, 5), (2, 6)]) == 'bncdforces'", "assert apps_run2('abacaba', [(0, 1), (1, 2), (2, 3)]) == 'aaacaba'", "assert apps_run2('zzzz', [(0, 1), (1, 2), (2, 3)]) == 'yzzz'", "assert apps_run2('abcde', [(0, 3), (1, 4), (2, 5)]) == 'aabce'", "assert apps_run2('aaaaa', [(0, 2), (1, 3), (2, 4)]) == 'aazza'"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "APPS/2013-4", "raw_problem": "You are given a non-empty string s consisting of lowercase English letters. You have to pick exactly one non-empty substring of s and shift all its letters 'z' $\\rightarrow$ 'y' $\\rightarrow$ 'x' $\\rightarrow \\ldots \\rightarrow$ 'b' $\\rightarrow$ 'a' $\\rightarrow$ 'z'. In other words, each character is replaced with the previous character of English alphabet and 'a' is replaced with 'z'.\n\nWhat is the lexicographically minimum string that can be obtained from s by performing this shift exactly once?\n\n\n-----Input-----\n\nThe only line of the input contains the string s (1 \u2264 |s| \u2264 100 000) consisting of lowercase English letters.\n\n\n-----Output-----\n\nPrint the lexicographically minimum string that can be obtained from s by shifting letters of exactly one non-empty substring.\n\n\n-----Examples-----\nInput\ncodeforces\n\nOutput\nbncdenqbdr\n\nInput\nabacaba\n\nOutput\naaacaba\n\n\n\n-----Note-----\n\nString s is lexicographically smaller than some other string t of the same length if there exists some 1 \u2264 i \u2264 |s|, such that s_1 = t_1, s_2 = t_2, ..., s_{i} - 1 = t_{i} - 1, and s_{i} < t_{i}.", "raw_solution": "def apps_run1(s):\n    import re\n    m = re.search(r\"[^a]\", s)\n    if m is None:\n        return s[:-1] + \"z\"\n    else:\n        j = s.find('a', m.end())\n        if j == -1:\n            j = len(s)\n        result = s[:m.start()]\n        for i in range(m.start(), j):\n            result += chr((ord(s[i]) - 98) % 26 + 97)\n        result += s[j:]\n        return result", "raw_test_input": ["assert apps_run1('codeforces\\n') == 'bncdenqbdrq'", "assert apps_run1('abacaba\\n') == 'aaacaba\\n'", "assert apps_run1('babbbabaababbaa\\n') == 'aabbbabaababbaa\\n'", "assert apps_run1('bcbacaabcababaccccaaaabacbbcbbaa\\n') == 'abaacaabcababaccccaaaabacbbcbbaa\\n'", "assert apps_run1('cabaccaacccabaacdbdcbcdbccbccbabbdadbdcdcdbdbcdcdbdadcbcda\\n') == 'babaccaacccabaacdbdcbcdbccbccbabbdadbdcdcdbdbcdcdbdadcbcda\\n'", "assert apps_run1('a\\n') == 'aq'", "assert apps_run1('eeeedddccbceaabdaecaebaeaecccbdeeeaadcecdbeacecdcdcceabaadbcbbadcdaeddbcccaaeebccecaeeeaebcaaccbdaccbdcadadaaeacbbdcbaeeaecedeeeedadec\\n') == 'ddddcccbbabdaabdaecaebaeaecccbdeeeaadcecdbeacecdcdcceabaadbcbbadcdaeddbcccaaeebccecaeeeaebcaaccbdaccbdcadadaaeacbbdcbaeeaecedeeeedadec\\n'", "assert apps_run1('fddfbabadaadaddfbfecadfaefaefefabcccdbbeeabcbbddefbafdcafdfcbdffeeaffcaebbbedabddeaecdddffcbeaafffcddccccfffdbcddcfccefafdbeaacbdeeebdeaaacdfdecadfeafaeaefbfdfffeeaefebdceebcebbfeaccfafdccdcecedeedadcadbfefccfdedfaaefabbaeebdebeecaadbebcfeafbfeeefcfaecadfe\\n') == 'ecceaabadaadaddfbfecadfaefaefefabcccdbbeeabcbbddefbafdcafdfcbdffeeaffcaebbbedabddeaecdddffcbeaafffcddccccfffdbcddcfccefafdbeaacbdeeebdeaaacdfdecadfeafaeaefbfdfffeeaefebdceebcebbfeaccfafdccdcecedeedadcadbfefccfdedfaaefabbaeebdebeecaadbebcfeafbfeeefcfaecadfe\\n'", "assert apps_run1('aaaaaaaaaa\\n') == 'aaaaaaaaaaq'", "assert apps_run1('abbabaaaaa\\n') == 'aaaabaaaaa\\n'", "assert apps_run1('bbbbbbbbbbbb\\n') == 'aaaaaaaaaaaaq'", "assert apps_run1('aabaaaaaaaaaaaa\\n') == 'aaaaaaaaaaaaaaa\\n'", "assert apps_run1('aaaaaaaaaaaaaaaaaaaa\\n') == 'aaaaaaaaaaaaaaaaaaaaq'", "assert apps_run1('abaabaaaaaabbaaaaaaabaaaaaaaaabaaaabaaaaaaabaaaaaaaaaabaaaaaaaaaaaaaaabaaaabbaaaaabaaaaaaaabaaaaaaaa\\n') == 'aaaabaaaaaabbaaaaaaabaaaaaaaaabaaaabaaaaaaabaaaaaaaaaabaaaaaaaaaaaaaaabaaaabbaaaaabaaaaaaaabaaaaaaaa\\n'", "assert apps_run1('abbbbbbbabbbbbbbbbbbbbbbbbbbbbbbabbabbbbbabbbbbbbbbbbabbbbbbbbabbabbbbbbbbbbbbbbabbabbbaababbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbabbabbbbbbbbbbbbbbbbabbbbabbbbbbbbbbbbbbbabbbbbbbbbaababbbbbbbbabbbbbbbbbbbbbbbbbbbbbbbbbbbbabbbbbbbbbbbbbbbbbbbbabbabbbbbbbbbbbbbbbbabbbabbbbbaabbabbbbbbbbbbbbbbbbbbbbbbbbbbbbbabbbbbbbbbbbbbbbbaabbbbbbbbbbbbababbabbbbbbbbbbbbbbbbbbbbbbbbabbbbbbbbbbbbbbbabbbbbbbbbbbabbbbbbbbbbbbbbbbbbbbbbabbbbbbbabbbbbbb\\n') == 'aaaaaaaaabbbbbbbbbbbbbbbbbbbbbbbabbabbbbbabbbbbbbbbbbabbbbbbbbabbabbbbbbbbbbbbbbabbabbbaababbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbabbabbbbbbbbbbbbbbbbabbbbabbbbbbbbbbbbbbbabbbbbbbbbaababbbbbbbbabbbbbbbbbbbbbbbbbbbbbbbbbbbbabbbbbbbbbbbbbbbbbbbbabbabbbbbbbbbbbbbbbbabbbabbbbbaabbabbbbbbbbbbbbbbbbbbbbbbbbbbbbbabbbbbbbbbbbbbbbbaabbbbbbbbbbbbababbabbbbbbbbbbbbbbbbbbbbbbbbabbbbbbbbbbbbbbbabbbbbbbbbbbabbbbbbbbbbbbbbbbbbbbbbabbbbbbbabbbbbbb\\n'", "assert apps_run1('aaaaa\\n') == 'aaaaaq'", "assert apps_run1('aaa\\n') == 'aaaq'", "assert apps_run1('aa\\n') == 'aaq'"], "new_problem": "You are given a non-empty string s consisting of lowercase English letters. You have to pick exactly one non-empty substring of s and shift all its letters 'z' \u2192 'y' \u2192 'x' \u2192 ... \u2192 'b' \u2192 'a' \u2192 'z'. In other words, each character is replaced with the previous character of the English alphabet and 'a' is replaced with 'z'. Implement error handling for the following scenarios: 1. Input string is empty or contains invalid characters. 2. Input string length exceeds the maximum allowed length. 3. Handle unexpected errors gracefully with meaningful error messages. 4. Propagate errors to the caller with custom exceptions.", "new_solution": "class InvalidCharacterError(Exception):\n    pass\n\nclass StringLengthError(Exception):\n    pass\n\ndef apps_run2(s: str) -> str:\n    if not s:\n        raise ValueError(\"Input string cannot be empty.\")\n    if len(s) > 100000:\n        raise StringLengthError(\"Input string exceeds maximum allowed length of 100,000 characters.\")\n    if not s.islower() or not s.isalpha():\n        raise InvalidCharacterError(\"Input string must consist of lowercase English letters only.\")\n\n    import re\n    m = re.search(r\"[^a]\", s)\n    if m is None:\n        return s[:-1] + \"z\"\n    else:\n        j = s.find('a', m.end())\n        if j == -1:\n            j = len(s)\n        result = s[:m.start()]\n        for i in range(m.start(), j):\n            result += chr((ord(s[i]) - 98) % 26 + 97)\n        result += s[j:]\n        return result", "input_format": "The input consists of a single string s (1 \u2264 |s| \u2264 100 000) consisting of lowercase English letters.", "output_format": "Print the lexicographically minimum string that can be obtained from s by shifting letters of exactly one non-empty substring.", "test_input": ["assert apps_run2('codeforces') == 'bncdenqbdr'", "assert apps_run2('abacaba') == 'aaacaba'", "try:\n    apps_run2('')\nexcept ValueError as e:\n    assert str(e) == 'Input string cannot be empty.'", "try:\n    apps_run2('a' * 100001)\nexcept StringLengthError as e:\n    assert str(e) == 'Input string exceeds maximum allowed length of 100,000 characters.'", "try:\n    apps_run2('abc123')\nexcept InvalidCharacterError as e:\n    assert str(e) == 'Input string must consist of lowercase English letters only.'"], "requirement_type": "PROMPT_ERROR_HANDLING"}
{"task_id": "APPS/2014-1", "raw_problem": "After a wonderful evening in the restaurant the time to go home came. Leha as a true gentlemen suggested Noora to give her a lift. Certainly the girl agreed with pleasure. Suddenly one problem appeared: Leha cannot find his car on a huge parking near the restaurant. So he decided to turn to the watchman for help.\n\nFormally the parking can be represented as a matrix 10^9 \u00d7 10^9. There is exactly one car in every cell of the matrix. All cars have their own machine numbers represented as a positive integer. Let's index the columns of the matrix by integers from 1 to 10^9 from left to right and the rows by integers from 1 to 10^9 from top to bottom. By coincidence it turned out, that for every cell (x, y) the number of the car, which stands in this cell, is equal to the minimum positive integer, which can't be found in the cells (i, y) and (x, j), 1 \u2264 i < x, 1 \u2264 j < y. $\\left. \\begin{array}{|l|l|l|l|l|} \\hline 1 & {2} & {3} & {4} & {5} \\\\ \\hline 2 & {1} & {4} & {3} & {6} \\\\ \\hline 3 & {4} & {1} & {2} & {7} \\\\ \\hline 4 & {3} & {2} & {1} & {8} \\\\ \\hline 5 & {6} & {7} & {8} & {1} \\\\ \\hline \\end{array} \\right.$ The upper left fragment 5 \u00d7 5 of the parking \n\nLeha wants to ask the watchman q requests, which can help him to find his car. Every request is represented as five integers x_1, y_1, x_2, y_2, k. The watchman have to consider all cells (x, y) of the matrix, such that x_1 \u2264 x \u2264 x_2 and y_1 \u2264 y \u2264 y_2, and if the number of the car in cell (x, y) does not exceed k, increase the answer to the request by the number of the car in cell (x, y). For each request Leha asks the watchman to tell him the resulting sum. Due to the fact that the sum can turn out to be quite large, hacker asks to calculate it modulo 10^9 + 7.\n\nHowever the requests seem to be impracticable for the watchman. Help the watchman to answer all Leha's requests.\n\n\n-----Input-----\n\nThe first line contains one integer q (1 \u2264 q \u2264 10^4)\u00a0\u2014 the number of Leha's requests.\n\nThe next q lines contain five integers x_1, y_1, x_2, y_2, k (1 \u2264 x_1 \u2264 x_2 \u2264 10^9, 1 \u2264 y_1 \u2264 y_2 \u2264 10^9, 1 \u2264 k \u2264 2\u00b710^9)\u00a0\u2014 parameters of Leha's requests.\n\n\n-----Output-----\n\nPrint exactly q lines\u00a0\u2014 in the first line print the answer to the first request, in the second\u00a0\u2014 the answer to the second request and so on.\n\n\n-----Example-----\nInput\n4\n1 1 1 1 1\n3 2 5 4 5\n1 1 5 5 10000\n1 4 2 5 2\n\nOutput\n1\n13\n93\n0\n\n\n\n-----Note-----\n\nLet's analyze all the requests. In each case the requested submatrix is highlighted in blue.\n\nIn the first request (k = 1) Leha asks only about the upper left parking cell. In this cell the car's number is 1. Consequentally the answer is 1.\n\n$\\left. \\begin{array}{|l|l|l|l|l|} \\hline 1 & {2} & {3} & {4} & {5} \\\\ \\hline 2 & {1} & {4} & {3} & {6} \\\\ \\hline 3 & {4} & {1} & {2} & {7} \\\\ \\hline 4 & {3} & {2} & {1} & {8} \\\\ \\hline 5 & {6} & {7} & {8} & {1} \\\\ \\hline \\end{array} \\right.$\n\nIn the second request (k = 5) suitable numbers are 4, 1, 2, 3, 2, 1. Consequentally the answer is 4 + 1 + 2 + 3 + 2 + 1 = 13.\n\n$\\left. \\begin{array}{|l|l|l|l|l|} \\hline 1 & {2} & {3} & {4} & {5} \\\\ \\hline 2 & {1} & {4} & {3} & {6} \\\\ \\hline 3 & {4} & {1} & {2} & {7} \\\\ \\hline 4 & {3} & {2} & {1} & {8} \\\\ \\hline 5 & {6} & {7} & {8} & {1} \\\\ \\hline \\end{array} \\right.$\n\nIn the third request (k = 10000) Leha asks about the upper left frament 5 \u00d7 5 of the parking. Since k is big enough, the answer is equal to 93.\n\n$\\left. \\begin{array}{|l|l|l|l|l|} \\hline 1 & {2} & {3} & {4} & {5} \\\\ \\hline 2 & {1} & {4} & {3} & {6} \\\\ \\hline 3 & {4} & {1} & {2} & {7} \\\\ \\hline 4 & {3} & {2} & {1} & {8} \\\\ \\hline 5 & {6} & {7} & {8} & {1} \\\\ \\hline \\end{array} \\right.$\n\nIn the last request (k = 2) none of the cur's numbers are suitable, so the answer is 0.\n\n$\\left. \\begin{array}{|l|l|l|l|l|} \\hline 1 & {2} & {3} & {4} & {5} \\\\ \\hline 2 & {1} & {4} & {3} & {6} \\\\ \\hline 3 & {4} & {1} & {2} & {7} \\\\ \\hline 4 & {3} & {2} & {1} & {8} \\\\ \\hline 5 & {6} & {7} & {8} & {1} \\\\ \\hline \\end{array} \\right.$.", "raw_solution": "def apps_run1(queries):\n    mod = 1000000007\n\n    def sum(x, y, k, add):\n        if k < add: return 0\n        up = x + add\n        if up > k: up = k\n        add = add + 1\n        return y * (((add + up) * (up - add + 1) // 2) % mod) % mod\n\n    def solve(x, y, k, add=0):\n        if x == 0 or y == 0: return 0\n        if x > y:\n            x, y = y, x\n        pw = 1\n        while (pw << 1) <= y:\n            pw <<= 1\n        if pw <= x:\n            return (sum(pw, pw, k, add)\n                    + sum(pw, x + y - pw - pw, k, add + pw)\n                    + solve(x - pw, y - pw, k, add)) % mod\n        else:\n            return (sum(pw, x, k, add)\n                    + solve(x, y - pw, k, add + pw)) % mod\n\n    results = []\n    for query in queries:\n        x1, y1, x2, y2, k = query\n        ans = (solve(x2, y2, k)\n               - solve(x1 - 1, y2, k)\n               - solve(x2, y1 - 1, k)\n               + solve(x1 - 1, y1 - 1, k)) % mod\n        if ans < 0: ans += mod\n        results.append(ans)\n    return results", "raw_test_input": ["assert apps_run1([(1, 1, 1, 1, 1), (3, 2, 5, 4, 5), (1, 1, 5, 5, 10000), (1, 4, 2, 5, 2)]) == [1, 13, 93, 0]", "assert apps_run1([(3, 7, 4, 10, 7), (6, 1, 7, 10, 18), (9, 6, 10, 8, 3), (1, 8, 3, 10, 3), (10, 4, 10, 5, 19), (8, 9, 9, 10, 10), (10, 1, 10, 5, 4), (8, 1, 9, 4, 18), (6, 3, 9, 5, 1), (6, 6, 9, 6, 16)]) == [22, 130, 0, 0, 25, 3, 0, 68, 0, 22]", "assert apps_run1([(1, 1, 2, 2, 8), (3, 4, 5, 9, 4), (2, 10, 5, 10, 6), (8, 5, 10, 8, 8), (1, 2, 8, 2, 20), (8, 6, 10, 8, 20), (6, 7, 6, 7, 9), (8, 5, 10, 10, 13), (1, 8, 10, 9, 13), (9, 8, 10, 9, 3)]) == [6, 13, 0, 10, 36, 95, 4, 42, 94, 3]"], "new_problem": "In a large e-commerce warehouse, each cell in a 10^9 \u00d7 10^9 grid represents a storage location with a unique product ID. The product ID in each cell (x, y) is determined by the minimum positive integer not found in any cell (i, y) and (x, j) for 1 \u2264 i < x and 1 \u2264 j < y. The warehouse manager needs to process q requests to determine the total value of products in a specified subgrid, where the value of a product is its ID multiplied by a time factor t. For each request, the manager needs to sum the values of all products in the subgrid (x1, y1) to (x2, y2) whose product ID does not exceed k, and return the result modulo 10^9 + 7.", "new_solution": "mod = 1000000007\n\ndef sum(x, y, k, add) :\n    if k < add : return 0\n    up = x + add\n    if up > k : up = k\n    add = add + 1\n    return y * ( ( (add + up) * (up - add + 1) // 2 ) % mod ) % mod\n\ndef solve(x, y, k, add = 0) :\n    if x == 0 or y == 0 : return 0\n    if x > y :\n        x, y = y, x\n    pw = 1\n    while (pw << 1) <= y :\n        pw <<= 1\n    if pw <= x :\n        return ( sum(pw, pw, k, add)\\\n                 + sum(pw, x + y - pw - pw, k, add + pw)\\\n                 + solve(x - pw, y - pw, k, add) ) % mod\n    else :\n        return ( sum(pw, x, k, add)\\\n                 + solve(x, y - pw, k, add + pw) ) % mod\n\ndef apps_run2(q, requests):\n    results = []\n    for i in range(q):\n        x1, y1, x2, y2, k, t = requests[i]\n        ans = ( solve(x2, y2, k)\\\n                - solve(x1 - 1, y2, k)\\\n                - solve(x2, y1 - 1, k)\\\n                + solve(x1 - 1, y1 - 1, k) ) % mod\n        if ans < 0 : ans += mod\n        results.append((ans * t) % mod)\n    return results", "input_format": "The first line contains one integer q (1 \u2264 q \u2264 10^4) \u2014 the number of requests. Each of the next q lines contains six integers x1, y1, x2, y2, k, t (1 \u2264 x1 \u2264 x2 \u2264 10^9, 1 \u2264 y1 \u2264 y2 \u2264 10^9, 1 \u2264 k \u2264 2\u00b710^9, 1 \u2264 t \u2264 10^9) \u2014 parameters of each request.", "output_format": "Print exactly q lines \u2014 in the first line print the answer to the first request, in the second \u2014 the answer to the second request and so on.", "test_input": ["assert apps_run2(1, [(1, 1, 1, 1, 1, 1)]) == [1]", "assert apps_run2(1, [(3, 2, 5, 4, 5, 2)]) == [26]", "assert apps_run2(1, [(1, 1, 5, 5, 10000, 1)]) == [93]", "assert apps_run2(1, [(1, 4, 2, 5, 2, 3)]) == [0]", "assert apps_run2(1, [(1, 1, 2, 2, 3, 5)]) == [30]"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "APPS/2014-2", "raw_problem": "After a wonderful evening in the restaurant the time to go home came. Leha as a true gentlemen suggested Noora to give her a lift. Certainly the girl agreed with pleasure. Suddenly one problem appeared: Leha cannot find his car on a huge parking near the restaurant. So he decided to turn to the watchman for help.\n\nFormally the parking can be represented as a matrix 10^9 \u00d7 10^9. There is exactly one car in every cell of the matrix. All cars have their own machine numbers represented as a positive integer. Let's index the columns of the matrix by integers from 1 to 10^9 from left to right and the rows by integers from 1 to 10^9 from top to bottom. By coincidence it turned out, that for every cell (x, y) the number of the car, which stands in this cell, is equal to the minimum positive integer, which can't be found in the cells (i, y) and (x, j), 1 \u2264 i < x, 1 \u2264 j < y. $\\left. \\begin{array}{|l|l|l|l|l|} \\hline 1 & {2} & {3} & {4} & {5} \\\\ \\hline 2 & {1} & {4} & {3} & {6} \\\\ \\hline 3 & {4} & {1} & {2} & {7} \\\\ \\hline 4 & {3} & {2} & {1} & {8} \\\\ \\hline 5 & {6} & {7} & {8} & {1} \\\\ \\hline \\end{array} \\right.$ The upper left fragment 5 \u00d7 5 of the parking \n\nLeha wants to ask the watchman q requests, which can help him to find his car. Every request is represented as five integers x_1, y_1, x_2, y_2, k. The watchman have to consider all cells (x, y) of the matrix, such that x_1 \u2264 x \u2264 x_2 and y_1 \u2264 y \u2264 y_2, and if the number of the car in cell (x, y) does not exceed k, increase the answer to the request by the number of the car in cell (x, y). For each request Leha asks the watchman to tell him the resulting sum. Due to the fact that the sum can turn out to be quite large, hacker asks to calculate it modulo 10^9 + 7.\n\nHowever the requests seem to be impracticable for the watchman. Help the watchman to answer all Leha's requests.\n\n\n-----Input-----\n\nThe first line contains one integer q (1 \u2264 q \u2264 10^4)\u00a0\u2014 the number of Leha's requests.\n\nThe next q lines contain five integers x_1, y_1, x_2, y_2, k (1 \u2264 x_1 \u2264 x_2 \u2264 10^9, 1 \u2264 y_1 \u2264 y_2 \u2264 10^9, 1 \u2264 k \u2264 2\u00b710^9)\u00a0\u2014 parameters of Leha's requests.\n\n\n-----Output-----\n\nPrint exactly q lines\u00a0\u2014 in the first line print the answer to the first request, in the second\u00a0\u2014 the answer to the second request and so on.\n\n\n-----Example-----\nInput\n4\n1 1 1 1 1\n3 2 5 4 5\n1 1 5 5 10000\n1 4 2 5 2\n\nOutput\n1\n13\n93\n0\n\n\n\n-----Note-----\n\nLet's analyze all the requests. In each case the requested submatrix is highlighted in blue.\n\nIn the first request (k = 1) Leha asks only about the upper left parking cell. In this cell the car's number is 1. Consequentally the answer is 1.\n\n$\\left. \\begin{array}{|l|l|l|l|l|} \\hline 1 & {2} & {3} & {4} & {5} \\\\ \\hline 2 & {1} & {4} & {3} & {6} \\\\ \\hline 3 & {4} & {1} & {2} & {7} \\\\ \\hline 4 & {3} & {2} & {1} & {8} \\\\ \\hline 5 & {6} & {7} & {8} & {1} \\\\ \\hline \\end{array} \\right.$\n\nIn the second request (k = 5) suitable numbers are 4, 1, 2, 3, 2, 1. Consequentally the answer is 4 + 1 + 2 + 3 + 2 + 1 = 13.\n\n$\\left. \\begin{array}{|l|l|l|l|l|} \\hline 1 & {2} & {3} & {4} & {5} \\\\ \\hline 2 & {1} & {4} & {3} & {6} \\\\ \\hline 3 & {4} & {1} & {2} & {7} \\\\ \\hline 4 & {3} & {2} & {1} & {8} \\\\ \\hline 5 & {6} & {7} & {8} & {1} \\\\ \\hline \\end{array} \\right.$\n\nIn the third request (k = 10000) Leha asks about the upper left frament 5 \u00d7 5 of the parking. Since k is big enough, the answer is equal to 93.\n\n$\\left. \\begin{array}{|l|l|l|l|l|} \\hline 1 & {2} & {3} & {4} & {5} \\\\ \\hline 2 & {1} & {4} & {3} & {6} \\\\ \\hline 3 & {4} & {1} & {2} & {7} \\\\ \\hline 4 & {3} & {2} & {1} & {8} \\\\ \\hline 5 & {6} & {7} & {8} & {1} \\\\ \\hline \\end{array} \\right.$\n\nIn the last request (k = 2) none of the cur's numbers are suitable, so the answer is 0.\n\n$\\left. \\begin{array}{|l|l|l|l|l|} \\hline 1 & {2} & {3} & {4} & {5} \\\\ \\hline 2 & {1} & {4} & {3} & {6} \\\\ \\hline 3 & {4} & {1} & {2} & {7} \\\\ \\hline 4 & {3} & {2} & {1} & {8} \\\\ \\hline 5 & {6} & {7} & {8} & {1} \\\\ \\hline \\end{array} \\right.$.", "raw_solution": "def apps_run1(queries):\n    mod = 1000000007\n\n    def sum(x, y, k, add):\n        if k < add: return 0\n        up = x + add\n        if up > k: up = k\n        add = add + 1\n        return y * (((add + up) * (up - add + 1) // 2) % mod) % mod\n\n    def solve(x, y, k, add=0):\n        if x == 0 or y == 0: return 0\n        if x > y:\n            x, y = y, x\n        pw = 1\n        while (pw << 1) <= y:\n            pw <<= 1\n        if pw <= x:\n            return (sum(pw, pw, k, add)\n                    + sum(pw, x + y - pw - pw, k, add + pw)\n                    + solve(x - pw, y - pw, k, add)) % mod\n        else:\n            return (sum(pw, x, k, add)\n                    + solve(x, y - pw, k, add + pw)) % mod\n\n    results = []\n    for query in queries:\n        x1, y1, x2, y2, k = query\n        ans = (solve(x2, y2, k)\n               - solve(x1 - 1, y2, k)\n               - solve(x2, y1 - 1, k)\n               + solve(x1 - 1, y1 - 1, k)) % mod\n        if ans < 0: ans += mod\n        results.append(ans)\n    return results", "raw_test_input": ["assert apps_run1([(1, 1, 1, 1, 1), (3, 2, 5, 4, 5), (1, 1, 5, 5, 10000), (1, 4, 2, 5, 2)]) == [1, 13, 93, 0]", "assert apps_run1([(3, 7, 4, 10, 7), (6, 1, 7, 10, 18), (9, 6, 10, 8, 3), (1, 8, 3, 10, 3), (10, 4, 10, 5, 19), (8, 9, 9, 10, 10), (10, 1, 10, 5, 4), (8, 1, 9, 4, 18), (6, 3, 9, 5, 1), (6, 6, 9, 6, 16)]) == [22, 130, 0, 0, 25, 3, 0, 68, 0, 22]", "assert apps_run1([(1, 1, 2, 2, 8), (3, 4, 5, 9, 4), (2, 10, 5, 10, 6), (8, 5, 10, 8, 8), (1, 2, 8, 2, 20), (8, 6, 10, 8, 20), (6, 7, 6, 7, 9), (8, 5, 10, 10, 13), (1, 8, 10, 9, 13), (9, 8, 10, 9, 3)]) == [6, 13, 0, 10, 36, 95, 4, 42, 94, 3]"], "new_problem": "Leha still needs to find his car in the parking matrix, but now he wants to apply a multiplier to the sum of car numbers in the specified submatrix. The multiplier is optional and defaults to 1 if not provided. The task is to compute the sum of car numbers in the specified submatrix, apply the multiplier, and return the result modulo 10^9 + 7. Ensure that the solution maintains backward compatibility with the original problem.", "new_solution": "from typing import Optional\n\nmod = 1000000007\n\ndef sum(x: int, y: int, k: int, add: int) -> int:\n    if k < add: return 0\n    up = x + add\n    if up > k: up = k\n    add = add + 1\n    return y * (((add + up) * (up - add + 1) // 2) % mod) % mod\n\ndef solve(x: int, y: int, k: int, add: int = 0) -> int:\n    if x == 0 or y == 0: return 0\n    if x > y:\n        x, y = y, x\n    pw = 1\n    while (pw << 1) <= y:\n        pw <<= 1\n    if pw <= x:\n        return (sum(pw, pw, k, add)\n                + sum(pw, x + y - pw - pw, k, add + pw)\n                + solve(x - pw, y - pw, k, add)) % mod\n    else:\n        return (sum(pw, x, k, add)\n                + solve(x, y - pw, k, add + pw)) % mod\n\ndef apps_run2(x1: int, y1: int, x2: int, y2: int, k: int, m: Optional[int] = 1) -> int:\n    ans = (solve(x2, y2, k)\n           - solve(x1 - 1, y2, k)\n           - solve(x2, y1 - 1, k)\n           + solve(x1 - 1, y1 - 1, k)) % mod\n    if ans < 0: ans += mod\n    return (ans * m) % mod", "input_format": "The first line contains one integer q (1 \u2264 q \u2264 10^4) \u2014 the number of Leha's requests. The next q lines contain five integers x_1, y_1, x_2, y_2, k (1 \u2264 x_1 \u2264 x_2 \u2264 10^9, 1 \u2264 y_1 \u2264 y_2 \u2264 10^9, 1 \u2264 k \u2264 2\u00b710^9) \u2014 parameters of Leha's requests. Optionally, each request can include a sixth integer m (1 \u2264 m \u2264 10^9) representing a multiplier for the sum of car numbers.", "output_format": "Print exactly q lines \u2014 in the first line print the answer to the first request, in the second \u2014 the answer to the second request and so on. Each answer should be the sum of car numbers in the specified submatrix, multiplied by m if provided, and taken modulo 10^9 + 7.", "test_input": ["assert apps_run2(1, 1, 1, 1, 1) == 1", "assert apps_run2(3, 2, 5, 4, 5) == 13", "assert apps_run2(1, 1, 5, 5, 10000) == 93", "assert apps_run2(1, 4, 2, 5, 2) == 0", "assert apps_run2(1, 1, 1, 1, 1, 2) == 2", "assert apps_run2(3, 2, 5, 4, 5, 3) == 39", "assert apps_run2(1, 1, 5, 5, 10000, 10) == 930", "assert apps_run2(1, 4, 2, 5, 2, 5) == 0"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "APPS/2014-3", "raw_problem": "After a wonderful evening in the restaurant the time to go home came. Leha as a true gentlemen suggested Noora to give her a lift. Certainly the girl agreed with pleasure. Suddenly one problem appeared: Leha cannot find his car on a huge parking near the restaurant. So he decided to turn to the watchman for help.\n\nFormally the parking can be represented as a matrix 10^9 \u00d7 10^9. There is exactly one car in every cell of the matrix. All cars have their own machine numbers represented as a positive integer. Let's index the columns of the matrix by integers from 1 to 10^9 from left to right and the rows by integers from 1 to 10^9 from top to bottom. By coincidence it turned out, that for every cell (x, y) the number of the car, which stands in this cell, is equal to the minimum positive integer, which can't be found in the cells (i, y) and (x, j), 1 \u2264 i < x, 1 \u2264 j < y. $\\left. \\begin{array}{|l|l|l|l|l|} \\hline 1 & {2} & {3} & {4} & {5} \\\\ \\hline 2 & {1} & {4} & {3} & {6} \\\\ \\hline 3 & {4} & {1} & {2} & {7} \\\\ \\hline 4 & {3} & {2} & {1} & {8} \\\\ \\hline 5 & {6} & {7} & {8} & {1} \\\\ \\hline \\end{array} \\right.$ The upper left fragment 5 \u00d7 5 of the parking \n\nLeha wants to ask the watchman q requests, which can help him to find his car. Every request is represented as five integers x_1, y_1, x_2, y_2, k. The watchman have to consider all cells (x, y) of the matrix, such that x_1 \u2264 x \u2264 x_2 and y_1 \u2264 y \u2264 y_2, and if the number of the car in cell (x, y) does not exceed k, increase the answer to the request by the number of the car in cell (x, y). For each request Leha asks the watchman to tell him the resulting sum. Due to the fact that the sum can turn out to be quite large, hacker asks to calculate it modulo 10^9 + 7.\n\nHowever the requests seem to be impracticable for the watchman. Help the watchman to answer all Leha's requests.\n\n\n-----Input-----\n\nThe first line contains one integer q (1 \u2264 q \u2264 10^4)\u00a0\u2014 the number of Leha's requests.\n\nThe next q lines contain five integers x_1, y_1, x_2, y_2, k (1 \u2264 x_1 \u2264 x_2 \u2264 10^9, 1 \u2264 y_1 \u2264 y_2 \u2264 10^9, 1 \u2264 k \u2264 2\u00b710^9)\u00a0\u2014 parameters of Leha's requests.\n\n\n-----Output-----\n\nPrint exactly q lines\u00a0\u2014 in the first line print the answer to the first request, in the second\u00a0\u2014 the answer to the second request and so on.\n\n\n-----Example-----\nInput\n4\n1 1 1 1 1\n3 2 5 4 5\n1 1 5 5 10000\n1 4 2 5 2\n\nOutput\n1\n13\n93\n0\n\n\n\n-----Note-----\n\nLet's analyze all the requests. In each case the requested submatrix is highlighted in blue.\n\nIn the first request (k = 1) Leha asks only about the upper left parking cell. In this cell the car's number is 1. Consequentally the answer is 1.\n\n$\\left. \\begin{array}{|l|l|l|l|l|} \\hline 1 & {2} & {3} & {4} & {5} \\\\ \\hline 2 & {1} & {4} & {3} & {6} \\\\ \\hline 3 & {4} & {1} & {2} & {7} \\\\ \\hline 4 & {3} & {2} & {1} & {8} \\\\ \\hline 5 & {6} & {7} & {8} & {1} \\\\ \\hline \\end{array} \\right.$\n\nIn the second request (k = 5) suitable numbers are 4, 1, 2, 3, 2, 1. Consequentally the answer is 4 + 1 + 2 + 3 + 2 + 1 = 13.\n\n$\\left. \\begin{array}{|l|l|l|l|l|} \\hline 1 & {2} & {3} & {4} & {5} \\\\ \\hline 2 & {1} & {4} & {3} & {6} \\\\ \\hline 3 & {4} & {1} & {2} & {7} \\\\ \\hline 4 & {3} & {2} & {1} & {8} \\\\ \\hline 5 & {6} & {7} & {8} & {1} \\\\ \\hline \\end{array} \\right.$\n\nIn the third request (k = 10000) Leha asks about the upper left frament 5 \u00d7 5 of the parking. Since k is big enough, the answer is equal to 93.\n\n$\\left. \\begin{array}{|l|l|l|l|l|} \\hline 1 & {2} & {3} & {4} & {5} \\\\ \\hline 2 & {1} & {4} & {3} & {6} \\\\ \\hline 3 & {4} & {1} & {2} & {7} \\\\ \\hline 4 & {3} & {2} & {1} & {8} \\\\ \\hline 5 & {6} & {7} & {8} & {1} \\\\ \\hline \\end{array} \\right.$\n\nIn the last request (k = 2) none of the cur's numbers are suitable, so the answer is 0.\n\n$\\left. \\begin{array}{|l|l|l|l|l|} \\hline 1 & {2} & {3} & {4} & {5} \\\\ \\hline 2 & {1} & {4} & {3} & {6} \\\\ \\hline 3 & {4} & {1} & {2} & {7} \\\\ \\hline 4 & {3} & {2} & {1} & {8} \\\\ \\hline 5 & {6} & {7} & {8} & {1} \\\\ \\hline \\end{array} \\right.$.", "raw_solution": "def apps_run1(queries):\n    mod = 1000000007\n\n    def sum(x, y, k, add):\n        if k < add: return 0\n        up = x + add\n        if up > k: up = k\n        add = add + 1\n        return y * (((add + up) * (up - add + 1) // 2) % mod) % mod\n\n    def solve(x, y, k, add=0):\n        if x == 0 or y == 0: return 0\n        if x > y:\n            x, y = y, x\n        pw = 1\n        while (pw << 1) <= y:\n            pw <<= 1\n        if pw <= x:\n            return (sum(pw, pw, k, add)\n                    + sum(pw, x + y - pw - pw, k, add + pw)\n                    + solve(x - pw, y - pw, k, add)) % mod\n        else:\n            return (sum(pw, x, k, add)\n                    + solve(x, y - pw, k, add + pw)) % mod\n\n    results = []\n    for query in queries:\n        x1, y1, x2, y2, k = query\n        ans = (solve(x2, y2, k)\n               - solve(x1 - 1, y2, k)\n               - solve(x2, y1 - 1, k)\n               + solve(x1 - 1, y1 - 1, k)) % mod\n        if ans < 0: ans += mod\n        results.append(ans)\n    return results", "raw_test_input": ["assert apps_run1([(1, 1, 1, 1, 1), (3, 2, 5, 4, 5), (1, 1, 5, 5, 10000), (1, 4, 2, 5, 2)]) == [1, 13, 93, 0]", "assert apps_run1([(3, 7, 4, 10, 7), (6, 1, 7, 10, 18), (9, 6, 10, 8, 3), (1, 8, 3, 10, 3), (10, 4, 10, 5, 19), (8, 9, 9, 10, 10), (10, 1, 10, 5, 4), (8, 1, 9, 4, 18), (6, 3, 9, 5, 1), (6, 6, 9, 6, 16)]) == [22, 130, 0, 0, 25, 3, 0, 68, 0, 22]", "assert apps_run1([(1, 1, 2, 2, 8), (3, 4, 5, 9, 4), (2, 10, 5, 10, 6), (8, 5, 10, 8, 8), (1, 2, 8, 2, 20), (8, 6, 10, 8, 20), (6, 7, 6, 7, 9), (8, 5, 10, 10, 13), (1, 8, 10, 9, 13), (9, 8, 10, 9, 3)]) == [6, 13, 0, 10, 36, 95, 4, 42, 94, 3]"], "new_problem": "Leha's car is now parked in a multi-level parking garage, represented as a 3D matrix of dimensions 10^9 \u00d7 10^9 \u00d7 10^3. Each level of the parking garage is a 2D matrix similar to the original problem. Leha wants to ask the watchman q requests to find his car. Each request is represented as six integers x_1, y_1, z_1, x_2, y_2, z_2, k. The watchman has to consider all cells (x, y, z) of the 3D matrix, such that x_1 \u2264 x \u2264 x_2, y_1 \u2264 y \u2264 y_2, z_1 \u2264 z \u2264 z_2, and if the number of the car in cell (x, y, z) does not exceed k, increase the answer to the request by the number of the car in cell (x, y, z). For each request, Leha asks the watchman to tell him the resulting sum modulo 10^9 + 7. Use a dictionary to store the results of subproblems to optimize the solution.", "new_solution": "from typing import Dict, Tuple\n\nmod = 1000000007\n\ncache: Dict[Tuple[int, int, int, int], int] = {}\n\ndef sum_3d(x: int, y: int, z: int, k: int, add: int) -> int:\n    if k < add: return 0\n    up = x + add\n    if up > k: up = k\n    add += 1\n    return y * z * (((add + up) * (up - add + 1) // 2) % mod) % mod\n\ndef solve_3d(x: int, y: int, z: int, k: int, add: int = 0) -> int:\n    if x == 0 or y == 0 or z == 0: return 0\n    if (x, y, z, add) in cache:\n        return cache[(x, y, z, add)]\n    if x > y:\n        x, y = y, x\n    pw = 1\n    while (pw << 1) <= y:\n        pw <<= 1\n    if pw <= x:\n        result = (sum_3d(pw, pw, z, k, add) +\n                  sum_3d(pw, x + y - pw - pw, z, k, add + pw) +\n                  solve_3d(x - pw, y - pw, z, k, add)) % mod\n    else:\n        result = (sum_3d(pw, x, z, k, add) +\n                  solve_3d(x, y - pw, z, k, add + pw)) % mod\n    cache[(x, y, z, add)] = result\n    return result\n\ndef apps_run2(q: int, requests: list) -> list:\n    results = []\n    for i in range(q):\n        x1, y1, z1, x2, y2, z2, k = requests[i]\n        ans = (solve_3d(x2, y2, z2, k) -\n               solve_3d(x1 - 1, y2, z2, k) -\n               solve_3d(x2, y1 - 1, z2, k) -\n               solve_3d(x2, y2, z1 - 1, k) +\n               solve_3d(x1 - 1, y1 - 1, z2, k) +\n               solve_3d(x1 - 1, y2, z1 - 1, k) +\n               solve_3d(x2, y1 - 1, z1 - 1, k) -\n               solve_3d(x1 - 1, y1 - 1, z1 - 1, k)) % mod\n        if ans < 0: ans += mod\n        results.append(ans)\n    return results", "input_format": "The first line contains one integer q (1 \u2264 q \u2264 10^4) \u2014 the number of Leha's requests. The next q lines contain five integers x_1, y_1, x_2, y_2, k (1 \u2264 x_1 \u2264 x_2 \u2264 10^9, 1 \u2264 y_1 \u2264 y_2 \u2264 10^9, 1 \u2264 k \u2264 2\u00b710^9) \u2014 parameters of Leha's requests.", "output_format": "Print exactly q lines \u2014 in the first line print the answer to the first request, in the second \u2014 the answer to the second request and so on.", "test_input": ["assert apps_run2(1, [(1, 1, 1, 1, 1, 1, 1)]) == [1]", "assert apps_run2(1, [(1, 1, 1, 2, 2, 2, 5)]) == [12]", "assert apps_run2(1, [(1, 1, 1, 5, 5, 5, 10000)]) == [465]", "assert apps_run2(1, [(1, 1, 1, 3, 3, 3, 2)]) == [21]", "assert apps_run2(1, [(2, 2, 2, 4, 4, 4, 10)]) == [63]"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "APPS/2014-4", "raw_problem": "After a wonderful evening in the restaurant the time to go home came. Leha as a true gentlemen suggested Noora to give her a lift. Certainly the girl agreed with pleasure. Suddenly one problem appeared: Leha cannot find his car on a huge parking near the restaurant. So he decided to turn to the watchman for help.\n\nFormally the parking can be represented as a matrix 10^9 \u00d7 10^9. There is exactly one car in every cell of the matrix. All cars have their own machine numbers represented as a positive integer. Let's index the columns of the matrix by integers from 1 to 10^9 from left to right and the rows by integers from 1 to 10^9 from top to bottom. By coincidence it turned out, that for every cell (x, y) the number of the car, which stands in this cell, is equal to the minimum positive integer, which can't be found in the cells (i, y) and (x, j), 1 \u2264 i < x, 1 \u2264 j < y. $\\left. \\begin{array}{|l|l|l|l|l|} \\hline 1 & {2} & {3} & {4} & {5} \\\\ \\hline 2 & {1} & {4} & {3} & {6} \\\\ \\hline 3 & {4} & {1} & {2} & {7} \\\\ \\hline 4 & {3} & {2} & {1} & {8} \\\\ \\hline 5 & {6} & {7} & {8} & {1} \\\\ \\hline \\end{array} \\right.$ The upper left fragment 5 \u00d7 5 of the parking \n\nLeha wants to ask the watchman q requests, which can help him to find his car. Every request is represented as five integers x_1, y_1, x_2, y_2, k. The watchman have to consider all cells (x, y) of the matrix, such that x_1 \u2264 x \u2264 x_2 and y_1 \u2264 y \u2264 y_2, and if the number of the car in cell (x, y) does not exceed k, increase the answer to the request by the number of the car in cell (x, y). For each request Leha asks the watchman to tell him the resulting sum. Due to the fact that the sum can turn out to be quite large, hacker asks to calculate it modulo 10^9 + 7.\n\nHowever the requests seem to be impracticable for the watchman. Help the watchman to answer all Leha's requests.\n\n\n-----Input-----\n\nThe first line contains one integer q (1 \u2264 q \u2264 10^4)\u00a0\u2014 the number of Leha's requests.\n\nThe next q lines contain five integers x_1, y_1, x_2, y_2, k (1 \u2264 x_1 \u2264 x_2 \u2264 10^9, 1 \u2264 y_1 \u2264 y_2 \u2264 10^9, 1 \u2264 k \u2264 2\u00b710^9)\u00a0\u2014 parameters of Leha's requests.\n\n\n-----Output-----\n\nPrint exactly q lines\u00a0\u2014 in the first line print the answer to the first request, in the second\u00a0\u2014 the answer to the second request and so on.\n\n\n-----Example-----\nInput\n4\n1 1 1 1 1\n3 2 5 4 5\n1 1 5 5 10000\n1 4 2 5 2\n\nOutput\n1\n13\n93\n0\n\n\n\n-----Note-----\n\nLet's analyze all the requests. In each case the requested submatrix is highlighted in blue.\n\nIn the first request (k = 1) Leha asks only about the upper left parking cell. In this cell the car's number is 1. Consequentally the answer is 1.\n\n$\\left. \\begin{array}{|l|l|l|l|l|} \\hline 1 & {2} & {3} & {4} & {5} \\\\ \\hline 2 & {1} & {4} & {3} & {6} \\\\ \\hline 3 & {4} & {1} & {2} & {7} \\\\ \\hline 4 & {3} & {2} & {1} & {8} \\\\ \\hline 5 & {6} & {7} & {8} & {1} \\\\ \\hline \\end{array} \\right.$\n\nIn the second request (k = 5) suitable numbers are 4, 1, 2, 3, 2, 1. Consequentally the answer is 4 + 1 + 2 + 3 + 2 + 1 = 13.\n\n$\\left. \\begin{array}{|l|l|l|l|l|} \\hline 1 & {2} & {3} & {4} & {5} \\\\ \\hline 2 & {1} & {4} & {3} & {6} \\\\ \\hline 3 & {4} & {1} & {2} & {7} \\\\ \\hline 4 & {3} & {2} & {1} & {8} \\\\ \\hline 5 & {6} & {7} & {8} & {1} \\\\ \\hline \\end{array} \\right.$\n\nIn the third request (k = 10000) Leha asks about the upper left frament 5 \u00d7 5 of the parking. Since k is big enough, the answer is equal to 93.\n\n$\\left. \\begin{array}{|l|l|l|l|l|} \\hline 1 & {2} & {3} & {4} & {5} \\\\ \\hline 2 & {1} & {4} & {3} & {6} \\\\ \\hline 3 & {4} & {1} & {2} & {7} \\\\ \\hline 4 & {3} & {2} & {1} & {8} \\\\ \\hline 5 & {6} & {7} & {8} & {1} \\\\ \\hline \\end{array} \\right.$\n\nIn the last request (k = 2) none of the cur's numbers are suitable, so the answer is 0.\n\n$\\left. \\begin{array}{|l|l|l|l|l|} \\hline 1 & {2} & {3} & {4} & {5} \\\\ \\hline 2 & {1} & {4} & {3} & {6} \\\\ \\hline 3 & {4} & {1} & {2} & {7} \\\\ \\hline 4 & {3} & {2} & {1} & {8} \\\\ \\hline 5 & {6} & {7} & {8} & {1} \\\\ \\hline \\end{array} \\right.$.", "raw_solution": "def apps_run1(queries):\n    mod = 1000000007\n\n    def sum(x, y, k, add):\n        if k < add: return 0\n        up = x + add\n        if up > k: up = k\n        add = add + 1\n        return y * (((add + up) * (up - add + 1) // 2) % mod) % mod\n\n    def solve(x, y, k, add=0):\n        if x == 0 or y == 0: return 0\n        if x > y:\n            x, y = y, x\n        pw = 1\n        while (pw << 1) <= y:\n            pw <<= 1\n        if pw <= x:\n            return (sum(pw, pw, k, add)\n                    + sum(pw, x + y - pw - pw, k, add + pw)\n                    + solve(x - pw, y - pw, k, add)) % mod\n        else:\n            return (sum(pw, x, k, add)\n                    + solve(x, y - pw, k, add + pw)) % mod\n\n    results = []\n    for query in queries:\n        x1, y1, x2, y2, k = query\n        ans = (solve(x2, y2, k)\n               - solve(x1 - 1, y2, k)\n               - solve(x2, y1 - 1, k)\n               + solve(x1 - 1, y1 - 1, k)) % mod\n        if ans < 0: ans += mod\n        results.append(ans)\n    return results", "raw_test_input": ["assert apps_run1([(1, 1, 1, 1, 1), (3, 2, 5, 4, 5), (1, 1, 5, 5, 10000), (1, 4, 2, 5, 2)]) == [1, 13, 93, 0]", "assert apps_run1([(3, 7, 4, 10, 7), (6, 1, 7, 10, 18), (9, 6, 10, 8, 3), (1, 8, 3, 10, 3), (10, 4, 10, 5, 19), (8, 9, 9, 10, 10), (10, 1, 10, 5, 4), (8, 1, 9, 4, 18), (6, 3, 9, 5, 1), (6, 6, 9, 6, 16)]) == [22, 130, 0, 0, 25, 3, 0, 68, 0, 22]", "assert apps_run1([(1, 1, 2, 2, 8), (3, 4, 5, 9, 4), (2, 10, 5, 10, 6), (8, 5, 10, 8, 8), (1, 2, 8, 2, 20), (8, 6, 10, 8, 20), (6, 7, 6, 7, 9), (8, 5, 10, 10, 13), (1, 8, 10, 9, 13), (9, 8, 10, 9, 3)]) == [6, 13, 0, 10, 36, 95, 4, 42, 94, 3]"], "new_problem": "Leha is trying to find his car in a massive parking lot represented as a matrix. However, due to a recent system update, the parking management system now requires error handling for invalid inputs. The system should handle the following errors: 1. InvalidMatrixSizeError: Raised when the matrix size exceeds the allowed limits. 2. InvalidRequestError: Raised when the request parameters are out of bounds or invalid. 3. CalculationError: Raised when an unexpected error occurs during the calculation. Implement error handling for these scenarios and ensure that meaningful error messages are provided. The system should also propagate errors appropriately and maintain type hints.", "new_solution": "class InvalidMatrixSizeError(Exception):\n    pass\n\nclass InvalidRequestError(Exception):\n    pass\n\nclass CalculationError(Exception):\n    pass\n\nmod = 1000000007\n\n\ndef sum(x: int, y: int, k: int, add: int) -> int:\n    if k < add:\n        return 0\n    up = x + add\n    if up > k:\n        up = k\n    add = add + 1\n    return y * (((add + up) * (up - add + 1) // 2) % mod) % mod\n\n\ndef solve(x: int, y: int, k: int, add: int = 0) -> int:\n    if x == 0 or y == 0:\n        return 0\n    if x > y:\n        x, y = y, x\n    pw = 1\n    while (pw << 1) <= y:\n        pw <<= 1\n    if pw <= x:\n        return (sum(pw, pw, k, add) +\n                sum(pw, x + y - pw - pw, k, add + pw) +\n                solve(x - pw, y - pw, k, add)) % mod\n    else:\n        return (sum(pw, x, k, add) +\n                solve(x, y - pw, k, add + pw)) % mod\n\n\ndef apps_run2(q: int, requests: list) -> list:\n    if q < 1 or q > 10000:\n        raise InvalidMatrixSizeError(\"Number of requests must be between 1 and 10,000.\")\n\n    results = []\n    for request in requests:\n        x1, y1, x2, y2, k = request\n        if not (1 <= x1 <= x2 <= 10**9 and 1 <= y1 <= y2 <= 10**9 and 1 <= k <= 2 * 10**9):\n            raise InvalidRequestError(\"Request parameters are out of bounds.\")\n\n        try:\n            ans = (solve(x2, y2, k) -\n                   solve(x1 - 1, y2, k) -\n                   solve(x2, y1 - 1, k) +\n                   solve(x1 - 1, y1 - 1, k)) % mod\n            if ans < 0:\n                ans += mod\n            results.append(ans)\n        except Exception as e:\n            raise CalculationError(f\"An error occurred during calculation: {str(e)}\")\n\n    return results", "input_format": "The first line contains one integer q (1 \u2264 q \u2264 10^4) \u2014 the number of Leha's requests. The next q lines contain five integers x_1, y_1, x_2, y_2, k (1 \u2264 x_1 \u2264 x_2 \u2264 10^9, 1 \u2264 y_1 \u2264 y_2 \u2264 10^9, 1 \u2264 k \u2264 2\u00b710^9) \u2014 parameters of Leha's requests.", "output_format": "Print exactly q lines \u2014 in the first line print the answer to the first request, in the second \u2014 the answer to the second request and so on.", "test_input": ["assert apps_run2(1, [(1, 1, 1, 1, 1)]) == [1]", "assert apps_run2(1, [(3, 2, 5, 4, 5)]) == [13]", "assert apps_run2(1, [(1, 1, 5, 5, 10000)]) == [93]", "assert apps_run2(1, [(1, 4, 2, 5, 2)]) == [0]", "try:\n    apps_run2(0, [(1, 1, 1, 1, 1)])\nexcept InvalidMatrixSizeError as e:\n    assert str(e) == \"Number of requests must be between 1 and 10,000.\""], "requirement_type": "PROMPT_ERROR_HANDLING"}
{"task_id": "APPS/2015-1", "raw_problem": "Gennady is one of the best child dentists in Berland. Today n children got an appointment with him, they lined up in front of his office.\n\nAll children love to cry loudly at the reception at the dentist. We enumerate the children with integers from 1 to n in the order they go in the line. Every child is associated with the value of his cofidence p_{i}. The children take turns one after another to come into the office; each time the child that is the first in the line goes to the doctor.\n\nWhile Gennady treats the teeth of the i-th child, the child is crying with the volume of v_{i}. At that the confidence of the first child in the line is reduced by the amount of v_{i}, the second one \u2014 by value v_{i} - 1, and so on. The children in the queue after the v_{i}-th child almost do not hear the crying, so their confidence remains unchanged.\n\nIf at any point in time the confidence of the j-th child is less than zero, he begins to cry with the volume of d_{j} and leaves the line, running towards the exit, without going to the doctor's office. At this the confidence of all the children after the j-th one in the line is reduced by the amount of d_{j}.\n\nAll these events occur immediately one after the other in some order. Some cries may lead to other cries, causing a chain reaction. Once in the hallway it is quiet, the child, who is first in the line, goes into the doctor's office.\n\nHelp Gennady the Dentist to determine the numbers of kids, whose teeth he will cure. Print their numbers in the chronological order.\n\n\n-----Input-----\n\nThe first line of the input contains a positive integer n (1 \u2264 n \u2264 4000) \u2014 the number of kids in the line. \n\nNext n lines contain three integers each v_{i}, d_{i}, p_{i} (1 \u2264 v_{i}, d_{i}, p_{i} \u2264 10^6) \u2014 the volume of the cry in the doctor's office, the volume of the cry in the hall and the confidence of the i-th child.\n\n\n-----Output-----\n\nIn the first line print number k \u2014 the number of children whose teeth Gennady will cure.\n\nIn the second line print k integers \u2014 the numbers of the children who will make it to the end of the line in the increasing order.\n\n\n-----Examples-----\nInput\n5\n4 2 2\n4 1 2\n5 2 4\n3 3 5\n5 1 2\n\nOutput\n2\n1 3 \nInput\n5\n4 5 1\n5 3 9\n4 1 2\n2 1 8\n4 1 9\n\nOutput\n4\n1 2 4 5 \n\n\n-----Note-----\n\nIn the first example, Gennady first treats the teeth of the first child who will cry with volume 4. The confidences of the remaining children will get equal to  - 2, 1, 3, 1, respectively. Thus, the second child also cries at the volume of 1 and run to the exit. The confidence of the remaining children will be equal to 0, 2, 0. Then the third child will go to the office, and cry with volume 5. The other children won't bear this, and with a loud cry they will run to the exit.\n\nIn the second sample, first the first child goes into the office, he will cry with volume 4. The confidence of the remaining children will be equal to 5,  - 1, 6, 8. Thus, the third child will cry with the volume of 1 and run to the exit. The confidence of the remaining children will be equal to 5, 5, 7. After that, the second child goes to the office and cry with the volume of 5. The confidences of the remaining children will be equal to 0, 3. Then the fourth child will go into the office and cry with the volume of 2. Because of this the confidence of the fifth child will be 1, and he will go into the office last.", "raw_solution": "def apps_run1(input_str):\n    lines = input_str.strip().split('\\n')\n    n = int(lines[0])\n    v = [list(map(int, line.split())) for line in lines[1:]]\n\n    res = []\n\n    for i in range(n):\n        if v[i][2] >= 0:\n            res.append(i + 1)\n            dec = 0\n            for j in range(i + 1, n):\n                if v[j][2] >= 0:\n                    if v[i][0] > 0:\n                        v[j][2] -= v[i][0]\n                        v[i][0] -= 1\n                    v[j][2] -= dec\n                    if v[j][2] < 0:\n                        dec += v[j][1]\n\n    return f\"{len(res)}\\n{' '.join(map(str, res))} \"", "raw_test_input": ["assert apps_run1('5\\n4 2 2\\n4 1 2\\n5 2 4\\n3 3 5\\n5 1 2\\n') == '2\\n1 3 '", "assert apps_run1('5\\n4 5 1\\n5 3 9\\n4 1 2\\n2 1 8\\n4 1 9\\n') == '4\\n1 2 4 5 '", "assert apps_run1('10\\n10 7 10\\n3 6 11\\n8 4 10\\n10 1 11\\n7 3 13\\n7 2 13\\n7 6 14\\n3 4 17\\n9 4 20\\n5 2 24\\n') == '3\\n1 2 5 '", "assert apps_run1('10\\n5 6 3\\n7 4 10\\n9 1 17\\n2 8 23\\n9 10 24\\n6 8 18\\n3 2 35\\n7 6 6\\n1 3 12\\n9 9 5\\n') == '6\\n1 2 3 4 5 7 '", "assert apps_run1('10\\n4 9 1\\n8 2 14\\n7 10 20\\n6 9 18\\n5 3 19\\n2 9 7\\n6 8 30\\n8 7 38\\n6 5 5\\n6 9 37\\n') == '8\\n1 2 3 4 5 7 8 10 '", "assert apps_run1('10\\n10 3 3\\n8 6 17\\n9 5 26\\n10 7 17\\n3 10 29\\n3 1 27\\n3 3 7\\n8 10 28\\n1 3 23\\n3 4 6\\n') == '5\\n1 2 3 5 8 '", "assert apps_run1('10\\n5 6 1\\n9 2 6\\n4 1 5\\n4 10 5\\n1 8 23\\n9 4 21\\n3 9 6\\n7 8 34\\n7 4 24\\n8 9 21\\n') == '5\\n1 2 5 6 8 '", "assert apps_run1('4\\n2 10 1\\n1 2 2\\n2 1 1\\n5 5 1\\n') == '3\\n1 2 4 '", "assert apps_run1('1\\n1 1 1\\n') == '1\\n1 '", "assert apps_run1('2\\n5 1 1\\n1 1 5\\n') == '2\\n1 2 '", "assert apps_run1('2\\n5 1 1\\n1 1 4\\n') == '1\\n1 '", "assert apps_run1('2\\n5 1 1\\n1 1 6\\n') == '2\\n1 2 '", "assert apps_run1('3\\n5 1 1\\n1 1 4\\n1 1 4\\n') == '1\\n1 '", "assert apps_run1('3\\n5 1 1\\n1 1 4\\n1 1 5\\n') == '2\\n1 3 '", "assert apps_run1('3\\n5 1 1\\n1 1 5\\n1 1 3\\n') == '2\\n1 2 '", "assert apps_run1('3\\n5 1 1\\n10 1 5\\n1000 1000 14\\n') == '3\\n1 2 3 '", "assert apps_run1('10\\n9 8 8\\n2 9 33\\n10 7 42\\n7 2 18\\n3 5 82\\n9 9 25\\n3 2 86\\n3 5 49\\n5 3 72\\n4 4 71\\n') == '10\\n1 2 3 4 5 6 7 8 9 10 '", "assert apps_run1('10\\n9 8 8\\n2 9 8\\n10 7 16\\n7 2 9\\n3 5 23\\n9 9 25\\n3 2 35\\n3 5 36\\n5 3 40\\n4 4 42\\n') == '1\\n1 '"], "new_problem": "Gennady the Dentist is now managing a dental clinic that operates over multiple days. Each day, the children line up in the same order, but their initial confidence levels may vary. The task is to determine which children will have their teeth treated each day, given their initial confidence levels for that day. The crying and confidence reduction mechanics remain the same as before. Help Gennady determine the sequence of children treated each day.", "new_solution": "def treat_children(n, children):\n    res = []\n    for i in range(n):\n        if children[i][2] >= 0:\n            res.append(i + 1)\n            dec = 0\n            for j in range(i + 1, n):\n                if children[j][2] >= 0:\n                    if children[i][0] > 0:\n                        children[j][2] -= children[i][0]\n                        children[i][0] -= 1\n                    children[j][2] -= dec\n                    if children[j][2] < 0: dec += children[j][1]\n    return res\n\ndef apps_run2(n, children, m, daily_confidences):\n    results = []\n    for day in range(m):\n        # Reset the confidence levels for the day\n        for i in range(n):\n            children[i][2] = daily_confidences[day][i]\n        # Determine the sequence of children treated\n        treated_children = treat_children(n, [list(child) for child in children])\n        results.append(treated_children)\n    return results", "input_format": "The first line contains a positive integer n (1 \u2264 n \u2264 4000) \u2014 the number of kids in the line. Next n lines contain three integers each v_{i}, d_{i}, p_{i} (1 \u2264 v_{i}, d_{i}, p_{i} \u2264 10^6) \u2014 the volume of the cry in the doctor's office, the volume of the cry in the hall and the confidence of the i-th child. The next line contains a positive integer m (1 \u2264 m \u2264 100) \u2014 the number of days. Each of the next m lines contains n integers representing the initial confidence of each child at the start of that day.", "output_format": "For each day, print the number of children whose teeth Gennady will cure and their indices in chronological order.", "test_input": ["assert apps_run2(5, [[4, 2, 2], [4, 1, 2], [5, 2, 4], [3, 3, 5], [5, 1, 2]], 2, [[2, 2, 4, 5, 2], [1, 9, 2, 8, 9]]) == [[1, 3], [1, 2, 4, 5]]", "assert apps_run2(3, [[3, 1, 3], [2, 2, 2], [1, 1, 1]], 1, [[3, 2, 1]]) == [[1]]", "assert apps_run2(4, [[5, 3, 5], [4, 2, 4], [3, 1, 3], [2, 1, 2]], 3, [[5, 4, 3, 2], [4, 3, 2, 1], [6, 5, 4, 3]]) == [[1], [1], [1, 2]]", "assert apps_run2(2, [[1, 1, 1], [1, 1, 1]], 2, [[1, 1], [2, 2]]) == [[1, 2], [1, 2]]", "assert apps_run2(6, [[6, 2, 6], [5, 3, 5], [4, 2, 4], [3, 1, 3], [2, 1, 2], [1, 1, 1]], 1, [[6, 5, 4, 3, 2, 1]]) == [[1]]"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "APPS/2015-2", "raw_problem": "Gennady is one of the best child dentists in Berland. Today n children got an appointment with him, they lined up in front of his office.\n\nAll children love to cry loudly at the reception at the dentist. We enumerate the children with integers from 1 to n in the order they go in the line. Every child is associated with the value of his cofidence p_{i}. The children take turns one after another to come into the office; each time the child that is the first in the line goes to the doctor.\n\nWhile Gennady treats the teeth of the i-th child, the child is crying with the volume of v_{i}. At that the confidence of the first child in the line is reduced by the amount of v_{i}, the second one \u2014 by value v_{i} - 1, and so on. The children in the queue after the v_{i}-th child almost do not hear the crying, so their confidence remains unchanged.\n\nIf at any point in time the confidence of the j-th child is less than zero, he begins to cry with the volume of d_{j} and leaves the line, running towards the exit, without going to the doctor's office. At this the confidence of all the children after the j-th one in the line is reduced by the amount of d_{j}.\n\nAll these events occur immediately one after the other in some order. Some cries may lead to other cries, causing a chain reaction. Once in the hallway it is quiet, the child, who is first in the line, goes into the doctor's office.\n\nHelp Gennady the Dentist to determine the numbers of kids, whose teeth he will cure. Print their numbers in the chronological order.\n\n\n-----Input-----\n\nThe first line of the input contains a positive integer n (1 \u2264 n \u2264 4000) \u2014 the number of kids in the line. \n\nNext n lines contain three integers each v_{i}, d_{i}, p_{i} (1 \u2264 v_{i}, d_{i}, p_{i} \u2264 10^6) \u2014 the volume of the cry in the doctor's office, the volume of the cry in the hall and the confidence of the i-th child.\n\n\n-----Output-----\n\nIn the first line print number k \u2014 the number of children whose teeth Gennady will cure.\n\nIn the second line print k integers \u2014 the numbers of the children who will make it to the end of the line in the increasing order.\n\n\n-----Examples-----\nInput\n5\n4 2 2\n4 1 2\n5 2 4\n3 3 5\n5 1 2\n\nOutput\n2\n1 3 \nInput\n5\n4 5 1\n5 3 9\n4 1 2\n2 1 8\n4 1 9\n\nOutput\n4\n1 2 4 5 \n\n\n-----Note-----\n\nIn the first example, Gennady first treats the teeth of the first child who will cry with volume 4. The confidences of the remaining children will get equal to  - 2, 1, 3, 1, respectively. Thus, the second child also cries at the volume of 1 and run to the exit. The confidence of the remaining children will be equal to 0, 2, 0. Then the third child will go to the office, and cry with volume 5. The other children won't bear this, and with a loud cry they will run to the exit.\n\nIn the second sample, first the first child goes into the office, he will cry with volume 4. The confidence of the remaining children will be equal to 5,  - 1, 6, 8. Thus, the third child will cry with the volume of 1 and run to the exit. The confidence of the remaining children will be equal to 5, 5, 7. After that, the second child goes to the office and cry with the volume of 5. The confidences of the remaining children will be equal to 0, 3. Then the fourth child will go into the office and cry with the volume of 2. Because of this the confidence of the fifth child will be 1, and he will go into the office last.", "raw_solution": "def apps_run1(input_str):\n    input_lines = input_str.strip().split('\\n')\n    n = int(input_lines[0])\n    v = [list(map(int, line.split())) for line in input_lines[1:n+1]]\n\n    res = []\n\n    for i in range(n):\n        if v[i][2] >= 0:\n            res.append(i + 1)\n            dec = 0\n            for j in range(i + 1, n):\n                if v[j][2] >= 0:\n                    if v[i][0] > 0:\n                        v[j][2] -= v[i][0]\n                        v[i][0] -= 1\n                    v[j][2] -= dec\n                    if v[j][2] < 0:\n                        dec += v[j][1]\n\n    return f\"{len(res)}\\n{' '.join(map(str, res))} \"", "raw_test_input": ["assert apps_run1('5\\n4 2 2\\n4 1 2\\n5 2 4\\n3 3 5\\n5 1 2\\n') == '2\\n1 3 '", "assert apps_run1('5\\n4 5 1\\n5 3 9\\n4 1 2\\n2 1 8\\n4 1 9\\n') == '4\\n1 2 4 5 '", "assert apps_run1('10\\n10 7 10\\n3 6 11\\n8 4 10\\n10 1 11\\n7 3 13\\n7 2 13\\n7 6 14\\n3 4 17\\n9 4 20\\n5 2 24\\n') == '3\\n1 2 5 '", "assert apps_run1('10\\n5 6 3\\n7 4 10\\n9 1 17\\n2 8 23\\n9 10 24\\n6 8 18\\n3 2 35\\n7 6 6\\n1 3 12\\n9 9 5\\n') == '6\\n1 2 3 4 5 7 '", "assert apps_run1('10\\n4 9 1\\n8 2 14\\n7 10 20\\n6 9 18\\n5 3 19\\n2 9 7\\n6 8 30\\n8 7 38\\n6 5 5\\n6 9 37\\n') == '8\\n1 2 3 4 5 7 8 10 '", "assert apps_run1('10\\n10 3 3\\n8 6 17\\n9 5 26\\n10 7 17\\n3 10 29\\n3 1 27\\n3 3 7\\n8 10 28\\n1 3 23\\n3 4 6\\n') == '5\\n1 2 3 5 8 '", "assert apps_run1('10\\n5 6 1\\n9 2 6\\n4 1 5\\n4 10 5\\n1 8 23\\n9 4 21\\n3 9 6\\n7 8 34\\n7 4 24\\n8 9 21\\n') == '5\\n1 2 5 6 8 '", "assert apps_run1('4\\n2 10 1\\n1 2 2\\n2 1 1\\n5 5 1\\n') == '3\\n1 2 4 '", "assert apps_run1('1\\n1 1 1\\n') == '1\\n1 '", "assert apps_run1('2\\n5 1 1\\n1 1 5\\n') == '2\\n1 2 '", "assert apps_run1('2\\n5 1 1\\n1 1 4\\n') == '1\\n1 '", "assert apps_run1('2\\n5 1 1\\n1 1 6\\n') == '2\\n1 2 '", "assert apps_run1('3\\n5 1 1\\n1 1 4\\n1 1 4\\n') == '1\\n1 '", "assert apps_run1('3\\n5 1 1\\n1 1 4\\n1 1 5\\n') == '2\\n1 3 '", "assert apps_run1('3\\n5 1 1\\n1 1 5\\n1 1 3\\n') == '2\\n1 2 '", "assert apps_run1('3\\n5 1 1\\n10 1 5\\n1000 1000 14\\n') == '3\\n1 2 3 '", "assert apps_run1('10\\n9 8 8\\n2 9 33\\n10 7 42\\n7 2 18\\n3 5 82\\n9 9 25\\n3 2 86\\n3 5 49\\n5 3 72\\n4 4 71\\n') == '10\\n1 2 3 4 5 6 7 8 9 10 '", "assert apps_run1('10\\n9 8 8\\n2 9 8\\n10 7 16\\n7 2 9\\n3 5 23\\n9 9 25\\n3 2 35\\n3 5 36\\n5 3 40\\n4 4 42\\n') == '1\\n1 '"], "new_problem": "Gennady is one of the best child dentists in Berland. Today n children got an appointment with him, they lined up in front of his office. All children love to cry loudly at the reception at the dentist. We enumerate the children with integers from 1 to n in the order they go in the line. Every child is associated with the value of his confidence p_{i}. The children take turns one after another to come into the office; each time the child that is the first in the line goes to the doctor. While Gennady treats the teeth of the i-th child, the child is crying with the volume of v_{i}. At that the confidence of the first child in the line is reduced by the amount of v_{i}, the second one \u2014 by value v_{i} - 1, and so on. The children in the queue after the v_{i}-th child almost do not hear the crying, so their confidence remains unchanged. If at any point in time the confidence of the j-th child is less than zero, he begins to cry with the volume of d_{j} and leaves the line, running towards the exit, without going to the doctor's office. At this the confidence of all the children after the j-th one in the line is reduced by the amount of d_{j}. All these events occur immediately one after the other in some order. Some cries may lead to other cries, causing a chain reaction. Once in the hallway it is quiet, the child, who is first in the line, goes into the doctor's office. Additionally, each child may have a time t_{i} they take in the office, which is optional. Help Gennady the Dentist to determine the numbers of kids, whose teeth he will cure. Print their numbers in the chronological order.", "new_solution": "from typing import List, Tuple, Optional\ndef apps_run2(n: int, children: List[Tuple[int, int, int, Optional[int]]]) -> Tuple[int, List[int]]:\n    children = [list(child) for child in children]\n    res = []\n\n    for i in range(n):\n        if children[i][2] >= 0:\n            res.append(i + 1)\n            current_v = children[i][0]\n            dec = 0  \n            \n            for j in range(i + 1, n):\n                if children[j][2] >= 0:\n                    if current_v > 0:\n                        children[j][2] -= current_v\n                        current_v -= 1\n\n                    children[j][2] -= dec\n\n                    if children[j][2] < 0:\n                        dec += children[j][1]\n\n    return len(res), res", "input_format": "The first line of the input contains a positive integer n (1 \u2264 n \u2264 4000) \u2014 the number of kids in the line. Next n lines contain three integers each v_{i}, d_{i}, p_{i} (1 \u2264 v_{i}, d_{i}, p_{i} \u2264 10^6) \u2014 the volume of the cry in the doctor's office, the volume of the cry in the hall and the confidence of the i-th child. Optionally, a fourth integer t_{i} (0 \u2264 t_{i} \u2264 100) can be provided, representing the time each child takes in the office.", "output_format": "In the first line print number k \u2014 the number of children whose teeth Gennady will cure. In the second line print k integers \u2014 the numbers of the children who will make it to the end of the line in the increasing order.", "test_input": ["assert apps_run2(5, [(4, 2, 2, None), (4, 1, 2, None), (5, 2, 4, None), (3, 3, 5, None), (5, 1, 2, None)]) == (2, [1, 3])", "assert apps_run2(5, [(4, 5, 1, None), (5, 3, 9, None), (4, 1, 2, None), (2, 1, 8, None), (4, 1, 9, None)]) == (4, [1, 2, 4, 5])", "assert apps_run2(3, [(1, 1, 1, 10), (1, 1, 1, 20), (1, 1, 1, 30)]) == (3, [1, 2, 3])", "assert apps_run2(4, [(3, 2, 5, 15), (2, 1, 3, 25), (1, 1, 2, 35), (4, 3, 6, 45)]) == (3, [1, 2, 4])", "assert apps_run2(2, [(5, 5, 5, None), (5, 5, 5, None)]) == (2, [1, 2])"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "APPS/2015-3", "raw_problem": "Gennady is one of the best child dentists in Berland. Today n children got an appointment with him, they lined up in front of his office.\n\nAll children love to cry loudly at the reception at the dentist. We enumerate the children with integers from 1 to n in the order they go in the line. Every child is associated with the value of his cofidence p_{i}. The children take turns one after another to come into the office; each time the child that is the first in the line goes to the doctor.\n\nWhile Gennady treats the teeth of the i-th child, the child is crying with the volume of v_{i}. At that the confidence of the first child in the line is reduced by the amount of v_{i}, the second one \u2014 by value v_{i} - 1, and so on. The children in the queue after the v_{i}-th child almost do not hear the crying, so their confidence remains unchanged.\n\nIf at any point in time the confidence of the j-th child is less than zero, he begins to cry with the volume of d_{j} and leaves the line, running towards the exit, without going to the doctor's office. At this the confidence of all the children after the j-th one in the line is reduced by the amount of d_{j}.\n\nAll these events occur immediately one after the other in some order. Some cries may lead to other cries, causing a chain reaction. Once in the hallway it is quiet, the child, who is first in the line, goes into the doctor's office.\n\nHelp Gennady the Dentist to determine the numbers of kids, whose teeth he will cure. Print their numbers in the chronological order.\n\n\n-----Input-----\n\nThe first line of the input contains a positive integer n (1 \u2264 n \u2264 4000) \u2014 the number of kids in the line. \n\nNext n lines contain three integers each v_{i}, d_{i}, p_{i} (1 \u2264 v_{i}, d_{i}, p_{i} \u2264 10^6) \u2014 the volume of the cry in the doctor's office, the volume of the cry in the hall and the confidence of the i-th child.\n\n\n-----Output-----\n\nIn the first line print number k \u2014 the number of children whose teeth Gennady will cure.\n\nIn the second line print k integers \u2014 the numbers of the children who will make it to the end of the line in the increasing order.\n\n\n-----Examples-----\nInput\n5\n4 2 2\n4 1 2\n5 2 4\n3 3 5\n5 1 2\n\nOutput\n2\n1 3 \nInput\n5\n4 5 1\n5 3 9\n4 1 2\n2 1 8\n4 1 9\n\nOutput\n4\n1 2 4 5 \n\n\n-----Note-----\n\nIn the first example, Gennady first treats the teeth of the first child who will cry with volume 4. The confidences of the remaining children will get equal to  - 2, 1, 3, 1, respectively. Thus, the second child also cries at the volume of 1 and run to the exit. The confidence of the remaining children will be equal to 0, 2, 0. Then the third child will go to the office, and cry with volume 5. The other children won't bear this, and with a loud cry they will run to the exit.\n\nIn the second sample, first the first child goes into the office, he will cry with volume 4. The confidence of the remaining children will be equal to 5,  - 1, 6, 8. Thus, the third child will cry with the volume of 1 and run to the exit. The confidence of the remaining children will be equal to 5, 5, 7. After that, the second child goes to the office and cry with the volume of 5. The confidences of the remaining children will be equal to 0, 3. Then the fourth child will go into the office and cry with the volume of 2. Because of this the confidence of the fifth child will be 1, and he will go into the office last.", "raw_solution": "def apps_run1(input_str):\n    input_lines = input_str.strip().split('\\n')\n    n = int(input_lines[0])\n    v = [list(map(int, line.split())) for line in input_lines[1:n+1]]\n\n    res = []\n\n    for i in range(n):\n        if v[i][2] >= 0:\n            res.append(i + 1)\n            dec = 0\n            for j in range(i + 1, n):\n                if v[j][2] >= 0:\n                    if v[i][0] > 0:\n                        v[j][2] -= v[i][0]\n                        v[i][0] -= 1\n                    v[j][2] -= dec\n                    if v[j][2] < 0: dec += v[j][1]\n\n    return f\"{len(res)}\\n{' '.join(map(str, res))} \"", "raw_test_input": ["assert apps_run1('5\\n4 2 2\\n4 1 2\\n5 2 4\\n3 3 5\\n5 1 2\\n') == '2\\n1 3 '", "assert apps_run1('5\\n4 5 1\\n5 3 9\\n4 1 2\\n2 1 8\\n4 1 9\\n') == '4\\n1 2 4 5 '", "assert apps_run1('10\\n10 7 10\\n3 6 11\\n8 4 10\\n10 1 11\\n7 3 13\\n7 2 13\\n7 6 14\\n3 4 17\\n9 4 20\\n5 2 24\\n') == '3\\n1 2 5 '", "assert apps_run1('10\\n5 6 3\\n7 4 10\\n9 1 17\\n2 8 23\\n9 10 24\\n6 8 18\\n3 2 35\\n7 6 6\\n1 3 12\\n9 9 5\\n') == '6\\n1 2 3 4 5 7 '", "assert apps_run1('10\\n4 9 1\\n8 2 14\\n7 10 20\\n6 9 18\\n5 3 19\\n2 9 7\\n6 8 30\\n8 7 38\\n6 5 5\\n6 9 37\\n') == '8\\n1 2 3 4 5 7 8 10 '", "assert apps_run1('10\\n10 3 3\\n8 6 17\\n9 5 26\\n10 7 17\\n3 10 29\\n3 1 27\\n3 3 7\\n8 10 28\\n1 3 23\\n3 4 6\\n') == '5\\n1 2 3 5 8 '", "assert apps_run1('10\\n5 6 1\\n9 2 6\\n4 1 5\\n4 10 5\\n1 8 23\\n9 4 21\\n3 9 6\\n7 8 34\\n7 4 24\\n8 9 21\\n') == '5\\n1 2 5 6 8 '", "assert apps_run1('4\\n2 10 1\\n1 2 2\\n2 1 1\\n5 5 1\\n') == '3\\n1 2 4 '", "assert apps_run1('1\\n1 1 1\\n') == '1\\n1 '", "assert apps_run1('2\\n5 1 1\\n1 1 5\\n') == '2\\n1 2 '", "assert apps_run1('2\\n5 1 1\\n1 1 4\\n') == '1\\n1 '", "assert apps_run1('2\\n5 1 1\\n1 1 6\\n') == '2\\n1 2 '", "assert apps_run1('3\\n5 1 1\\n1 1 4\\n1 1 4\\n') == '1\\n1 '", "assert apps_run1('3\\n5 1 1\\n1 1 4\\n1 1 5\\n') == '2\\n1 3 '", "assert apps_run1('3\\n5 1 1\\n1 1 5\\n1 1 3\\n') == '2\\n1 2 '", "assert apps_run1('3\\n5 1 1\\n10 1 5\\n1000 1000 14\\n') == '3\\n1 2 3 '", "assert apps_run1('10\\n9 8 8\\n2 9 33\\n10 7 42\\n7 2 18\\n3 5 82\\n9 9 25\\n3 2 86\\n3 5 49\\n5 3 72\\n4 4 71\\n') == '10\\n1 2 3 4 5 6 7 8 9 10 '", "assert apps_run1('10\\n9 8 8\\n2 9 8\\n10 7 16\\n7 2 9\\n3 5 23\\n9 9 25\\n3 2 35\\n3 5 36\\n5 3 40\\n4 4 42\\n') == '1\\n1 '"], "new_problem": "Gennady is one of the best child dentists in Berland. Today n children got an appointment with him, and they lined up in front of his office. Each child is associated with a unique ID and a set of attributes: the volume of their cry in the doctor's office, the volume of their cry in the hall, and their confidence level. The children take turns one after another to come into the office; each time the child that is first in the line goes to the doctor. While Gennady treats the teeth of the i-th child, the child cries with a certain volume, affecting the confidence of the children behind them in line. If a child's confidence drops below zero, they cry and leave the line, affecting the confidence of those behind them. The task is to determine which children will have their teeth treated. However, the data is now stored in a dictionary where each key is a child's ID and the value is a tuple of their attributes. Additionally, the children are now organized in a binary tree structure based on their initial confidence levels, and the traversal of this tree determines the order in which they are treated. Implement a solution that uses this new data structure and includes type hints.", "new_solution": "from typing import Dict, Tuple, List\n\nclass TreeNode:\n    def __init__(self, child_id: int, confidence: int):\n        self.child_id = child_id\n        self.confidence = confidence\n        self.left = None\n        self.right = None\n\n\ndef insert(root: TreeNode, child_id: int, confidence: int) -> TreeNode:\n    if root is None:\n        return TreeNode(child_id, confidence)\n    if confidence < root.confidence:\n        root.left = insert(root.left, child_id, confidence)\n    else:\n        root.right = insert(root.right, child_id, confidence)\n    return root\n\n\ndef inorder_traversal(root: TreeNode, result: List[int]) -> None:\n    if root is not None:\n        inorder_traversal(root.left, result)\n        result.append(root.child_id)\n        inorder_traversal(root.right, result)\n\n\ndef apps_run2(children: Dict[int, Tuple[int, int, int]]) -> List[int]:\n    n = len(children)\n    root = None\n    for child_id, (v_i, d_i, p_i) in children.items():\n        root = insert(root, child_id, p_i)\n\n    order = []\n    inorder_traversal(root, order)\n\n    res = []\n    for i in order:\n        if children[i][2] >= 0:\n            res.append(i)\n            dec = 0\n            for j in order:\n                if j > i and children[j][2] >= 0:\n                    if children[i][0] > 0:\n                        children[j] = (children[j][0], children[j][1], children[j][2] - children[i][0])\n                        children[i] = (children[i][0] - 1, children[i][1], children[i][2])\n                    children[j] = (children[j][0], children[j][1], children[j][2] - dec)\n                    if children[j][2] < 0:\n                        dec += children[j][1]\n\n    return res", "input_format": "The first line contains a positive integer n (1 \u2264 n \u2264 4000) \u2014 the number of kids in the line. Next n lines contain three integers each v_{i}, d_{i}, p_{i} (1 \u2264 v_{i}, d_{i}, p_{i} \u2264 10^6) \u2014 the volume of the cry in the doctor's office, the volume of the cry in the hall, and the confidence of the i-th child.", "output_format": "In the first line, print number k \u2014 the number of children whose teeth Gennady will cure. In the second line, print k integers \u2014 the numbers of the children who will make it to the end of the line in increasing order.", "test_input": ["assert apps_run2({1: (4, 2, 2), 2: (4, 1, 2), 3: (5, 2, 4), 4: (3, 3, 5), 5: (5, 1, 2)}) == [1, 3]", "assert apps_run2({1: (4, 5, 1), 2: (5, 3, 9), 3: (4, 1, 2), 4: (2, 1, 8), 5: (4, 1, 9)}) == [1, 4, 2, 5]", "assert apps_run2({1: (3, 2, 5), 2: (2, 1, 3), 3: (1, 1, 1)}) == [3, 2, 1]", "assert apps_run2({1: (5, 2, 10), 2: (3, 1, 5), 3: (4, 2, 8), 4: (2, 1, 6)}) == [2, 4, 3, 1]", "assert apps_run2({1: (1, 1, 1), 2: (1, 1, 1), 3: (1, 1, 1), 4: (1, 1, 1)}) == [1, 2, 3, 4]"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "APPS/2015-4", "raw_problem": "Gennady is one of the best child dentists in Berland. Today n children got an appointment with him, they lined up in front of his office.\n\nAll children love to cry loudly at the reception at the dentist. We enumerate the children with integers from 1 to n in the order they go in the line. Every child is associated with the value of his cofidence p_{i}. The children take turns one after another to come into the office; each time the child that is the first in the line goes to the doctor.\n\nWhile Gennady treats the teeth of the i-th child, the child is crying with the volume of v_{i}. At that the confidence of the first child in the line is reduced by the amount of v_{i}, the second one \u2014 by value v_{i} - 1, and so on. The children in the queue after the v_{i}-th child almost do not hear the crying, so their confidence remains unchanged.\n\nIf at any point in time the confidence of the j-th child is less than zero, he begins to cry with the volume of d_{j} and leaves the line, running towards the exit, without going to the doctor's office. At this the confidence of all the children after the j-th one in the line is reduced by the amount of d_{j}.\n\nAll these events occur immediately one after the other in some order. Some cries may lead to other cries, causing a chain reaction. Once in the hallway it is quiet, the child, who is first in the line, goes into the doctor's office.\n\nHelp Gennady the Dentist to determine the numbers of kids, whose teeth he will cure. Print their numbers in the chronological order.\n\n\n-----Input-----\n\nThe first line of the input contains a positive integer n (1 \u2264 n \u2264 4000) \u2014 the number of kids in the line. \n\nNext n lines contain three integers each v_{i}, d_{i}, p_{i} (1 \u2264 v_{i}, d_{i}, p_{i} \u2264 10^6) \u2014 the volume of the cry in the doctor's office, the volume of the cry in the hall and the confidence of the i-th child.\n\n\n-----Output-----\n\nIn the first line print number k \u2014 the number of children whose teeth Gennady will cure.\n\nIn the second line print k integers \u2014 the numbers of the children who will make it to the end of the line in the increasing order.\n\n\n-----Examples-----\nInput\n5\n4 2 2\n4 1 2\n5 2 4\n3 3 5\n5 1 2\n\nOutput\n2\n1 3 \nInput\n5\n4 5 1\n5 3 9\n4 1 2\n2 1 8\n4 1 9\n\nOutput\n4\n1 2 4 5 \n\n\n-----Note-----\n\nIn the first example, Gennady first treats the teeth of the first child who will cry with volume 4. The confidences of the remaining children will get equal to  - 2, 1, 3, 1, respectively. Thus, the second child also cries at the volume of 1 and run to the exit. The confidence of the remaining children will be equal to 0, 2, 0. Then the third child will go to the office, and cry with volume 5. The other children won't bear this, and with a loud cry they will run to the exit.\n\nIn the second sample, first the first child goes into the office, he will cry with volume 4. The confidence of the remaining children will be equal to 5,  - 1, 6, 8. Thus, the third child will cry with the volume of 1 and run to the exit. The confidence of the remaining children will be equal to 5, 5, 7. After that, the second child goes to the office and cry with the volume of 5. The confidences of the remaining children will be equal to 0, 3. Then the fourth child will go into the office and cry with the volume of 2. Because of this the confidence of the fifth child will be 1, and he will go into the office last.", "raw_solution": "def apps_run1(input_str):\n    input_lines = input_str.strip().split('\\n')\n    n = int(input_lines[0])\n    v = [list(map(int, line.split())) for line in input_lines[1:]]\n\n    res = []\n\n    for i in range(n):\n        if v[i][2] >= 0:\n            res.append(i + 1)\n            dec = 0\n            for j in range(i + 1, n):\n                if v[j][2] >= 0:\n                    if v[i][0] > 0:\n                        v[j][2] -= v[i][0]\n                        v[i][0] -= 1\n                    v[j][2] -= dec\n                    if v[j][2] < 0:\n                        dec += v[j][1]\n\n    return f\"{len(res)}\\n{' '.join(map(str, res))} \"", "raw_test_input": ["assert apps_run1('5\\n4 2 2\\n4 1 2\\n5 2 4\\n3 3 5\\n5 1 2\\n') == '2\\n1 3 '", "assert apps_run1('5\\n4 5 1\\n5 3 9\\n4 1 2\\n2 1 8\\n4 1 9\\n') == '4\\n1 2 4 5 '", "assert apps_run1('10\\n10 7 10\\n3 6 11\\n8 4 10\\n10 1 11\\n7 3 13\\n7 2 13\\n7 6 14\\n3 4 17\\n9 4 20\\n5 2 24\\n') == '3\\n1 2 5 '", "assert apps_run1('10\\n5 6 3\\n7 4 10\\n9 1 17\\n2 8 23\\n9 10 24\\n6 8 18\\n3 2 35\\n7 6 6\\n1 3 12\\n9 9 5\\n') == '6\\n1 2 3 4 5 7 '", "assert apps_run1('10\\n4 9 1\\n8 2 14\\n7 10 20\\n6 9 18\\n5 3 19\\n2 9 7\\n6 8 30\\n8 7 38\\n6 5 5\\n6 9 37\\n') == '8\\n1 2 3 4 5 7 8 10 '", "assert apps_run1('10\\n10 3 3\\n8 6 17\\n9 5 26\\n10 7 17\\n3 10 29\\n3 1 27\\n3 3 7\\n8 10 28\\n1 3 23\\n3 4 6\\n') == '5\\n1 2 3 5 8 '", "assert apps_run1('10\\n5 6 1\\n9 2 6\\n4 1 5\\n4 10 5\\n1 8 23\\n9 4 21\\n3 9 6\\n7 8 34\\n7 4 24\\n8 9 21\\n') == '5\\n1 2 5 6 8 '", "assert apps_run1('4\\n2 10 1\\n1 2 2\\n2 1 1\\n5 5 1\\n') == '3\\n1 2 4 '", "assert apps_run1('1\\n1 1 1\\n') == '1\\n1 '", "assert apps_run1('2\\n5 1 1\\n1 1 5\\n') == '2\\n1 2 '", "assert apps_run1('2\\n5 1 1\\n1 1 4\\n') == '1\\n1 '", "assert apps_run1('2\\n5 1 1\\n1 1 6\\n') == '2\\n1 2 '", "assert apps_run1('3\\n5 1 1\\n1 1 4\\n1 1 4\\n') == '1\\n1 '", "assert apps_run1('3\\n5 1 1\\n1 1 4\\n1 1 5\\n') == '2\\n1 3 '", "assert apps_run1('3\\n5 1 1\\n1 1 5\\n1 1 3\\n') == '2\\n1 2 '", "assert apps_run1('3\\n5 1 1\\n10 1 5\\n1000 1000 14\\n') == '3\\n1 2 3 '", "assert apps_run1('10\\n9 8 8\\n2 9 33\\n10 7 42\\n7 2 18\\n3 5 82\\n9 9 25\\n3 2 86\\n3 5 49\\n5 3 72\\n4 4 71\\n') == '10\\n1 2 3 4 5 6 7 8 9 10 '", "assert apps_run1('10\\n9 8 8\\n2 9 8\\n10 7 16\\n7 2 9\\n3 5 23\\n9 9 25\\n3 2 35\\n3 5 36\\n5 3 40\\n4 4 42\\n') == '1\\n1 '"], "new_problem": "Gennady is one of the best child dentists in Berland. Today n children got an appointment with him, they lined up in front of his office. Each child is associated with the value of his confidence p_{i}. The children take turns one after another to come into the office; each time the child that is the first in the line goes to the doctor. While Gennady treats the teeth of the i-th child, the child is crying with the volume of v_{i}. At that the confidence of the first child in the line is reduced by the amount of v_{i}, the second one \u2014 by value v_{i} - 1, and so on. The children in the queue after the v_{i}-th child almost do not hear the crying, so their confidence remains unchanged. If at any point in time the confidence of the j-th child is less than zero, he begins to cry with the volume of d_{j} and leaves the line, running towards the exit, without going to the doctor's office. At this the confidence of all the children after the j-th one in the line is reduced by the amount of d_{j}. All these events occur immediately one after the other in some order. Some cries may lead to other cries, causing a chain reaction. Once in the hallway it is quiet, the child, who is first in the line, goes into the doctor's office. However, due to a recent system update, the input data might contain errors such as negative values for n, v_{i}, d_{i}, or p_{i}, or non-integer values. Implement error handling to manage these scenarios. Define specific error types for invalid input data and handle error propagation. Ensure that the solution maintains type hints and provides meaningful error messages.", "new_solution": "from typing import List, Tuple\nclass InvalidInputError(Exception):\n    pass\nclass NegativeValueError(InvalidInputError):\n    pass\nclass NonIntegerValueError(InvalidInputError):\n    pass\n\ndef apps_run2(n: int, children_data: List[Tuple[int, int, int]]) -> Tuple[int, List[int]]:\n    children = []\n    for child in children_data:\n        if not all(isinstance(x, int) for x in child):\n            raise NonIntegerValueError(\"All values must be integers\")\n        children.append(list(child))\n\n    if n <= 0:\n        raise NegativeValueError(\"Number of children must be positive.\")\n    for v_i, d_i, p_i in children:\n        if v_i < 0 or d_i < 0 or p_i < 0:\n            raise NegativeValueError(\"Values must be non-negative\")\n\n    res = []\n    for i in range(n):\n        if children[i][2] >= 0:\n            res.append(i + 1)\n            current_v = children[i][0]\n            dec = 0\n\n            for j in range(i + 1, n):\n                if children[j][2] >= 0:\n                    if current_v > 0:\n                        children[j][2] -= current_v\n                        current_v -= 1\n                    children[j][2] -= dec\n                    if children[j][2] < 0:\n                        dec += children[j][1]\n\n    return len(res), res", "input_format": "The first line of the input contains a positive integer n (1 \u2264 n \u2264 4000) \u2014 the number of kids in the line. Next n lines contain three integers each v_{i}, d_{i}, p_{i} (1 \u2264 v_{i}, d_{i}, p_{i} \u2264 10^6) \u2014 the volume of the cry in the doctor's office, the volume of the cry in the hall and the confidence of the i-th child.", "output_format": "In the first line print number k \u2014 the number of children whose teeth Gennady will cure. In the second line print k integers \u2014 the numbers of the children who will make it to the end of the line in the increasing order.", "test_input": ["assert apps_run2(5, [(4, 2, 2), (4, 1, 2), (5, 2, 4), (3, 3, 5), (5, 1, 2)]) == (2, [1, 3])", "assert apps_run2(5, [(4, 5, 1), (5, 3, 9), (4, 1, 2), (2, 1, 8), (4, 1, 9)]) == (4, [1, 2, 4, 5])", "try:\n    apps_run2(-1, [(4, 2, 2), (4, 1, 2)])\nexcept NegativeValueError as e:\n    assert str(e) == \"Number of children must be positive.\"", "try:\n    apps_run2(5, [(4, 2, 2), (4, 1, -2), (5, 2, 4), (3, 3, 5), (5, 1, 2)])\nexcept NegativeValueError as e:\n    assert str(e) == \"Values must be non-negative\"", "try:\n    apps_run2(5, [(4, 2, 2), (4, 1, 'two'), (5, 2, 4), (3, 3, 5), (5, 1, 2)])\nexcept NonIntegerValueError as e:\n    assert str(e) == \"All values must be integers\""], "requirement_type": "PROMPT_ERROR_HANDLING"}
{"task_id": "APPS/2016-1", "raw_problem": "Alex decided to go on a touristic trip over the country.\n\nFor simplicity let's assume that the country has $n$ cities and $m$ bidirectional roads connecting them. Alex lives in city $s$ and initially located in it. To compare different cities Alex assigned each city a score $w_i$ which is as high as interesting city seems to Alex.\n\nAlex believes that his trip will be interesting only if he will not use any road twice in a row. That is if Alex came to city $v$ from city $u$, he may choose as the next city in the trip any city connected with $v$ by the road, except for the city $u$.\n\nYour task is to help Alex plan his city in a way that maximizes total score over all cities he visited. Note that for each city its score is counted at most once, even if Alex been there several times during his trip.\n\n\n-----Input-----\n\nFirst line of input contains two integers $n$ and $m$, ($1 \\le n \\le 2 \\cdot 10^5$, $0 \\le m \\le 2 \\cdot 10^5$) which are numbers of cities and roads in the country.\n\nSecond line contains $n$ integers $w_1, w_2, \\ldots, w_n$ ($0 \\le w_i \\le 10^9$) which are scores of all cities.\n\nThe following $m$ lines contain description of the roads. Each of these $m$ lines contains two integers $u$ and $v$ ($1 \\le u, v \\le n$) which are cities connected by this road.\n\nIt is guaranteed that there is at most one direct road between any two cities, no city is connected to itself by the road and, finally, it is possible to go from any city to any other one using only roads.\n\nThe last line contains single integer $s$ ($1 \\le s \\le n$), which is the number of the initial city.\n\n\n-----Output-----\n\nOutput single integer which is the maximum possible sum of scores of visited cities.\n\n\n-----Examples-----\nInput\n5 7\n2 2 8 6 9\n1 2\n1 3\n2 4\n3 2\n4 5\n2 5\n1 5\n2\n\nOutput\n27\n\nInput\n10 12\n1 7 1 9 3 3 6 30 1 10\n1 2\n1 3\n3 5\n5 7\n2 3\n5 4\n6 9\n4 6\n3 7\n6 8\n9 4\n9 10\n6\n\nOutput\n61.", "raw_solution": "def apps_run1(n, m, weights, edges, start):\n    W = [0] + weights\n    E = edges\n    S = start\n\n    ELIST = [[] for _ in range(n + 1)]\n    EW = [0] * (n + 1)\n\n    for x, y in E:\n        ELIST[x].append(y)\n        ELIST[y].append(x)\n\n        EW[x] += 1\n        EW[y] += 1\n\n    from collections import deque\n    Q = deque()\n    USED = [0] * (n + 1)\n\n    for i in range(1, n + 1):\n        if EW[i] == 1 and i != S:\n            USED[i] = 1\n            Q.append(i)\n\n    EW[S] += 1 << 50\n    USED[S] = 1\n\n    while Q:\n        x = Q.pop()\n        EW[x] -= 1\n\n        for to in ELIST[x]:\n            if USED[to] == 1:\n                continue\n            EW[to] -= 1\n\n            if EW[to] == 1 and USED[to] == 0:\n                Q.append(to)\n                USED[to] = 1\n\n    LOOP = []\n    ANS = 0\n    for i in range(1, n + 1):\n        if EW[i] != 0:\n            ANS += W[i]\n            LOOP.append(i)\n\n    SCORE = [0] * (n + 1)\n    USED = [0] * (n + 1)\n\n    for l in LOOP:\n        SCORE[l] = ANS\n        USED[l] = 1\n\n    Q = deque(LOOP)\n\n    while Q:\n        x = Q.pop()\n\n        for to in ELIST[x]:\n            if USED[to] == 1:\n                continue\n\n            SCORE[to] = W[to] + SCORE[x]\n            Q.append(to)\n            USED[to] = 1\n\n    return max(SCORE)\n", "raw_test_input": ["assert apps_run1(5, 7, [2, 2, 8, 6, 9], [(1, 2), (1, 3), (2, 4), (3, 2), (4, 5), (2, 5), (1, 5)], 2) == 27", "assert apps_run1(10, 12, [1, 7, 1, 9, 3, 3, 6, 30, 1, 10], [(1, 2), (1, 3), (3, 5), (5, 7), (2, 3), (5, 4), (6, 9), (4, 6), (3, 7), (6, 8), (9, 4), (9, 10)], 6) == 61", "assert apps_run1(1, 0, [1000000000], [], 1) == 1000000000", "assert apps_run1(2, 1, [999999999, 2], [(1, 2)], 2) == 1000000001", "assert apps_run1(3, 2, [1, 1335, 2], [(2, 1), (3, 2)], 2) == 1337", "assert apps_run1(3, 3, [1, 1, 1], [(1, 2), (3, 2), (3, 1)], 3) == 3", "assert apps_run1(6, 6, [0, 0, 0, 2, 0, 1], [(1, 2), (2, 3), (3, 1), (3, 4), (1, 6), (5, 3)], 5) == 2", "assert apps_run1(8, 9, [1, 7, 1, 9, 3, 3, 6, 30], [(1, 2), (1, 3), (3, 5), (5, 7), (2, 3), (5, 4), (4, 6), (3, 7), (6, 8)], 6) == 60", "assert apps_run1(8, 9, [0, 2, 10, 0, 1, 0, 4, 1], [(3, 8), (4, 8), (1, 5), (6, 4), (5, 7), (6, 8), (5, 8), (2, 1), (3, 5)], 5) == 16", "assert apps_run1(10, 9, [96, 86, 63, 95, 78, 91, 96, 100, 99, 90], [(10, 5), (1, 2), (8, 7), (4, 5), (4, 6), (3, 8), (6, 7), (3, 9), (10, 2)], 8) == 732", "assert apps_run1(10, 20, [64, 70, 28, 86, 100, 62, 79, 86, 85, 95], [(7, 10), (6, 2), (4, 8), (8, 10), (9, 2), (5, 1), (5, 3), (8, 2), (3, 6), (4, 3), (9, 4), (4, 2), (6, 9), (7, 6), (8, 6), (7, 3), (8, 5), (2, 7), (8, 7), (7, 4)], 4) == 755", "assert apps_run1(10, 9, [0, 1, 0, 1, 2, 1, 1, 1, 2, 1], [(1, 7), (6, 4), (1, 8), (10, 7), (1, 2), (1, 9), (9, 3), (5, 1), (1, 4)], 2) == 3", "assert apps_run1(10, 10, [1, 1, 4, 1, 3, 0, 4, 0, 1, 0], [(3, 9), (3, 2), (4, 5), (10, 7), (4, 8), (5, 3), (5, 7), (7, 1), (6, 7), (1, 8)], 7) == 14", "assert apps_run1(17, 17, [1, 0, 0, 2, 2, 0, 1, 0, 2, 0, 0, 0, 0, 2, 1, 0, 1], [(13, 14), (8, 12), (14, 7), (10, 14), (9, 8), (4, 14), (12, 11), (8, 4), (14, 15), (16, 2), (5, 12), (1, 6), (5, 2), (5, 6), (2, 7), (2, 17), (2, 3)], 1) == 10", "assert apps_run1(30, 30, [81, 86, 81, 91, 90, 100, 98, 89, 96, 97, 88, 99, 68, 45, 82, 92, 94, 80, 99, 67, 70, 90, 81, 74, 91, 100, 92, 89, 74, 98], [(16, 26), (20, 3), (23, 16), (17, 27), (30, 22), (18, 23), (14, 30), (25, 4), (3, 8), (18, 9), (29, 26), (27, 21), (26, 6), (10, 7), (28, 5), (1, 30), (28, 30), (12, 15), (17, 25), (26, 15), (30, 2), (5, 15), (14, 20), (10, 4), (24, 16), (8, 7), (11, 30), (19, 8), (21, 9), (13, 15)], 2) == 1909", "assert apps_run1(10, 45, [1, 0, 2, 2, 2, 1, 1, 2, 1, 0], [(3, 1), (9, 6), (7, 1), (6, 8), (8, 4), (2, 7), (7, 10), (4, 5), (7, 4), (3, 4), (9, 2), (7, 5), (8, 5), (5, 1), (7, 3), (6, 2), (3, 5), (3, 8), (1, 9), (10, 3), (9, 7), (4, 6), (9, 8), (5, 9), (10, 8), (2, 1), (9, 4), (3, 9), (8, 7), (5, 10), (6, 5), (4, 2), (2, 8), (4, 10), (9, 10), (6, 10), (6, 1), (6, 7), (3, 6), (2, 5), (8, 1), (1, 4), (10, 1), (10, 2), (3, 2)], 6) == 12", "assert apps_run1(10, 20, [4, 1, 5, 1, 3, 0, 2, 2, 10, 4], [(10, 6), (10, 4), (2, 5), (6, 3), (2, 9), (1, 7), (5, 10), (5, 6), (5, 3), (3, 4), (9, 6), (1, 8), (10, 9), (10, 3), (9, 4), (4, 6), (6, 2), (3, 8), (9, 5), (8, 2)], 10) == 32", "assert apps_run1(28, 31, [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 1, 0, 1, 0, 0, 1, 1, 1, 0], [(9, 7), (24, 10), (12, 27), (3, 20), (16, 3), (27, 8), (23, 25), (19, 20), (10, 17), (7, 13), (7, 5), (15, 11), (19, 1), (25, 4), (26, 22), (21, 3), (17, 24), (27, 11), (26, 20), (22, 24), (8, 12), (25, 6), (2, 14), (22, 28), (20, 18), (2, 21), (13, 9), (23, 4), (19, 7), (22, 25), (11, 24)], 2) == 9"], "new_problem": "In a country with n cities and m bidirectional roads, k tourists are planning their trips. Each tourist starts from a different city and wants to maximize the total score of the cities they visit, without using any road twice in a row. The task is to calculate the maximum possible sum of scores of visited cities for all tourists combined.", "new_solution": "def max_score_for_tourist(n, m, W, E, S):\n    from collections import deque\n    ELIST = [[] for _ in range(n+1)]\n    EW = [0] * (n+1)\n\n    for x, y in E:\n        ELIST[x].append(y)\n        ELIST[y].append(x)\n        EW[x] += 1\n        EW[y] += 1\n\n    Q = deque()\n    USED = [0] * (n+1)\n\n    for i in range(1, n+1):\n        if EW[i] == 1 and i != S:\n            USED[i] = 1\n            Q.append(i)\n\n    EW[S] += 1 << 50\n    USED[S] = 1\n\n    while Q:\n        x = Q.pop()\n        EW[x] -= 1\n\n        for to in ELIST[x]:\n            if USED[to] == 1:\n                continue\n            EW[to] -= 1\n\n            if EW[to] == 1 and USED[to] == 0:\n                Q.append(to)\n                USED[to] = 1\n\n    ANS = 0\n    LOOP = []\n\n    for i in range(1, n+1):\n        if EW[i] != 0:\n            ANS += W[i]\n            LOOP.append(i)\n\n    SCORE = [0] * (n+1)\n    USED = [0] * (n+1)\n\n    for l in LOOP:\n        SCORE[l] = ANS\n        USED[l] = 1\n\n    Q = deque(LOOP)\n\n    while Q:\n        x = Q.pop()\n\n        for to in ELIST[x]:\n            if USED[to] == 1:\n                continue\n\n            SCORE[to] = W[to] + SCORE[x]\n            Q.append(to)\n            USED[to] = 1\n\n    return max(SCORE)\n\ndef apps_run2(n, m, W, E, tourists):\n    total_score = 0\n    for S in tourists:\n        total_score += max_score_for_tourist(n, m, W, E, S)\n    return total_score\n", "input_format": "The first line contains two integers n and m, representing the number of cities and roads. The second line contains n integers representing the scores of the cities. The next m lines each contain two integers u and v, representing a road between cities u and v. The last line contains an integer s, the starting city. Additionally, the input includes k, the number of tourists, followed by k lines each containing an integer t_i, the starting city for each tourist.", "output_format": "Output a single integer, the maximum possible sum of scores of visited cities for all tourists combined.", "test_input": ["assert apps_run2(5, 7, [0, 2, 2, 8, 6, 9], [(1, 2), (1, 3), (2, 4), (3, 2), (4, 5), (2, 5), (1, 5)], [2, 3]) == 54", "assert apps_run2(10, 12, [0, 1, 7, 1, 9, 3, 3, 6, 30, 1, 10], [(1, 2), (1, 3), (3, 5), (5, 7), (2, 3), (5, 4), (6, 9), (4, 6), (3, 7), (6, 8), (9, 4), (9, 10)], [6, 1]) == 122", "assert apps_run2(3, 2, [0, 5, 10, 15], [(1, 2), (2, 3)], [1, 3]) == 60", "assert apps_run2(4, 3, [0, 4, 5, 6, 7], [(1, 2), (2, 3), (3, 4)], [1, 4]) == 44", "assert apps_run2(6, 5, [0, 1, 2, 3, 4, 5, 6], [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)], [2, 5]) == 35"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "APPS/2016-2", "raw_problem": "Alex decided to go on a touristic trip over the country.\n\nFor simplicity let's assume that the country has $n$ cities and $m$ bidirectional roads connecting them. Alex lives in city $s$ and initially located in it. To compare different cities Alex assigned each city a score $w_i$ which is as high as interesting city seems to Alex.\n\nAlex believes that his trip will be interesting only if he will not use any road twice in a row. That is if Alex came to city $v$ from city $u$, he may choose as the next city in the trip any city connected with $v$ by the road, except for the city $u$.\n\nYour task is to help Alex plan his city in a way that maximizes total score over all cities he visited. Note that for each city its score is counted at most once, even if Alex been there several times during his trip.\n\n\n-----Input-----\n\nFirst line of input contains two integers $n$ and $m$, ($1 \\le n \\le 2 \\cdot 10^5$, $0 \\le m \\le 2 \\cdot 10^5$) which are numbers of cities and roads in the country.\n\nSecond line contains $n$ integers $w_1, w_2, \\ldots, w_n$ ($0 \\le w_i \\le 10^9$) which are scores of all cities.\n\nThe following $m$ lines contain description of the roads. Each of these $m$ lines contains two integers $u$ and $v$ ($1 \\le u, v \\le n$) which are cities connected by this road.\n\nIt is guaranteed that there is at most one direct road between any two cities, no city is connected to itself by the road and, finally, it is possible to go from any city to any other one using only roads.\n\nThe last line contains single integer $s$ ($1 \\le s \\le n$), which is the number of the initial city.\n\n\n-----Output-----\n\nOutput single integer which is the maximum possible sum of scores of visited cities.\n\n\n-----Examples-----\nInput\n5 7\n2 2 8 6 9\n1 2\n1 3\n2 4\n3 2\n4 5\n2 5\n1 5\n2\n\nOutput\n27\n\nInput\n10 12\n1 7 1 9 3 3 6 30 1 10\n1 2\n1 3\n3 5\n5 7\n2 3\n5 4\n6 9\n4 6\n3 7\n6 8\n9 4\n9 10\n6\n\nOutput\n61.", "raw_solution": "def apps_run1(n, m, weights, edges, S):\n    W = [0] + weights\n    E = edges\n    ELIST = [[] for _ in range(n + 1)]\n    EW = [0] * (n + 1)\n\n    for x, y in E:\n        ELIST[x].append(y)\n        ELIST[y].append(x)\n        EW[x] += 1\n        EW[y] += 1\n\n    from collections import deque\n    Q = deque()\n    USED = [0] * (n + 1)\n\n    for i in range(1, n + 1):\n        if EW[i] == 1 and i != S:\n            USED[i] = 1\n            Q.append(i)\n\n    EW[S] += 1 << 50\n    USED[S] = 1\n\n    while Q:\n        x = Q.pop()\n        EW[x] -= 1\n\n        for to in ELIST[x]:\n            if USED[to] == 1:\n                continue\n            EW[to] -= 1\n\n            if EW[to] == 1 and USED[to] == 0:\n                Q.append(to)\n                USED[to] = 1\n\n    LOOP = []\n    ANS = 0\n    for i in range(1, n + 1):\n        if EW[i] != 0:\n            ANS += W[i]\n            LOOP.append(i)\n\n    SCORE = [0] * (n + 1)\n    USED = [0] * (n + 1)\n\n    for l in LOOP:\n        SCORE[l] = ANS\n        USED[l] = 1\n\n    Q = deque(LOOP)\n\n    while Q:\n        x = Q.pop()\n\n        for to in ELIST[x]:\n            if USED[to] == 1:\n                continue\n\n            SCORE[to] = W[to] + SCORE[x]\n            Q.append(to)\n            USED[to] = 1\n\n    return max(SCORE)\n", "raw_test_input": ["assert apps_run1(5, 7, [2, 2, 8, 6, 9], [(1, 2), (1, 3), (2, 4), (3, 2), (4, 5), (2, 5), (1, 5)], 2) == 27", "assert apps_run1(10, 12, [1, 7, 1, 9, 3, 3, 6, 30, 1, 10], [(1, 2), (1, 3), (3, 5), (5, 7), (2, 3), (5, 4), (6, 9), (4, 6), (3, 7), (6, 8), (9, 4), (9, 10)], 6) == 61", "assert apps_run1(1, 0, [1000000000], [], 1) == 1000000000", "assert apps_run1(2, 1, [999999999, 2], [(1, 2)], 2) == 1000000001", "assert apps_run1(3, 2, [1, 1335, 2], [(2, 1), (3, 2)], 2) == 1337", "assert apps_run1(3, 3, [1, 1, 1], [(1, 2), (3, 2), (3, 1)], 3) == 3", "assert apps_run1(6, 6, [0, 0, 0, 2, 0, 1], [(1, 2), (2, 3), (3, 1), (3, 4), (1, 6), (5, 3)], 5) == 2", "assert apps_run1(8, 9, [1, 7, 1, 9, 3, 3, 6, 30], [(1, 2), (1, 3), (3, 5), (5, 7), (2, 3), (5, 4), (4, 6), (3, 7), (6, 8)], 6) == 60", "assert apps_run1(8, 9, [0, 2, 10, 0, 1, 0, 4, 1], [(3, 8), (4, 8), (1, 5), (6, 4), (5, 7), (6, 8), (5, 8), (2, 1), (3, 5)], 5) == 16", "assert apps_run1(10, 9, [96, 86, 63, 95, 78, 91, 96, 100, 99, 90], [(10, 5), (1, 2), (8, 7), (4, 5), (4, 6), (3, 8), (6, 7), (3, 9), (10, 2)], 8) == 732", "assert apps_run1(10, 20, [64, 70, 28, 86, 100, 62, 79, 86, 85, 95], [(7, 10), (6, 2), (4, 8), (8, 10), (9, 2), (5, 1), (5, 3), (8, 2), (3, 6), (4, 3), (9, 4), (4, 2), (6, 9), (7, 6), (8, 6), (7, 3), (8, 5), (2, 7), (8, 7), (7, 4)], 4) == 755", "assert apps_run1(10, 9, [0, 1, 0, 1, 2, 1, 1, 1, 2, 1], [(1, 7), (6, 4), (1, 8), (10, 7), (1, 2), (1, 9), (9, 3), (5, 1), (1, 4)], 2) == 3", "assert apps_run1(10, 10, [1, 1, 4, 1, 3, 0, 4, 0, 1, 0], [(3, 9), (3, 2), (4, 5), (10, 7), (4, 8), (5, 3), (5, 7), (7, 1), (6, 7), (1, 8)], 7) == 14", "assert apps_run1(17, 17, [1, 0, 0, 2, 2, 0, 1, 0, 2, 0, 0, 0, 0, 2, 1, 0, 1], [(13, 14), (8, 12), (14, 7), (10, 14), (9, 8), (4, 14), (12, 11), (8, 4), (14, 15), (16, 2), (5, 12), (1, 6), (5, 2), (5, 6), (2, 7), (2, 17), (2, 3)], 1) == 10", "assert apps_run1(30, 30, [81, 86, 81, 91, 90, 100, 98, 89, 96, 97, 88, 99, 68, 45, 82, 92, 94, 80, 99, 67, 70, 90, 81, 74, 91, 100, 92, 89, 74, 98], [(16, 26), (20, 3), (23, 16), (17, 27), (30, 22), (18, 23), (14, 30), (25, 4), (3, 8), (18, 9), (29, 26), (27, 21), (26, 6), (10, 7), (28, 5), (1, 30), (28, 30), (12, 15), (17, 25), (26, 15), (30, 2), (5, 15), (14, 20), (10, 4), (24, 16), (8, 7), (11, 30), (19, 8), (21, 9), (13, 15)], 2) == 1909", "assert apps_run1(10, 45, [1, 0, 2, 2, 2, 1, 1, 2, 1, 0], [(3, 1), (9, 6), (7, 1), (6, 8), (8, 4), (2, 7), (7, 10), (4, 5), (7, 4), (3, 4), (9, 2), (7, 5), (8, 5), (5, 1), (7, 3), (6, 2), (3, 5), (3, 8), (1, 9), (10, 3), (9, 7), (4, 6), (9, 8), (5, 9), (10, 8), (2, 1), (9, 4), (3, 9), (8, 7), (5, 10), (6, 5), (4, 2), (2, 8), (4, 10), (9, 10), (6, 10), (6, 1), (6, 7), (3, 6), (2, 5), (8, 1), (1, 4), (10, 1), (10, 2), (3, 2)], 6) == 12", "assert apps_run1(10, 20, [4, 1, 5, 1, 3, 0, 2, 2, 10, 4], [(10, 6), (10, 4), (2, 5), (6, 3), (2, 9), (1, 7), (5, 10), (5, 6), (5, 3), (3, 4), (9, 6), (1, 8), (10, 9), (10, 3), (9, 4), (4, 6), (6, 2), (3, 8), (9, 5), (8, 2)], 10) == 32", "assert apps_run1(28, 31, [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 1, 0, 1, 0, 0, 1, 1, 1, 0], [(9, 7), (24, 10), (12, 27), (3, 20), (16, 3), (27, 8), (23, 25), (19, 20), (10, 17), (7, 13), (7, 5), (15, 11), (19, 1), (25, 4), (26, 22), (21, 3), (17, 24), (27, 11), (26, 20), (22, 24), (8, 12), (25, 6), (2, 14), (22, 28), (20, 18), (2, 21), (13, 9), (23, 4), (19, 7), (22, 25), (11, 24)], 2) == 9"], "new_problem": "Alex decided to go on a touristic trip over the country. For simplicity, let's assume that the country has n cities and m bidirectional roads connecting them. Alex lives in city s and is initially located in it. To compare different cities, Alex assigned each city a score w_i, which is as high as the interesting city seems to Alex. Alex believes that his trip will be interesting only if he will not use any road twice in a row. That is, if Alex came to city v from city u, he may choose as the next city in the trip any city connected with v by the road, except for the city u. Your task is to help Alex plan his city in a way that maximizes the total score over all cities he visited. Note that for each city, its score is counted at most once, even if Alex has been there several times during his trip. Additionally, Alex wants to optionally specify a maximum number of cities he can visit during his trip. If this parameter is not provided, he can visit as many cities as possible. The solution must maintain backward compatibility with existing implementations.", "new_solution": "from collections import deque\nfrom typing import List, Tuple, Optional\n\ndef apps_run2(n: int, m: int, W: List[int], E: List[Tuple[int, int]], S: int, max_cities: Optional[int] = None) -> int:\n    W = [0] + W\n    ELIST = [[] for _ in range(n + 1)]\n    EW = [0] * (n + 1)\n\n    for x, y in E:\n        ELIST[x].append(y)\n        ELIST[y].append(x)\n        EW[x] += 1\n        EW[y] += 1\n\n    Q = deque()\n    USED = [0] * (n + 1)\n\n    for i in range(1, n + 1):\n        if EW[i] == 1 and i != S:\n            USED[i] = 1\n            Q.append(i)\n\n    EW[S] += 1 << 50\n    USED[S] = 1\n\n    while Q:\n        x = Q.pop()\n        EW[x] -= 1\n\n        for to in ELIST[x]:\n            if USED[to] == 1:\n                continue\n            EW[to] -= 1\n\n            if EW[to] == 1 and USED[to] == 0:\n                Q.append(to)\n                USED[to] = 1\n\n    LOOP = []\n    ANS = 0\n    for i in range(1, n + 1):\n        if EW[i] != 0:\n            ANS += W[i]\n            LOOP.append(i)\n\n    SCORE = [0] * (n + 1)\n    USED = [0] * (n + 1)\n\n    for l in LOOP:\n        SCORE[l] = ANS\n        USED[l] = 1\n\n    Q = deque(LOOP)\n\n    while Q:\n        x = Q.pop()\n\n        for to in ELIST[x]:\n            if USED[to] == 1:\n                continue\n\n            SCORE[to] = W[to] + SCORE[x]\n            Q.append(to)\n            USED[to] = 1\n\n    max_score = max(SCORE)\n\n    if max_cities is not None:\n        visited_cities = sum(1 for score in SCORE if score > 0)\n        if visited_cities > max_cities:\n            return -1  # Indicating it's not possible to visit within the limit\n\n    return max_score", "input_format": "First line of input contains two integers n and m, (1 \u2264 n \u2264 2 \u22c5 10^5, 0 \u2264 m \u2264 2 \u22c5 10^5) which are numbers of cities and roads in the country. Second line contains n integers w_1, w_2, ..., w_n (0 \u2264 w_i \u2264 10^9) which are scores of all cities. The following m lines contain description of the roads. Each of these m lines contains two integers u and v (1 \u2264 u, v \u2264 n) which are cities connected by this road. The last line contains single integer s (1 \u2264 s \u2264 n), which is the number of the initial city.", "output_format": "Output single integer which is the maximum possible sum of scores of visited cities.", "test_input": ["assert apps_run2(5, 7, [2, 2, 8, 6, 9], [(1, 2), (1, 3), (2, 4), (3, 2), (4, 5), (2, 5), (1, 5)], 2) == 27", "assert apps_run2(10, 12, [1, 7, 1, 9, 3, 3, 6, 30, 1, 10], [(1, 2), (1, 3), (3, 5), (5, 7), (2, 3), (5, 4), (6, 9), (4, 6), (3, 7), (6, 8), (9, 4), (9, 10)], 6) == 61", "assert apps_run2(5, 7, [2, 2, 8, 6, 9], [(1, 2), (1, 3), (2, 4), (3, 2), (4, 5), (2, 5), (1, 5)], 2, 3) == -1", "assert apps_run2(5, 7, [2, 2, 8, 6, 9], [(1, 2), (1, 3), (2, 4), (3, 2), (4, 5), (2, 5), (1, 5)], 2, 5) == 27", "assert apps_run2(10, 12, [1, 7, 1, 9, 3, 3, 6, 30, 1, 10], [(1, 2), (1, 3), (3, 5), (5, 7), (2, 3), (5, 4), (6, 9), (4, 6), (3, 7), (6, 8), (9, 4), (9, 10)], 6, 10) == 61"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "APPS/2016-3", "raw_problem": "Alex decided to go on a touristic trip over the country.\n\nFor simplicity let's assume that the country has $n$ cities and $m$ bidirectional roads connecting them. Alex lives in city $s$ and initially located in it. To compare different cities Alex assigned each city a score $w_i$ which is as high as interesting city seems to Alex.\n\nAlex believes that his trip will be interesting only if he will not use any road twice in a row. That is if Alex came to city $v$ from city $u$, he may choose as the next city in the trip any city connected with $v$ by the road, except for the city $u$.\n\nYour task is to help Alex plan his city in a way that maximizes total score over all cities he visited. Note that for each city its score is counted at most once, even if Alex been there several times during his trip.\n\n\n-----Input-----\n\nFirst line of input contains two integers $n$ and $m$, ($1 \\le n \\le 2 \\cdot 10^5$, $0 \\le m \\le 2 \\cdot 10^5$) which are numbers of cities and roads in the country.\n\nSecond line contains $n$ integers $w_1, w_2, \\ldots, w_n$ ($0 \\le w_i \\le 10^9$) which are scores of all cities.\n\nThe following $m$ lines contain description of the roads. Each of these $m$ lines contains two integers $u$ and $v$ ($1 \\le u, v \\le n$) which are cities connected by this road.\n\nIt is guaranteed that there is at most one direct road between any two cities, no city is connected to itself by the road and, finally, it is possible to go from any city to any other one using only roads.\n\nThe last line contains single integer $s$ ($1 \\le s \\le n$), which is the number of the initial city.\n\n\n-----Output-----\n\nOutput single integer which is the maximum possible sum of scores of visited cities.\n\n\n-----Examples-----\nInput\n5 7\n2 2 8 6 9\n1 2\n1 3\n2 4\n3 2\n4 5\n2 5\n1 5\n2\n\nOutput\n27\n\nInput\n10 12\n1 7 1 9 3 3 6 30 1 10\n1 2\n1 3\n3 5\n5 7\n2 3\n5 4\n6 9\n4 6\n3 7\n6 8\n9 4\n9 10\n6\n\nOutput\n61.", "raw_solution": "def apps_run1(n, m, weights, edges, S):\n    W = [0] + weights\n    E = edges\n\n    ELIST = [[] for _ in range(n + 1)]\n    EW = [0] * (n + 1)\n\n    for x, y in E:\n        ELIST[x].append(y)\n        ELIST[y].append(x)\n\n        EW[x] += 1\n        EW[y] += 1\n\n    from collections import deque\n    Q = deque()\n    USED = [0] * (n + 1)\n\n    for i in range(1, n + 1):\n        if EW[i] == 1 and i != S:\n            USED[i] = 1\n            Q.append(i)\n\n    EW[S] += 1 << 50\n    USED[S] = 1\n\n    while Q:\n        x = Q.pop()\n        EW[x] -= 1\n\n        for to in ELIST[x]:\n            if USED[to] == 1:\n                continue\n            EW[to] -= 1\n\n            if EW[to] == 1 and USED[to] == 0:\n                Q.append(to)\n                USED[to] = 1\n\n    LOOP = []\n\n    ANS = 0\n    for i in range(1, n + 1):\n        if EW[i] != 0:\n            ANS += W[i]\n            LOOP.append(i)\n\n    SCORE = [0] * (n + 1)\n    USED = [0] * (n + 1)\n\n    for l in LOOP:\n        SCORE[l] = ANS\n        USED[l] = 1\n\n    Q = deque(LOOP)\n\n    while Q:\n        x = Q.pop()\n\n        for to in ELIST[x]:\n            if USED[to] == 1:\n                continue\n\n            SCORE[to] = W[to] + SCORE[x]\n            Q.append(to)\n            USED[to] = 1\n\n    return max(SCORE)\n", "raw_test_input": ["assert apps_run1(5, 7, [2, 2, 8, 6, 9], [(1, 2), (1, 3), (2, 4), (3, 2), (4, 5), (2, 5), (1, 5)], 2) == 27", "assert apps_run1(10, 12, [1, 7, 1, 9, 3, 3, 6, 30, 1, 10], [(1, 2), (1, 3), (3, 5), (5, 7), (2, 3), (5, 4), (6, 9), (4, 6), (3, 7), (6, 8), (9, 4), (9, 10)], 6) == 61", "assert apps_run1(1, 0, [1000000000], [], 1) == 1000000000", "assert apps_run1(2, 1, [999999999, 2], [(1, 2)], 2) == 1000000001", "assert apps_run1(3, 2, [1, 1335, 2], [(2, 1), (3, 2)], 2) == 1337", "assert apps_run1(3, 3, [1, 1, 1], [(1, 2), (3, 2), (3, 1)], 3) == 3", "assert apps_run1(6, 6, [0, 0, 0, 2, 0, 1], [(1, 2), (2, 3), (3, 1), (3, 4), (1, 6), (5, 3)], 5) == 2", "assert apps_run1(8, 9, [1, 7, 1, 9, 3, 3, 6, 30], [(1, 2), (1, 3), (3, 5), (5, 7), (2, 3), (5, 4), (4, 6), (3, 7), (6, 8)], 6) == 60", "assert apps_run1(8, 9, [0, 2, 10, 0, 1, 0, 4, 1], [(3, 8), (4, 8), (1, 5), (6, 4), (5, 7), (6, 8), (5, 8), (2, 1), (3, 5)], 5) == 16", "assert apps_run1(10, 9, [96, 86, 63, 95, 78, 91, 96, 100, 99, 90], [(10, 5), (1, 2), (8, 7), (4, 5), (4, 6), (3, 8), (6, 7), (3, 9), (10, 2)], 8) == 732", "assert apps_run1(10, 20, [64, 70, 28, 86, 100, 62, 79, 86, 85, 95], [(7, 10), (6, 2), (4, 8), (8, 10), (9, 2), (5, 1), (5, 3), (8, 2), (3, 6), (4, 3), (9, 4), (4, 2), (6, 9), (7, 6), (8, 6), (7, 3), (8, 5), (2, 7), (8, 7), (7, 4)], 4) == 755", "assert apps_run1(10, 9, [0, 1, 0, 1, 2, 1, 1, 1, 2, 1], [(1, 7), (6, 4), (1, 8), (10, 7), (1, 2), (1, 9), (9, 3), (5, 1), (1, 4)], 2) == 3", "assert apps_run1(10, 10, [1, 1, 4, 1, 3, 0, 4, 0, 1, 0], [(3, 9), (3, 2), (4, 5), (10, 7), (4, 8), (5, 3), (5, 7), (7, 1), (6, 7), (1, 8)], 7) == 14", "assert apps_run1(17, 17, [1, 0, 0, 2, 2, 0, 1, 0, 2, 0, 0, 0, 0, 2, 1, 0, 1], [(13, 14), (8, 12), (14, 7), (10, 14), (9, 8), (4, 14), (12, 11), (8, 4), (14, 15), (16, 2), (5, 12), (1, 6), (5, 2), (5, 6), (2, 7), (2, 17), (2, 3)], 1) == 10", "assert apps_run1(30, 30, [81, 86, 81, 91, 90, 100, 98, 89, 96, 97, 88, 99, 68, 45, 82, 92, 94, 80, 99, 67, 70, 90, 81, 74, 91, 100, 92, 89, 74, 98], [(16, 26), (20, 3), (23, 16), (17, 27), (30, 22), (18, 23), (14, 30), (25, 4), (3, 8), (18, 9), (29, 26), (27, 21), (26, 6), (10, 7), (28, 5), (1, 30), (28, 30), (12, 15), (17, 25), (26, 15), (30, 2), (5, 15), (14, 20), (10, 4), (24, 16), (8, 7), (11, 30), (19, 8), (21, 9), (13, 15)], 2) == 1909", "assert apps_run1(10, 45, [1, 0, 2, 2, 2, 1, 1, 2, 1, 0], [(3, 1), (9, 6), (7, 1), (6, 8), (8, 4), (2, 7), (7, 10), (4, 5), (7, 4), (3, 4), (9, 2), (7, 5), (8, 5), (5, 1), (7, 3), (6, 2), (3, 5), (3, 8), (1, 9), (10, 3), (9, 7), (4, 6), (9, 8), (5, 9), (10, 8), (2, 1), (9, 4), (3, 9), (8, 7), (5, 10), (6, 5), (4, 2), (2, 8), (4, 10), (9, 10), (6, 10), (6, 1), (6, 7), (3, 6), (2, 5), (8, 1), (1, 4), (10, 1), (10, 2), (3, 2)], 6) == 12", "assert apps_run1(10, 20, [4, 1, 5, 1, 3, 0, 2, 2, 10, 4], [(10, 6), (10, 4), (2, 5), (6, 3), (2, 9), (1, 7), (5, 10), (5, 6), (5, 3), (3, 4), (9, 6), (1, 8), (10, 9), (10, 3), (9, 4), (4, 6), (6, 2), (3, 8), (9, 5), (8, 2)], 10) == 32", "assert apps_run1(28, 31, [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 1, 0, 1, 0, 0, 1, 1, 1, 0], [(9, 7), (24, 10), (12, 27), (3, 20), (16, 3), (27, 8), (23, 25), (19, 20), (10, 17), (7, 13), (7, 5), (15, 11), (19, 1), (25, 4), (26, 22), (21, 3), (17, 24), (27, 11), (26, 20), (22, 24), (8, 12), (25, 6), (2, 14), (22, 28), (20, 18), (2, 21), (13, 9), (23, 4), (19, 7), (22, 25), (11, 24)], 2) == 9"], "new_problem": "Alex is planning a touristic trip across a country with n cities and m bidirectional roads. Each city has a score indicating its interest level. Alex wants to maximize the total score of cities visited, but he cannot use the same road twice in a row. Additionally, each city can only be visited once. The cities and roads are now represented using a graph with adjacency lists stored in a dictionary, where keys are city IDs and values are sets of connected cities. The task is to help Alex plan his trip to maximize the total score of visited cities. The graph is guaranteed to be connected, and there are no self-loops or multiple roads between the same pair of cities. The solution should use type hints and handle up to 10^6 cities and roads.", "new_solution": "from collections import deque\nfrom typing import Dict, Set, List, Tuple\n\ndef apps_run2(n: int, m: int, scores: List[int], roads: List[Tuple[int, int]], start: int) -> int:\n    graph: Dict[int, Set[int]] = {i: set() for i in range(1, n + 1)}\n    for u, v in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n\n    used = [False] * (n + 1)\n    score = [0] * (n + 1)\n    queue = deque([start])\n    used[start] = True\n    score[start] = scores[start - 1]\n\n    while queue:\n        current = queue.popleft()\n        for neighbor in graph[current]:\n            if not used[neighbor]:\n                used[neighbor] = True\n                score[neighbor] = score[current] + scores[neighbor - 1]\n                queue.append(neighbor)\n\n    return max(score)\n", "input_format": "The first line contains two integers n and m, the number of cities and roads. The second line contains n integers representing the scores of the cities. The next m lines each contain two integers u and v, representing a road between cities u and v. The last line contains an integer s, the starting city.", "output_format": "Output a single integer, the maximum possible sum of scores of visited cities.", "test_input": ["assert apps_run2(5, 7, [2, 2, 8, 6, 9], [(1, 2), (1, 3), (2, 4), (3, 2), (4, 5), (2, 5), (1, 5)], 2) == 11", "assert apps_run2(10, 12, [1, 7, 1, 9, 3, 3, 6, 30, 1, 10], [(1, 2), (1, 3), (3, 5), (5, 7), (2, 3), (5, 4), (6, 9), (4, 6), (3, 7), (6, 8), (9, 4), (9, 10)], 6) == 33", "assert apps_run2(3, 2, [5, 10, 15], [(1, 2), (2, 3)], 1) == 30", "assert apps_run2(4, 3, [1, 2, 3, 4], [(1, 2), (2, 3), (3, 4)], 1) == 10", "assert apps_run2(6, 5, [10, 20, 30, 40, 50, 60], [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)], 3) == 180"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "APPS/2016-4", "raw_problem": "Alex decided to go on a touristic trip over the country.\n\nFor simplicity let's assume that the country has $n$ cities and $m$ bidirectional roads connecting them. Alex lives in city $s$ and initially located in it. To compare different cities Alex assigned each city a score $w_i$ which is as high as interesting city seems to Alex.\n\nAlex believes that his trip will be interesting only if he will not use any road twice in a row. That is if Alex came to city $v$ from city $u$, he may choose as the next city in the trip any city connected with $v$ by the road, except for the city $u$.\n\nYour task is to help Alex plan his city in a way that maximizes total score over all cities he visited. Note that for each city its score is counted at most once, even if Alex been there several times during his trip.\n\n\n-----Input-----\n\nFirst line of input contains two integers $n$ and $m$, ($1 \\le n \\le 2 \\cdot 10^5$, $0 \\le m \\le 2 \\cdot 10^5$) which are numbers of cities and roads in the country.\n\nSecond line contains $n$ integers $w_1, w_2, \\ldots, w_n$ ($0 \\le w_i \\le 10^9$) which are scores of all cities.\n\nThe following $m$ lines contain description of the roads. Each of these $m$ lines contains two integers $u$ and $v$ ($1 \\le u, v \\le n$) which are cities connected by this road.\n\nIt is guaranteed that there is at most one direct road between any two cities, no city is connected to itself by the road and, finally, it is possible to go from any city to any other one using only roads.\n\nThe last line contains single integer $s$ ($1 \\le s \\le n$), which is the number of the initial city.\n\n\n-----Output-----\n\nOutput single integer which is the maximum possible sum of scores of visited cities.\n\n\n-----Examples-----\nInput\n5 7\n2 2 8 6 9\n1 2\n1 3\n2 4\n3 2\n4 5\n2 5\n1 5\n2\n\nOutput\n27\n\nInput\n10 12\n1 7 1 9 3 3 6 30 1 10\n1 2\n1 3\n3 5\n5 7\n2 3\n5 4\n6 9\n4 6\n3 7\n6 8\n9 4\n9 10\n6\n\nOutput\n61.", "raw_solution": "def apps_run1(n, m, weights, edges, S):\n    W = [0] + weights\n    E = edges\n\n    ELIST = [[] for _ in range(n + 1)]\n    EW = [0] * (n + 1)\n\n    for x, y in E:\n        ELIST[x].append(y)\n        ELIST[y].append(x)\n\n        EW[x] += 1\n        EW[y] += 1\n\n    from collections import deque\n    Q = deque()\n    USED = [0] * (n + 1)\n\n    for i in range(1, n + 1):\n        if EW[i] == 1 and i != S:\n            USED[i] = 1\n            Q.append(i)\n\n    EW[S] += 1 << 50\n    USED[S] = 1\n\n    while Q:\n        x = Q.pop()\n        EW[x] -= 1\n\n        for to in ELIST[x]:\n            if USED[to] == 1:\n                continue\n            EW[to] -= 1\n\n            if EW[to] == 1 and USED[to] == 0:\n                Q.append(to)\n                USED[to] = 1\n\n    LOOP = []\n    ANS = 0\n    for i in range(1, n + 1):\n        if EW[i] != 0:\n            ANS += W[i]\n            LOOP.append(i)\n\n    SCORE = [0] * (n + 1)\n    USED = [0] * (n + 1)\n\n    for l in LOOP:\n        SCORE[l] = ANS\n        USED[l] = 1\n\n    Q = deque(LOOP)\n\n    while Q:\n        x = Q.pop()\n\n        for to in ELIST[x]:\n            if USED[to] == 1:\n                continue\n\n            SCORE[to] = W[to] + SCORE[x]\n            Q.append(to)\n            USED[to] = 1\n\n    return max(SCORE)\n", "raw_test_input": ["assert apps_run1(5, 7, [2, 2, 8, 6, 9], [(1, 2), (1, 3), (2, 4), (3, 2), (4, 5), (2, 5), (1, 5)], 2) == 27", "assert apps_run1(10, 12, [1, 7, 1, 9, 3, 3, 6, 30, 1, 10], [(1, 2), (1, 3), (3, 5), (5, 7), (2, 3), (5, 4), (6, 9), (4, 6), (3, 7), (6, 8), (9, 4), (9, 10)], 6) == 61", "assert apps_run1(1, 0, [1000000000], [], 1) == 1000000000", "assert apps_run1(2, 1, [999999999, 2], [(1, 2)], 2) == 1000000001", "assert apps_run1(3, 2, [1, 1335, 2], [(2, 1), (3, 2)], 2) == 1337", "assert apps_run1(3, 3, [1, 1, 1], [(1, 2), (3, 2), (3, 1)], 3) == 3", "assert apps_run1(6, 6, [0, 0, 0, 2, 0, 1], [(1, 2), (2, 3), (3, 1), (3, 4), (1, 6), (5, 3)], 5) == 2", "assert apps_run1(8, 9, [1, 7, 1, 9, 3, 3, 6, 30], [(1, 2), (1, 3), (3, 5), (5, 7), (2, 3), (5, 4), (4, 6), (3, 7), (6, 8)], 6) == 60", "assert apps_run1(8, 9, [0, 2, 10, 0, 1, 0, 4, 1], [(3, 8), (4, 8), (1, 5), (6, 4), (5, 7), (6, 8), (5, 8), (2, 1), (3, 5)], 5) == 16", "assert apps_run1(10, 9, [96, 86, 63, 95, 78, 91, 96, 100, 99, 90], [(10, 5), (1, 2), (8, 7), (4, 5), (4, 6), (3, 8), (6, 7), (3, 9), (10, 2)], 8) == 732", "assert apps_run1(10, 20, [64, 70, 28, 86, 100, 62, 79, 86, 85, 95], [(7, 10), (6, 2), (4, 8), (8, 10), (9, 2), (5, 1), (5, 3), (8, 2), (3, 6), (4, 3), (9, 4), (4, 2), (6, 9), (7, 6), (8, 6), (7, 3), (8, 5), (2, 7), (8, 7), (7, 4)], 4) == 755", "assert apps_run1(10, 9, [0, 1, 0, 1, 2, 1, 1, 1, 2, 1], [(1, 7), (6, 4), (1, 8), (10, 7), (1, 2), (1, 9), (9, 3), (5, 1), (1, 4)], 2) == 3", "assert apps_run1(10, 10, [1, 1, 4, 1, 3, 0, 4, 0, 1, 0], [(3, 9), (3, 2), (4, 5), (10, 7), (4, 8), (5, 3), (5, 7), (7, 1), (6, 7), (1, 8)], 7) == 14", "assert apps_run1(17, 17, [1, 0, 0, 2, 2, 0, 1, 0, 2, 0, 0, 0, 0, 2, 1, 0, 1], [(13, 14), (8, 12), (14, 7), (10, 14), (9, 8), (4, 14), (12, 11), (8, 4), (14, 15), (16, 2), (5, 12), (1, 6), (5, 2), (5, 6), (2, 7), (2, 17), (2, 3)], 1) == 10", "assert apps_run1(30, 30, [81, 86, 81, 91, 90, 100, 98, 89, 96, 97, 88, 99, 68, 45, 82, 92, 94, 80, 99, 67, 70, 90, 81, 74, 91, 100, 92, 89, 74, 98], [(16, 26), (20, 3), (23, 16), (17, 27), (30, 22), (18, 23), (14, 30), (25, 4), (3, 8), (18, 9), (29, 26), (27, 21), (26, 6), (10, 7), (28, 5), (1, 30), (28, 30), (12, 15), (17, 25), (26, 15), (30, 2), (5, 15), (14, 20), (10, 4), (24, 16), (8, 7), (11, 30), (19, 8), (21, 9), (13, 15)], 2) == 1909", "assert apps_run1(10, 45, [1, 0, 2, 2, 2, 1, 1, 2, 1, 0], [(3, 1), (9, 6), (7, 1), (6, 8), (8, 4), (2, 7), (7, 10), (4, 5), (7, 4), (3, 4), (9, 2), (7, 5), (8, 5), (5, 1), (7, 3), (6, 2), (3, 5), (3, 8), (1, 9), (10, 3), (9, 7), (4, 6), (9, 8), (5, 9), (10, 8), (2, 1), (9, 4), (3, 9), (8, 7), (5, 10), (6, 5), (4, 2), (2, 8), (4, 10), (9, 10), (6, 10), (6, 1), (6, 7), (3, 6), (2, 5), (8, 1), (1, 4), (10, 1), (10, 2), (3, 2)], 6) == 12", "assert apps_run1(10, 20, [4, 1, 5, 1, 3, 0, 2, 2, 10, 4], [(10, 6), (10, 4), (2, 5), (6, 3), (2, 9), (1, 7), (5, 10), (5, 6), (5, 3), (3, 4), (9, 6), (1, 8), (10, 9), (10, 3), (9, 4), (4, 6), (6, 2), (3, 8), (9, 5), (8, 2)], 10) == 32", "assert apps_run1(28, 31, [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 1, 0, 1, 0, 0, 1, 1, 1, 0], [(9, 7), (24, 10), (12, 27), (3, 20), (16, 3), (27, 8), (23, 25), (19, 20), (10, 17), (7, 13), (7, 5), (15, 11), (19, 1), (25, 4), (26, 22), (21, 3), (17, 24), (27, 11), (26, 20), (22, 24), (8, 12), (25, 6), (2, 14), (22, 28), (20, 18), (2, 21), (13, 9), (23, 4), (19, 7), (22, 25), (11, 24)], 2) == 9"], "new_problem": "Alex is planning a touristic trip across a country with n cities and m bidirectional roads. Each city has a score indicating its interest level. Alex wants to maximize the total score of cities visited, with the constraint that no road is used twice in a row. However, due to recent changes, some roads may be temporarily closed, and some cities may have incorrect scores. Your task is to help Alex plan his trip while handling potential errors: 1. If a road is closed, it should be ignored. 2. If a city has a negative score, raise a ValueError. 3. If the starting city is isolated (no roads), raise a RuntimeError. 4. If the input format is incorrect, raise a custom InputFormatError. Implement error handling to manage these scenarios and ensure Alex's trip is planned correctly.", "new_solution": "from collections import deque\nfrom typing import List, Tuple\n\n\nclass InputFormatError(Exception):\n    pass\n\n\ndef apps_run2(n: int, m: int, W: List[int], E: List[Tuple[int, int]], S: int) -> int:\n    if len(W) != n or len(E) != m:\n        raise InputFormatError(\"Input format is incorrect.\")\n    if any(w < 0 for w in W):\n        raise ValueError(\"City scores must be non-negative.\")\n\n    # \u6dfb\u52a0\u8d77\u59cb\u57ce\u5e02\u5408\u6cd5\u6027\u68c0\u67e5\n    if S < 1 or S > n:\n        raise ValueError(f\"Starting city must be between 1 and {n}\")\n\n    ELIST = [[] for _ in range(n + 1)]\n    EW = [0] * (n + 1)\n\n    # \u6784\u5efa\u90bb\u63a5\u8868\u65f6\u4fdd\u6301\u539f\u59cb\u903b\u8f91\n    for x, y in E:\n        if 1 <= x <= n and 1 <= y <= n:\n            ELIST[x].append(y)\n            ELIST[y].append(x)\n            EW[x] += 1\n            EW[y] += 1\n\n    if EW[S] == 0:\n        raise RuntimeError(\"Starting city is isolated.\")\n\n    Q = deque()\n    USED = [0] * (n + 1)\n\n    # \u62d3\u6251\u6392\u5e8f\u9884\u5904\u7406\n    for i in range(1, n + 1):\n        if EW[i] == 1 and i != S:\n            USED[i] = 1\n            Q.append(i)\n\n    EW[S] += 1 << 50\n    USED[S] = 1\n\n    while Q:\n        x = Q.pop()\n        EW[x] -= 1\n        for to in ELIST[x]:\n            if USED[to] == 1:\n                continue\n            EW[to] -= 1\n            if EW[to] == 1 and USED[to] == 0:\n                Q.append(to)\n                USED[to] = 1\n\n    LOOP = []\n    ANS = 0\n    # \u4fee\u6b63\u7d22\u5f15\u8bbf\u95ee\uff1aW[i-1]\n    for i in range(1, n + 1):\n        if EW[i] != 0:\n            ANS += W[i - 1]  # \u6539\u4e3ai-1\n            LOOP.append(i)\n\n    SCORE = [0] * (n + 1)\n    USED = [0] * (n + 1)\n\n    # \u521d\u59cb\u5316\u73af\u8def\u8282\u70b9\u5206\u6570\n    for l in LOOP:\n        SCORE[l] = ANS\n        USED[l] = 1\n\n    Q = deque(LOOP)\n    while Q:\n        x = Q.pop()\n        for to in ELIST[x]:\n            if USED[to] == 1:\n                continue\n            # \u4fee\u6b63\u7d22\u5f15\u8bbf\u95ee\uff1aW[to-1]\n            SCORE[to] = W[to - 1] + SCORE[x]  # \u6539\u4e3ato-1\n            USED[to] = 1\n            Q.append(to)\n\n    return max(SCORE)", "input_format": "First line of input contains two integers n and m, (1 <= n <= 2 * 10^5, 0 <= m <= 2 * 10^5) which are numbers of cities and roads in the country. Second line contains n integers w_1, w_2, ..., w_n (0 <= w_i <= 10^9) which are scores of all cities. The following m lines contain description of the roads. Each of these m lines contains two integers u and v (1 <= u, v <= n) which are cities connected by this road. The last line contains single integer s (1 <= s <= n), which is the number of the initial city.", "output_format": "Output single integer which is the maximum possible sum of scores of visited cities.", "test_input": ["assert apps_run2(5, 7, [2, 2, 8, 6, 9], [(1, 2), (1, 3), (2, 4), (3, 2), (4, 5), (2, 5), (1, 5)], 2) == 27", "assert apps_run2(10, 12, [1, 7, 1, 9, 3, 3, 6, 30, 1, 10], [(1, 2), (1, 3), (3, 5), (5, 7), (2, 3), (5, 4), (6, 9), (4, 6), (3, 7), (6, 8), (9, 4), (9, 10)], 6) == 61", "try: apps_run2(5, 7, [2, -2, 8, 6, 9], [(1, 2), (1, 3), (2, 4), (3, 2), (4, 5), (2, 5), (1, 5)], 2)\nexcept ValueError as e: assert str(e) == 'City scores must be non-negative.'", "try: apps_run2(5, 7, [2, 2, 8, 6, 9], [(1, 2), (1, 3), (2, 4), (3, 2), (4, 5), (2, 5), (1, 5)], 6)\nexcept ValueError as e: assert str(e) == 'Starting city must be between 1 and 5'", "try: apps_run2(5, 6, [2, 2, 8, 6, 9], [(1, 2), (1, 3), (2, 4), (3, 2), (4, 5), (2, 5)], 2)\nexcept InputFormatError as e: assert str(e) == 'Input format is incorrect.'"], "requirement_type": "PROMPT_ERROR_HANDLING"}
{"task_id": "APPS/2017-1", "raw_problem": "Allen is hosting a formal dinner party. $2n$ people come to the event in $n$ pairs (couples). After a night of fun, Allen wants to line everyone up for a final picture. The $2n$ people line up, but Allen doesn't like the ordering. Allen prefers if each pair occupies adjacent positions in the line, as this makes the picture more aesthetic.\n\nHelp Allen find the minimum number of swaps of adjacent positions he must perform to make it so that each couple occupies adjacent positions in the line.\n\n\n-----Input-----\n\nThe first line contains a single integer $n$ ($1 \\le n \\le 100$), the number of pairs of people.\n\nThe second line contains $2n$ integers $a_1, a_2, \\dots, a_{2n}$. For each $i$ with $1 \\le i \\le n$, $i$ appears exactly twice. If $a_j = a_k = i$, that means that the $j$-th and $k$-th people in the line form a couple.\n\n\n-----Output-----\n\nOutput a single integer, representing the minimum number of adjacent swaps needed to line the people up so that each pair occupies adjacent positions.\n\n\n-----Examples-----\nInput\n4\n1 1 2 3 3 2 4 4\n\nOutput\n2\n\nInput\n3\n1 1 2 2 3 3\n\nOutput\n0\n\nInput\n3\n3 1 2 3 1 2\n\nOutput\n3\n\n\n\n-----Note-----\n\nIn the first sample case, we can transform $1 1 2 3 3 2 4 4 \\rightarrow 1 1 2 3 2 3 4 4 \\rightarrow 1 1 2 2 3 3 4 4$ in two steps. Note that the sequence $1 1 2 3 3 2 4 4 \\rightarrow 1 1 3 2 3 2 4 4 \\rightarrow 1 1 3 3 2 2 4 4$ also works in the same number of steps.\n\nThe second sample case already satisfies the constraints; therefore we need $0$ swaps.", "raw_solution": "def apps_run1(n, xs):\n    seen = {}\n    res = 0\n    while xs:\n        j = xs.index(xs[0], 1)\n        res += j - 1\n        xs = xs[1:j] + xs[j+1:]\n    return res", "raw_test_input": ["assert apps_run1(4, [1, 1, 2, 3, 3, 2, 4, 4]) == 2", "assert apps_run1(3, [1, 1, 2, 2, 3, 3]) == 0", "assert apps_run1(3, [3, 1, 2, 3, 1, 2]) == 3", "assert apps_run1(8, [7, 6, 2, 1, 4, 3, 3, 7, 2, 6, 5, 1, 8, 5, 8, 4]) == 27", "assert apps_run1(2, [1, 2, 1, 2]) == 1", "assert apps_run1(3, [1, 2, 3, 3, 1, 2]) == 5", "assert apps_run1(38, [26, 28, 23, 34, 33, 14, 38, 15, 35, 36, 30, 1, 19, 17, 18, 28, 22, 15, 9, 27, 11, 16, 17, 32, 7, 21, 6, 8, 32, 26, 33, 23, 18, 4, 2, 25, 29, 3, 35, 8, 38, 37, 31, 37, 12, 25, 3, 27, 16, 24, 5, 20, 12, 13, 29, 11, 30, 22, 9, 19, 2, 24, 7, 10, 34, 4, 36, 21, 14, 31, 13, 6, 20, 10, 5, 1]) == 744", "assert apps_run1(24, [21, 21, 22, 5, 8, 5, 15, 11, 13, 16, 17, 9, 3, 18, 15, 1, 12, 12, 7, 2, 22, 19, 20, 19, 23, 14, 8, 24, 4, 23, 16, 17, 9, 10, 1, 6, 4, 2, 7, 3, 18, 11, 24, 10, 13, 6, 20, 14]) == 259", "assert apps_run1(1, [1, 1]) == 0", "assert apps_run1(19, [15, 19, 18, 8, 12, 2, 11, 7, 5, 2, 1, 1, 9, 9, 3, 3, 16, 6, 15, 17, 13, 18, 4, 14, 5, 8, 10, 12, 6, 11, 17, 13, 14, 16, 19, 7, 4, 10]) == 181", "assert apps_run1(8, [3, 1, 5, 2, 1, 6, 3, 5, 6, 2, 4, 8, 8, 4, 7, 7]) == 13", "assert apps_run1(2, [2, 1, 1, 2]) == 2", "assert apps_run1(81, [48, 22, 31, 24, 73, 77, 79, 75, 37, 78, 43, 56, 20, 33, 70, 34, 6, 50, 51, 21, 39, 29, 20, 11, 73, 53, 39, 61, 28, 17, 55, 52, 28, 57, 52, 74, 35, 13, 55, 2, 57, 9, 46, 81, 60, 47, 21, 68, 1, 53, 31, 64, 42, 9, 79, 80, 69, 30, 32, 24, 15, 2, 69, 10, 22, 3, 71, 19, 67, 66, 17, 50, 62, 36, 32, 65, 58, 18, 25, 59, 38, 10, 14, 51, 23, 16, 29, 81, 45, 40, 18, 54, 47, 12, 45, 74, 41, 34, 75, 44, 19, 77, 71, 67, 7, 16, 35, 49, 15, 3, 38, 4, 7, 25, 76, 66, 5, 65, 27, 6, 1, 72, 37, 42, 26, 60, 12, 64, 44, 41, 80, 13, 49, 68, 76, 48, 11, 78, 40, 61, 30, 43, 62, 58, 5, 4, 33, 26, 54, 27, 36, 72, 63, 63, 59, 70, 23, 8, 56, 8, 46, 14]) == 3186", "assert apps_run1(84, [10, 29, 12, 22, 55, 3, 81, 33, 64, 78, 46, 44, 69, 41, 34, 71, 24, 12, 22, 54, 63, 9, 65, 40, 36, 81, 32, 37, 83, 50, 28, 84, 53, 25, 72, 77, 41, 35, 50, 8, 29, 78, 72, 53, 21, 63, 16, 1, 79, 20, 66, 23, 38, 18, 44, 5, 27, 77, 32, 52, 42, 60, 67, 62, 64, 52, 14, 80, 4, 19, 15, 45, 40, 47, 42, 46, 68, 18, 70, 8, 3, 36, 65, 38, 73, 43, 59, 20, 66, 6, 51, 10, 58, 55, 51, 13, 4, 5, 43, 82, 71, 21, 9, 33, 47, 11, 61, 30, 76, 27, 24, 48, 75, 15, 48, 75, 2, 31, 83, 67, 59, 74, 56, 11, 39, 13, 45, 76, 26, 30, 39, 17, 61, 57, 68, 7, 70, 62, 49, 57, 49, 84, 31, 26, 56, 54, 74, 16, 60, 1, 80, 35, 82, 28, 79, 73, 14, 69, 6, 19, 25, 34, 23, 2, 58, 37, 7, 17]) == 3279", "assert apps_run1(4, [3, 4, 2, 4, 1, 2, 1, 3]) == 8", "assert apps_run1(75, [28, 28, 42, 3, 39, 39, 73, 73, 75, 75, 30, 30, 21, 9, 57, 41, 26, 70, 15, 15, 65, 65, 24, 24, 4, 4, 62, 62, 17, 17, 29, 29, 37, 37, 18, 18, 1, 1, 8, 8, 63, 63, 49, 49, 5, 5, 59, 59, 19, 19, 34, 34, 48, 48, 10, 10, 14, 42, 22, 22, 38, 38, 50, 50, 60, 60, 64, 35, 47, 31, 72, 72, 41, 52, 46, 46, 20, 20, 21, 9, 7, 7, 36, 36, 2, 2, 6, 6, 70, 26, 69, 69, 16, 16, 61, 61, 66, 66, 33, 33, 44, 44, 11, 11, 23, 23, 40, 40, 12, 12, 64, 35, 56, 56, 27, 27, 53, 53, 3, 14, 43, 43, 31, 47, 68, 68, 13, 13, 74, 74, 67, 67, 71, 71, 45, 45, 57, 52, 32, 32, 25, 25, 58, 58, 55, 55, 51, 51, 54, 54]) == 870", "assert apps_run1(35, [6, 32, 4, 19, 9, 34, 20, 29, 22, 26, 19, 14, 33, 11, 17, 31, 30, 13, 7, 12, 8, 16, 5, 5, 21, 15, 18, 28, 34, 3, 2, 10, 23, 24, 35, 6, 32, 4, 25, 9, 1, 11, 24, 20, 26, 25, 2, 13, 22, 17, 31, 30, 33, 7, 12, 8, 16, 27, 27, 21, 15, 18, 28, 1, 3, 14, 10, 23, 29, 35]) == 673", "assert apps_run1(86, [33, 6, 22, 8, 54, 43, 57, 85, 70, 41, 20, 17, 35, 12, 66, 25, 45, 78, 67, 55, 50, 19, 31, 75, 77, 29, 58, 78, 34, 15, 40, 48, 14, 82, 6, 37, 44, 53, 62, 23, 56, 22, 34, 18, 71, 83, 21, 80, 47, 38, 3, 42, 60, 9, 73, 49, 84, 7, 76, 30, 5, 4, 11, 28, 69, 16, 26, 10, 59, 48, 64, 46, 32, 68, 24, 63, 79, 36, 13, 1, 27, 61, 39, 74, 2, 51, 51, 2, 74, 39, 61, 27, 1, 13, 36, 79, 86, 24, 68, 32, 46, 64, 63, 59, 10, 26, 16, 69, 28, 11, 4, 5, 30, 76, 7, 84, 49, 73, 9, 60, 42, 3, 38, 47, 80, 21, 83, 72, 18, 52, 65, 56, 23, 62, 53, 44, 37, 81, 82, 14, 86, 40, 15, 52, 72, 58, 29, 77, 85, 31, 19, 50, 55, 67, 71, 45, 25, 66, 12, 35, 17, 20, 41, 70, 75, 57, 43, 54, 8, 65, 81, 33]) == 6194"], "new_problem": "Allen is now organizing a series of formal dinner parties over several days. Each day, a different number of people attend, and they line up for a picture. Allen wants to ensure that each couple is adjacent in the lineup for each event. Help Allen find the total minimum number of swaps of adjacent positions he must perform across all events to make it so that each couple occupies adjacent positions in the line for each event.", "new_solution": "def min_swaps_for_event(n, xs):\n    res = 0\n    while xs:\n        j = xs.index(xs[0], 1)\n        res += j - 1\n        xs = xs[1:j] + xs[j+1:]\n    return res\n\ndef apps_run2(m, events):\n    total_swaps = 0\n    for n, xs in events:\n        total_swaps += min_swaps_for_event(n, xs)\n    return total_swaps", "input_format": "The first line contains a single integer m (1 <= m <= 50), the number of events. For each event, the first line contains a single integer n (1 <= n <= 100), the number of pairs of people. The second line contains 2n integers a_1, a_2, ..., a_{2n}. For each i with 1 <= i <= n, i appears exactly twice. If a_j = a_k = i, that means that the j-th and k-th people in the line form a couple.", "output_format": "Output a single integer, representing the total minimum number of adjacent swaps needed to line the people up for all events so that each pair occupies adjacent positions.", "test_input": ["assert apps_run2(2, [(4, [1, 1, 2, 3, 3, 2, 4, 4]), (3, [3, 1, 2, 3, 1, 2])]) == 5", "assert apps_run2(1, [(3, [1, 1, 2, 2, 3, 3])]) == 0", "assert apps_run2(3, [(2, [1, 2, 1, 2]), (2, [2, 1, 2, 1]), (1, [1, 1])]) == 2", "assert apps_run2(1, [(4, [4, 3, 2, 1, 1, 2, 3, 4])]) == 12", "assert apps_run2(2, [(3, [2, 3, 1, 3, 2, 1]), (3, [1, 2, 3, 1, 2, 3])]) == 7"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "APPS/2017-2", "raw_problem": "Allen is hosting a formal dinner party. $2n$ people come to the event in $n$ pairs (couples). After a night of fun, Allen wants to line everyone up for a final picture. The $2n$ people line up, but Allen doesn't like the ordering. Allen prefers if each pair occupies adjacent positions in the line, as this makes the picture more aesthetic.\n\nHelp Allen find the minimum number of swaps of adjacent positions he must perform to make it so that each couple occupies adjacent positions in the line.\n\n\n-----Input-----\n\nThe first line contains a single integer $n$ ($1 \\le n \\le 100$), the number of pairs of people.\n\nThe second line contains $2n$ integers $a_1, a_2, \\dots, a_{2n}$. For each $i$ with $1 \\le i \\le n$, $i$ appears exactly twice. If $a_j = a_k = i$, that means that the $j$-th and $k$-th people in the line form a couple.\n\n\n-----Output-----\n\nOutput a single integer, representing the minimum number of adjacent swaps needed to line the people up so that each pair occupies adjacent positions.\n\n\n-----Examples-----\nInput\n4\n1 1 2 3 3 2 4 4\n\nOutput\n2\n\nInput\n3\n1 1 2 2 3 3\n\nOutput\n0\n\nInput\n3\n3 1 2 3 1 2\n\nOutput\n3\n\n\n\n-----Note-----\n\nIn the first sample case, we can transform $1 1 2 3 3 2 4 4 \\rightarrow 1 1 2 3 2 3 4 4 \\rightarrow 1 1 2 2 3 3 4 4$ in two steps. Note that the sequence $1 1 2 3 3 2 4 4 \\rightarrow 1 1 3 2 3 2 4 4 \\rightarrow 1 1 3 3 2 2 4 4$ also works in the same number of steps.\n\nThe second sample case already satisfies the constraints; therefore we need $0$ swaps.", "raw_solution": "def apps_run1(n, xs):\n    seen = {}\n    res = 0\n    while xs:\n        j = xs.index(xs[0], 1)\n        res += j - 1\n        xs = xs[1:j] + xs[j+1:]\n    return res", "raw_test_input": ["assert apps_run1(4, [1, 1, 2, 3, 3, 2, 4, 4]) == 2", "assert apps_run1(3, [1, 1, 2, 2, 3, 3]) == 0", "assert apps_run1(3, [3, 1, 2, 3, 1, 2]) == 3", "assert apps_run1(8, [7, 6, 2, 1, 4, 3, 3, 7, 2, 6, 5, 1, 8, 5, 8, 4]) == 27", "assert apps_run1(2, [1, 2, 1, 2]) == 1", "assert apps_run1(3, [1, 2, 3, 3, 1, 2]) == 5", "assert apps_run1(38, [26, 28, 23, 34, 33, 14, 38, 15, 35, 36, 30, 1, 19, 17, 18, 28, 22, 15, 9, 27, 11, 16, 17, 32, 7, 21, 6, 8, 32, 26, 33, 23, 18, 4, 2, 25, 29, 3, 35, 8, 38, 37, 31, 37, 12, 25, 3, 27, 16, 24, 5, 20, 12, 13, 29, 11, 30, 22, 9, 19, 2, 24, 7, 10, 34, 4, 36, 21, 14, 31, 13, 6, 20, 10, 5, 1]) == 744", "assert apps_run1(24, [21, 21, 22, 5, 8, 5, 15, 11, 13, 16, 17, 9, 3, 18, 15, 1, 12, 12, 7, 2, 22, 19, 20, 19, 23, 14, 8, 24, 4, 23, 16, 17, 9, 10, 1, 6, 4, 2, 7, 3, 18, 11, 24, 10, 13, 6, 20, 14]) == 259", "assert apps_run1(1, [1, 1]) == 0", "assert apps_run1(19, [15, 19, 18, 8, 12, 2, 11, 7, 5, 2, 1, 1, 9, 9, 3, 3, 16, 6, 15, 17, 13, 18, 4, 14, 5, 8, 10, 12, 6, 11, 17, 13, 14, 16, 19, 7, 4, 10]) == 181", "assert apps_run1(8, [3, 1, 5, 2, 1, 6, 3, 5, 6, 2, 4, 8, 8, 4, 7, 7]) == 13", "assert apps_run1(2, [2, 1, 1, 2]) == 2", "assert apps_run1(81, [48, 22, 31, 24, 73, 77, 79, 75, 37, 78, 43, 56, 20, 33, 70, 34, 6, 50, 51, 21, 39, 29, 20, 11, 73, 53, 39, 61, 28, 17, 55, 52, 28, 57, 52, 74, 35, 13, 55, 2, 57, 9, 46, 81, 60, 47, 21, 68, 1, 53, 31, 64, 42, 9, 79, 80, 69, 30, 32, 24, 15, 2, 69, 10, 22, 3, 71, 19, 67, 66, 17, 50, 62, 36, 32, 65, 58, 18, 25, 59, 38, 10, 14, 51, 23, 16, 29, 81, 45, 40, 18, 54, 47, 12, 45, 74, 41, 34, 75, 44, 19, 77, 71, 67, 7, 16, 35, 49, 15, 3, 38, 4, 7, 25, 76, 66, 5, 65, 27, 6, 1, 72, 37, 42, 26, 60, 12, 64, 44, 41, 80, 13, 49, 68, 76, 48, 11, 78, 40, 61, 30, 43, 62, 58, 5, 4, 33, 26, 54, 27, 36, 72, 63, 63, 59, 70, 23, 8, 56, 8, 46, 14]) == 3186", "assert apps_run1(84, [10, 29, 12, 22, 55, 3, 81, 33, 64, 78, 46, 44, 69, 41, 34, 71, 24, 12, 22, 54, 63, 9, 65, 40, 36, 81, 32, 37, 83, 50, 28, 84, 53, 25, 72, 77, 41, 35, 50, 8, 29, 78, 72, 53, 21, 63, 16, 1, 79, 20, 66, 23, 38, 18, 44, 5, 27, 77, 32, 52, 42, 60, 67, 62, 64, 52, 14, 80, 4, 19, 15, 45, 40, 47, 42, 46, 68, 18, 70, 8, 3, 36, 65, 38, 73, 43, 59, 20, 66, 6, 51, 10, 58, 55, 51, 13, 4, 5, 43, 82, 71, 21, 9, 33, 47, 11, 61, 30, 76, 27, 24, 48, 75, 15, 48, 75, 2, 31, 83, 67, 59, 74, 56, 11, 39, 13, 45, 76, 26, 30, 39, 17, 61, 57, 68, 7, 70, 62, 49, 57, 49, 84, 31, 26, 56, 54, 74, 16, 60, 1, 80, 35, 82, 28, 79, 73, 14, 69, 6, 19, 25, 34, 23, 2, 58, 37, 7, 17]) == 3279", "assert apps_run1(4, [3, 4, 2, 4, 1, 2, 1, 3]) == 8", "assert apps_run1(75, [28, 28, 42, 3, 39, 39, 73, 73, 75, 75, 30, 30, 21, 9, 57, 41, 26, 70, 15, 15, 65, 65, 24, 24, 4, 4, 62, 62, 17, 17, 29, 29, 37, 37, 18, 18, 1, 1, 8, 8, 63, 63, 49, 49, 5, 5, 59, 59, 19, 19, 34, 34, 48, 48, 10, 10, 14, 42, 22, 22, 38, 38, 50, 50, 60, 60, 64, 35, 47, 31, 72, 72, 41, 52, 46, 46, 20, 20, 21, 9, 7, 7, 36, 36, 2, 2, 6, 6, 70, 26, 69, 69, 16, 16, 61, 61, 66, 66, 33, 33, 44, 44, 11, 11, 23, 23, 40, 40, 12, 12, 64, 35, 56, 56, 27, 27, 53, 53, 3, 14, 43, 43, 31, 47, 68, 68, 13, 13, 74, 74, 67, 67, 71, 71, 45, 45, 57, 52, 32, 32, 25, 25, 58, 58, 55, 55, 51, 51, 54, 54]) == 870", "assert apps_run1(35, [6, 32, 4, 19, 9, 34, 20, 29, 22, 26, 19, 14, 33, 11, 17, 31, 30, 13, 7, 12, 8, 16, 5, 5, 21, 15, 18, 28, 34, 3, 2, 10, 23, 24, 35, 6, 32, 4, 25, 9, 1, 11, 24, 20, 26, 25, 2, 13, 22, 17, 31, 30, 33, 7, 12, 8, 16, 27, 27, 21, 15, 18, 28, 1, 3, 14, 10, 23, 29, 35]) == 673", "assert apps_run1(86, [33, 6, 22, 8, 54, 43, 57, 85, 70, 41, 20, 17, 35, 12, 66, 25, 45, 78, 67, 55, 50, 19, 31, 75, 77, 29, 58, 78, 34, 15, 40, 48, 14, 82, 6, 37, 44, 53, 62, 23, 56, 22, 34, 18, 71, 83, 21, 80, 47, 38, 3, 42, 60, 9, 73, 49, 84, 7, 76, 30, 5, 4, 11, 28, 69, 16, 26, 10, 59, 48, 64, 46, 32, 68, 24, 63, 79, 36, 13, 1, 27, 61, 39, 74, 2, 51, 51, 2, 74, 39, 61, 27, 1, 13, 36, 79, 86, 24, 68, 32, 46, 64, 63, 59, 10, 26, 16, 69, 28, 11, 4, 5, 30, 76, 7, 84, 49, 73, 9, 60, 42, 3, 38, 47, 80, 21, 83, 72, 18, 52, 65, 56, 23, 62, 53, 44, 37, 81, 82, 14, 86, 40, 15, 52, 72, 58, 29, 77, 85, 31, 19, 50, 55, 67, 71, 45, 25, 66, 12, 35, 17, 20, 41, 70, 75, 57, 43, 54, 8, 65, 81, 33]) == 6194"], "new_problem": "Allen is hosting a formal dinner party. 2n people come to the event in n pairs (couples). After a night of fun, Allen wants to line everyone up for a final picture. The 2n people line up, but Allen doesn't like the ordering. Allen prefers if each pair occupies adjacent positions in the line, as this makes the picture more aesthetic. Help Allen find the minimum number of swaps of adjacent positions he must perform to make it so that each couple occupies adjacent positions in the line. Additionally, provide an option to output the intermediate steps of the swaps if requested.", "new_solution": "from typing import List, Tuple\n\ndef apps_run2(n: int, xs: List[int], verbose: bool = False) -> int:\n    res = 0\n    steps = []\n    while xs:\n        j = xs.index(xs[0], 1)\n        res += j - 1\n        if verbose:\n            steps.append((xs[0], xs[j]))\n        xs = xs[1:j] + xs[j+1:]\n    if verbose:\n        print('Steps:', steps)\n    return res\n\n# Original function for backward compatibility\ndef original_min_swaps(n: int, xs: List[int]) -> int:\n    return apps_run2(n, xs)", "input_format": "The first line contains a single integer n (1 \u2264 n \u2264 100), the number of pairs of people. The second line contains 2n integers a_1, a_2, ..., a_{2n}. For each i with 1 \u2264 i \u2264 n, i appears exactly twice. If a_j = a_k = i, that means that the j-th and k-th people in the line form a couple. An optional third line can contain a string 'verbose' to enable detailed output.", "output_format": "Output a single integer, representing the minimum number of adjacent swaps needed to line the people up so that each pair occupies adjacent positions. If 'verbose' is provided, also output the intermediate steps.", "test_input": ["assert apps_run2(4, [1, 1, 2, 3, 3, 2, 4, 4]) == 2", "assert apps_run2(3, [1, 1, 2, 2, 3, 3]) == 0", "assert apps_run2(3, [3, 1, 2, 3, 1, 2]) == 3", "assert apps_run2(2, [1, 2, 1, 2]) == 1", "assert apps_run2(5, [1, 2, 3, 4, 5, 1, 2, 3, 4, 5]) == 10"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "APPS/2017-3", "raw_problem": "Allen is hosting a formal dinner party. $2n$ people come to the event in $n$ pairs (couples). After a night of fun, Allen wants to line everyone up for a final picture. The $2n$ people line up, but Allen doesn't like the ordering. Allen prefers if each pair occupies adjacent positions in the line, as this makes the picture more aesthetic.\n\nHelp Allen find the minimum number of swaps of adjacent positions he must perform to make it so that each couple occupies adjacent positions in the line.\n\n\n-----Input-----\n\nThe first line contains a single integer $n$ ($1 \\le n \\le 100$), the number of pairs of people.\n\nThe second line contains $2n$ integers $a_1, a_2, \\dots, a_{2n}$. For each $i$ with $1 \\le i \\le n$, $i$ appears exactly twice. If $a_j = a_k = i$, that means that the $j$-th and $k$-th people in the line form a couple.\n\n\n-----Output-----\n\nOutput a single integer, representing the minimum number of adjacent swaps needed to line the people up so that each pair occupies adjacent positions.\n\n\n-----Examples-----\nInput\n4\n1 1 2 3 3 2 4 4\n\nOutput\n2\n\nInput\n3\n1 1 2 2 3 3\n\nOutput\n0\n\nInput\n3\n3 1 2 3 1 2\n\nOutput\n3\n\n\n\n-----Note-----\n\nIn the first sample case, we can transform $1 1 2 3 3 2 4 4 \\rightarrow 1 1 2 3 2 3 4 4 \\rightarrow 1 1 2 2 3 3 4 4$ in two steps. Note that the sequence $1 1 2 3 3 2 4 4 \\rightarrow 1 1 3 2 3 2 4 4 \\rightarrow 1 1 3 3 2 2 4 4$ also works in the same number of steps.\n\nThe second sample case already satisfies the constraints; therefore we need $0$ swaps.", "raw_solution": "def apps_run1(n, xs):\n    res = 0\n    while xs:\n        j = xs.index(xs[0], 1)\n        res += j - 1\n        xs = xs[1:j] + xs[j+1:]\n    return res", "raw_test_input": ["assert apps_run1(4, [1, 1, 2, 3, 3, 2, 4, 4]) == 2", "assert apps_run1(3, [1, 1, 2, 2, 3, 3]) == 0", "assert apps_run1(3, [3, 1, 2, 3, 1, 2]) == 3", "assert apps_run1(8, [7, 6, 2, 1, 4, 3, 3, 7, 2, 6, 5, 1, 8, 5, 8, 4]) == 27", "assert apps_run1(2, [1, 2, 1, 2]) == 1", "assert apps_run1(3, [1, 2, 3, 3, 1, 2]) == 5", "assert apps_run1(38, [26, 28, 23, 34, 33, 14, 38, 15, 35, 36, 30, 1, 19, 17, 18, 28, 22, 15, 9, 27, 11, 16, 17, 32, 7, 21, 6, 8, 32, 26, 33, 23, 18, 4, 2, 25, 29, 3, 35, 8, 38, 37, 31, 37, 12, 25, 3, 27, 16, 24, 5, 20, 12, 13, 29, 11, 30, 22, 9, 19, 2, 24, 7, 10, 34, 4, 36, 21, 14, 31, 13, 6, 20, 10, 5, 1]) == 744", "assert apps_run1(24, [21, 21, 22, 5, 8, 5, 15, 11, 13, 16, 17, 9, 3, 18, 15, 1, 12, 12, 7, 2, 22, 19, 20, 19, 23, 14, 8, 24, 4, 23, 16, 17, 9, 10, 1, 6, 4, 2, 7, 3, 18, 11, 24, 10, 13, 6, 20, 14]) == 259", "assert apps_run1(1, [1, 1]) == 0", "assert apps_run1(19, [15, 19, 18, 8, 12, 2, 11, 7, 5, 2, 1, 1, 9, 9, 3, 3, 16, 6, 15, 17, 13, 18, 4, 14, 5, 8, 10, 12, 6, 11, 17, 13, 14, 16, 19, 7, 4, 10]) == 181", "assert apps_run1(8, [3, 1, 5, 2, 1, 6, 3, 5, 6, 2, 4, 8, 8, 4, 7, 7]) == 13", "assert apps_run1(2, [2, 1, 1, 2]) == 2", "assert apps_run1(81, [48, 22, 31, 24, 73, 77, 79, 75, 37, 78, 43, 56, 20, 33, 70, 34, 6, 50, 51, 21, 39, 29, 20, 11, 73, 53, 39, 61, 28, 17, 55, 52, 28, 57, 52, 74, 35, 13, 55, 2, 57, 9, 46, 81, 60, 47, 21, 68, 1, 53, 31, 64, 42, 9, 79, 80, 69, 30, 32, 24, 15, 2, 69, 10, 22, 3, 71, 19, 67, 66, 17, 50, 62, 36, 32, 65, 58, 18, 25, 59, 38, 10, 14, 51, 23, 16, 29, 81, 45, 40, 18, 54, 47, 12, 45, 74, 41, 34, 75, 44, 19, 77, 71, 67, 7, 16, 35, 49, 15, 3, 38, 4, 7, 25, 76, 66, 5, 65, 27, 6, 1, 72, 37, 42, 26, 60, 12, 64, 44, 41, 80, 13, 49, 68, 76, 48, 11, 78, 40, 61, 30, 43, 62, 58, 5, 4, 33, 26, 54, 27, 36, 72, 63, 63, 59, 70, 23, 8, 56, 8, 46, 14]) == 3186", "assert apps_run1(84, [10, 29, 12, 22, 55, 3, 81, 33, 64, 78, 46, 44, 69, 41, 34, 71, 24, 12, 22, 54, 63, 9, 65, 40, 36, 81, 32, 37, 83, 50, 28, 84, 53, 25, 72, 77, 41, 35, 50, 8, 29, 78, 72, 53, 21, 63, 16, 1, 79, 20, 66, 23, 38, 18, 44, 5, 27, 77, 32, 52, 42, 60, 67, 62, 64, 52, 14, 80, 4, 19, 15, 45, 40, 47, 42, 46, 68, 18, 70, 8, 3, 36, 65, 38, 73, 43, 59, 20, 66, 6, 51, 10, 58, 55, 51, 13, 4, 5, 43, 82, 71, 21, 9, 33, 47, 11, 61, 30, 76, 27, 24, 48, 75, 15, 48, 75, 2, 31, 83, 67, 59, 74, 56, 11, 39, 13, 45, 76, 26, 30, 39, 17, 61, 57, 68, 7, 70, 62, 49, 57, 49, 84, 31, 26, 56, 54, 74, 16, 60, 1, 80, 35, 82, 28, 79, 73, 14, 69, 6, 19, 25, 34, 23, 2, 58, 37, 7, 17]) == 3279", "assert apps_run1(4, [3, 4, 2, 4, 1, 2, 1, 3]) == 8", "assert apps_run1(75, [28, 28, 42, 3, 39, 39, 73, 73, 75, 75, 30, 30, 21, 9, 57, 41, 26, 70, 15, 15, 65, 65, 24, 24, 4, 4, 62, 62, 17, 17, 29, 29, 37, 37, 18, 18, 1, 1, 8, 8, 63, 63, 49, 49, 5, 5, 59, 59, 19, 19, 34, 34, 48, 48, 10, 10, 14, 42, 22, 22, 38, 38, 50, 50, 60, 60, 64, 35, 47, 31, 72, 72, 41, 52, 46, 46, 20, 20, 21, 9, 7, 7, 36, 36, 2, 2, 6, 6, 70, 26, 69, 69, 16, 16, 61, 61, 66, 66, 33, 33, 44, 44, 11, 11, 23, 23, 40, 40, 12, 12, 64, 35, 56, 56, 27, 27, 53, 53, 3, 14, 43, 43, 31, 47, 68, 68, 13, 13, 74, 74, 67, 67, 71, 71, 45, 45, 57, 52, 32, 32, 25, 25, 58, 58, 55, 55, 51, 51, 54, 54]) == 870", "assert apps_run1(35, [6, 32, 4, 19, 9, 34, 20, 29, 22, 26, 19, 14, 33, 11, 17, 31, 30, 13, 7, 12, 8, 16, 5, 5, 21, 15, 18, 28, 34, 3, 2, 10, 23, 24, 35, 6, 32, 4, 25, 9, 1, 11, 24, 20, 26, 25, 2, 13, 22, 17, 31, 30, 33, 7, 12, 8, 16, 27, 27, 21, 15, 18, 28, 1, 3, 14, 10, 23, 29, 35]) == 673", "assert apps_run1(86, [33, 6, 22, 8, 54, 43, 57, 85, 70, 41, 20, 17, 35, 12, 66, 25, 45, 78, 67, 55, 50, 19, 31, 75, 77, 29, 58, 78, 34, 15, 40, 48, 14, 82, 6, 37, 44, 53, 62, 23, 56, 22, 34, 18, 71, 83, 21, 80, 47, 38, 3, 42, 60, 9, 73, 49, 84, 7, 76, 30, 5, 4, 11, 28, 69, 16, 26, 10, 59, 48, 64, 46, 32, 68, 24, 63, 79, 36, 13, 1, 27, 61, 39, 74, 2, 51, 51, 2, 74, 39, 61, 27, 1, 13, 36, 79, 86, 24, 68, 32, 46, 64, 63, 59, 10, 26, 16, 69, 28, 11, 4, 5, 30, 76, 7, 84, 49, 73, 9, 60, 42, 3, 38, 47, 80, 21, 83, 72, 18, 52, 65, 56, 23, 62, 53, 44, 37, 81, 82, 14, 86, 40, 15, 52, 72, 58, 29, 77, 85, 31, 19, 50, 55, 67, 71, 45, 25, 66, 12, 35, 17, 20, 41, 70, 75, 57, 43, 54, 8, 65, 81, 33]) == 6194"], "new_problem": "Allen is hosting a formal dinner party. $2n$ people come to the event in $n$ pairs (couples). After a night of fun, Allen wants to line everyone up for a final picture. The $2n$ people line up, but Allen doesn't like the ordering. Allen prefers if each pair occupies adjacent positions in the line, as this makes the picture more aesthetic. However, this time, each person has a unique identifier and a name. Help Allen find the minimum number of swaps of adjacent positions he must perform to make it so that each couple occupies adjacent positions in the line. Use a dictionary to map each person's identifier to their name and ensure that the solution handles this mapping efficiently.", "new_solution": "def apps_run2(n: int, people: list[tuple[int, str]]) -> int:\n    xs = [person[0] for person in people]\n    seen = {}\n    res = 0\n    while xs:\n        j = xs.index(xs[0], 1)\n        res += j - 1\n        xs = xs[1:j] + xs[j+1:]\n    return res", "input_format": "The first line contains a single integer n (1 \u2264 n \u2264 100), the number of pairs of people. The second line contains 2n integers a_1, a_2, ..., a_{2n}. For each i with 1 \u2264 i \u2264 n, i appears exactly twice. If a_j = a_k = i, that means that the j-th and k-th people in the line form a couple.", "output_format": "Output a single integer, representing the minimum number of adjacent swaps needed to line the people up so that each pair occupies adjacent positions.", "test_input": ["assert apps_run2(4, [(1, 'Alice'), (1, 'Bob'), (2, 'Charlie'), (3, 'David'), (3, 'Eve'), (2, 'Frank'), (4, 'Grace'), (4, 'Heidi')]) == 2", "assert apps_run2(3, [(1, 'Alice'), (1, 'Bob'), (2, 'Charlie'), (2, 'David'), (3, 'Eve'), (3, 'Frank')]) == 0", "assert apps_run2(3, [(3, 'Alice'), (1, 'Bob'), (2, 'Charlie'), (3, 'David'), (1, 'Eve'), (2, 'Frank')]) == 3", "assert apps_run2(2, [(1, 'Alice'), (2, 'Bob'), (1, 'Charlie'), (2, 'David')]) == 1", "assert apps_run2(5, [(1, 'Alice'), (2, 'Bob'), (3, 'Charlie'), (4, 'David'), (5, 'Eve'), (1, 'Frank'), (2, 'Grace'), (3, 'Heidi'), (4, 'Ivan'), (5, 'Judy')]) == 10"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "APPS/2017-4", "raw_problem": "Allen is hosting a formal dinner party. $2n$ people come to the event in $n$ pairs (couples). After a night of fun, Allen wants to line everyone up for a final picture. The $2n$ people line up, but Allen doesn't like the ordering. Allen prefers if each pair occupies adjacent positions in the line, as this makes the picture more aesthetic.\n\nHelp Allen find the minimum number of swaps of adjacent positions he must perform to make it so that each couple occupies adjacent positions in the line.\n\n\n-----Input-----\n\nThe first line contains a single integer $n$ ($1 \\le n \\le 100$), the number of pairs of people.\n\nThe second line contains $2n$ integers $a_1, a_2, \\dots, a_{2n}$. For each $i$ with $1 \\le i \\le n$, $i$ appears exactly twice. If $a_j = a_k = i$, that means that the $j$-th and $k$-th people in the line form a couple.\n\n\n-----Output-----\n\nOutput a single integer, representing the minimum number of adjacent swaps needed to line the people up so that each pair occupies adjacent positions.\n\n\n-----Examples-----\nInput\n4\n1 1 2 3 3 2 4 4\n\nOutput\n2\n\nInput\n3\n1 1 2 2 3 3\n\nOutput\n0\n\nInput\n3\n3 1 2 3 1 2\n\nOutput\n3\n\n\n\n-----Note-----\n\nIn the first sample case, we can transform $1 1 2 3 3 2 4 4 \\rightarrow 1 1 2 3 2 3 4 4 \\rightarrow 1 1 2 2 3 3 4 4$ in two steps. Note that the sequence $1 1 2 3 3 2 4 4 \\rightarrow 1 1 3 2 3 2 4 4 \\rightarrow 1 1 3 3 2 2 4 4$ also works in the same number of steps.\n\nThe second sample case already satisfies the constraints; therefore we need $0$ swaps.", "raw_solution": "def apps_run1(n, xs):\n    seen = {}\n    res = 0\n    while xs:\n        j = xs.index(xs[0], 1)\n        res += j - 1\n        xs = xs[1:j] + xs[j+1:]\n    return res", "raw_test_input": ["assert apps_run1(4, [1, 1, 2, 3, 3, 2, 4, 4]) == 2", "assert apps_run1(3, [1, 1, 2, 2, 3, 3]) == 0", "assert apps_run1(3, [3, 1, 2, 3, 1, 2]) == 3", "assert apps_run1(8, [7, 6, 2, 1, 4, 3, 3, 7, 2, 6, 5, 1, 8, 5, 8, 4]) == 27", "assert apps_run1(2, [1, 2, 1, 2]) == 1", "assert apps_run1(3, [1, 2, 3, 3, 1, 2]) == 5", "assert apps_run1(38, [26, 28, 23, 34, 33, 14, 38, 15, 35, 36, 30, 1, 19, 17, 18, 28, 22, 15, 9, 27, 11, 16, 17, 32, 7, 21, 6, 8, 32, 26, 33, 23, 18, 4, 2, 25, 29, 3, 35, 8, 38, 37, 31, 37, 12, 25, 3, 27, 16, 24, 5, 20, 12, 13, 29, 11, 30, 22, 9, 19, 2, 24, 7, 10, 34, 4, 36, 21, 14, 31, 13, 6, 20, 10, 5, 1]) == 744", "assert apps_run1(24, [21, 21, 22, 5, 8, 5, 15, 11, 13, 16, 17, 9, 3, 18, 15, 1, 12, 12, 7, 2, 22, 19, 20, 19, 23, 14, 8, 24, 4, 23, 16, 17, 9, 10, 1, 6, 4, 2, 7, 3, 18, 11, 24, 10, 13, 6, 20, 14]) == 259", "assert apps_run1(1, [1, 1]) == 0", "assert apps_run1(19, [15, 19, 18, 8, 12, 2, 11, 7, 5, 2, 1, 1, 9, 9, 3, 3, 16, 6, 15, 17, 13, 18, 4, 14, 5, 8, 10, 12, 6, 11, 17, 13, 14, 16, 19, 7, 4, 10]) == 181", "assert apps_run1(8, [3, 1, 5, 2, 1, 6, 3, 5, 6, 2, 4, 8, 8, 4, 7, 7]) == 13", "assert apps_run1(2, [2, 1, 1, 2]) == 2", "assert apps_run1(81, [48, 22, 31, 24, 73, 77, 79, 75, 37, 78, 43, 56, 20, 33, 70, 34, 6, 50, 51, 21, 39, 29, 20, 11, 73, 53, 39, 61, 28, 17, 55, 52, 28, 57, 52, 74, 35, 13, 55, 2, 57, 9, 46, 81, 60, 47, 21, 68, 1, 53, 31, 64, 42, 9, 79, 80, 69, 30, 32, 24, 15, 2, 69, 10, 22, 3, 71, 19, 67, 66, 17, 50, 62, 36, 32, 65, 58, 18, 25, 59, 38, 10, 14, 51, 23, 16, 29, 81, 45, 40, 18, 54, 47, 12, 45, 74, 41, 34, 75, 44, 19, 77, 71, 67, 7, 16, 35, 49, 15, 3, 38, 4, 7, 25, 76, 66, 5, 65, 27, 6, 1, 72, 37, 42, 26, 60, 12, 64, 44, 41, 80, 13, 49, 68, 76, 48, 11, 78, 40, 61, 30, 43, 62, 58, 5, 4, 33, 26, 54, 27, 36, 72, 63, 63, 59, 70, 23, 8, 56, 8, 46, 14]) == 3186", "assert apps_run1(84, [10, 29, 12, 22, 55, 3, 81, 33, 64, 78, 46, 44, 69, 41, 34, 71, 24, 12, 22, 54, 63, 9, 65, 40, 36, 81, 32, 37, 83, 50, 28, 84, 53, 25, 72, 77, 41, 35, 50, 8, 29, 78, 72, 53, 21, 63, 16, 1, 79, 20, 66, 23, 38, 18, 44, 5, 27, 77, 32, 52, 42, 60, 67, 62, 64, 52, 14, 80, 4, 19, 15, 45, 40, 47, 42, 46, 68, 18, 70, 8, 3, 36, 65, 38, 73, 43, 59, 20, 66, 6, 51, 10, 58, 55, 51, 13, 4, 5, 43, 82, 71, 21, 9, 33, 47, 11, 61, 30, 76, 27, 24, 48, 75, 15, 48, 75, 2, 31, 83, 67, 59, 74, 56, 11, 39, 13, 45, 76, 26, 30, 39, 17, 61, 57, 68, 7, 70, 62, 49, 57, 49, 84, 31, 26, 56, 54, 74, 16, 60, 1, 80, 35, 82, 28, 79, 73, 14, 69, 6, 19, 25, 34, 23, 2, 58, 37, 7, 17]) == 3279", "assert apps_run1(4, [3, 4, 2, 4, 1, 2, 1, 3]) == 8", "assert apps_run1(75, [28, 28, 42, 3, 39, 39, 73, 73, 75, 75, 30, 30, 21, 9, 57, 41, 26, 70, 15, 15, 65, 65, 24, 24, 4, 4, 62, 62, 17, 17, 29, 29, 37, 37, 18, 18, 1, 1, 8, 8, 63, 63, 49, 49, 5, 5, 59, 59, 19, 19, 34, 34, 48, 48, 10, 10, 14, 42, 22, 22, 38, 38, 50, 50, 60, 60, 64, 35, 47, 31, 72, 72, 41, 52, 46, 46, 20, 20, 21, 9, 7, 7, 36, 36, 2, 2, 6, 6, 70, 26, 69, 69, 16, 16, 61, 61, 66, 66, 33, 33, 44, 44, 11, 11, 23, 23, 40, 40, 12, 12, 64, 35, 56, 56, 27, 27, 53, 53, 3, 14, 43, 43, 31, 47, 68, 68, 13, 13, 74, 74, 67, 67, 71, 71, 45, 45, 57, 52, 32, 32, 25, 25, 58, 58, 55, 55, 51, 51, 54, 54]) == 870", "assert apps_run1(35, [6, 32, 4, 19, 9, 34, 20, 29, 22, 26, 19, 14, 33, 11, 17, 31, 30, 13, 7, 12, 8, 16, 5, 5, 21, 15, 18, 28, 34, 3, 2, 10, 23, 24, 35, 6, 32, 4, 25, 9, 1, 11, 24, 20, 26, 25, 2, 13, 22, 17, 31, 30, 33, 7, 12, 8, 16, 27, 27, 21, 15, 18, 28, 1, 3, 14, 10, 23, 29, 35]) == 673", "assert apps_run1(86, [33, 6, 22, 8, 54, 43, 57, 85, 70, 41, 20, 17, 35, 12, 66, 25, 45, 78, 67, 55, 50, 19, 31, 75, 77, 29, 58, 78, 34, 15, 40, 48, 14, 82, 6, 37, 44, 53, 62, 23, 56, 22, 34, 18, 71, 83, 21, 80, 47, 38, 3, 42, 60, 9, 73, 49, 84, 7, 76, 30, 5, 4, 11, 28, 69, 16, 26, 10, 59, 48, 64, 46, 32, 68, 24, 63, 79, 36, 13, 1, 27, 61, 39, 74, 2, 51, 51, 2, 74, 39, 61, 27, 1, 13, 36, 79, 86, 24, 68, 32, 46, 64, 63, 59, 10, 26, 16, 69, 28, 11, 4, 5, 30, 76, 7, 84, 49, 73, 9, 60, 42, 3, 38, 47, 80, 21, 83, 72, 18, 52, 65, 56, 23, 62, 53, 44, 37, 81, 82, 14, 86, 40, 15, 52, 72, 58, 29, 77, 85, 31, 19, 50, 55, 67, 71, 45, 25, 66, 12, 35, 17, 20, 41, 70, 75, 57, 43, 54, 8, 65, 81, 33]) == 6194"], "new_problem": "Allen is hosting a formal dinner party. $2n$ people come to the event in $n$ pairs (couples). After a night of fun, Allen wants to line everyone up for a final picture. The $2n$ people line up, but Allen doesn't like the ordering. Allen prefers if each pair occupies adjacent positions in the line, as this makes the picture more aesthetic. However, due to a miscommunication, the list of people might not be correctly formatted. Help Allen find the minimum number of swaps of adjacent positions he must perform to make it so that each couple occupies adjacent positions in the line. You must handle the following errors: 1. If the number of people is not even, raise a ValueError with the message 'Number of people must be even.' 2. If any person appears more than twice or less than twice, raise a ValueError with the message 'Each person must appear exactly twice.' 3. If the input list is empty or does not match the expected format, raise a ValueError with the message 'Invalid input format.'", "new_solution": "def apps_run2(n: int, xs: list[int]) -> int:\n    if len(xs) != 2 * n:\n        raise ValueError('Number of people must be even.')\n    \n    from collections import Counter\n    count = Counter(xs)\n    for person, cnt in count.items():\n        if cnt != 2:\n            raise ValueError('Each person must appear exactly twice.')\n\n    res = 0\n    while xs:\n        try:\n            j = xs.index(xs[0], 1)\n        except ValueError:\n            raise ValueError('Invalid input format.')\n        res += j - 1\n        xs = xs[1:j] + xs[j+1:]\n\n    return res", "input_format": "The first line contains a single integer n (1 <= n <= 100), the number of pairs of people. The second line contains 2n integers a_1, a_2, ..., a_{2n}. For each i with 1 <= i <= n, i appears exactly twice.", "output_format": "Output a single integer, representing the minimum number of adjacent swaps needed to line the people up so that each pair occupies adjacent positions.", "test_input": ["assert apps_run2(4, [1, 1, 2, 3, 3, 2, 4, 4]) == 2", "assert apps_run2(3, [1, 1, 2, 2, 3, 3]) == 0", "assert apps_run2(3, [3, 1, 2, 3, 1, 2]) == 3", "try:\n    apps_run2(3, [1, 1, 2, 2, 3])\nexcept ValueError as e:\n    assert str(e) == 'Number of people must be even.'", "try:\n    apps_run2(3, [1, 1, 2, 2, 3, 3, 3])\nexcept ValueError as e:\n    assert str(e) == 'Number of people must be even.'"], "requirement_type": "PROMPT_ERROR_HANDLING"}
{"task_id": "APPS/2018-1", "raw_problem": "This problem is the most boring one you've ever seen. \n\nGiven a sequence of integers a_1, a_2, ..., a_{n} and a non-negative integer h, our goal is to partition the sequence into two subsequences (not necessarily consist of continuous elements). Each element of the original sequence should be contained in exactly one of the result subsequences. Note, that one of the result subsequences can be empty.\n\nLet's define function f(a_{i}, a_{j}) on pairs of distinct elements (that is i \u2260 j) in the original sequence. If a_{i} and a_{j} are in the same subsequence in the current partition then f(a_{i}, a_{j}) = a_{i} + a_{j} otherwise f(a_{i}, a_{j}) = a_{i} + a_{j} + h. \n\nConsider all possible values of the function f for some partition. We'll call the goodness of this partiotion the difference between the maximum value of function f and the minimum value of function f.\n\nYour task is to find a partition of the given sequence a that have the minimal possible goodness among all possible partitions.\n\n\n-----Input-----\n\nThe first line of input contains integers n and h (2 \u2264 n \u2264 10^5, 0 \u2264 h \u2264 10^8). In the second line there is a list of n space-separated integers representing a_1, a_2, ..., a_{n} (0 \u2264 a_{i} \u2264 10^8).\n\n\n-----Output-----\n\nThe first line of output should contain the required minimum goodness. \n\nThe second line describes the optimal partition. You should print n whitespace-separated integers in the second line. The i-th integer is 1 if a_{i} is in the first subsequence otherwise it should be 2.\n\nIf there are several possible correct answers you are allowed to print any of them.\n\n\n-----Examples-----\nInput\n3 2\n1 2 3\n\nOutput\n1\n1 2 2 \n\nInput\n5 10\n0 1 0 2 1\n\nOutput\n3\n2 2 2 2 2 \n\n\n\n-----Note-----\n\nIn the first sample the values of f are as follows: f(1, 2) = 1 + 2 + 2 = 5, f(1, 3) = 1 + 3 + 2 = 6 and f(2, 3) = 2 + 3 = 5. So the difference between maximum and minimum values of f is 1.\n\nIn the second sample the value of h is large, so it's better for one of the sub-sequences to be empty.", "raw_solution": "def apps_run1(input_str):\n    input_lines = input_str.strip().split('\\n')\n    n, m = map(int, input_lines[0].split())\n    a = list(map(int, input_lines[1].split()))\n    p = 0\n    t = [0] * 3\n    for i in range(n):\n        if a[i] < a[p]:\n            p = i\n    if n == 2:\n        return '0\\n1 1\\n'\n    else:\n        a.sort()\n        t[0] = min(a[0] + a[1] + m, a[1] + a[2])\n        t[1] = max(a[0] + a[n - 1] + m, a[n - 2] + a[n - 1])\n        t[2] = (a[n - 2] + a[n - 1]) - (a[0] + a[1])\n        if t[1] - t[0] > t[2]:\n            p = n\n        else:\n            t[2] = t[1] - t[0]\n        result = f'{t[2]}\\n'\n        result += ' '.join(str(int(i == p) + 1) for i in range(n)) + ' '\n        return result\n", "raw_test_input": ["assert apps_run1('3 2\\n1 2 3\\n') == '1\\n2 1 1 '", "assert apps_run1('5 10\\n0 1 0 2 1\\n') == '3\\n1 1 1 1 1 '", "assert apps_run1('9 0\\n11 22 33 44 55 66 77 88 99\\n') == '154\\n2 1 1 1 1 1 1 1 1 '", "assert apps_run1('10 100\\n2705446 2705444 2705446 2705445 2705448 2705447 2705444 2705448 2705448 2705449\\n') == '9\\n1 1 1 1 1 1 1 1 1 1 '", "assert apps_run1('10 5\\n5914099 5914094 5914099 5914097 5914100 5914101 5914097 5914095 5914101 5914102\\n') == '11\\n1 2 1 1 1 1 1 1 1 1 '", "assert apps_run1('12 3\\n7878607 7878605 7878605 7878613 7878612 7878609 7878609 7878608 7878609 7878611 7878609 7878613\\n') == '14\\n1 2 1 1 1 1 1 1 1 1 1 1 '", "assert apps_run1('9 6\\n10225066 10225069 10225069 10225064 10225068 10225067 10225066 10225063 10225062\\n') == '11\\n1 1 1 1 1 1 1 1 2 '", "assert apps_run1('20 10\\n12986238 12986234 12986240 12986238 12986234 12986238 12986234 12986234 12986236 12986236 12986232 12986238 12986232 12986239 12986233 12986238 12986237 12986232 12986231 12986235\\n') == '16\\n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 '", "assert apps_run1('4 3\\n16194884 16194881 16194881 16194883\\n') == '4\\n1 2 1 1 '", "assert apps_run1('2 5\\n23921862 23921857\\n') == '0\\n1 1\\n'", "assert apps_run1('3 8\\n28407428 28407413 28407422\\n') == '7\\n1 2 1 '", "assert apps_run1('7 4\\n0 10 10 11 11 12 13\\n') == '11\\n2 1 1 1 1 1 1 '", "assert apps_run1('10 6\\n4 2 2 3 4 0 3 2 2 2\\n') == '6\\n1 1 1 1 1 2 1 1 1 1 '", "assert apps_run1('5 10000000\\n1 1 2 2 100000000\\n') == '100000000\\n1 1 1 1 1 '", "assert apps_run1('2 2\\n2 2\\n') == '0\\n1 1\\n'", "assert apps_run1('2 0\\n8 9\\n') == '0\\n1 1\\n'", "assert apps_run1('2 5\\n8 9\\n') == '0\\n1 1\\n'", "assert apps_run1('10 1\\n10 10 10 10 10 4 4 4 4 1\\n') == '14\\n1 1 1 1 1 1 1 1 1 2 '"], "new_problem": "In a logistics company, you are tasked with optimizing the distribution of packages to minimize the variance in delivery times. Each package has a priority level represented by an integer. You need to partition these packages into two groups such that the difference between the maximum and minimum sum of priorities within the same group is minimized. Additionally, you have the option to swap the priority levels of any two packages up to k times to achieve a better partition. Given the sequence of priority levels and a number of swap queries, determine the minimum possible goodness for each query after performing the swap.", "new_solution": "def find_min_goodness(n, h, a):\n    p = 0\n    t = [0] * 3\n    for i in range(n):\n        if a[i] < a[p]:\n            p = i\n    if n == 2:\n        return 0, [1, 1]\n    else:\n        a.sort()\n        t[0] = min(a[0] + a[1] + h, a[1] + a[2])\n        t[1] = max(a[0] + a[n-1] + h, a[n-2] + a[n-1])\n        t[2] = (a[n-2] + a[n-1]) - (a[0] + a[1])\n        if t[1] - t[0] > t[2]:\n            p = n\n        else:\n            t[2] = t[1] - t[0]\n        return t[2], [int(i == p) + 1 for i in range(n)]\n\ndef apps_run2(n, h, a, queries):\n    results = []\n    for x, y in queries:\n        a[x-1], a[y-1] = a[y-1], a[x-1]\n        min_goodness, _ = find_min_goodness(n, h, a)\n        results.append(min_goodness)\n        a[x-1], a[y-1] = a[y-1], a[x-1]  # Swap back to original\n    return results", "input_format": "The first line contains integers n, h, and k (2 \u2264 n \u2264 10^5, 0 \u2264 h \u2264 10^8, 1 \u2264 k \u2264 10^3). The second line contains n space-separated integers representing a_1, a_2, ..., a_{n} (0 \u2264 a_{i} \u2264 10^8). The next k lines each contain two integers x and y (1 \u2264 x, y \u2264 n) representing a query to find the minimum goodness of the sequence after swapping elements a_x and a_y.", "output_format": "For each query, output the minimum goodness of the sequence after the swap on a new line.", "test_input": ["assert apps_run2(3, 2, [1, 2, 3], [(1, 2), (2, 3)]) == [1, 1]", "assert apps_run2(5, 10, [0, 1, 0, 2, 1], [(1, 5), (2, 4)]) == [3, 3]", "assert apps_run2(4, 5, [4, 3, 2, 1], [(1, 4), (2, 3)]) == [4, 4]", "assert apps_run2(6, 0, [10, 20, 30, 40, 50, 60], [(1, 6), (3, 4)]) == [80, 80]", "assert apps_run2(7, 3, [7, 6, 5, 4, 3, 2, 1], [(1, 7), (2, 6)]) == [8, 8]"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "APPS/2018-2", "raw_problem": "This problem is the most boring one you've ever seen. \n\nGiven a sequence of integers a_1, a_2, ..., a_{n} and a non-negative integer h, our goal is to partition the sequence into two subsequences (not necessarily consist of continuous elements). Each element of the original sequence should be contained in exactly one of the result subsequences. Note, that one of the result subsequences can be empty.\n\nLet's define function f(a_{i}, a_{j}) on pairs of distinct elements (that is i \u2260 j) in the original sequence. If a_{i} and a_{j} are in the same subsequence in the current partition then f(a_{i}, a_{j}) = a_{i} + a_{j} otherwise f(a_{i}, a_{j}) = a_{i} + a_{j} + h. \n\nConsider all possible values of the function f for some partition. We'll call the goodness of this partiotion the difference between the maximum value of function f and the minimum value of function f.\n\nYour task is to find a partition of the given sequence a that have the minimal possible goodness among all possible partitions.\n\n\n-----Input-----\n\nThe first line of input contains integers n and h (2 \u2264 n \u2264 10^5, 0 \u2264 h \u2264 10^8). In the second line there is a list of n space-separated integers representing a_1, a_2, ..., a_{n} (0 \u2264 a_{i} \u2264 10^8).\n\n\n-----Output-----\n\nThe first line of output should contain the required minimum goodness. \n\nThe second line describes the optimal partition. You should print n whitespace-separated integers in the second line. The i-th integer is 1 if a_{i} is in the first subsequence otherwise it should be 2.\n\nIf there are several possible correct answers you are allowed to print any of them.\n\n\n-----Examples-----\nInput\n3 2\n1 2 3\n\nOutput\n1\n1 2 2 \n\nInput\n5 10\n0 1 0 2 1\n\nOutput\n3\n2 2 2 2 2 \n\n\n\n-----Note-----\n\nIn the first sample the values of f are as follows: f(1, 2) = 1 + 2 + 2 = 5, f(1, 3) = 1 + 3 + 2 = 6 and f(2, 3) = 2 + 3 = 5. So the difference between maximum and minimum values of f is 1.\n\nIn the second sample the value of h is large, so it's better for one of the sub-sequences to be empty.", "raw_solution": "def apps_run1(n, m, a):\n    p = 0\n    t = [0] * 3\n    for i in range(n):\n        if a[i] < a[p]:\n            p = i\n    if n == 2:\n        return '0\\n1 1\\n'\n    else:\n        a.sort()\n        t[0] = min(a[0] + a[1] + m, a[1] + a[2])\n        t[1] = max(a[0] + a[n - 1] + m, a[n - 2] + a[n - 1])\n        t[2] = (a[n - 2] + a[n - 1]) - (a[0] + a[1])\n        if t[1] - t[0] > t[2]:\n            p = n\n        else:\n            t[2] = t[1] - t[0]\n        result = f'{t[2]}\\n'\n        result += ' '.join(str(int(i == p) + 1) for i in range(n)) + ' '\n        return result\n", "raw_test_input": ["assert apps_run1(3, 2, [1, 2, 3]) == '1\\n2 1 1 '", "assert apps_run1(5, 10, [0, 1, 0, 2, 1]) == '3\\n1 1 1 1 1 '", "assert apps_run1(9, 0, [11, 22, 33, 44, 55, 66, 77, 88, 99]) == '154\\n2 1 1 1 1 1 1 1 1 '", "assert apps_run1(10, 100, [2705446, 2705444, 2705446, 2705445, 2705448, 2705447, 2705444, 2705448, 2705448, 2705449]) == '9\\n1 1 1 1 1 1 1 1 1 1 '", "assert apps_run1(10, 5, [5914099, 5914094, 5914099, 5914097, 5914100, 5914101, 5914097, 5914095, 5914101, 5914102]) == '11\\n1 2 1 1 1 1 1 1 1 1 '", "assert apps_run1(12, 3, [7878607, 7878605, 7878605, 7878613, 7878612, 7878609, 7878609, 7878608, 7878609, 7878611, 7878609, 7878613]) == '14\\n1 2 1 1 1 1 1 1 1 1 1 1 '", "assert apps_run1(9, 6, [10225066, 10225069, 10225069, 10225064, 10225068, 10225067, 10225066, 10225063, 10225062]) == '11\\n1 1 1 1 1 1 1 1 2 '", "assert apps_run1(20, 10, [12986238, 12986234, 12986240, 12986238, 12986234, 12986238, 12986234, 12986234, 12986236, 12986236, 12986232, 12986238, 12986232, 12986239, 12986233, 12986238, 12986237, 12986232, 12986231, 12986235]) == '16\\n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 '", "assert apps_run1(4, 3, [16194884, 16194881, 16194881, 16194883]) == '4\\n1 2 1 1 '", "assert apps_run1(2, 5, [23921862, 23921857]) == '0\\n1 1\\n'", "assert apps_run1(3, 8, [28407428, 28407413, 28407422]) == '7\\n1 2 1 '", "assert apps_run1(7, 4, [0, 10, 10, 11, 11, 12, 13]) == '11\\n2 1 1 1 1 1 1 '", "assert apps_run1(10, 6, [4, 2, 2, 3, 4, 0, 3, 2, 2, 2]) == '6\\n1 1 1 1 1 2 1 1 1 1 '", "assert apps_run1(5, 10000000, [1, 1, 2, 2, 100000000]) == '100000000\\n1 1 1 1 1 '", "assert apps_run1(2, 2, [2, 2]) == '0\\n1 1\\n'", "assert apps_run1(2, 0, [8, 9]) == '0\\n1 1\\n'", "assert apps_run1(2, 5, [8, 9]) == '0\\n1 1\\n'", "assert apps_run1(10, 1, [10, 10, 10, 10, 10, 4, 4, 4, 4, 1]) == '14\\n1 1 1 1 1 1 1 1 1 2 '"], "new_problem": "Given a sequence of integers a_1, a_2, ..., a_{n}, a non-negative integer h, and an optional integer k, our goal is to partition the sequence into two subsequences (not necessarily consisting of continuous elements). Each element of the original sequence should be contained in exactly one of the result subsequences. Note that one of the result subsequences can be empty. The function f(a_{i}, a_{j}) is defined on pairs of distinct elements (i \u2260 j) in the original sequence. If a_{i} and a_{j} are in the same subsequence in the current partition, then f(a_{i}, a_{j}) = a_{i} + a_{j}. Otherwise, f(a_{i}, a_{j}) = a_{i} + a_{j} + h. Additionally, if the optional parameter k is provided, it should be added to the goodness value. Consider all possible values of the function f for some partition. We'll call the goodness of this partition the difference between the maximum value of function f and the minimum value of function f, plus k if k is provided. Your task is to find a partition of the given sequence a that has the minimal possible goodness among all possible partitions.", "new_solution": "def apps_run2(n: int, h: int, a: list[int], k: int = 0) -> tuple[int, list[int]]:\n    p = 0\n    t = [0] * 3\n    for i in range(n):\n        if a[i] < a[p]:\n            p = i\n    if n == 2:\n        return (0 + k, [1, 1])\n    else:\n        a.sort()\n        t[0] = min(a[0] + a[1] + h, a[1] + a[2])\n        t[1] = max(a[0] + a[n-1] + h, a[n-2] + a[n-1])\n        t[2] = (a[n-2] + a[n-1]) - (a[0] + a[1])\n        if t[1] - t[0] > t[2]:\n            p = n\n        else:\n            t[2] = t[1] - t[0]\n        return (t[2] + k, [int(i == p) + 1 for i in range(n)])", "input_format": "The first line of input contains integers n, h, and an optional integer k (2 \u2264 n \u2264 10^5, 0 \u2264 h \u2264 10^8, 0 \u2264 k \u2264 10^8). In the second line there is a list of n space-separated integers representing a_1, a_2, ..., a_{n} (0 \u2264 a_{i} \u2264 10^8).", "output_format": "The first line of output should contain the required minimum goodness. The second line describes the optimal partition. You should print n whitespace-separated integers in the second line. The i-th integer is 1 if a_{i} is in the first subsequence otherwise it should be 2.", "test_input": ["assert apps_run2(3, 2, [1, 2, 3]) == (1, [2, 1, 1])", "assert apps_run2(5, 10, [0, 1, 0, 2, 1]) == (3, [1, 1, 1, 1, 1])", "assert apps_run2(3, 2, [1, 2, 3], 5) == (6, [2, 1, 1])", "assert apps_run2(5, 10, [0, 1, 0, 2, 1], 7) == (10, [1, 1, 1, 1, 1])", "assert apps_run2(4, 0, [4, 3, 2, 1]) == (4, [1, 1, 1, 2])"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "APPS/2018-3", "raw_problem": "This problem is the most boring one you've ever seen. \n\nGiven a sequence of integers a_1, a_2, ..., a_{n} and a non-negative integer h, our goal is to partition the sequence into two subsequences (not necessarily consist of continuous elements). Each element of the original sequence should be contained in exactly one of the result subsequences. Note, that one of the result subsequences can be empty.\n\nLet's define function f(a_{i}, a_{j}) on pairs of distinct elements (that is i \u2260 j) in the original sequence. If a_{i} and a_{j} are in the same subsequence in the current partition then f(a_{i}, a_{j}) = a_{i} + a_{j} otherwise f(a_{i}, a_{j}) = a_{i} + a_{j} + h. \n\nConsider all possible values of the function f for some partition. We'll call the goodness of this partiotion the difference between the maximum value of function f and the minimum value of function f.\n\nYour task is to find a partition of the given sequence a that have the minimal possible goodness among all possible partitions.\n\n\n-----Input-----\n\nThe first line of input contains integers n and h (2 \u2264 n \u2264 10^5, 0 \u2264 h \u2264 10^8). In the second line there is a list of n space-separated integers representing a_1, a_2, ..., a_{n} (0 \u2264 a_{i} \u2264 10^8).\n\n\n-----Output-----\n\nThe first line of output should contain the required minimum goodness. \n\nThe second line describes the optimal partition. You should print n whitespace-separated integers in the second line. The i-th integer is 1 if a_{i} is in the first subsequence otherwise it should be 2.\n\nIf there are several possible correct answers you are allowed to print any of them.\n\n\n-----Examples-----\nInput\n3 2\n1 2 3\n\nOutput\n1\n1 2 2 \n\nInput\n5 10\n0 1 0 2 1\n\nOutput\n3\n2 2 2 2 2 \n\n\n\n-----Note-----\n\nIn the first sample the values of f are as follows: f(1, 2) = 1 + 2 + 2 = 5, f(1, 3) = 1 + 3 + 2 = 6 and f(2, 3) = 2 + 3 = 5. So the difference between maximum and minimum values of f is 1.\n\nIn the second sample the value of h is large, so it's better for one of the sub-sequences to be empty.", "raw_solution": "def apps_run1(n, m, a):\n    p = 0\n    t = [0] * 3\n    for i in range(n):\n        if a[i] < a[p]:\n            p = i\n    if n == 2:\n        return '0\\n1 1\\n'\n    else:\n        a.sort()\n        t[0] = min(a[0] + a[1] + m, a[1] + a[2])\n        t[1] = max(a[0] + a[n - 1] + m, a[n - 2] + a[n - 1])\n        t[2] = (a[n - 2] + a[n - 1]) - (a[0] + a[1])\n        if t[1] - t[0] > t[2]:\n            p = n\n        else:\n            t[2] = t[1] - t[0]\n        result = f'{t[2]}\\n'\n        result += ' '.join(str(int(i == p) + 1) for i in range(n)) + ' '\n        return result\n", "raw_test_input": ["assert apps_run1(3, 2, [1, 2, 3]) == '1\\n2 1 1 '", "assert apps_run1(5, 10, [0, 1, 0, 2, 1]) == '3\\n1 1 1 1 1 '", "assert apps_run1(9, 0, [11, 22, 33, 44, 55, 66, 77, 88, 99]) == '154\\n2 1 1 1 1 1 1 1 1 '", "assert apps_run1(10, 100, [2705446, 2705444, 2705446, 2705445, 2705448, 2705447, 2705444, 2705448, 2705448, 2705449]) == '9\\n1 1 1 1 1 1 1 1 1 1 '", "assert apps_run1(10, 5, [5914099, 5914094, 5914099, 5914097, 5914100, 5914101, 5914097, 5914095, 5914101, 5914102]) == '11\\n1 2 1 1 1 1 1 1 1 1 '", "assert apps_run1(12, 3, [7878607, 7878605, 7878605, 7878613, 7878612, 7878609, 7878609, 7878608, 7878609, 7878611, 7878609, 7878613]) == '14\\n1 2 1 1 1 1 1 1 1 1 1 1 '", "assert apps_run1(9, 6, [10225066, 10225069, 10225069, 10225064, 10225068, 10225067, 10225066, 10225063, 10225062]) == '11\\n1 1 1 1 1 1 1 1 2 '", "assert apps_run1(20, 10, [12986238, 12986234, 12986240, 12986238, 12986234, 12986238, 12986234, 12986234, 12986236, 12986236, 12986232, 12986238, 12986232, 12986239, 12986233, 12986238, 12986237, 12986232, 12986231, 12986235]) == '16\\n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 '", "assert apps_run1(4, 3, [16194884, 16194881, 16194881, 16194883]) == '4\\n1 2 1 1 '", "assert apps_run1(2, 5, [23921862, 23921857]) == '0\\n1 1\\n'", "assert apps_run1(3, 8, [28407428, 28407413, 28407422]) == '7\\n1 2 1 '", "assert apps_run1(7, 4, [0, 10, 10, 11, 11, 12, 13]) == '11\\n2 1 1 1 1 1 1 '", "assert apps_run1(10, 6, [4, 2, 2, 3, 4, 0, 3, 2, 2, 2]) == '6\\n1 1 1 1 1 2 1 1 1 1 '", "assert apps_run1(5, 10000000, [1, 1, 2, 2, 100000000]) == '100000000\\n1 1 1 1 1 '", "assert apps_run1(2, 2, [2, 2]) == '0\\n1 1\\n'", "assert apps_run1(2, 0, [8, 9]) == '0\\n1 1\\n'", "assert apps_run1(2, 5, [8, 9]) == '0\\n1 1\\n'", "assert apps_run1(10, 1, [10, 10, 10, 10, 10, 4, 4, 4, 4, 1]) == '14\\n1 1 1 1 1 1 1 1 1 2 '"], "new_problem": "Given a sequence of integers a_1, a_2, ..., a_{n} and a non-negative integer h, our goal is to partition the sequence into two subsequences (not necessarily consisting of continuous elements). Each element of the original sequence should be contained in exactly one of the result subsequences. Note that one of the result subsequences can be empty. Let's define function f(a_{i}, a_{j}) on pairs of distinct elements (that is i \u2260 j) in the original sequence. If a_{i} and a_{j} are in the same subsequence in the current partition then f(a_{i}, a_{j}) = a_{i} + a_{j} otherwise f(a_{i}, a_{j}) = a_{i} + a_{j} + h. Consider all possible values of the function f for some partition. We'll call the goodness of this partition the difference between the maximum value of function f and the minimum value of function f. Your task is to find a partition of the given sequence a that has the minimal possible goodness among all possible partitions. However, this time, the sequence is given as a dictionary where keys are indices and values are the integers. Additionally, the sequence can have up to 10^6 elements, and the solution must use a dictionary to store intermediate results for optimization.", "new_solution": "from typing import Dict, Tuple, List\n\ndef apps_run2(n: int, h: int, a: Dict[int, int]) -> Tuple[int, List[int]]:\n    p = 0\n    t = [0] * 3\n    a_list = list(a.values())\n    for i in range(n):\n        if a_list[i] < a_list[p]:\n            p = i\n    if n == 2:\n        return 0, [1, 1]\n    else:\n        a_list.sort()\n        t[0] = min(a_list[0] + a_list[1] + h, a_list[1] + a_list[2])\n        t[1] = max(a_list[0] + a_list[n-1] + h, a_list[n-2] + a_list[n-1])\n        t[2] = (a_list[n-2] + a_list[n-1]) - (a_list[0] + a_list[1])\n        if t[1] - t[0] > t[2]:\n            p = n\n        else:\n            t[2] = t[1] - t[0]\n        partition = [int(i == p) + 1 for i in range(n)]\n        return t[2], partition", "input_format": "The first line of input contains integers n and h (2 \u2264 n \u2264 10^5, 0 \u2264 h \u2264 10^8). In the second line, there is a list of n space-separated integers representing a_1, a_2, ..., a_{n} (0 \u2264 a_{i} \u2264 10^8).", "output_format": "The first line of output should contain the required minimum goodness. The second line describes the optimal partition. You should print n whitespace-separated integers in the second line. The i-th integer is 1 if a_{i} is in the first subsequence otherwise it should be 2.", "test_input": ["assert apps_run2(3, 2, {0: 1, 1: 2, 2: 3}) == (1, [2, 1, 1])", "assert apps_run2(5, 10, {0: 0, 1: 1, 2: 0, 3: 2, 4: 1}) == (3, [1, 1, 1, 1, 1])", "assert apps_run2(4, 5, {0: 4, 1: 3, 2: 2, 3: 1}) == (4, [1, 1, 1, 1])", "assert apps_run2(6, 0, {0: 10, 1: 20, 2: 30, 3: 40, 4: 50, 5: 60}) == (80, [2, 1, 1, 1, 1, 1])", "assert apps_run2(2, 100, {0: 100, 1: 200}) == (0, [1, 1])"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "APPS/2018-4", "raw_problem": "This problem is the most boring one you've ever seen. \n\nGiven a sequence of integers a_1, a_2, ..., a_{n} and a non-negative integer h, our goal is to partition the sequence into two subsequences (not necessarily consist of continuous elements). Each element of the original sequence should be contained in exactly one of the result subsequences. Note, that one of the result subsequences can be empty.\n\nLet's define function f(a_{i}, a_{j}) on pairs of distinct elements (that is i \u2260 j) in the original sequence. If a_{i} and a_{j} are in the same subsequence in the current partition then f(a_{i}, a_{j}) = a_{i} + a_{j} otherwise f(a_{i}, a_{j}) = a_{i} + a_{j} + h. \n\nConsider all possible values of the function f for some partition. We'll call the goodness of this partiotion the difference between the maximum value of function f and the minimum value of function f.\n\nYour task is to find a partition of the given sequence a that have the minimal possible goodness among all possible partitions.\n\n\n-----Input-----\n\nThe first line of input contains integers n and h (2 \u2264 n \u2264 10^5, 0 \u2264 h \u2264 10^8). In the second line there is a list of n space-separated integers representing a_1, a_2, ..., a_{n} (0 \u2264 a_{i} \u2264 10^8).\n\n\n-----Output-----\n\nThe first line of output should contain the required minimum goodness. \n\nThe second line describes the optimal partition. You should print n whitespace-separated integers in the second line. The i-th integer is 1 if a_{i} is in the first subsequence otherwise it should be 2.\n\nIf there are several possible correct answers you are allowed to print any of them.\n\n\n-----Examples-----\nInput\n3 2\n1 2 3\n\nOutput\n1\n1 2 2 \n\nInput\n5 10\n0 1 0 2 1\n\nOutput\n3\n2 2 2 2 2 \n\n\n\n-----Note-----\n\nIn the first sample the values of f are as follows: f(1, 2) = 1 + 2 + 2 = 5, f(1, 3) = 1 + 3 + 2 = 6 and f(2, 3) = 2 + 3 = 5. So the difference between maximum and minimum values of f is 1.\n\nIn the second sample the value of h is large, so it's better for one of the sub-sequences to be empty.", "raw_solution": "def apps_run1(input_str):\n    lines = input_str.strip().split('\\n')\n    n, m = map(int, lines[0].split())\n    a = list(map(int, lines[1].split()))\n    p = 0\n    t = [0] * 3\n    for i in range(n):\n        if a[i] < a[p]:\n            p = i\n    if n == 2:\n        return '0\\n1 1\\n'\n    else:\n        a.sort()\n        t[0] = min(a[0] + a[1] + m, a[1] + a[2])\n        t[1] = max(a[0] + a[n - 1] + m, a[n - 2] + a[n - 1])\n        t[2] = (a[n - 2] + a[n - 1]) - (a[0] + a[1])\n        if t[1] - t[0] > t[2]:\n            p = n\n        else:\n            t[2] = t[1] - t[0]\n        result = f'{t[2]}\\n'\n        result += ' '.join(str(int(i == p) + 1) for i in range(n)) + ' '\n        return result\n", "raw_test_input": ["assert apps_run1('3 2\\n1 2 3\\n') == '1\\n2 1 1 '", "assert apps_run1('5 10\\n0 1 0 2 1\\n') == '3\\n1 1 1 1 1 '", "assert apps_run1('9 0\\n11 22 33 44 55 66 77 88 99\\n') == '154\\n2 1 1 1 1 1 1 1 1 '", "assert apps_run1('10 100\\n2705446 2705444 2705446 2705445 2705448 2705447 2705444 2705448 2705448 2705449\\n') == '9\\n1 1 1 1 1 1 1 1 1 1 '", "assert apps_run1('10 5\\n5914099 5914094 5914099 5914097 5914100 5914101 5914097 5914095 5914101 5914102\\n') == '11\\n1 2 1 1 1 1 1 1 1 1 '", "assert apps_run1('12 3\\n7878607 7878605 7878605 7878613 7878612 7878609 7878609 7878608 7878609 7878611 7878609 7878613\\n') == '14\\n1 2 1 1 1 1 1 1 1 1 1 1 '", "assert apps_run1('9 6\\n10225066 10225069 10225069 10225064 10225068 10225067 10225066 10225063 10225062\\n') == '11\\n1 1 1 1 1 1 1 1 2 '", "assert apps_run1('20 10\\n12986238 12986234 12986240 12986238 12986234 12986238 12986234 12986234 12986236 12986236 12986232 12986238 12986232 12986239 12986233 12986238 12986237 12986232 12986231 12986235\\n') == '16\\n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 '", "assert apps_run1('4 3\\n16194884 16194881 16194881 16194883\\n') == '4\\n1 2 1 1 '", "assert apps_run1('2 5\\n23921862 23921857\\n') == '0\\n1 1\\n'", "assert apps_run1('3 8\\n28407428 28407413 28407422\\n') == '7\\n1 2 1 '", "assert apps_run1('7 4\\n0 10 10 11 11 12 13\\n') == '11\\n2 1 1 1 1 1 1 '", "assert apps_run1('10 6\\n4 2 2 3 4 0 3 2 2 2\\n') == '6\\n1 1 1 1 1 2 1 1 1 1 '", "assert apps_run1('5 10000000\\n1 1 2 2 100000000\\n') == '100000000\\n1 1 1 1 1 '", "assert apps_run1('2 2\\n2 2\\n') == '0\\n1 1\\n'", "assert apps_run1('2 0\\n8 9\\n') == '0\\n1 1\\n'", "assert apps_run1('2 5\\n8 9\\n') == '0\\n1 1\\n'", "assert apps_run1('10 1\\n10 10 10 10 10 4 4 4 4 1\\n') == '14\\n1 1 1 1 1 1 1 1 1 2 '"], "new_problem": "In a real-world scenario, you are tasked with developing a system that partitions a sequence of integers into two subsequences to minimize the 'goodness' of the partition. However, the system must handle various errors that can occur during input processing and computation. Specifically, you need to handle the following errors: \n1. InputFormatError: Raised when the input format is incorrect or when the number of integers does not match the specified n.\n2. ValueOutOfRangeError: Raised when any integer in the sequence is out of the specified range (0 \u2264 a_{i} \u2264 10^8).\n3. EmptySequenceError: Raised when the sequence is empty or n is less than 2.\n4. ComputationError: Raised when an unexpected error occurs during the computation of the partition.\n\nYour task is to implement error handling for these scenarios and ensure that meaningful error messages are provided. The function should propagate errors appropriately and maintain type hints.", "new_solution": "from typing import List, Tuple\n\nclass InputFormatError(Exception):\n    pass\n\nclass ValueOutOfRangeError(Exception):\n    pass\n\nclass EmptySequenceError(Exception):\n    pass\n\nclass ComputationError(Exception):\n    pass\n\ndef apps_run2(n: int, h: int, a: List[int]) -> Tuple[int, List[int]]:\n    if n < 2:\n        raise EmptySequenceError(\"The sequence must contain at least two elements.\")\n    if len(a) != n:\n        raise InputFormatError(\"The number of integers does not match the specified n.\")\n    if any(x < 0 or x > 10**8 for x in a):\n        raise ValueOutOfRangeError(\"All integers must be in the range 0 to 10^8.\")\n    try:\n        p = 0\n        t = [0] * 3\n        for i in range(n):\n            if a[i] < a[p]:\n                p = i\n        if n == 2:\n            return 0, [1, 1]\n        else:\n            a.sort()\n            t[0] = min(a[0] + a[1] + h, a[1] + a[2])\n            t[1] = max(a[0] + a[n-1] + h, a[n-2] + a[n-1])\n            t[2] = (a[n-2] + a[n-1]) - (a[0] + a[1])\n            if t[1] - t[0] > t[2]:\n                p = n\n            else:\n                t[2] = t[1] - t[0]\n            partition = [int(i == p) + 1 for i in range(n)]\n            return t[2], partition\n    except Exception as e:\n        raise ComputationError(\"An error occurred during computation: \" + str(e))", "input_format": "The first line of input contains integers n and h (2 \u2264 n \u2264 10^5, 0 \u2264 h \u2264 10^8). In the second line there is a list of n space-separated integers representing a_1, a_2, ..., a_{n} (0 \u2264 a_{i} \u2264 10^8).", "output_format": "The first line of output should contain the required minimum goodness. The second line describes the optimal partition. You should print n whitespace-separated integers in the second line. The i-th integer is 1 if a_{i} is in the first subsequence otherwise it should be 2.", "test_input": ["assert apps_run2(3, 2, [1, 2, 3]) == (1, [2, 1, 1])", "assert apps_run2(5, 10, [0, 1, 0, 2, 1]) == (3, [1, 1, 1, 1, 1])", "try:\n    apps_run2(1, 2, [1])\nexcept EmptySequenceError as e:\n    assert str(e) == \"The sequence must contain at least two elements.\"", "try:\n    apps_run2(3, 2, [1, 2])\nexcept InputFormatError as e:\n    assert str(e) == \"The number of integers does not match the specified n.\"", "try:\n    apps_run2(3, 2, [1, 2, 1000000000])\nexcept ValueOutOfRangeError as e:\n    assert str(e) == \"All integers must be in the range 0 to 10^8.\""], "requirement_type": "PROMPT_ERROR_HANDLING"}
{"task_id": "APPS/2019-1", "raw_problem": "One day n friends gathered together to play \"Mafia\". During each round of the game some player must be the supervisor and other n - 1 people take part in the game. For each person we know in how many rounds he wants to be a player, not the supervisor: the i-th person wants to play a_{i} rounds. What is the minimum number of rounds of the \"Mafia\" game they need to play to let each person play at least as many rounds as they want?\n\n\n-----Input-----\n\nThe first line contains integer n (3 \u2264 n \u2264 10^5). The second line contains n space-separated integers a_1, a_2, ..., a_{n} (1 \u2264 a_{i} \u2264 10^9) \u2014 the i-th number in the list is the number of rounds the i-th person wants to play.\n\n\n-----Output-----\n\nIn a single line print a single integer \u2014 the minimum number of game rounds the friends need to let the i-th person play at least a_{i} rounds.\n\nPlease, do not use the %lld specifier to read or write 64-bit integers in \u0421++. It is preferred to use the cin, cout streams or the %I64d specifier.\n\n\n-----Examples-----\nInput\n3\n3 2 2\n\nOutput\n4\n\nInput\n4\n2 2 2 2\n\nOutput\n3\n\n\n\n-----Note-----\n\nYou don't need to know the rules of \"Mafia\" to solve this problem. If you're curious, it's a game Russia got from the Soviet times: http://en.wikipedia.org/wiki/Mafia_(party_game).", "raw_solution": "def apps_run1(n, a):\n    r = n-2\n    for d in a:\n        r += d\n    return max(max(a), r//(n-1))", "raw_test_input": ["assert apps_run1(3, [3, 2, 2]) == 4", "assert apps_run1(4, [2, 2, 2, 2]) == 3", "assert apps_run1(7, [9, 7, 7, 8, 8, 7, 8]) == 9", "assert apps_run1(10, [13, 12, 10, 13, 13, 14, 10, 10, 12, 12]) == 14", "assert apps_run1(10, [94, 96, 91, 95, 99, 94, 96, 92, 95, 99]) == 106", "assert apps_run1(100, [1, 555, 876, 444, 262, 234, 231, 598, 416, 261, 206, 165, 181, 988, 469, 123, 602, 592, 533, 97, 864, 716, 831, 156, 962, 341, 207, 377, 892, 51, 866, 96, 757, 317, 832, 476, 549, 472, 770, 1000, 887, 145, 956, 515, 992, 653, 972, 677, 973, 527, 984, 559, 280, 346, 580, 30, 372, 547, 209, 929, 492, 520, 446, 726, 47, 170, 699, 560, 814, 206, 688, 955, 308, 287, 26, 102, 77, 430, 262, 71, 415, 586, 532, 562, 419, 615, 732, 658, 108, 315, 268, 574, 86, 12, 23, 429, 640, 995, 342, 305]) == 1000", "assert apps_run1(3, [1, 1, 1]) == 2", "assert apps_run1(30, [94, 93, 90, 94, 90, 91, 93, 91, 93, 94, 93, 90, 100, 94, 97, 94, 94, 95, 94, 96, 94, 98, 97, 95, 97, 91, 91, 95, 98, 96]) == 100", "assert apps_run1(5, [1000000000, 5, 5, 4, 4]) == 1000000000", "assert apps_run1(3, [1, 2, 1]) == 2", "assert apps_run1(3, [2, 1, 1]) == 2", "assert apps_run1(4, [1, 2, 3, 4]) == 4", "assert apps_run1(3, [1000000000, 1000000000, 10000000]) == 1005000000", "assert apps_run1(3, [677876423, 834056477, 553175531]) == 1032554216", "assert apps_run1(5, [1000000000, 1, 1, 1, 1]) == 1000000000", "assert apps_run1(4, [1000000000, 1000000000, 1000000000, 1000000000]) == 1333333334", "assert apps_run1(3, [4, 10, 11]) == 13", "assert apps_run1(5, [1000000000, 1000000000, 1000000000, 1000000000, 1000000000]) == 1250000000"], "new_problem": "In a gaming club, n friends regularly play the game 'Mafia'. Each friend has a specific number of rounds they want to play. However, they have already played some rounds in different game sessions. Given the number of rounds each friend wants to play and the number of rounds they have already played in each session, determine the additional number of rounds needed for each session to satisfy all players' requirements.", "new_solution": "def minimum_rounds(n, a):\n    r = n - 2\n    for d in a:\n        r += d\n    return max(max(a), r // (n - 1))\n\ndef apps_run2(n, a, sessions):\n    results = []\n    for session in sessions:\n        remaining_rounds = [max(0, a[i] - session[i]) for i in range(n)]\n        results.append(minimum_rounds(n, remaining_rounds))\n    return results", "input_format": "The first line contains an integer n (3 \u2264 n \u2264 10^5), the number of friends. The second line contains n space-separated integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9), representing the number of rounds each person wants to play. The third line contains an integer m (1 \u2264 m \u2264 10^5), the number of different game sessions. The next m lines each contain n space-separated integers b_1, b_2, ..., b_n (0 \u2264 b_i \u2264 10^9), representing the number of rounds each person has already played in each session.", "output_format": "A single integer for each session, representing the additional number of rounds needed for each session to satisfy all players' requirements.", "test_input": ["assert apps_run2(3, [3, 2, 2], [[1, 1, 1], [2, 1, 1], [0, 0, 0]]) == [2, 2, 4]", "assert apps_run2(4, [2, 2, 2, 2], [[1, 1, 1, 1], [0, 0, 0, 0], [2, 2, 2, 2]]) == [2, 3, 0]", "assert apps_run2(5, [5, 5, 5, 5, 5], [[3, 3, 3, 3, 3], [4, 4, 4, 4, 4], [5, 5, 5, 5, 5]]) == [3, 2, 0]", "assert apps_run2(3, [10, 10, 10], [[5, 5, 5], [9, 9, 9], [0, 0, 0]]) == [8, 2, 15]", "assert apps_run2(6, [1, 1, 1, 1, 1, 1], [[0, 0, 0, 0, 0, 0], [1, 1, 1, 1, 1, 1], [0, 0, 0, 0, 0, 0]]) == [2, 0, 2]"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "APPS/2019-2", "raw_problem": "One day n friends gathered together to play \"Mafia\". During each round of the game some player must be the supervisor and other n - 1 people take part in the game. For each person we know in how many rounds he wants to be a player, not the supervisor: the i-th person wants to play a_{i} rounds. What is the minimum number of rounds of the \"Mafia\" game they need to play to let each person play at least as many rounds as they want?\n\n\n-----Input-----\n\nThe first line contains integer n (3 \u2264 n \u2264 10^5). The second line contains n space-separated integers a_1, a_2, ..., a_{n} (1 \u2264 a_{i} \u2264 10^9) \u2014 the i-th number in the list is the number of rounds the i-th person wants to play.\n\n\n-----Output-----\n\nIn a single line print a single integer \u2014 the minimum number of game rounds the friends need to let the i-th person play at least a_{i} rounds.\n\nPlease, do not use the %lld specifier to read or write 64-bit integers in \u0421++. It is preferred to use the cin, cout streams or the %I64d specifier.\n\n\n-----Examples-----\nInput\n3\n3 2 2\n\nOutput\n4\n\nInput\n4\n2 2 2 2\n\nOutput\n3\n\n\n\n-----Note-----\n\nYou don't need to know the rules of \"Mafia\" to solve this problem. If you're curious, it's a game Russia got from the Soviet times: http://en.wikipedia.org/wiki/Mafia_(party_game).", "raw_solution": "def apps_run1(n, a):\n    r = n-2\n    for d in a:\n        r += d\n    return max(max(a), r//(n-1))", "raw_test_input": ["assert apps_run1(3, [3, 2, 2]) == 4", "assert apps_run1(4, [2, 2, 2, 2]) == 3", "assert apps_run1(7, [9, 7, 7, 8, 8, 7, 8]) == 9", "assert apps_run1(10, [13, 12, 10, 13, 13, 14, 10, 10, 12, 12]) == 14", "assert apps_run1(10, [94, 96, 91, 95, 99, 94, 96, 92, 95, 99]) == 106", "assert apps_run1(100, [1, 555, 876, 444, 262, 234, 231, 598, 416, 261, 206, 165, 181, 988, 469, 123, 602, 592, 533, 97, 864, 716, 831, 156, 962, 341, 207, 377, 892, 51, 866, 96, 757, 317, 832, 476, 549, 472, 770, 1000, 887, 145, 956, 515, 992, 653, 972, 677, 973, 527, 984, 559, 280, 346, 580, 30, 372, 547, 209, 929, 492, 520, 446, 726, 47, 170, 699, 560, 814, 206, 688, 955, 308, 287, 26, 102, 77, 430, 262, 71, 415, 586, 532, 562, 419, 615, 732, 658, 108, 315, 268, 574, 86, 12, 23, 429, 640, 995, 342, 305]) == 1000", "assert apps_run1(3, [1, 1, 1]) == 2", "assert apps_run1(30, [94, 93, 90, 94, 90, 91, 93, 91, 93, 94, 93, 90, 100, 94, 97, 94, 94, 95, 94, 96, 94, 98, 97, 95, 97, 91, 91, 95, 98, 96]) == 100", "assert apps_run1(5, [1000000000, 5, 5, 4, 4]) == 1000000000", "assert apps_run1(3, [1, 2, 1]) == 2", "assert apps_run1(3, [2, 1, 1]) == 2", "assert apps_run1(4, [1, 2, 3, 4]) == 4", "assert apps_run1(3, [1000000000, 1000000000, 10000000]) == 1005000000", "assert apps_run1(3, [677876423, 834056477, 553175531]) == 1032554216", "assert apps_run1(5, [1000000000, 1, 1, 1, 1]) == 1000000000", "assert apps_run1(4, [1000000000, 1000000000, 1000000000, 1000000000]) == 1333333334", "assert apps_run1(3, [4, 10, 11]) == 13", "assert apps_run1(5, [1000000000, 1000000000, 1000000000, 1000000000, 1000000000]) == 1250000000"], "new_problem": "One day n friends gathered together to play 'Mafia'. During each round of the game, some player must be the supervisor and the other n - 1 people take part in the game. For each person, we know in how many rounds they want to be a player, not the supervisor: the i-th person wants to play a_{i} rounds. Additionally, there might be a constraint on the maximum number of rounds they can play. What is the minimum number of rounds of the 'Mafia' game they need to play to let each person play at least as many rounds as they want, without exceeding the maximum number of rounds if specified?", "new_solution": "from typing import List, Optional\n\ndef apps_run2(n: int, a: List[int], max_rounds: Optional[int] = None) -> int:\n    r = n - 2\n    for d in a:\n        r += d\n    min_rounds = max(max(a), r // (n - 1))\n    if max_rounds is not None:\n        return min(min_rounds, max_rounds)\n    return min_rounds", "input_format": "The first line contains integer n (3 \u2264 n \u2264 10^5). The second line contains n space-separated integers a_1, a_2, ..., a_{n} (1 \u2264 a_{i} \u2264 10^9) \u2014 the i-th number in the list is the number of rounds the i-th person wants to play. Optionally, a third line can contain an integer m (1 \u2264 m \u2264 10^9) representing the maximum number of rounds allowed.", "output_format": "In a single line print a single integer \u2014 the minimum number of game rounds the friends need to let the i-th person play at least a_{i} rounds, without exceeding m if provided.", "test_input": ["assert apps_run2(3, [3, 2, 2]) == 4", "assert apps_run2(4, [2, 2, 2, 2]) == 3", "assert apps_run2(3, [3, 2, 2], 3) == 3", "assert apps_run2(5, [5, 5, 5, 5, 5]) == 7", "assert apps_run2(5, [5, 5, 5, 5, 5], 5) == 5"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "APPS/2019-3", "raw_problem": "One day n friends gathered together to play \"Mafia\". During each round of the game some player must be the supervisor and other n - 1 people take part in the game. For each person we know in how many rounds he wants to be a player, not the supervisor: the i-th person wants to play a_{i} rounds. What is the minimum number of rounds of the \"Mafia\" game they need to play to let each person play at least as many rounds as they want?\n\n\n-----Input-----\n\nThe first line contains integer n (3 \u2264 n \u2264 10^5). The second line contains n space-separated integers a_1, a_2, ..., a_{n} (1 \u2264 a_{i} \u2264 10^9) \u2014 the i-th number in the list is the number of rounds the i-th person wants to play.\n\n\n-----Output-----\n\nIn a single line print a single integer \u2014 the minimum number of game rounds the friends need to let the i-th person play at least a_{i} rounds.\n\nPlease, do not use the %lld specifier to read or write 64-bit integers in \u0421++. It is preferred to use the cin, cout streams or the %I64d specifier.\n\n\n-----Examples-----\nInput\n3\n3 2 2\n\nOutput\n4\n\nInput\n4\n2 2 2 2\n\nOutput\n3\n\n\n\n-----Note-----\n\nYou don't need to know the rules of \"Mafia\" to solve this problem. If you're curious, it's a game Russia got from the Soviet times: http://en.wikipedia.org/wiki/Mafia_(party_game).", "raw_solution": "def apps_run1(n, a):\n    r = n-2\n    for d in a:\n        r += d\n    return max(max(a), r//(n-1))", "raw_test_input": ["assert apps_run1(3, [3, 2, 2]) == 4", "assert apps_run1(4, [2, 2, 2, 2]) == 3", "assert apps_run1(7, [9, 7, 7, 8, 8, 7, 8]) == 9", "assert apps_run1(10, [13, 12, 10, 13, 13, 14, 10, 10, 12, 12]) == 14", "assert apps_run1(10, [94, 96, 91, 95, 99, 94, 96, 92, 95, 99]) == 106", "assert apps_run1(100, [1, 555, 876, 444, 262, 234, 231, 598, 416, 261, 206, 165, 181, 988, 469, 123, 602, 592, 533, 97, 864, 716, 831, 156, 962, 341, 207, 377, 892, 51, 866, 96, 757, 317, 832, 476, 549, 472, 770, 1000, 887, 145, 956, 515, 992, 653, 972, 677, 973, 527, 984, 559, 280, 346, 580, 30, 372, 547, 209, 929, 492, 520, 446, 726, 47, 170, 699, 560, 814, 206, 688, 955, 308, 287, 26, 102, 77, 430, 262, 71, 415, 586, 532, 562, 419, 615, 732, 658, 108, 315, 268, 574, 86, 12, 23, 429, 640, 995, 342, 305]) == 1000", "assert apps_run1(3, [1, 1, 1]) == 2", "assert apps_run1(30, [94, 93, 90, 94, 90, 91, 93, 91, 93, 94, 93, 90, 100, 94, 97, 94, 94, 95, 94, 96, 94, 98, 97, 95, 97, 91, 91, 95, 98, 96]) == 100", "assert apps_run1(5, [1000000000, 5, 5, 4, 4]) == 1000000000", "assert apps_run1(3, [1, 2, 1]) == 2", "assert apps_run1(3, [2, 1, 1]) == 2", "assert apps_run1(4, [1, 2, 3, 4]) == 4", "assert apps_run1(3, [1000000000, 1000000000, 10000000]) == 1005000000", "assert apps_run1(3, [677876423, 834056477, 553175531]) == 1032554216", "assert apps_run1(5, [1000000000, 1, 1, 1, 1]) == 1000000000", "assert apps_run1(4, [1000000000, 1000000000, 1000000000, 1000000000]) == 1333333334", "assert apps_run1(3, [4, 10, 11]) == 13", "assert apps_run1(5, [1000000000, 1000000000, 1000000000, 1000000000, 1000000000]) == 1250000000"], "new_problem": "One day n friends gathered together to play 'Mafia'. During each round of the game, one player must be the supervisor and the other n - 1 people take part in the game. For each person, we know in how many rounds they want to be a player and in how many rounds they want to be the supervisor: the i-th person wants to play a_{i} rounds and be the supervisor b_{i} rounds. What is the minimum number of rounds of the 'Mafia' game they need to play to let each person play at least as many rounds as they want and be the supervisor at least as many rounds as they want?", "new_solution": "from typing import List, Dict\n\ndef apps_run2(n: int, a: List[int], b: List[int]) -> int:\n    total_rounds = 0\n    for i in range(n):\n        total_rounds += a[i] + b[i]\n    return max(max(a), max(b), total_rounds // (n - 1))\n", "input_format": "The first line contains integer n (3 \u2264 n \u2264 10^5). The second line contains n space-separated integers a_1, a_2, ..., a_{n} (1 \u2264 a_{i} \u2264 10^9) \u2014 the i-th number in the list is the number of rounds the i-th person wants to play.", "output_format": "In a single line print a single integer \u2014 the minimum number of game rounds the friends need to let the i-th person play at least a_{i} rounds.", "test_input": ["assert apps_run2(3, [3, 2, 2], [1, 1, 1]) == 5", "assert apps_run2(4, [2, 2, 2, 2], [1, 1, 1, 1]) == 4", "assert apps_run2(5, [1, 2, 3, 4, 5], [5, 4, 3, 2, 1]) == 7", "assert apps_run2(3, [10, 20, 30], [5, 10, 15]) == 45", "assert apps_run2(2, [1, 1], [1, 1]) == 4"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "APPS/2019-4", "raw_problem": "One day n friends gathered together to play \"Mafia\". During each round of the game some player must be the supervisor and other n - 1 people take part in the game. For each person we know in how many rounds he wants to be a player, not the supervisor: the i-th person wants to play a_{i} rounds. What is the minimum number of rounds of the \"Mafia\" game they need to play to let each person play at least as many rounds as they want?\n\n\n-----Input-----\n\nThe first line contains integer n (3 \u2264 n \u2264 10^5). The second line contains n space-separated integers a_1, a_2, ..., a_{n} (1 \u2264 a_{i} \u2264 10^9) \u2014 the i-th number in the list is the number of rounds the i-th person wants to play.\n\n\n-----Output-----\n\nIn a single line print a single integer \u2014 the minimum number of game rounds the friends need to let the i-th person play at least a_{i} rounds.\n\nPlease, do not use the %lld specifier to read or write 64-bit integers in \u0421++. It is preferred to use the cin, cout streams or the %I64d specifier.\n\n\n-----Examples-----\nInput\n3\n3 2 2\n\nOutput\n4\n\nInput\n4\n2 2 2 2\n\nOutput\n3\n\n\n\n-----Note-----\n\nYou don't need to know the rules of \"Mafia\" to solve this problem. If you're curious, it's a game Russia got from the Soviet times: http://en.wikipedia.org/wiki/Mafia_(party_game).", "raw_solution": "def apps_run1(n, a):\n    r = n-2\n    for d in a:\n        r += d\n    return max(max(a), r//(n-1))", "raw_test_input": ["assert apps_run1(3, [3, 2, 2]) == 4", "assert apps_run1(4, [2, 2, 2, 2]) == 3", "assert apps_run1(7, [9, 7, 7, 8, 8, 7, 8]) == 9", "assert apps_run1(10, [13, 12, 10, 13, 13, 14, 10, 10, 12, 12]) == 14", "assert apps_run1(10, [94, 96, 91, 95, 99, 94, 96, 92, 95, 99]) == 106", "assert apps_run1(100, [1, 555, 876, 444, 262, 234, 231, 598, 416, 261, 206, 165, 181, 988, 469, 123, 602, 592, 533, 97, 864, 716, 831, 156, 962, 341, 207, 377, 892, 51, 866, 96, 757, 317, 832, 476, 549, 472, 770, 1000, 887, 145, 956, 515, 992, 653, 972, 677, 973, 527, 984, 559, 280, 346, 580, 30, 372, 547, 209, 929, 492, 520, 446, 726, 47, 170, 699, 560, 814, 206, 688, 955, 308, 287, 26, 102, 77, 430, 262, 71, 415, 586, 532, 562, 419, 615, 732, 658, 108, 315, 268, 574, 86, 12, 23, 429, 640, 995, 342, 305]) == 1000", "assert apps_run1(3, [1, 1, 1]) == 2", "assert apps_run1(30, [94, 93, 90, 94, 90, 91, 93, 91, 93, 94, 93, 90, 100, 94, 97, 94, 94, 95, 94, 96, 94, 98, 97, 95, 97, 91, 91, 95, 98, 96]) == 100", "assert apps_run1(5, [1000000000, 5, 5, 4, 4]) == 1000000000", "assert apps_run1(3, [1, 2, 1]) == 2", "assert apps_run1(3, [2, 1, 1]) == 2", "assert apps_run1(4, [1, 2, 3, 4]) == 4", "assert apps_run1(3, [1000000000, 1000000000, 10000000]) == 1005000000", "assert apps_run1(3, [677876423, 834056477, 553175531]) == 1032554216", "assert apps_run1(5, [1000000000, 1, 1, 1, 1]) == 1000000000", "assert apps_run1(4, [1000000000, 1000000000, 1000000000, 1000000000]) == 1333333334", "assert apps_run1(3, [4, 10, 11]) == 13", "assert apps_run1(5, [1000000000, 1000000000, 1000000000, 1000000000, 1000000000]) == 1250000000"], "new_problem": "In a group of friends playing 'Mafia', each person has a specific number of rounds they want to play. However, due to scheduling conflicts, some players might not be able to play as many rounds as they wish. Write a function that calculates the minimum number of rounds needed to satisfy each player's request, but also handle the following errors: 1) If the input list of rounds is empty, raise a ValueError with the message 'Player list cannot be empty'. 2) If any player's desired rounds are negative, raise a ValueError with the message 'Rounds cannot be negative'. 3) If the number of players n is less than 3, raise a ValueError with the message 'At least 3 players are required'. Implement error propagation and ensure that the function maintains type hints.", "new_solution": "from typing import List\n\nclass MafiaGameError(Exception):\n    pass\n\nclass EmptyPlayerListError(MafiaGameError):\n    def __init__(self, message: str = 'Player list cannot be empty'):\n        self.message = message\n        super().__init__(self.message)\n\nclass NegativeRoundsError(MafiaGameError):\n    def __init__(self, message: str = 'Rounds cannot be negative'):\n        self.message = message\n        super().__init__(self.message)\n\nclass InsufficientPlayersError(MafiaGameError):\n    def __init__(self, message: str = 'At least 3 players are required'):\n        self.message = message\n        super().__init__(self.message)\n\ndef apps_run2(n: int, a: List[int]) -> int:\n    if n < 3:\n        raise InsufficientPlayersError()\n    if not a:\n        raise EmptyPlayerListError()\n    if any(d < 0 for d in a):\n        raise NegativeRoundsError()\n    r = n - 2\n    for d in a:\n        r += d\n    return max(max(a), r // (n - 1))", "input_format": "The first line contains integer n (3 \u2264 n \u2264 10^5). The second line contains n space-separated integers a_1, a_2, ..., a_{n} (1 \u2264 a_{i} \u2264 10^9) \u2014 the i-th number in the list is the number of rounds the i-th person wants to play.", "output_format": "In a single line print a single integer \u2014 the minimum number of game rounds the friends need to let the i-th person play at least a_{i} rounds.", "test_input": ["assert apps_run2(3, [3, 2, 2]) == 4", "assert apps_run2(4, [2, 2, 2, 2]) == 3", "try:\n    apps_run2(2, [1, 2])\nexcept InsufficientPlayersError as e:\n    assert str(e) == 'At least 3 players are required'", "try:\n    apps_run2(3, [])\nexcept EmptyPlayerListError as e:\n    assert str(e) == 'Player list cannot be empty'", "try:\n    apps_run2(3, [3, -2, 2])\nexcept NegativeRoundsError as e:\n    assert str(e) == 'Rounds cannot be negative'"], "requirement_type": "PROMPT_ERROR_HANDLING"}
{"task_id": "APPS/2020-1", "raw_problem": "Ivan wants to make a necklace as a present to his beloved girl. A necklace is a cyclic sequence of beads of different colors. Ivan says that necklace is beautiful relative to the cut point between two adjacent beads, if the chain of beads remaining after this cut is a palindrome (reads the same forward and backward).\n\n [Image] \n\nIvan has beads of n colors. He wants to make a necklace, such that it's beautiful relative to as many cuts as possible. He certainly wants to use all the beads. Help him to make the most beautiful necklace.\n\n\n-----Input-----\n\nThe first line of the input contains a single number n (1 \u2264 n \u2264 26) \u2014 the number of colors of beads. The second line contains after n positive integers a_{i} \u00a0 \u2014 the quantity of beads of i-th color. It is guaranteed that the sum of a_{i} is at least 2 and does not exceed 100 000.\n\n\n-----Output-----\n\nIn the first line print a single number\u00a0\u2014 the maximum number of beautiful cuts that a necklace composed from given beads may have. In the second line print any example of such necklace.\n\nEach color of the beads should be represented by the corresponding lowercase English letter (starting with a). As the necklace is cyclic, print it starting from any point.\n\n\n-----Examples-----\nInput\n3\n4 2 1\n\nOutput\n1\nabacaba\nInput\n1\n4\n\nOutput\n4\naaaa\n\nInput\n2\n1 1\n\nOutput\n0\nab\n\n\n\n-----Note-----\n\nIn the first sample a necklace can have at most one beautiful cut. The example of such a necklace is shown on the picture.\n\nIn the second sample there is only one way to compose a necklace.", "raw_solution": "def apps_run1(n, beads):\n    import math\n    from functools import reduce\n\n    odd = -1\n    for i in range(n):\n        if beads[i] % 2:\n            if odd >= 0:\n                return 0#, ''.join(chr(ord('a') + i) * beads[i] for i in range(n)))\n            else:\n                odd = i\n    else:\n        gcd = reduce(lambda x, y: math.gcd(x, y), beads)\n        if odd >= 0:\n            s = ''.join(chr(ord('a') + i) * (beads[i] // (2 * gcd)) for i in range(n) if i != odd)\n            p = s + chr(ord('a') + odd) * (beads[odd] // gcd) + s[::-1]\n            return gcd#, p * gcd)\n        else:\n            s = ''.join(chr(ord('a') + i) * (beads[i] // gcd) for i in range(n))\n            p = s + s[::-1]\n            return gcd#, p * (gcd // 2))", "raw_test_input": ["assert apps_run1(3, [4, 2, 1]) == 1#, 'aabcbaa')", "assert apps_run1(1, [4]) == 4", "assert apps_run1(2, [1, 1]) == 0", "assert apps_run1(1, [2]) == 2", "assert apps_run1(1, [3]) == 3", "assert apps_run1(1, [5]) == 5", "assert apps_run1(2, [2, 2]) == 2", "assert apps_run1(3, [1, 2, 4]) == 1", "assert apps_run1(3, [3, 3, 3]) == 0", "assert apps_run1(3, [3, 3, 6]) == 0", "assert apps_run1(3, [6, 6, 6]) == 6", "assert apps_run1(3, [6, 6, 9]) == 3", "assert apps_run1(26, [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) == 0", "assert apps_run1(3, [7, 7, 21]) == 0", "assert apps_run1(2, [95, 50]) == 5", "assert apps_run1(3, [30, 30, 15]) == 15", "assert apps_run1(3, [1, 50, 70]) == 1", "assert apps_run1(2, [70, 10]) == 10"], "new_problem": "In a jewelry design company, a designer is tasked with creating multiple necklaces for a new collection. Each necklace must be as beautiful as possible, meaning it should have the maximum number of beautiful cuts. A beautiful cut is defined as a cut where the sequence of beads forms a palindrome. The designer has a set number of beads of different colors for each necklace. Help the designer determine the maximum number of beautiful cuts for each necklace and provide an example of such a necklace.", "new_solution": "def process_beads(n, beads):\n    import math\n    from functools import reduce\n    # \u7528\u4e8e\u8bb0\u5f55\u51fa\u73b0\u5947\u6570\u6b21\u73e0\u5b50\u6570\u91cf\u7684\u989c\u8272\u7d22\u5f15\uff0c\u521d\u59cb\u5316\u4e3a -1\n    odd = -1\n    # \u904d\u5386\u6bcf\u79cd\u989c\u8272\u73e0\u5b50\u7684\u6570\u91cf\n    for i in range(n):\n        # \u5982\u679c\u5f53\u524d\u989c\u8272\u73e0\u5b50\u6570\u91cf\u4e3a\u5947\u6570\n        if beads[i] % 2:\n            # \u5982\u679c\u4e4b\u524d\u5df2\u7ecf\u6709\u5176\u4ed6\u989c\u8272\u73e0\u5b50\u6570\u91cf\u4e3a\u5947\u6570\n            if odd >= 0:\n                # \u65e0\u6cd5\u5f62\u6210\u6709\u591a\u4e2a\u6f02\u4eae\u5207\u5272\u70b9\u7684\u9879\u94fe\uff0c\u8fd4\u56de\u6f02\u4eae\u5207\u5272\u70b9\u6570\u91cf\u4e3a0\u548c\u6309\u987a\u5e8f\u6392\u5217\u7684\u73e0\u5b50\u7ec4\u6210\u7684\u9879\u94fe\n                return (0, ''.join(chr(ord('a') + i) * beads[i] for i in range(n)))\n            else:\n                # \u8bb0\u5f55\u5f53\u524d\u989c\u8272\u7d22\u5f15\n                odd = i\n    else:\n        # \u8ba1\u7b97\u6240\u6709\u989c\u8272\u73e0\u5b50\u6570\u91cf\u7684\u6700\u5927\u516c\u7ea6\u6570\n        gcd = reduce(lambda x, y: math.gcd(x, y), beads)\n        if odd >= 0:\n            # \u5f53\u5b58\u5728\u5947\u6570\u6b21\u73e0\u5b50\u6570\u91cf\u7684\u989c\u8272\u65f6\n            # \u6784\u5efa\u4e2d\u95f4\u90e8\u5206\u7684\u5b57\u7b26\u4e32\uff0c\u4e0d\u5305\u542b\u5947\u6570\u6b21\u73e0\u5b50\u6570\u91cf\u7684\u989c\u8272\uff0c\u4e14\u6570\u91cf\u4e3a\u603b\u6570\u91cf\u9664\u4ee52\u500d\u6700\u5927\u516c\u7ea6\u6570\n            s = ''.join(chr(ord('a') + i) * (beads[i] // (2 * gcd)) for i in range(n) if i != odd)\n            # \u6784\u5efa\u5b8c\u6574\u7684\u9879\u94fe\u5b57\u7b26\u4e32\uff0c\u4e2d\u95f4\u662f\u5947\u6570\u6b21\u73e0\u5b50\u6570\u91cf\u7684\u989c\u8272\uff0c\u4e14\u6570\u91cf\u4e3a\u603b\u6570\u91cf\u9664\u4ee5\u6700\u5927\u516c\u7ea6\u6570\uff0c\u4e24\u8fb9\u662f\u5bf9\u79f0\u7684s\n            p = s + chr(ord('a') + odd) * (beads[odd] // gcd) + s[::-1]\n            # \u8fd4\u56de\u6700\u5927\u6f02\u4eae\u5207\u5272\u70b9\u6570\u91cf\u548c\u7531p\u91cd\u590dgcd\u6b21\u7ec4\u6210\u7684\u9879\u94fe\n            return (gcd, p * gcd)\n        else:\n            # \u5f53\u6240\u6709\u989c\u8272\u73e0\u5b50\u6570\u91cf\u90fd\u662f\u5076\u6570\u65f6\n            # \u6784\u5efa\u4e00\u534a\u7684\u9879\u94fe\u5b57\u7b26\u4e32\uff0c\u6bcf\u79cd\u989c\u8272\u6570\u91cf\u4e3a\u603b\u6570\u91cf\u9664\u4ee5\u6700\u5927\u516c\u7ea6\u6570\n            s = ''.join(chr(ord('a') + i) * (beads[i] // gcd) for i in range(n))\n            # \u6784\u5efa\u5b8c\u6574\u7684\u9879\u94fe\u5b57\u7b26\u4e32\uff0c\u7531s\u548c\u5176\u53cd\u5411\u5b57\u7b26\u4e32\u7ec4\u6210\n            p = s + s[::-1]\n            # \u8fd4\u56de\u6700\u5927\u6f02\u4eae\u5207\u5272\u70b9\u6570\u91cf\uff08\u6700\u5927\u516c\u7ea6\u6570\u7684\u4e00\u534a\uff09\u548c\u7531p\u91cd\u590d\u6700\u5927\u516c\u7ea6\u6570\u4e00\u534a\u6b21\u7ec4\u6210\u7684\u9879\u94fe\n            return (gcd, p * (gcd // 2))\n\ndef apps_run2(m, necklaces):\n    results = []\n    # \u904d\u5386\u6bcf\u6761\u9879\u94fe\u7684\u4fe1\u606f\n    for i in range(m):\n        # \u89e3\u5305\u83b7\u53d6\u5f53\u524d\u9879\u94fe\u7684\u989c\u8272\u6570\u91cfn\u548c\u6bcf\u79cd\u989c\u8272\u73e0\u5b50\u6570\u91cfbeads\n        n, *beads = necklaces[i]\n        # \u8c03\u7528max_beautiful_cuts\u51fd\u6570\u8ba1\u7b97\u5f53\u524d\u9879\u94fe\u7684\u6700\u5927\u6f02\u4eae\u5207\u5272\u70b9\u6570\u91cf\u548c\u793a\u4f8b\u9879\u94fe\n        max_cuts, necklace = process_beads(n, beads)\n        # \u5c06\u7ed3\u679c\u6dfb\u52a0\u5230\u7ed3\u679c\u5217\u8868\u4e2d\n        results.append((max_cuts))\n    # \u8fd4\u56de\u6240\u6709\u9879\u94fe\u7684\u7ed3\u679c\u5217\u8868\n    return results", "input_format": "The first line contains a single integer m (1 \u2264 m \u2264 100) \u2014 the number of necklaces. The next m lines each contain a single integer n (1 \u2264 n \u2264 26) followed by n positive integers a_{i} \u2014 the quantity of beads of i-th color for each necklace.", "output_format": "For each necklace, output two lines. The first line contains a single number \u2014 the maximum number of beautiful cuts that the necklace may have. The second line contains an example of such a necklace.", "test_input": ["assert apps_run2(2, [(3, 4, 2, 1), (1, 4)]) == [1, 4]", "assert apps_run2(1, [(2, 1, 1)]) == [0]", "assert apps_run2(1, [(4, 2, 2, 2, 2)]) == [2]", "assert apps_run2(1, [(3, 3, 3, 3)]) == [0]", "assert apps_run2(1, [(2, 5, 5)]) == [0]"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "APPS/2020-2", "raw_problem": "Ivan wants to make a necklace as a present to his beloved girl. A necklace is a cyclic sequence of beads of different colors. Ivan says that necklace is beautiful relative to the cut point between two adjacent beads, if the chain of beads remaining after this cut is a palindrome (reads the same forward and backward).\n\n [Image] \n\nIvan has beads of n colors. He wants to make a necklace, such that it's beautiful relative to as many cuts as possible. He certainly wants to use all the beads. Help him to make the most beautiful necklace.\n\n\n-----Input-----\n\nThe first line of the input contains a single number n (1 \u2264 n \u2264 26) \u2014 the number of colors of beads. The second line contains after n positive integers a_{i} \u00a0 \u2014 the quantity of beads of i-th color. It is guaranteed that the sum of a_{i} is at least 2 and does not exceed 100 000.\n\n\n-----Output-----\n\nIn the first line print a single number\u00a0\u2014 the maximum number of beautiful cuts that a necklace composed from given beads may have. In the second line print any example of such necklace.\n\nEach color of the beads should be represented by the corresponding lowercase English letter (starting with a). As the necklace is cyclic, print it starting from any point.\n\n\n-----Examples-----\nInput\n3\n4 2 1\n\nOutput\n1\nabacaba\nInput\n1\n4\n\nOutput\n4\naaaa\n\nInput\n2\n1 1\n\nOutput\n0\nab\n\n\n\n-----Note-----\n\nIn the first sample a necklace can have at most one beautiful cut. The example of such a necklace is shown on the picture.\n\nIn the second sample there is only one way to compose a necklace.", "raw_solution": "def apps_run1(n, beads):\n    import math\n    from functools import reduce\n\n    odd = -1\n    for i in range(n):\n        if beads[i] % 2:\n            if odd >= 0:\n                return 0#, ''.join(chr(ord('a') + i) * beads[i] for i in range(n)))\n            else:\n                odd = i\n    else:\n        gcd = reduce(lambda x, y: math.gcd(x, y), beads)\n        if odd >= 0:\n            s = ''.join(chr(ord('a') + i) * (beads[i] // (2 * gcd)) for i in range(n) if i != odd)\n            p = s + chr(ord('a') + odd) * (beads[odd] // gcd) + s[::-1]\n            return gcd#, p * gcd)\n        else:\n            s = ''.join(chr(ord('a') + i) * (beads[i] // gcd) for i in range(n))\n            p = s + s[::-1]\n            return gcd#, p * (gcd // 2))", "raw_test_input": ["assert apps_run1(3, [4, 2, 1]) == 1#, 'aabcbaa')", "assert apps_run1(1, [4]) == 4", "assert apps_run1(2, [1, 1]) == 0", "assert apps_run1(1, [2]) == 2", "assert apps_run1(1, [3]) == 3", "assert apps_run1(1, [5]) == 5", "assert apps_run1(2, [2, 2]) == 2", "assert apps_run1(3, [1, 2, 4]) == 1", "assert apps_run1(3, [3, 3, 3]) == 0", "assert apps_run1(3, [3, 3, 6]) == 0", "assert apps_run1(3, [6, 6, 6]) == 6", "assert apps_run1(3, [6, 6, 9]) == 3", "assert apps_run1(26, [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) == 0", "assert apps_run1(3, [7, 7, 21]) == 0", "assert apps_run1(2, [95, 50]) == 5", "assert apps_run1(3, [30, 30, 15]) == 15", "assert apps_run1(3, [1, 50, 70]) == 1", "assert apps_run1(2, [70, 10]) == 10"], "new_problem": "Ivan wants to make a necklace as a present to his beloved girl. A necklace is a cyclic sequence of beads of different colors. Ivan says that a necklace is beautiful relative to the cut point between two adjacent beads if the chain of beads remaining after this cut is a palindrome (reads the same forward and backward). Ivan has beads of n colors. He wants to make a necklace such that it's beautiful relative to as many cuts as possible. He certainly wants to use all the beads. Help him to make the most beautiful necklace. Additionally, Ivan may specify a preferred starting color for the necklace. If specified, the necklace should start with this color. If not specified, any starting point is acceptable.", "new_solution": "from typing import List, Optional\nimport math\nfrom functools import reduce\n\ndef apps_run2(n: int, beads: List[int], start_color: Optional[str] = None) -> (int, str):\n    odd = -1\n    for i in range(n):\n        if beads[i] % 2:\n            if odd >= 0:\n                return 0#, ''.join(chr(ord('a') + i) * beads[i] for i in range(n))\n            else:\n                odd = i\n    gcd = reduce(lambda x, y: math.gcd(x, y), beads)\n    if odd >= 0:\n        s = ''.join(chr(ord('a') + i) * (beads[i] // (2 * gcd)) for i in range(n) if i != odd)\n        p = s + chr(ord('a') + odd) * (beads[odd] // gcd) + s[::-1]\n        necklace = p * gcd\n    else:\n        s = ''.join(chr(ord('a') + i) * (beads[i] // gcd) for i in range(n))\n        p = s + s[::-1]\n        necklace = p * (gcd // 2)\n    if start_color:\n        start_index = necklace.find(start_color)\n        if start_index != -1:\n            necklace = necklace[start_index:] + necklace[:start_index]\n    return gcd", "input_format": "The first line of the input contains a single number n (1 \u2264 n \u2264 26) \u2014 the number of colors of beads. The second line contains n positive integers a_{i} \u2014 the quantity of beads of i-th color. Optionally, a third line may contain a string representing a preferred starting color for the necklace.", "output_format": "In the first line, print a single number \u2014 the maximum number of beautiful cuts that a necklace composed from given beads may have. In the second line, print any example of such a necklace, starting with the preferred color if specified.", "test_input": ["assert apps_run2(3, [4, 2, 1]) == 1", "assert apps_run2(1, [4]) == 4", "assert apps_run2(2, [1, 1]) == 0", "assert apps_run2(3, [4, 2, 1], 'b') == 1", "assert apps_run2(3, [4, 2, 1], 'c') == 1"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "APPS/2020-3", "raw_problem": "Ivan wants to make a necklace as a present to his beloved girl. A necklace is a cyclic sequence of beads of different colors. Ivan says that necklace is beautiful relative to the cut point between two adjacent beads, if the chain of beads remaining after this cut is a palindrome (reads the same forward and backward).\n\n [Image] \n\nIvan has beads of n colors. He wants to make a necklace, such that it's beautiful relative to as many cuts as possible. He certainly wants to use all the beads. Help him to make the most beautiful necklace.\n\n\n-----Input-----\n\nThe first line of the input contains a single number n (1 \u2264 n \u2264 26) \u2014 the number of colors of beads. The second line contains after n positive integers a_{i} \u00a0 \u2014 the quantity of beads of i-th color. It is guaranteed that the sum of a_{i} is at least 2 and does not exceed 100 000.\n\n\n-----Output-----\n\nIn the first line print a single number\u00a0\u2014 the maximum number of beautiful cuts that a necklace composed from given beads may have. In the second line print any example of such necklace.\n\nEach color of the beads should be represented by the corresponding lowercase English letter (starting with a). As the necklace is cyclic, print it starting from any point.\n\n\n-----Examples-----\nInput\n3\n4 2 1\n\nOutput\n1\nabacaba\nInput\n1\n4\n\nOutput\n4\naaaa\n\nInput\n2\n1 1\n\nOutput\n0\nab\n\n\n\n-----Note-----\n\nIn the first sample a necklace can have at most one beautiful cut. The example of such a necklace is shown on the picture.\n\nIn the second sample there is only one way to compose a necklace.", "raw_solution": "def apps_run1(n, beads):\n    import math\n    from functools import reduce\n\n    odd = -1\n    for i in range(n):\n        if beads[i] % 2:\n            if odd >= 0:\n                return 0#, ''.join(chr(ord('a') + i) * beads[i] for i in range(n)))\n            else:\n                odd = i\n    else:\n        gcd = reduce(lambda x, y: math.gcd(x, y), beads)\n        if odd >= 0:\n            s = ''.join(chr(ord('a') + i) * (beads[i] // (2 * gcd)) for i in range(n) if i != odd)\n            p = s + chr(ord('a') + odd) * (beads[odd] // gcd) + s[::-1]\n            return gcd#, p * gcd)\n        else:\n            s = ''.join(chr(ord('a') + i) * (beads[i] // gcd) for i in range(n))\n            p = s + s[::-1]\n            return gcd#, p * (gcd // 2))", "raw_test_input": ["assert apps_run1(3, [4, 2, 1]) == 1#, 'aabcbaa')", "assert apps_run1(1, [4]) == 4", "assert apps_run1(2, [1, 1]) == 0", "assert apps_run1(1, [2]) == 2", "assert apps_run1(1, [3]) == 3", "assert apps_run1(1, [5]) == 5", "assert apps_run1(2, [2, 2]) == 2", "assert apps_run1(3, [1, 2, 4]) == 1", "assert apps_run1(3, [3, 3, 3]) == 0", "assert apps_run1(3, [3, 3, 6]) == 0", "assert apps_run1(3, [6, 6, 6]) == 6", "assert apps_run1(3, [6, 6, 9]) == 3", "assert apps_run1(26, [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) == 0", "assert apps_run1(3, [7, 7, 21]) == 0", "assert apps_run1(2, [95, 50]) == 5", "assert apps_run1(3, [30, 30, 15]) == 15", "assert apps_run1(3, [1, 50, 70]) == 1", "assert apps_run1(2, [70, 10]) == 10"], "new_problem": "Ivan wants to make a necklace as a present to his beloved girl. A necklace is a cyclic sequence of beads of different colors. Ivan says that a necklace is beautiful relative to the cut point between two adjacent beads if the chain of beads remaining after this cut is a palindrome (reads the same forward and backward). Ivan has beads of n colors. He wants to make a necklace such that it's beautiful relative to as many cuts as possible. He certainly wants to use all the beads. Additionally, there are m special pairs of colors, and Ivan wants to ensure that each special pair appears consecutively at least once in the necklace. Help him to make the most beautiful necklace.", "new_solution": "from typing import List, Tuple\nimport math\nfrom functools import reduce\nfrom itertools import permutations\n\ndef apps_run2(n: int, beads: List[int], m: int, special_pairs: List[Tuple[str, str]]) -> Tuple[int, str]:\n    odd = -1\n    color_map = {chr(ord('a') + i): beads[i] for i in range(n)}\n    for i, count in enumerate(beads):\n        if count % 2:\n            if odd >= 0:\n                return 0#, ''.join(chr(ord('a') + i) * beads[i] for i in range(n))\n            else:\n                odd = i\n    gcd = reduce(lambda x, y: math.gcd(x, y), beads)\n\n    def generate_necklaces():\n        all_colors = ''.join(chr(ord('a') + i) * beads[i] for i in range(n))\n        # \u76f4\u63a5\u904d\u5386 permutations \u7ed3\u679c\uff0c\u4e0d\u8f6c\u6362\u4e3a\u96c6\u5408\n        for perm in permutations(all_colors):\n            necklace = ''.join(perm)\n            valid = True\n            for pair in special_pairs:\n                if pair[0] + pair[1] not in necklace and pair[1] + pair[0] not in necklace:\n                    valid = False\n                    break\n            if valid:\n                if odd >= 0:\n                    # \u7b80\u5355\u5224\u65ad\u662f\u5426\u6ee1\u8db3\u56de\u6587\u5207\u5272\u70b9\u8981\u6c42\uff0c\u8fd9\u91cc\u53ef\u4ee5\u8fdb\u4e00\u6b65\u4f18\u5316\n                    for i in range(len(necklace)):\n                        new_necklace = necklace[i:] + necklace[:i]\n                        if new_necklace == new_necklace[::-1]:\n                            yield gcd, new_necklace\n                else:\n                    for i in range(len(necklace)):\n                        new_necklace = necklace[i:] + necklace[:i]\n                        if new_necklace == new_necklace[::-1]:\n                            yield gcd // 2, new_necklace\n\n    max_cuts = 0\n    best_necklace = ''\n    for cuts, necklace in generate_necklaces():\n        if cuts > max_cuts:\n            max_cuts = cuts\n            best_necklace = necklace\n\n    if max_cuts == 0:\n        return 0#, ''.join(chr(ord('a') + i) * beads[i] for i in range(n))\n    return max_cuts#, best_necklace\n", "input_format": "The first line contains a single number n (1 \u2264 n \u2264 26) \u2014 the number of colors of beads. The second line contains n positive integers a_{i} \u2014 the quantity of beads of i-th color. The third line contains a single integer m (1 \u2264 m \u2264 100) \u2014 the number of special pairs of colors. The next m lines each contain two lowercase letters representing a special pair of colors.", "output_format": "In the first line, print a single number \u2014 the maximum number of beautiful cuts that a necklace composed from given beads may have. In the second line, print any example of such a necklace.", "test_input": ["assert apps_run2(3, [4, 2, 1], 1, [('a', 'b')]) == 1", "assert apps_run2(1, [4], 0, []) == 2", "assert apps_run2(2, [1, 1], 1, [('a', 'b')]) == 0", "assert apps_run2(3, [3, 3, 2], 2, [('a', 'b'), ('b', 'c')]) == 0", "assert apps_run2(4, [2, 2, 2, 2], 2, [('a', 'b'), ('c', 'd')]) == 1"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "APPS/2020-4", "raw_problem": "Ivan wants to make a necklace as a present to his beloved girl. A necklace is a cyclic sequence of beads of different colors. Ivan says that necklace is beautiful relative to the cut point between two adjacent beads, if the chain of beads remaining after this cut is a palindrome (reads the same forward and backward).\n\n [Image] \n\nIvan has beads of n colors. He wants to make a necklace, such that it's beautiful relative to as many cuts as possible. He certainly wants to use all the beads. Help him to make the most beautiful necklace.\n\n\n-----Input-----\n\nThe first line of the input contains a single number n (1 \u2264 n \u2264 26) \u2014 the number of colors of beads. The second line contains after n positive integers a_{i} \u00a0 \u2014 the quantity of beads of i-th color. It is guaranteed that the sum of a_{i} is at least 2 and does not exceed 100 000.\n\n\n-----Output-----\n\nIn the first line print a single number\u00a0\u2014 the maximum number of beautiful cuts that a necklace composed from given beads may have. In the second line print any example of such necklace.\n\nEach color of the beads should be represented by the corresponding lowercase English letter (starting with a). As the necklace is cyclic, print it starting from any point.\n\n\n-----Examples-----\nInput\n3\n4 2 1\n\nOutput\n1\nabacaba\nInput\n1\n4\n\nOutput\n4\naaaa\n\nInput\n2\n1 1\n\nOutput\n0\nab\n\n\n\n-----Note-----\n\nIn the first sample a necklace can have at most one beautiful cut. The example of such a necklace is shown on the picture.\n\nIn the second sample there is only one way to compose a necklace.", "raw_solution": "def apps_run1(n, beads):\n    import math\n    from functools import reduce\n\n    odd = -1\n    for i in range(n):\n        if beads[i] % 2:\n            if odd >= 0:\n                return 0#, ''.join(chr(ord('a') + i) * beads[i] for i in range(n)))\n            else:\n                odd = i\n    else:\n        gcd = reduce(lambda x, y: math.gcd(x, y), beads)\n        if odd >= 0:\n            s = ''.join(chr(ord('a') + i) * (beads[i] // (2 * gcd)) for i in range(n) if i != odd)\n            p = s + chr(ord('a') + odd) * (beads[odd] // gcd) + s[::-1]\n            return gcd#, p * gcd)\n        else:\n            s = ''.join(chr(ord('a') + i) * (beads[i] // gcd) for i in range(n))\n            p = s + s[::-1]\n            return gcd#, p * (gcd // 2))", "raw_test_input": ["assert apps_run1(3, [4, 2, 1]) == 1#, 'aabcbaa')", "assert apps_run1(1, [4]) == 4", "assert apps_run1(2, [1, 1]) == 0", "assert apps_run1(1, [2]) == 2", "assert apps_run1(1, [3]) == 3", "assert apps_run1(1, [5]) == 5", "assert apps_run1(2, [2, 2]) == 2", "assert apps_run1(3, [1, 2, 4]) == 1", "assert apps_run1(3, [3, 3, 3]) == 0", "assert apps_run1(3, [3, 3, 6]) == 0", "assert apps_run1(3, [6, 6, 6]) == 6", "assert apps_run1(3, [6, 6, 9]) == 3", "assert apps_run1(26, [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) == 0", "assert apps_run1(3, [7, 7, 21]) == 0", "assert apps_run1(2, [95, 50]) == 5", "assert apps_run1(3, [30, 30, 15]) == 15", "assert apps_run1(3, [1, 50, 70]) == 1", "assert apps_run1(2, [70, 10]) == 10"], "new_problem": "Ivan wants to make a necklace as a present to his beloved girl. A necklace is a cyclic sequence of beads of different colors. Ivan says that a necklace is beautiful relative to the cut point between two adjacent beads if the chain of beads remaining after this cut is a palindrome (reads the same forward and backward). Ivan has beads of n colors. He wants to make a necklace such that it's beautiful relative to as many cuts as possible. He certainly wants to use all the beads. Help him to make the most beautiful necklace. However, the input may contain errors such as invalid number of colors, negative bead counts, or non-integer values. Implement error handling to manage these scenarios. The program should raise specific exceptions with meaningful error messages for each type of error.", "new_solution": "import math\nfrom functools import reduce\nfrom typing import List, Tuple\n\nclass NecklaceError(Exception):\n    pass\n\nclass InvalidColorCountError(NecklaceError):\n    def __init__(self, message=\"Invalid number of colors. Must be between 1 and 26.\"):\n        self.message = message\n        super().__init__(self.message)\n\nclass InvalidBeadCountError(NecklaceError):\n    def __init__(self, message=\"Bead counts must be positive integers.\"):\n        self.message = message\n        super().__init__(self.message)\n\nclass BeadSumError(NecklaceError):\n    def __init__(self, message=\"The sum of beads must be at least 2 and not exceed 100,000.\"):\n        self.message = message\n        super().__init__(self.message)\n\n\ndef apps_run2(n: int, beads: List[int]) -> Tuple[int, str]:\n    if not (1 <= n <= 26):\n        raise InvalidColorCountError()\n    if any(b <= 0 for b in beads):\n        raise InvalidBeadCountError()\n    if not (2 <= sum(beads) <= 100000):\n        raise BeadSumError()\n\n    odd = -1\n    for i in range(n):\n        if beads[i] % 2:\n            if odd >= 0:\n                return 0#, ''.join(chr(ord('a') + i) * beads[i] for i in range(n))\n            else:\n                odd = i\n    gcd = reduce(lambda x, y: math.gcd(x, y), beads)\n    if odd >= 0:\n        s = ''.join(chr(ord('a') + i) * (beads[i] // (2 * gcd)) for i in range(n) if i != odd)\n        p = s + chr(ord('a') + odd) * (beads[odd] // gcd) + s[::-1]\n        return gcd#, p * gcd\n    else:\n        s = ''.join(chr(ord('a') + i) * (beads[i] // gcd) for i in range(n))\n        p = s + s[::-1]\n        return gcd#, p * (gcd // 2)\n", "input_format": "The first line of the input contains a single number n (1 \u2264 n \u2264 26) \u2014 the number of colors of beads. The second line contains n positive integers a_{i} \u2014 the quantity of beads of i-th color. It is guaranteed that the sum of a_{i} is at least 2 and does not exceed 100,000.", "output_format": "In the first line print a single number \u2014 the maximum number of beautiful cuts that a necklace composed from given beads may have. In the second line print any example of such necklace. Each color of the beads should be represented by the corresponding lowercase English letter (starting with a). As the necklace is cyclic, print it starting from any point.", "test_input": ["assert apps_run2(3, [4, 2, 1]) == 1", "assert apps_run2(1, [4]) == 4", "assert apps_run2(2, [1, 1]) == 0", "try:\n    apps_run2(0, [1, 1])\nexcept InvalidColorCountError as e:\n    assert str(e) == 'Invalid number of colors. Must be between 1 and 26.'", "try:\n    apps_run2(3, [-1, 2, 1])\nexcept InvalidBeadCountError as e:\n    assert str(e) == 'Bead counts must be positive integers.'", "try:\n    apps_run2(3, [1, 1, 1])\nexcept BeadSumError as e:\n    assert str(e) == 'The sum of beads must be at least 2 and not exceed 100,000.'"], "requirement_type": "PROMPT_ERROR_HANDLING"}
{"task_id": "APPS/2021-1", "raw_problem": "Recently, Pari and Arya did some research about NP-Hard problems and they found the minimum vertex cover problem very interesting.\n\nSuppose the graph G is given. Subset A of its vertices is called a vertex cover of this graph, if for each edge uv there is at least one endpoint of it in this set, i.e. $u \\in A$ or $v \\in A$ (or both).\n\nPari and Arya have won a great undirected graph as an award in a team contest. Now they have to split it in two parts, but both of them want their parts of the graph to be a vertex cover.\n\nThey have agreed to give you their graph and you need to find two disjoint subsets of its vertices A and B, such that both A and B are vertex cover or claim it's impossible. Each vertex should be given to no more than one of the friends (or you can even keep it for yourself).\n\n\n-----Input-----\n\nThe first line of the input contains two integers n and m (2 \u2264 n \u2264 100 000, 1 \u2264 m \u2264 100 000)\u00a0\u2014 the number of vertices and the number of edges in the prize graph, respectively.\n\nEach of the next m lines contains a pair of integers u_{i} and v_{i} (1  \u2264  u_{i},  v_{i}  \u2264  n), denoting an undirected edge between u_{i} and v_{i}. It's guaranteed the graph won't contain any self-loops or multiple edges.\n\n\n-----Output-----\n\nIf it's impossible to split the graph between Pari and Arya as they expect, print \"-1\" (without quotes).\n\nIf there are two disjoint sets of vertices, such that both sets are vertex cover, print their descriptions. Each description must contain two lines. The first line contains a single integer k denoting the number of vertices in that vertex cover, and the second line contains k integers\u00a0\u2014 the indices of vertices. Note that because of m \u2265 1, vertex cover cannot be empty.\n\n\n-----Examples-----\nInput\n4 2\n1 2\n2 3\n\nOutput\n1\n2 \n2\n1 3 \n\nInput\n3 3\n1 2\n2 3\n1 3\n\nOutput\n-1\n\n\n\n-----Note-----\n\nIn the first sample, you can give the vertex number 2 to Arya and vertices numbered 1 and 3 to Pari and keep vertex number 4 for yourself (or give it someone, if you wish).\n\nIn the second sample, there is no way to satisfy both Pari and Arya.", "raw_solution": "def apps_run1(n, m, edges):\n    l = [[] for _ in range(n + 1)]\n    for u, v in edges:\n        l[u].append(v)\n        l[v].append(u)\n    res = [0] * (n + 1)\n    for u, x in enumerate(res):\n        if not x:\n            x, nxt = -1, [u]\n            while nxt:\n                x, cur, nxt = -x, nxt, []\n                for u in cur:\n                    if l[u]:\n                        res[u] = x\n                        for v in l[u]:\n                            if not res[v]:\n                                nxt.append(v)\n                            elif res[v] == x:\n                                return '-1\\n'\n    result = []\n    for x in -1, 1:\n        l = [u for u in range(1, n + 1) if res[u] == x]\n        result.append(f\"{len(l)}\\n\")\n        result.append(' '.join(map(str, l)) + ' \\n')\n    return ''.join(result)\n", "raw_test_input": ["assert apps_run1(4, 2, [(1, 2), (2, 3)]) == '1\\n2 \\n2\\n1 3 \\n'", "assert apps_run1(3, 3, [(1, 2), (2, 3), (1, 3)]) == '-1\\n'", "assert apps_run1(5, 7, [(3, 2), (5, 4), (3, 4), (1, 3), (1, 5), (1, 4), (2, 5)]) == '-1\\n'", "assert apps_run1(10, 11, [(4, 10), (8, 10), (2, 3), (2, 4), (7, 1), (8, 5), (2, 8), (7, 2), (1, 2), (2, 9), (6, 8)]) == '-1\\n'", "assert apps_run1(10, 9, [(2, 5), (2, 4), (2, 7), (2, 9), (2, 3), (2, 8), (2, 6), (2, 10), (2, 1)]) == '1\\n2 \\n9\\n1 3 4 5 6 7 8 9 10 \\n'", "assert apps_run1(10, 16, [(6, 10), (5, 2), (6, 4), (6, 8), (5, 3), (5, 4), (6, 2), (5, 9), (5, 7), (5, 1), (6, 9), (5, 8), (5, 10), (6, 1), (6, 7), (6, 3)]) == '2\\n5 6 \\n8\\n1 2 3 4 7 8 9 10 \\n'", "assert apps_run1(10, 17, [(5, 1), (8, 1), (2, 1), (2, 6), (3, 1), (5, 7), (3, 7), (8, 6), (4, 7), (2, 7), (9, 7), (10, 7), (3, 6), (4, 1), (9, 1), (8, 7), (10, 1)]) == '7\\n2 3 4 5 8 9 10 \\n3\\n1 6 7 \\n'", "assert apps_run1(10, 15, [(5, 9), (7, 8), (2, 9), (1, 9), (3, 8), (3, 9), (5, 8), (1, 8), (6, 9), (7, 9), (4, 8), (4, 9), (10, 9), (10, 8), (6, 8)]) == '2\\n8 9 \\n8\\n1 2 3 4 5 6 7 10 \\n'", "assert apps_run1(10, 9, [(4, 9), (1, 9), (10, 9), (2, 9), (3, 9), (6, 9), (5, 9), (7, 9), (8, 9)]) == '1\\n9 \\n9\\n1 2 3 4 5 6 7 8 10 \\n'", "assert apps_run1(2, 1, [(1, 2)]) == '1\\n2 \\n1\\n1 \\n'", "assert apps_run1(10, 10, [(6, 4), (9, 1), (3, 6), (6, 7), (4, 2), (9, 6), (8, 6), (5, 7), (1, 4), (6, 10)]) == '6\\n3 4 7 8 9 10 \\n4\\n1 2 5 6 \\n'", "assert apps_run1(20, 22, [(20, 8), (1, 3), (3, 18), (14, 7), (19, 6), (7, 20), (14, 8), (8, 10), (2, 5), (11, 2), (4, 19), (14, 2), (7, 11), (15, 1), (12, 15), (7, 6), (11, 13), (1, 16), (9, 12), (1, 19), (17, 3), (11, 20)]) == '-1\\n'", "assert apps_run1(20, 22, [(3, 18), (9, 19), (6, 15), (7, 1), (16, 8), (18, 7), (12, 3), (18, 4), (9, 15), (20, 1), (4, 2), (6, 7), (14, 2), (7, 15), (7, 10), (8, 1), (13, 6), (9, 7), (11, 8), (2, 6), (18, 5), (17, 15)]) == '-1\\n'", "assert apps_run1(1000, 1, [(839, 771)]) == '1\\n839 \\n1\\n771 \\n'", "assert apps_run1(1000, 1, [(195, 788)]) == '1\\n788 \\n1\\n195 \\n'", "assert apps_run1(100000, 1, [(42833, 64396)]) == '1\\n64396 \\n1\\n42833 \\n'", "assert apps_run1(100000, 1, [(26257, 21752)]) == '1\\n26257 \\n1\\n21752 \\n'", "assert apps_run1(5, 5, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 1)]) == '-1\\n'"], "new_problem": "In a network security system, you are tasked with analyzing a network graph to ensure that certain critical nodes can be isolated into separate security zones. The network is represented as an undirected graph where nodes are devices and edges are direct connections between them. Your task is to determine if it's possible to split the network into two disjoint vertex covers such that specific pairs of critical nodes can be placed in separate covers. Given the graph and a list of critical node pairs, determine for each pair if they can be isolated into separate vertex covers.", "new_solution": "def apps_run2(n, m, edges, queries):\n    def find_vertex_covers(n, m, edges):\n        l = [[] for _ in range(n + 1)]\n        for u, v in edges:\n            l[u].append(v)\n            l[v].append(u)\n        res = [0] * (n + 1)\n        for u, x in enumerate(res):\n            if not x:\n                x, nxt = -1, [u]\n                while nxt:\n                    x, cur, nxt = -x, nxt, []\n                    for u in cur:\n                        if l[u]:\n                            res[u] = x\n                            for v in l[u]:\n                                if not res[v]:\n                                    nxt.append(v)\n                                elif res[v] == x:\n                                    return None\n        return res\n\n    res = find_vertex_covers(n, m, edges)\n    if res is None:\n        return ['NO' for _ in queries]\n\n    results = []\n    for a, b in queries:\n        if res[a] != res[b]:\n            results.append('YES')\n        else:\n            results.append('NO')\n    return results", "input_format": "The input consists of multiple test cases. Each test case starts with two integers n and m (2 \u2264 n \u2264 100 000, 1 \u2264 m \u2264 100 000) \u2014 the number of vertices and the number of edges in the graph, respectively. Each of the next m lines contains a pair of integers u_{i} and v_{i} (1 \u2264 u_{i}, v_{i} \u2264 n), denoting an undirected edge between u_{i} and v_{i}. After the graph data, an integer q (1 \u2264 q \u2264 1000) is given, representing the number of queries. Each query consists of two integers a and b (1 \u2264 a, b \u2264 n), representing a request to check if vertices a and b can be in separate vertex covers.", "output_format": "For each query, output 'YES' if it's possible to assign vertices a and b to separate vertex covers, otherwise output 'NO'.", "test_input": ["assert apps_run2(4, 2, [(1, 2), (2, 3)], [(1, 3), (2, 4)]) == ['NO', 'YES']", "assert apps_run2(3, 3, [(1, 2), (2, 3), (1, 3)], [(1, 2), (2, 3)]) == ['NO', 'NO']", "assert apps_run2(5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)], [(1, 5), (2, 4)]) == ['NO', 'NO']", "assert apps_run2(6, 5, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)], [(1, 6), (2, 5)]) == ['YES', 'YES']", "assert apps_run2(4, 3, [(1, 2), (2, 3), (3, 4)], [(1, 4), (2, 3)]) == ['YES', 'YES']"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "APPS/2021-2", "raw_problem": "Recently, Pari and Arya did some research about NP-Hard problems and they found the minimum vertex cover problem very interesting.\n\nSuppose the graph G is given. Subset A of its vertices is called a vertex cover of this graph, if for each edge uv there is at least one endpoint of it in this set, i.e. $u \\in A$ or $v \\in A$ (or both).\n\nPari and Arya have won a great undirected graph as an award in a team contest. Now they have to split it in two parts, but both of them want their parts of the graph to be a vertex cover.\n\nThey have agreed to give you their graph and you need to find two disjoint subsets of its vertices A and B, such that both A and B are vertex cover or claim it's impossible. Each vertex should be given to no more than one of the friends (or you can even keep it for yourself).\n\n\n-----Input-----\n\nThe first line of the input contains two integers n and m (2 \u2264 n \u2264 100 000, 1 \u2264 m \u2264 100 000)\u00a0\u2014 the number of vertices and the number of edges in the prize graph, respectively.\n\nEach of the next m lines contains a pair of integers u_{i} and v_{i} (1  \u2264  u_{i},  v_{i}  \u2264  n), denoting an undirected edge between u_{i} and v_{i}. It's guaranteed the graph won't contain any self-loops or multiple edges.\n\n\n-----Output-----\n\nIf it's impossible to split the graph between Pari and Arya as they expect, print \"-1\" (without quotes).\n\nIf there are two disjoint sets of vertices, such that both sets are vertex cover, print their descriptions. Each description must contain two lines. The first line contains a single integer k denoting the number of vertices in that vertex cover, and the second line contains k integers\u00a0\u2014 the indices of vertices. Note that because of m \u2265 1, vertex cover cannot be empty.\n\n\n-----Examples-----\nInput\n4 2\n1 2\n2 3\n\nOutput\n1\n2 \n2\n1 3 \n\nInput\n3 3\n1 2\n2 3\n1 3\n\nOutput\n-1\n\n\n\n-----Note-----\n\nIn the first sample, you can give the vertex number 2 to Arya and vertices numbered 1 and 3 to Pari and keep vertex number 4 for yourself (or give it someone, if you wish).\n\nIn the second sample, there is no way to satisfy both Pari and Arya.", "raw_solution": "def apps_run1(n, m, edges):\n    l = [[] for _ in range(n + 1)]\n    for u, v in edges:\n        l[u].append(v)\n        l[v].append(u)\n    res = [0] * (n + 1)\n    for u, x in enumerate(res):\n        if not x:\n            x, nxt = -1, [u]\n            while nxt:\n                x, cur, nxt = -x, nxt, []\n                for u in cur:\n                    if l[u]:\n                        res[u] = x\n                        for v in l[u]:\n                            if not res[v]:\n                                nxt.append(v)\n                            elif res[v] == x:\n                                return '-1\\n'\n    result = []\n    for x in -1, 1:\n        l = [u for u in range(1, n + 1) if res[u] == x]\n        result.append(f\"{len(l)}\\n\")\n        result.append(' '.join(map(str, l)) + ' \\n')\n    return ''.join(result)\n", "raw_test_input": ["assert apps_run1(4, 2, [(1, 2), (2, 3)]) == '1\\n2 \\n2\\n1 3 \\n'", "assert apps_run1(3, 3, [(1, 2), (2, 3), (1, 3)]) == '-1\\n'", "assert apps_run1(5, 7, [(3, 2), (5, 4), (3, 4), (1, 3), (1, 5), (1, 4), (2, 5)]) == '-1\\n'", "assert apps_run1(10, 11, [(4, 10), (8, 10), (2, 3), (2, 4), (7, 1), (8, 5), (2, 8), (7, 2), (1, 2), (2, 9), (6, 8)]) == '-1\\n'", "assert apps_run1(10, 9, [(2, 5), (2, 4), (2, 7), (2, 9), (2, 3), (2, 8), (2, 6), (2, 10), (2, 1)]) == '1\\n2 \\n9\\n1 3 4 5 6 7 8 9 10 \\n'", "assert apps_run1(10, 16, [(6, 10), (5, 2), (6, 4), (6, 8), (5, 3), (5, 4), (6, 2), (5, 9), (5, 7), (5, 1), (6, 9), (5, 8), (5, 10), (6, 1), (6, 7), (6, 3)]) == '2\\n5 6 \\n8\\n1 2 3 4 7 8 9 10 \\n'", "assert apps_run1(10, 17, [(5, 1), (8, 1), (2, 1), (2, 6), (3, 1), (5, 7), (3, 7), (8, 6), (4, 7), (2, 7), (9, 7), (10, 7), (3, 6), (4, 1), (9, 1), (8, 7), (10, 1)]) == '7\\n2 3 4 5 8 9 10 \\n3\\n1 6 7 \\n'", "assert apps_run1(10, 15, [(5, 9), (7, 8), (2, 9), (1, 9), (3, 8), (3, 9), (5, 8), (1, 8), (6, 9), (7, 9), (4, 8), (4, 9), (10, 9), (10, 8), (6, 8)]) == '2\\n8 9 \\n8\\n1 2 3 4 5 6 7 10 \\n'", "assert apps_run1(10, 9, [(4, 9), (1, 9), (10, 9), (2, 9), (3, 9), (6, 9), (5, 9), (7, 9), (8, 9)]) == '1\\n9 \\n9\\n1 2 3 4 5 6 7 8 10 \\n'", "assert apps_run1(2, 1, [(1, 2)]) == '1\\n2 \\n1\\n1 \\n'", "assert apps_run1(10, 10, [(6, 4), (9, 1), (3, 6), (6, 7), (4, 2), (9, 6), (8, 6), (5, 7), (1, 4), (6, 10)]) == '6\\n3 4 7 8 9 10 \\n4\\n1 2 5 6 \\n'", "assert apps_run1(20, 22, [(20, 8), (1, 3), (3, 18), (14, 7), (19, 6), (7, 20), (14, 8), (8, 10), (2, 5), (11, 2), (4, 19), (14, 2), (7, 11), (15, 1), (12, 15), (7, 6), (11, 13), (1, 16), (9, 12), (1, 19), (17, 3), (11, 20)]) == '-1\\n'", "assert apps_run1(20, 22, [(3, 18), (9, 19), (6, 15), (7, 1), (16, 8), (18, 7), (12, 3), (18, 4), (9, 15), (20, 1), (4, 2), (6, 7), (14, 2), (7, 15), (7, 10), (8, 1), (13, 6), (9, 7), (11, 8), (2, 6), (18, 5), (17, 15)]) == '-1\\n'", "assert apps_run1(1000, 1, [(839, 771)]) == '1\\n839 \\n1\\n771 \\n'", "assert apps_run1(1000, 1, [(195, 788)]) == '1\\n788 \\n1\\n195 \\n'", "assert apps_run1(100000, 1, [(42833, 64396)]) == '1\\n64396 \\n1\\n42833 \\n'", "assert apps_run1(100000, 1, [(26257, 21752)]) == '1\\n26257 \\n1\\n21752 \\n'", "assert apps_run1(5, 5, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 1)]) == '-1\\n'"], "new_problem": "Pari and Arya are now interested in a more complex version of the vertex cover problem. They want to split the graph into two disjoint subsets of vertices A and B, such that both A and B are vertex covers. Additionally, they want to know the total number of edges covered by each subset. You need to maintain backward compatibility with the existing implementation, support the original function parameters, and include type hints. Add an optional parameter `return_edge_count` (defaulting to False) that, when set to True, also returns the number of edges covered by each subset.", "new_solution": "from typing import List, Tuple, Union\n\ndef apps_run2(n: int, m: int, edges: List[Tuple[int, int]], return_edge_count: bool = False) -> Union[int, Tuple[List[int], List[int], Union[None, Tuple[int, int]]]]:\n    l = [[] for _ in range(n + 1)]\n    for u, v in edges:\n        l[u].append(v)\n        l[v].append(u)\n    res = [0] * (n + 1)\n    for u, x in enumerate(res):\n        if not x:\n            x, nxt = -1, [u]\n            while nxt:\n                x, cur, nxt = -x, nxt, []\n                for u in cur:\n                    if l[u]:\n                        res[u] = x\n                        for v in l[u]:\n                            if not res[v]:\n                                nxt.append(v)\n                            elif res[v] == x:\n                                return -1\n    cover_a = [u for u in range(1, n + 1) if res[u] == -1]\n    cover_b = [u for u in range(1, n + 1) if res[u] == 1]\n    if return_edge_count:\n        edges_a = sum(1 for u in cover_a for v in l[u] if v in cover_a)\n        edges_b = sum(1 for u in cover_b for v in l[u] if v in cover_b)\n        return cover_a, cover_b, (edges_a, edges_b)\n    return cover_a, cover_b, None", "input_format": "The first line of the input contains two integers n and m (2 \u2264 n \u2264 100 000, 1 \u2264 m \u2264 100 000) \u2014 the number of vertices and the number of edges in the prize graph, respectively. Each of the next m lines contains a pair of integers u_{i} and v_{i} (1 \u2264 u_{i}, v_{i} \u2264 n), denoting an undirected edge between u_{i} and v_{i}. It's guaranteed the graph won't contain any self-loops or multiple edges.", "output_format": "If it's impossible to split the graph between Pari and Arya as they expect, print \"-1\" (without quotes). If there are two disjoint sets of vertices, such that both sets are vertex cover, print their descriptions. Each description must contain two lines. The first line contains a single integer k denoting the number of vertices in that vertex cover, and the second line contains k integers \u2014 the indices of vertices. Note that because of m \u2265 1, vertex cover cannot be empty.", "test_input": ["assert apps_run2(4, 2, [(1, 2), (2, 3)]) == ([2], [1, 3], None)", "assert apps_run2(3, 3, [(1, 2), (2, 3), (1, 3)]) == -1", "assert apps_run2(4, 2, [(1, 2), (2, 3)], return_edge_count=True) == ([2], [1, 3], (0, 0))", "assert apps_run2(5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)]) == ([2, 4], [1, 3, 5], None)", "assert apps_run2(5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)], return_edge_count=True) == ([2, 4], [1, 3, 5], (0, 0))"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "APPS/2021-3", "raw_problem": "Recently, Pari and Arya did some research about NP-Hard problems and they found the minimum vertex cover problem very interesting.\n\nSuppose the graph G is given. Subset A of its vertices is called a vertex cover of this graph, if for each edge uv there is at least one endpoint of it in this set, i.e. $u \\in A$ or $v \\in A$ (or both).\n\nPari and Arya have won a great undirected graph as an award in a team contest. Now they have to split it in two parts, but both of them want their parts of the graph to be a vertex cover.\n\nThey have agreed to give you their graph and you need to find two disjoint subsets of its vertices A and B, such that both A and B are vertex cover or claim it's impossible. Each vertex should be given to no more than one of the friends (or you can even keep it for yourself).\n\n\n-----Input-----\n\nThe first line of the input contains two integers n and m (2 \u2264 n \u2264 100 000, 1 \u2264 m \u2264 100 000)\u00a0\u2014 the number of vertices and the number of edges in the prize graph, respectively.\n\nEach of the next m lines contains a pair of integers u_{i} and v_{i} (1  \u2264  u_{i},  v_{i}  \u2264  n), denoting an undirected edge between u_{i} and v_{i}. It's guaranteed the graph won't contain any self-loops or multiple edges.\n\n\n-----Output-----\n\nIf it's impossible to split the graph between Pari and Arya as they expect, print \"-1\" (without quotes).\n\nIf there are two disjoint sets of vertices, such that both sets are vertex cover, print their descriptions. Each description must contain two lines. The first line contains a single integer k denoting the number of vertices in that vertex cover, and the second line contains k integers\u00a0\u2014 the indices of vertices. Note that because of m \u2265 1, vertex cover cannot be empty.\n\n\n-----Examples-----\nInput\n4 2\n1 2\n2 3\n\nOutput\n1\n2 \n2\n1 3 \n\nInput\n3 3\n1 2\n2 3\n1 3\n\nOutput\n-1\n\n\n\n-----Note-----\n\nIn the first sample, you can give the vertex number 2 to Arya and vertices numbered 1 and 3 to Pari and keep vertex number 4 for yourself (or give it someone, if you wish).\n\nIn the second sample, there is no way to satisfy both Pari and Arya.", "raw_solution": "def apps_run1(n, m, edges):\n    l = [[] for _ in range(n + 1)]\n    for u, v in edges:\n        l[u].append(v)\n        l[v].append(u)\n    res = [0] * (n + 1)\n    for u, x in enumerate(res):\n        if not x:\n            x, nxt = -1, [u]\n            while nxt:\n                x, cur, nxt = -x, nxt, []\n                for u in cur:\n                    if l[u]:\n                        res[u] = x\n                        for v in l[u]:\n                            if not res[v]:\n                                nxt.append(v)\n                            elif res[v] == x:\n                                return '-1\\n'\n    result = []\n    for x in -1, 1:\n        l = [u for u in range(1, n + 1) if res[u] == x]\n        result.append(f\"{len(l)}\\n\")\n        result.append(' '.join(map(str, l)) + ' \\n')\n    return ''.join(result)\n\nassert apps_run1(4, 2, [(1, 2), (2, 3)]) == '1\\n2 \\n2\\n1 3 \\n'\nassert apps_run1(3, 3, [(1, 2), (2, 3), (1, 3)]) == '-1\\n'\nassert apps_run1(5, 7, [(3, 2), (5, 4), (3, 4), (1, 3), (1, 5), (1, 4), (2, 5)]) == '-1\\n'\nassert apps_run1(10, 11, [(4, 10), (8, 10), (2, 3), (2, 4), (7, 1), (8, 5), (2, 8), (7, 2), (1, 2), (2, 9), (6, 8)]) == '-1\\n'\nassert apps_run1(10, 9, [(2, 5), (2, 4), (2, 7), (2, 9), (2, 3), (2, 8), (2, 6), (2, 10), (2, 1)]) == '1\\n2 \\n9\\n1 3 4 5 6 7 8 9 10 \\n'\nassert apps_run1(10, 16, [(6, 10), (5, 2), (6, 4), (6, 8), (5, 3), (5, 4), (6, 2), (5, 9), (5, 7), (5, 1), (6, 9), (5, 8), (5, 10), (6, 1), (6, 7), (6, 3)]) == '2\\n5 6 \\n8\\n1 2 3 4 7 8 9 10 \\n'\nassert apps_run1(10, 17, [(5, 1), (8, 1), (2, 1), (2, 6), (3, 1), (5, 7), (3, 7), (8, 6), (4, 7), (2, 7), (9, 7), (10, 7), (3, 6), (4, 1), (9, 1), (8, 7), (10, 1)]) == '7\\n2 3 4 5 8 9 10 \\n3\\n1 6 7 \\n'\nassert apps_run1(10, 15, [(5, 9), (7, 8), (2, 9), (1, 9), (3, 8), (3, 9), (5, 8), (1, 8), (6, 9), (7, 9), (4, 8), (4, 9), (10, 9), (10, 8), (6, 8)]) == '2\\n8 9 \\n8\\n1 2 3 4 5 6 7 10 \\n'\nassert apps_run1(10, 9, [(4, 9), (1, 9), (10, 9), (2, 9), (3, 9), (6, 9), (5, 9), (7, 9), (8, 9)]) == '1\\n9 \\n9\\n1 2 3 4 5 6 7 8 10 \\n'\nassert apps_run1(2, 1, [(1, 2)]) == '1\\n2 \\n1\\n1 \\n'\nassert apps_run1(10, 10, [(6, 4), (9, 1), (3, 6), (6, 7), (4, 2), (9, 6), (8, 6), (5, 7), (1, 4), (6, 10)]) == '6\\n3 4 7 8 9 10 \\n4\\n1 2 5 6 \\n'\nassert apps_run1(20, 22, [(20, 8), (1, 3), (3, 18), (14, 7), (19, 6), (7, 20), (14, 8), (8, 10), (2, 5), (11, 2), (4, 19), (14, 2), (7, 11), (15, 1), (12, 15), (7, 6), (11, 13), (1, 16), (9, 12), (1, 19), (17, 3), (11, 20)]) == '-1\\n'\nassert apps_run1(20, 22, [(3, 18), (9, 19), (6, 15), (7, 1), (16, 8), (18, 7), (12, 3), (18, 4), (9, 15), (20, 1), (4, 2), (6, 7), (14, 2), (7, 15), (7, 10), (8, 1), (13, 6), (9, 7), (11, 8), (2, 6), (18, 5), (17, 15)]) == '-1\\n'\nassert apps_run1(1000, 1, [(839, 771)]) == '1\\n839 \\n1\\n771 \\n'\nassert apps_run1(1000, 1, [(195, 788)]) == '1\\n788 \\n1\\n195 \\n'\nassert apps_run1(100000, 1, [(42833, 64396)]) == '1\\n64396 \\n1\\n42833 \\n'\nassert apps_run1(100000, 1, [(26257, 21752)]) == '1\\n26257 \\n1\\n21752 \\n'\nassert apps_run1(5, 5, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 1)]) == '-1\\n'", "raw_test_input": ["assert apps_run1(4, 2, [(1, 2), (2, 3)]) == '1\\n2 \\n2\\n1 3 \\n'", "assert apps_run1(3, 3, [(1, 2), (2, 3), (1, 3)]) == '-1\\n'", "assert apps_run1(5, 7, [(3, 2), (5, 4), (3, 4), (1, 3), (1, 5), (1, 4), (2, 5)]) == '-1\\n'"], "new_problem": "Pari and Arya are now interested in a more complex graph structure where each vertex can have a weight, and they want to split the graph such that both parts are vertex covers and the sum of weights in each part is as balanced as possible. The graph is represented using a dictionary where keys are vertex indices and values are tuples containing a list of connected vertices and the weight of the vertex. You need to find two disjoint subsets of its vertices A and B, such that both A and B are vertex covers, and the absolute difference between the sum of weights in A and B is minimized. If it's impossible, print \"-1\".", "new_solution": "from typing import Dict, List, Tuple\nimport itertools\n\ndef is_vertex_cover(graph: Dict[int, Tuple[List[int], int]], vertices: List[int]) -> bool:\n    # \u68c0\u67e5\u7ed9\u5b9a\u7684\u9876\u70b9\u96c6\u5408\u662f\u5426\u4e3a\u9876\u70b9\u8986\u76d6\n    covered_edges = set()\n    for u in vertices:\n        for v in graph[u][0]:\n            covered_edges.add((min(u, v), max(u, v)))\n    all_edges = set()\n    for u in graph:\n        for v in graph[u][0]:\n            all_edges.add((min(u, v), max(u, v)))\n    return covered_edges == all_edges\n\ndef apps_run2(graph: Dict[int, Tuple[List[int], int]]) -> Tuple[List[int], List[int]]:\n    n = len(graph)\n    vertices = list(graph.keys())\n    min_diff = float('inf')\n    best_set_a = []\n    best_set_b = []\n    # \u904d\u5386\u6240\u6709\u53ef\u80fd\u7684\u9876\u70b9\u5b50\u96c6\n    for r in range(1, n):\n        for subset in itertools.combinations(vertices, r):\n            set_a = list(subset)\n            set_b = [v for v in vertices if v not in set_a]\n            # \u68c0\u67e5\u4e24\u4e2a\u5b50\u96c6\u662f\u5426\u90fd\u662f\u9876\u70b9\u8986\u76d6\n            if is_vertex_cover(graph, set_a) and is_vertex_cover(graph, set_b):\n                weight_a = sum(graph[u][1] for u in set_a)\n                weight_b = sum(graph[u][1] for u in set_b)\n                diff = abs(weight_a - weight_b)\n                if diff < min_diff:\n                    min_diff = diff\n                    best_set_a = set_a\n                    best_set_b = set_b\n    if min_diff == float('inf'):\n        return -1, -1\n    return best_set_a, best_set_b", "input_format": "The first line of the input contains two integers n and m (2 \u2264 n \u2264 100 000, 1 \u2264 m \u2264 100 000) \u2014 the number of vertices and the number of edges in the prize graph, respectively. Each of the next m lines contains a pair of integers u_{i} and v_{i} (1 \u2264 u_{i}, v_{i} \u2264 n), denoting an undirected edge between u_{i} and v_{i}.", "output_format": "If it's impossible to split the graph between Pari and Arya as they expect, print \"-1\" (without quotes). If there are two disjoint sets of vertices, such that both sets are vertex cover, print their descriptions. Each description must contain two lines. The first line contains a single integer k denoting the number of vertices in that vertex cover, and the second line contains k integers \u2014 the indices of vertices.", "test_input": ["assert apps_run2({1: ([2], 3), 2: ([1, 3], 2), 3: ([2], 1)}) == ([2], [1, 3])", "assert apps_run2({1: ([2, 3], 1), 2: ([1, 3], 1), 3: ([1, 2], 1)}) == (-1, -1)", "assert apps_run2({1: ([2], 2), 2: ([1, 3], 3), 3: ([2, 4], 2), 4: ([3], 1)}) == ([1, 3], [2, 4])", "assert apps_run2({1: ([2], 5), 2: ([1, 3], 5), 3: ([2, 4], 5), 4: ([3], 5)}) == ([1, 3], [2, 4])", "assert apps_run2({1: ([2, 3], 10), 2: ([1, 3], 10), 3: ([1, 2], 10)}) == (-1, -1)"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "APPS/2021-4", "raw_problem": "Recently, Pari and Arya did some research about NP-Hard problems and they found the minimum vertex cover problem very interesting.\n\nSuppose the graph G is given. Subset A of its vertices is called a vertex cover of this graph, if for each edge uv there is at least one endpoint of it in this set, i.e. $u \\in A$ or $v \\in A$ (or both).\n\nPari and Arya have won a great undirected graph as an award in a team contest. Now they have to split it in two parts, but both of them want their parts of the graph to be a vertex cover.\n\nThey have agreed to give you their graph and you need to find two disjoint subsets of its vertices A and B, such that both A and B are vertex cover or claim it's impossible. Each vertex should be given to no more than one of the friends (or you can even keep it for yourself).\n\n\n-----Input-----\n\nThe first line of the input contains two integers n and m (2 \u2264 n \u2264 100 000, 1 \u2264 m \u2264 100 000)\u00a0\u2014 the number of vertices and the number of edges in the prize graph, respectively.\n\nEach of the next m lines contains a pair of integers u_{i} and v_{i} (1  \u2264  u_{i},  v_{i}  \u2264  n), denoting an undirected edge between u_{i} and v_{i}. It's guaranteed the graph won't contain any self-loops or multiple edges.\n\n\n-----Output-----\n\nIf it's impossible to split the graph between Pari and Arya as they expect, print \"-1\" (without quotes).\n\nIf there are two disjoint sets of vertices, such that both sets are vertex cover, print their descriptions. Each description must contain two lines. The first line contains a single integer k denoting the number of vertices in that vertex cover, and the second line contains k integers\u00a0\u2014 the indices of vertices. Note that because of m \u2265 1, vertex cover cannot be empty.\n\n\n-----Examples-----\nInput\n4 2\n1 2\n2 3\n\nOutput\n1\n2 \n2\n1 3 \n\nInput\n3 3\n1 2\n2 3\n1 3\n\nOutput\n-1\n\n\n\n-----Note-----\n\nIn the first sample, you can give the vertex number 2 to Arya and vertices numbered 1 and 3 to Pari and keep vertex number 4 for yourself (or give it someone, if you wish).\n\nIn the second sample, there is no way to satisfy both Pari and Arya.", "raw_solution": "def apps_run1(n, m, edges):\n    l = [[] for _ in range(n + 1)]\n    for u, v in edges:\n        l[u].append(v)\n        l[v].append(u)\n    res = [0] * (n + 1)\n    for u, x in enumerate(res):\n        if not x:\n            x, nxt = -1, [u]\n            while nxt:\n                x, cur, nxt = -x, nxt, []\n                for u in cur:\n                    if l[u]:\n                        res[u] = x\n                        for v in l[u]:\n                            if not res[v]:\n                                nxt.append(v)\n                            elif res[v] == x:\n                                return '-1\\n'\n    result = []\n    for x in -1, 1:\n        l = [u for u in range(1, n + 1) if res[u] == x]\n        result.append(f\"{len(l)}\\n\")\n        result.append(' '.join(map(str, l)) + ' \\n')\n    return ''.join(result)\n", "raw_test_input": ["assert apps_run1(4, 2, [(1, 2), (2, 3)]) == '1\\n2 \\n2\\n1 3 \\n'", "assert apps_run1(3, 3, [(1, 2), (2, 3), (1, 3)]) == '-1\\n'", "assert apps_run1(5, 7, [(3, 2), (5, 4), (3, 4), (1, 3), (1, 5), (1, 4), (2, 5)]) == '-1\\n'", "assert apps_run1(10, 11, [(4, 10), (8, 10), (2, 3), (2, 4), (7, 1), (8, 5), (2, 8), (7, 2), (1, 2), (2, 9), (6, 8)]) == '-1\\n'", "assert apps_run1(10, 9, [(2, 5), (2, 4), (2, 7), (2, 9), (2, 3), (2, 8), (2, 6), (2, 10), (2, 1)]) == '1\\n2 \\n9\\n1 3 4 5 6 7 8 9 10 \\n'", "assert apps_run1(10, 16, [(6, 10), (5, 2), (6, 4), (6, 8), (5, 3), (5, 4), (6, 2), (5, 9), (5, 7), (5, 1), (6, 9), (5, 8), (5, 10), (6, 1), (6, 7), (6, 3)]) == '2\\n5 6 \\n8\\n1 2 3 4 7 8 9 10 \\n'", "assert apps_run1(10, 17, [(5, 1), (8, 1), (2, 1), (2, 6), (3, 1), (5, 7), (3, 7), (8, 6), (4, 7), (2, 7), (9, 7), (10, 7), (3, 6), (4, 1), (9, 1), (8, 7), (10, 1)]) == '7\\n2 3 4 5 8 9 10 \\n3\\n1 6 7 \\n'", "assert apps_run1(10, 15, [(5, 9), (7, 8), (2, 9), (1, 9), (3, 8), (3, 9), (5, 8), (1, 8), (6, 9), (7, 9), (4, 8), (4, 9), (10, 9), (10, 8), (6, 8)]) == '2\\n8 9 \\n8\\n1 2 3 4 5 6 7 10 \\n'", "assert apps_run1(10, 9, [(4, 9), (1, 9), (10, 9), (2, 9), (3, 9), (6, 9), (5, 9), (7, 9), (8, 9)]) == '1\\n9 \\n9\\n1 2 3 4 5 6 7 8 10 \\n'", "assert apps_run1(2, 1, [(1, 2)]) == '1\\n2 \\n1\\n1 \\n'", "assert apps_run1(10, 10, [(6, 4), (9, 1), (3, 6), (6, 7), (4, 2), (9, 6), (8, 6), (5, 7), (1, 4), (6, 10)]) == '6\\n3 4 7 8 9 10 \\n4\\n1 2 5 6 \\n'", "assert apps_run1(20, 22, [(20, 8), (1, 3), (3, 18), (14, 7), (19, 6), (7, 20), (14, 8), (8, 10), (2, 5), (11, 2), (4, 19), (14, 2), (7, 11), (15, 1), (12, 15), (7, 6), (11, 13), (1, 16), (9, 12), (1, 19), (17, 3), (11, 20)]) == '-1\\n'", "assert apps_run1(20, 22, [(3, 18), (9, 19), (6, 15), (7, 1), (16, 8), (18, 7), (12, 3), (18, 4), (9, 15), (20, 1), (4, 2), (6, 7), (14, 2), (7, 15), (7, 10), (8, 1), (13, 6), (9, 7), (11, 8), (2, 6), (18, 5), (17, 15)]) == '-1\\n'", "assert apps_run1(1000, 1, [(839, 771)]) == '1\\n839 \\n1\\n771 \\n'", "assert apps_run1(1000, 1, [(195, 788)]) == '1\\n788 \\n1\\n195 \\n'", "assert apps_run1(100000, 1, [(42833, 64396)]) == '1\\n64396 \\n1\\n42833 \\n'", "assert apps_run1(100000, 1, [(26257, 21752)]) == '1\\n26257 \\n1\\n21752 \\n'", "assert apps_run1(5, 5, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 1)]) == '-1\\n'"], "new_problem": "Pari and Arya have a graph that they want to split into two disjoint vertex covers. However, the graph data they received might be corrupted or incomplete. You need to handle the following errors: 1. Invalid vertex indices (e.g., indices out of range). 2. Duplicate edges. 3. Missing edges (i.e., m is less than the number of edges provided). 4. Non-integer input. Implement error handling to manage these scenarios and provide meaningful error messages. If the input is valid, find two disjoint subsets of its vertices A and B, such that both A and B are vertex covers, or claim it's impossible.", "new_solution": "class GraphError(Exception):\n    pass\n\n\nclass InvalidVertexIndexError(GraphError):\n    pass\n\n\nclass DuplicateEdgeError(GraphError):\n    pass\n\n\nclass MissingEdgesError(GraphError):\n    pass\n\n\nclass NonIntegerInputError(GraphError):\n    pass\n\n\ndef apps_run2(n, m, edges):\n\n    # \u68c0\u67e5\u8fb9\u5217\u8868\u4e2d\u7684\u6bcf\u4e2a\u5143\u7d20\u662f\u5426\u4e3a\u6709\u6548\u7684\u6574\u6570\u5bf9\n    for edge in edges:\n        if not isinstance(edge, tuple) or len(edge) != 2:\n            raise NonIntegerInputError(\"Non-integer input detected.\")\n        u, v = edge\n        if not isinstance(u, int) or not isinstance(v, int):\n            raise NonIntegerInputError(\"Non-integer input detected.\")\n    # \u68c0\u67e5\u9876\u70b9\u7d22\u5f15\u662f\u5426\u6709\u6548\n    for u, v in edges:\n        if u < 1 or u > n or v < 1 or v > n:\n            raise InvalidVertexIndexError(f\"Vertex index out of range: {u}, {v}\")\n    # \u68c0\u67e5\u662f\u5426\u6709\u91cd\u590d\u8fb9\n    unique_edges = set()\n    for edge in edges:\n        sorted_edge = tuple(sorted(edge))\n        if sorted_edge in unique_edges:\n            raise DuplicateEdgeError(f\"Duplicate edge detected: {edge[0]}-{edge[1]}\")\n        unique_edges.add(sorted_edge)\n    # \u68c0\u67e5\u8fb9\u7684\u6570\u91cf\u662f\u5426\u6b63\u786e\n    if len(unique_edges) != m:\n        raise MissingEdgesError(\"Number of edges does not match the provided count.\")\n\n    l = [[] for _ in range(n + 1)]\n    for u, v in edges:\n        l[u].append(v)\n        l[v].append(u)\n    res = [0] * (n + 1)\n    for u, x in enumerate(res):\n        if not x:\n            x, nxt = -1, [u]\n            while nxt:\n                x, cur, nxt = -x, nxt, []\n                for u in cur:\n                    if l[u]:\n                        res[u] = x\n                        for v in l[u]:\n                            if not res[v]:\n                                nxt.append(v)\n                            elif res[v] == x:\n                                return '-1\\n'\n    result = []\n    for x in -1, 1:\n        l = [u for u in range(1, n + 1) if res[u] == x]\n        result.append(f\"{len(l)}\\n\")\n        result.append(' '.join(map(str, l)) + ' \\n')\n    return ''.join(result)", "input_format": "The first line of the input contains two integers n and m (2 \u2264 n \u2264 100 000, 1 \u2264 m \u2264 100 000) \u2014 the number of vertices and the number of edges in the prize graph, respectively. Each of the next m lines contains a pair of integers u_{i} and v_{i} (1 \u2264 u_{i}, v_{i} \u2264 n), denoting an undirected edge between u_{i} and v_{i}.", "output_format": "If it's impossible to split the graph between Pari and Arya as they expect, print \"-1\" (without quotes). If there are two disjoint sets of vertices, such that both sets are vertex cover, print their descriptions. Each description must contain two lines. The first line contains a single integer k denoting the number of vertices in that vertex cover, and the second line contains k integers \u2014 the indices of vertices.", "test_input": ["try:\n    apps_run2(4, 2, [(1, 2), (2, 3)])\nexcept InvalidVertexIndexError as e:\n    assert str(e) == \"Vertex index out of range: 5, 6\"", "try:\n    apps_run2(4, 2, [(1, 2), (1, 2)])\nexcept DuplicateEdgeError as e:\n    assert str(e) == \"Duplicate edge detected: 1-2\"", "try:\n    apps_run2(4, 2, [(1, 2)])\nexcept MissingEdgesError as e:\n    assert str(e) == \"Number of edges does not match the provided count.\"", "try:\n    apps_run2(4, 2, [('a')])\nexcept NonIntegerInputError as e:\n    assert str(e) == \"Non-integer input detected.\"", "assert apps_run2(3, 3, [(1, 2), (2, 3),(1,3)])=='-1\\n'"], "requirement_type": "PROMPT_ERROR_HANDLING"}
{"task_id": "APPS/2022-1", "raw_problem": "Students went into a class to write a test and sat in some way. The teacher thought: \"Probably they sat in this order to copy works of each other. I need to rearrange them in such a way that students that were neighbors are not neighbors in a new seating.\"\n\nThe class can be represented as a matrix with n rows and m columns with a student in each cell. Two students are neighbors if cells in which they sit have a common side.\n\nLet's enumerate students from 1 to n\u00b7m in order of rows. So a student who initially sits in the cell in row i and column j has a number (i - 1)\u00b7m + j. You have to find a matrix with n rows and m columns in which all numbers from 1 to n\u00b7m appear exactly once and adjacent numbers in the original matrix are not adjacent in it, or determine that there is no such matrix.\n\n\n-----Input-----\n\nThe only line contains two integers n and m (1 \u2264 n, m \u2264 10^5; n\u00b7m \u2264 10^5)\u00a0\u2014 the number of rows and the number of columns in the required matrix.\n\n\n-----Output-----\n\nIf there is no such matrix, output \"NO\" (without quotes). \n\nOtherwise in the first line output \"YES\" (without quotes), and in the next n lines output m integers which form the required matrix.\n\n\n-----Examples-----\nInput\n2 4\n\nOutput\nYES\n5 4 7 2 \n3 6 1 8 \n\nInput\n2 1\n\nOutput\nNO\n\n\n\n-----Note-----\n\nIn the first test case the matrix initially looks like this:\n\n1 2 3 4\n\n5 6 7 8\n\n\n\nIt's easy to see that there are no two students that are adjacent in both matrices.\n\nIn the second test case there are only two possible seatings and in both of them students with numbers 1 and 2 are neighbors.", "raw_solution": "def apps_run1(n, m):\n    if n==1 and m==1:\n        return 'YES\\n1'\n    elif n==3 and m==3:\n        return 'YES\\n6 1 8\\n7 5 3\\n2 9 4'\n    elif n<4 and m<4:\n        return 'NO'\n    elif n==1 or m==1:\n        t=max(n,m)\n        a=[i for i in range(2,t+1,2)]\n        a+=[i for i in range(1,t+1,2)]\n        result = 'YES\\n'\n        for i in a:\n            result += str(i) + ([' ','\\n'][m==1])\n        return result.strip()\n    else:\n        a=[]\n        for j in range(n):\n            a.append([int(i)+int(m*j) for i in range(1,m+1)])\n        if n<=m:\n            for j in range(1,m,2):\n                t=a[0][j]\n                for i in range(1,n):\n                    a[i-1][j]=a[i][j]\n                a[n-1][j]=t\n            for i in range(1,n,2):\n                r,s=a[i][0],a[i][1]\n                for j in range(2,m):\n                    a[i][j-2]=a[i][j]\n                a[i][m-2],a[i][m-1]=r,s\n        else:\n            for j in range(1,m,2):\n                r,s=a[0][j],a[1][j]\n                for i in range(2,n):\n                    a[i-2][j]=a[i][j]\n                a[n-2][j], a[n-1][j] = r, s\n            for i in range(1,n,2):\n                t=a[i][0]\n                for j in range(1,m):\n                    a[i][j-1]=a[i][j]\n                a[i][m-1]=t\n        result = 'YES\\n'\n        for i in range(n):\n            result += ' '.join(map(str, a[i])) + '\\n'\n        return result.strip()", "raw_test_input": ["assert apps_run1(2, 4) == 'YES\\n1 6 3 8\\n7 4 5 2'", "assert apps_run1(2, 1) == 'NO'", "assert apps_run1(1, 1) == 'YES\\n1'", "assert apps_run1(1, 2) == 'NO'", "assert apps_run1(1, 3) == 'NO'", "assert apps_run1(2, 2) == 'NO'", "assert apps_run1(2, 3) == 'NO'", "assert apps_run1(3, 1) == 'NO'", "assert apps_run1(3, 2) == 'NO'", "assert apps_run1(3, 3) == 'YES\\n6 1 8\\n7 5 3\\n2 9 4'", "assert apps_run1(1, 4) == 'YES\\n2 4 1 3'", "assert apps_run1(4, 1) == 'YES\\n2\\n4\\n1\\n3'", "assert apps_run1(4, 2) == 'YES\\n1 6\\n8 3\\n5 2\\n4 7'", "assert apps_run1(100, 1) == 'YES\\n2\\n4\\n6\\n8\\n10\\n12\\n14\\n16\\n18\\n20\\n22\\n24\\n26\\n28\\n30\\n32\\n34\\n36\\n38\\n40\\n42\\n44\\n46\\n48\\n50\\n52\\n54\\n56\\n58\\n60\\n62\\n64\\n66\\n68\\n70\\n72\\n74\\n76\\n78\\n80\\n82\\n84\\n86\\n88\\n90\\n92\\n94\\n96\\n98\\n100\\n1\\n3\\n5\\n7\\n9\\n11\\n13\\n15\\n17\\n19\\n21\\n23\\n25\\n27\\n29\\n31\\n33\\n35\\n37\\n39\\n41\\n43\\n45\\n47\\n49\\n51\\n53\\n55\\n57\\n59\\n61\\n63\\n65\\n67\\n69\\n71\\n73\\n75\\n77\\n79\\n81\\n83\\n85\\n87\\n89\\n91\\n93\\n95\\n97\\n99'", "assert apps_run1(1, 100) == 'YES\\n2 4 6 8 10 12 14 16 18 20 22 24 26 28 30 32 34 36 38 40 42 44 46 48 50 52 54 56 58 60 62 64 66 68 70 72 74 76 78 80 82 84 86 88 90 92 94 96 98 100 1 3 5 7 9 11 13 15 17 19 21 23 25 27 29 31 33 35 37 39 41 43 45 47 49 51 53 55 57 59 61 63 65 67 69 71 73 75 77 79 81 83 85 87 89 91 93 95 97 99'", "assert apps_run1(101, 1) == 'YES\\n2\\n4\\n6\\n8\\n10\\n12\\n14\\n16\\n18\\n20\\n22\\n24\\n26\\n28\\n30\\n32\\n34\\n36\\n38\\n40\\n42\\n44\\n46\\n48\\n50\\n52\\n54\\n56\\n58\\n60\\n62\\n64\\n66\\n68\\n70\\n72\\n74\\n76\\n78\\n80\\n82\\n84\\n86\\n88\\n90\\n92\\n94\\n96\\n98\\n100\\n1\\n3\\n5\\n7\\n9\\n11\\n13\\n15\\n17\\n19\\n21\\n23\\n25\\n27\\n29\\n31\\n33\\n35\\n37\\n39\\n41\\n43\\n45\\n47\\n49\\n51\\n53\\n55\\n57\\n59\\n61\\n63\\n65\\n67\\n69\\n71\\n73\\n75\\n77\\n79\\n81\\n83\\n85\\n87\\n89\\n91\\n93\\n95\\n97\\n99\\n101'\n", "assert apps_run1(1, 101) == 'YES\\n2 4 6 8 10 12 14 16 18 20 22 24 26 28 30 32 34 36 38 40 42 44 46 48 50 52 54 56 58 60 62 64 66 68 70 72 74 76 78 80 82 84 86 88 90 92 94 96 98 100 1 3 5 7 9 11 13 15 17 19 21 23 25 27 29 31 33 35 37 39 41 43 45 47 49 51 53 55 57 59 61 63 65 67 69 71 73 75 77 79 81 83 85 87 89 91 93 95 97 99 101'", "assert apps_run1(2, 20) == 'YES\\n1 22 3 24 5 26 7 28 9 30 11 32 13 34 15 36 17 38 19 40\\n23 4 25 6 27 8 29 10 31 12 33 14 35 16 37 18 39 20 21 2'"], "new_problem": "In a school, there are multiple classes, each with a different seating arrangement. The school wants to ensure that certain pairs of students are not seated next to each other in any class to prevent cheating. Given the dimensions of the classroom and a list of student pairs that should not be neighbors, determine if it's possible to arrange the students in each class such that no specified pairs are neighbors. If possible, provide the seating arrangement for each class.", "new_solution": "from itertools import permutations\n\ndef is_valid(arrangement, n, m, pairs):\n    matrix = [arrangement[i * m:(i + 1) * m] for i in range(n)]\n    for a, b in pairs:\n        found_a = False\n        found_b = False\n        for i in range(n):\n            for j in range(m):\n                if matrix[i][j] == a:\n                    a_pos = (i, j)\n                    found_a = True\n                if matrix[i][j] == b:\n                    b_pos = (i, j)\n                    found_b = True\n                if found_a and found_b:\n                    break\n            if found_a and found_b:\n                break\n        if abs(a_pos[0] - b_pos[0]) + abs(a_pos[1] - b_pos[1]) == 1:\n            return False\n    return True\n\ndef apps_run2(n, m, k, pairs):\n    all_students = list(range(1, n * m + 1))\n    for arrangement in permutations(all_students):\n        if is_valid(arrangement, n, m, pairs):\n            matrix = [arrangement[i * m:(i + 1) * m] for i in range(n)]\n            return 'YES', matrix\n    return 'NO'", "input_format": "The first line contains two integers n and m (1 \u2264 n, m \u2264 10^5; n\u00b7m \u2264 10^5) representing the number of rows and columns of the classroom. The second line contains an integer k (1 \u2264 k \u2264 10^5) representing the number of classes. The next k lines each contain two integers a and b (1 \u2264 a, b \u2264 n\u00b7m) representing pairs of students who should not be neighbors in any class.", "output_format": "If it's possible to arrange the students in all classes such that no specified pairs are neighbors, output 'YES' followed by the seating arrangement for each class. Otherwise, output 'NO'.", "test_input": ["assert apps_run2(2, 4, 1, [(1, 2)]) == ('YES', [(1, 3, 2, 4), (5, 6, 7, 8)])", "assert apps_run2(2, 1, 1, [(1, 2)]) == 'NO'", "assert apps_run2(3, 3, 2, [(1, 2), (3, 4)]) == ('YES', [(1, 3, 2), (4, 5, 6), (7, 8, 9)])", "assert apps_run2(1, 5, 1, [(1, 3)]) == ('YES', [(1, 2, 3, 4, 5)])", "assert apps_run2(4, 4, 0, []) == ('YES', [(1, 2, 3, 4), (5, 6, 7, 8), (9, 10, 11, 12), (13, 14, 15, 16)])"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "APPS/2022-2", "raw_problem": "Students went into a class to write a test and sat in some way. The teacher thought: \"Probably they sat in this order to copy works of each other. I need to rearrange them in such a way that students that were neighbors are not neighbors in a new seating.\"\n\nThe class can be represented as a matrix with n rows and m columns with a student in each cell. Two students are neighbors if cells in which they sit have a common side.\n\nLet's enumerate students from 1 to n\u00b7m in order of rows. So a student who initially sits in the cell in row i and column j has a number (i - 1)\u00b7m + j. You have to find a matrix with n rows and m columns in which all numbers from 1 to n\u00b7m appear exactly once and adjacent numbers in the original matrix are not adjacent in it, or determine that there is no such matrix.\n\n\n-----Input-----\n\nThe only line contains two integers n and m (1 \u2264 n, m \u2264 10^5; n\u00b7m \u2264 10^5)\u00a0\u2014 the number of rows and the number of columns in the required matrix.\n\n\n-----Output-----\n\nIf there is no such matrix, output \"NO\" (without quotes). \n\nOtherwise in the first line output \"YES\" (without quotes), and in the next n lines output m integers which form the required matrix.\n\n\n-----Examples-----\nInput\n2 4\n\nOutput\nYES\n5 4 7 2 \n3 6 1 8 \n\nInput\n2 1\n\nOutput\nNO\n\n\n\n-----Note-----\n\nIn the first test case the matrix initially looks like this:\n\n1 2 3 4\n\n5 6 7 8\n\n\n\nIt's easy to see that there are no two students that are adjacent in both matrices.\n\nIn the second test case there are only two possible seatings and in both of them students with numbers 1 and 2 are neighbors.", "raw_solution": "def apps_run1(n, m):\n    if n == 1 and m == 1:\n        return 'YES\\n1'\n    elif n == 3 and m == 3:\n        return 'YES\\n6 1 8\\n7 5 3\\n2 9 4'\n    elif n < 4 and m < 4:\n        return 'NO'\n    elif n == 1 or m == 1:\n        t = max(n, m)\n        a = [i for i in range(2, t + 1, 2)]\n        a += [i for i in range(1, t + 1, 2)]\n        result = 'YES\\n'\n        for i in a:\n            result += str(i) + ([' ', '\\n'][m == 1])\n        return result.strip()\n    else:\n        a = []\n        for j in range(n):\n            a.append([int(i) + int(m * j) for i in range(1, m + 1)])\n        if n <= m:\n            for j in range(1, m, 2):\n                t = a[0][j]\n                for i in range(1, n):\n                    a[i - 1][j] = a[i][j]\n                a[n - 1][j] = t\n            for i in range(1, n, 2):\n                r, s = a[i][0], a[i][1]\n                for j in range(2, m):\n                    a[i][j - 2] = a[i][j]\n                a[i][m - 2], a[i][m - 1] = r, s\n        else:\n            for j in range(1, m, 2):\n                r, s = a[0][j], a[1][j]\n                for i in range(2, n):\n                    a[i - 2][j] = a[i][j]\n                a[n - 2][j], a[n - 1][j] = r, s\n            for i in range(1, n, 2):\n                t = a[i][0]\n                for j in range(1, m):\n                    a[i][j - 1] = a[i][j]\n                a[i][m - 1] = t\n        result = 'YES\\n'\n        for i in range(n):\n            result += ' '.join(map(str, a[i])) + '\\n'\n        return result.strip()\n", "raw_test_input": ["assert apps_run1(2, 4) == 'YES\\n1 6 3 8\\n7 4 5 2'", "assert apps_run1(2, 1) == 'NO'", "assert apps_run1(1, 1) == 'YES\\n1'", "assert apps_run1(1, 2) == 'NO'", "assert apps_run1(1, 3) == 'NO'", "assert apps_run1(2, 2) == 'NO'", "assert apps_run1(2, 3) == 'NO'", "assert apps_run1(3, 1) == 'NO'", "assert apps_run1(3, 2) == 'NO'", "assert apps_run1(3, 3) == 'YES\\n6 1 8\\n7 5 3\\n2 9 4'", "assert apps_run1(1, 4) == 'YES\\n2 4 1 3'", "assert apps_run1(4, 1) == 'YES\\n2\\n4\\n1\\n3'", "assert apps_run1(4, 2) == 'YES\\n1 6\\n8 3\\n5 2\\n4 7'", "assert apps_run1(100, 1) == 'YES\\n2\\n4\\n6\\n8\\n10\\n12\\n14\\n16\\n18\\n20\\n22\\n24\\n26\\n28\\n30\\n32\\n34\\n36\\n38\\n40\\n42\\n44\\n46\\n48\\n50\\n52\\n54\\n56\\n58\\n60\\n62\\n64\\n66\\n68\\n70\\n72\\n74\\n76\\n78\\n80\\n82\\n84\\n86\\n88\\n90\\n92\\n94\\n96\\n98\\n100\\n1\\n3\\n5\\n7\\n9\\n11\\n13\\n15\\n17\\n19\\n21\\n23\\n25\\n27\\n29\\n31\\n33\\n35\\n37\\n39\\n41\\n43\\n45\\n47\\n49\\n51\\n53\\n55\\n57\\n59\\n61\\n63\\n65\\n67\\n69\\n71\\n73\\n75\\n77\\n79\\n81\\n83\\n85\\n87\\n89\\n91\\n93\\n95\\n97\\n99'", "assert apps_run1(1, 100) == 'YES\\n2 4 6 8 10 12 14 16 18 20 22 24 26 28 30 32 34 36 38 40 42 44 46 48 50 52 54 56 58 60 62 64 66 68 70 72 74 76 78 80 82 84 86 88 90 92 94 96 98 100 1 3 5 7 9 11 13 15 17 19 21 23 25 27 29 31 33 35 37 39 41 43 45 47 49 51 53 55 57 59 61 63 65 67 69 71 73 75 77 79 81 83 85 87 89 91 93 95 97 99'", "assert apps_run1(101, 1) == 'YES\\n2\\n4\\n6\\n8\\n10\\n12\\n14\\n16\\n18\\n20\\n22\\n24\\n26\\n28\\n30\\n32\\n34\\n36\\n38\\n40\\n42\\n44\\n46\\n48\\n50\\n52\\n54\\n56\\n58\\n60\\n62\\n64\\n66\\n68\\n70\\n72\\n74\\n76\\n78\\n80\\n82\\n84\\n86\\n88\\n90\\n92\\n94\\n96\\n98\\n100\\n1\\n3\\n5\\n7\\n9\\n11\\n13\\n15\\n17\\n19\\n21\\n23\\n25\\n27\\n29\\n31\\n33\\n35\\n37\\n39\\n41\\n43\\n45\\n47\\n49\\n51\\n53\\n55\\n57\\n59\\n61\\n63\\n65\\n67\\n69\\n71\\n73\\n75\\n77\\n79\\n81\\n83\\n85\\n87\\n89\\n91\\n93\\n95\\n97\\n99\\n101'", "assert apps_run1(1, 101) == 'YES\\n2 4 6 8 10 12 14 16 18 20 22 24 26 28 30 32 34 36 38 40 42 44 46 48 50 52 54 56 58 60 62 64 66 68 70 72 74 76 78 80 82 84 86 88 90 92 94 96 98 100 1 3 5 7 9 11 13 15 17 19 21 23 25 27 29 31 33 35 37 39 41 43 45 47 49 51 53 55 57 59 61 63 65 67 69 71 73 75 77 79 81 83 85 87 89 91 93 95 97 99 101'", "assert apps_run1(2, 20) == 'YES\\n1 22 3 24 5 26 7 28 9 30 11 32 13 34 15 36 17 38 19 40\\n23 4 25 6 27 8 29 10 31 12 33 14 35 16 37 18 39 20 21 2'"], "new_problem": "Students went into a class to write a test and sat in some way. The teacher thought: 'Probably they sat in this order to copy works of each other. I need to rearrange them in such a way that students that were neighbors are not neighbors in a new seating.' The class can be represented as a matrix with n rows and m columns with a student in each cell. Two students are neighbors if cells in which they sit have a common side. Let's enumerate students from 1 to n\u00b7m in order of rows. So a student who initially sits in the cell in row i and column j has a number (i - 1)\u00b7m + j. You have to find a matrix with n rows and m columns in which all numbers from 1 to n\u00b7m appear exactly once and adjacent numbers in the original matrix are not adjacent in it, or determine that there is no such matrix. Additionally, provide an option to shuffle the resulting matrix randomly while maintaining the non-adjacency condition.", "new_solution": "import random\nfrom typing import List, Tuple\n\ndef apps_run2(n: int, m: int, shuffle: bool = False) -> Tuple[str, List[List[int]]]:\n    if n == 1 and m == 1:\n        return 'YES', [[1]]\n    elif n == 3 and m == 3:\n        result = [[6, 1, 8], [7, 5, 3], [2, 9, 4]]\n        if shuffle:\n            random.shuffle(result)\n        return 'YES', result\n    elif n < 4 and m < 4:\n        return 'NO', []\n    elif n == 1 or m == 1:\n        t = max(n, m)\n        a = [i for i in range(2, t + 1, 2)]\n        a += [i for i in range(1, t + 1, 2)]\n        result = [[i] for i in a] if m == 1 else [a]\n        if shuffle:\n            random.shuffle(result)\n        return 'YES', result\n    else:\n        a = []\n        for j in range(n):\n            a.append([int(i) + int(m * j) for i in range(1, m + 1)])\n        if n <= m:\n            for j in range(1, m, 2):\n                t = a[0][j]\n                for i in range(1, n):\n                    a[i - 1][j] = a[i][j]\n                a[n - 1][j] = t\n            for i in range(1, n, 2):\n                r, s = a[i][0], a[i][1]\n                for j in range(2, m):\n                    a[i][j - 2] = a[i][j]\n                a[i][m - 2], a[i][m - 1] = r, s\n        else:\n            for j in range(1, m, 2):\n                r, s = a[0][j], a[1][j]\n                for i in range(2, n):\n                    a[i - 2][j] = a[i][j]\n                a[n - 2][j], a[n - 1][j] = r, s\n            for i in range(1, n, 2):\n                t = a[i][0]\n                for j in range(1, m):\n                    a[i][j - 1] = a[i][j]\n                a[i][m - 1] = t\n        if shuffle:\n            random.shuffle(a)\n        return 'YES', a\n", "input_format": "The first line contains two integers n and m (1 \u2264 n, m \u2264 10^5; n\u00b7m \u2264 10^5) \u2014 the number of rows and the number of columns in the required matrix. Optionally, a third parameter 'shuffle' can be provided as a boolean to indicate if the output matrix should be shuffled randomly.", "output_format": "If there is no such matrix, output 'NO' (without quotes). Otherwise, in the first line output 'YES' (without quotes), and in the next n lines output m integers which form the required matrix. If 'shuffle' is True, the matrix should be shuffled randomly while maintaining the non-adjacency condition.", "test_input": ["assert apps_run2(2, 4) == ('YES', [[1, 6, 3, 8], [7, 4, 5, 2]])", "assert apps_run2(2, 1) == ('NO', [])", "assert apps_run2(3, 3) == ('YES', [[6, 1, 8], [7, 5, 3], [2, 9, 4]])", "assert apps_run2(1, 1) == ('YES', [[1]])", "assert apps_run2(4, 4, shuffle=True)[0] == 'YES'"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "APPS/2022-3", "raw_problem": "Students went into a class to write a test and sat in some way. The teacher thought: \"Probably they sat in this order to copy works of each other. I need to rearrange them in such a way that students that were neighbors are not neighbors in a new seating.\"\n\nThe class can be represented as a matrix with n rows and m columns with a student in each cell. Two students are neighbors if cells in which they sit have a common side.\n\nLet's enumerate students from 1 to n\u00b7m in order of rows. So a student who initially sits in the cell in row i and column j has a number (i - 1)\u00b7m + j. You have to find a matrix with n rows and m columns in which all numbers from 1 to n\u00b7m appear exactly once and adjacent numbers in the original matrix are not adjacent in it, or determine that there is no such matrix.\n\n\n-----Input-----\n\nThe only line contains two integers n and m (1 \u2264 n, m \u2264 10^5; n\u00b7m \u2264 10^5)\u00a0\u2014 the number of rows and the number of columns in the required matrix.\n\n\n-----Output-----\n\nIf there is no such matrix, output \"NO\" (without quotes). \n\nOtherwise in the first line output \"YES\" (without quotes), and in the next n lines output m integers which form the required matrix.\n\n\n-----Examples-----\nInput\n2 4\n\nOutput\nYES\n5 4 7 2 \n3 6 1 8 \n\nInput\n2 1\n\nOutput\nNO\n\n\n\n-----Note-----\n\nIn the first test case the matrix initially looks like this:\n\n1 2 3 4\n\n5 6 7 8\n\n\n\nIt's easy to see that there are no two students that are adjacent in both matrices.\n\nIn the second test case there are only two possible seatings and in both of them students with numbers 1 and 2 are neighbors.", "raw_solution": "def apps_run1(n, m):\n    if n == 1 and m == 1:\n        return 'YES\\n1'\n    elif n == 3 and m == 3:\n        return 'YES\\n6 1 8\\n7 5 3\\n2 9 4'\n    elif n < 4 and m < 4:\n        return 'NO'\n    elif n == 1 or m == 1:\n        t = max(n, m)\n        a = [i for i in range(2, t + 1, 2)]\n        a += [i for i in range(1, t + 1, 2)]\n        result = 'YES\\n'\n        for i in a:\n            result += str(i) + ([' ', '\\n'][m == 1])\n        return result.strip()\n    else:\n        a = []\n        for j in range(n):\n            a.append([int(i) + int(m * j) for i in range(1, m + 1)])\n        if n <= m:\n            for j in range(1, m, 2):\n                t = a[0][j]\n                for i in range(1, n):\n                    a[i - 1][j] = a[i][j]\n                a[n - 1][j] = t\n            for i in range(1, n, 2):\n                r, s = a[i][0], a[i][1]\n                for j in range(2, m):\n                    a[i][j - 2] = a[i][j]\n                a[i][m - 2], a[i][m - 1] = r, s\n        else:\n            for j in range(1, m, 2):\n                r, s = a[0][j], a[1][j]\n                for i in range(2, n):\n                    a[i - 2][j] = a[i][j]\n                a[n - 2][j], a[n - 1][j] = r, s\n            for i in range(1, n, 2):\n                t = a[i][0]\n                for j in range(1, m):\n                    a[i][j - 1] = a[i][j]\n                a[i][m - 1] = t\n        result = 'YES\\n'\n        for i in range(n):\n            result += ' '.join(map(str, a[i])) + '\\n'\n        return result.strip()\n", "raw_test_input": ["assert apps_run1(2, 4) == 'YES\\n1 6 3 8\\n7 4 5 2'", "assert apps_run1(2, 1) == 'NO'", "assert apps_run1(1, 1) == 'YES\\n1'", "assert apps_run1(1, 2) == 'NO'", "assert apps_run1(1, 3) == 'NO'", "assert apps_run1(2, 2) == 'NO'", "assert apps_run1(2, 3) == 'NO'", "assert apps_run1(3, 1) == 'NO'", "assert apps_run1(3, 2) == 'NO'", "assert apps_run1(3, 3) == 'YES\\n6 1 8\\n7 5 3\\n2 9 4'", "assert apps_run1(1, 4) == 'YES\\n2 4 1 3'", "assert apps_run1(4, 1) == 'YES\\n2\\n4\\n1\\n3'", "assert apps_run1(4, 2) == 'YES\\n1 6\\n8 3\\n5 2\\n4 7'", "assert apps_run1(100, 1) == 'YES\\n2\\n4\\n6\\n8\\n10\\n12\\n14\\n16\\n18\\n20\\n22\\n24\\n26\\n28\\n30\\n32\\n34\\n36\\n38\\n40\\n42\\n44\\n46\\n48\\n50\\n52\\n54\\n56\\n58\\n60\\n62\\n64\\n66\\n68\\n70\\n72\\n74\\n76\\n78\\n80\\n82\\n84\\n86\\n88\\n90\\n92\\n94\\n96\\n98\\n100\\n1\\n3\\n5\\n7\\n9\\n11\\n13\\n15\\n17\\n19\\n21\\n23\\n25\\n27\\n29\\n31\\n33\\n35\\n37\\n39\\n41\\n43\\n45\\n47\\n49\\n51\\n53\\n55\\n57\\n59\\n61\\n63\\n65\\n67\\n69\\n71\\n73\\n75\\n77\\n79\\n81\\n83\\n85\\n87\\n89\\n91\\n93\\n95\\n97\\n99'", "assert apps_run1(1, 100) == 'YES\\n2 4 6 8 10 12 14 16 18 20 22 24 26 28 30 32 34 36 38 40 42 44 46 48 50 52 54 56 58 60 62 64 66 68 70 72 74 76 78 80 82 84 86 88 90 92 94 96 98 100 1 3 5 7 9 11 13 15 17 19 21 23 25 27 29 31 33 35 37 39 41 43 45 47 49 51 53 55 57 59 61 63 65 67 69 71 73 75 77 79 81 83 85 87 89 91 93 95 97 99'", "assert apps_run1(101, 1) == 'YES\\n2\\n4\\n6\\n8\\n10\\n12\\n14\\n16\\n18\\n20\\n22\\n24\\n26\\n28\\n30\\n32\\n34\\n36\\n38\\n40\\n42\\n44\\n46\\n48\\n50\\n52\\n54\\n56\\n58\\n60\\n62\\n64\\n66\\n68\\n70\\n72\\n74\\n76\\n78\\n80\\n82\\n84\\n86\\n88\\n90\\n92\\n94\\n96\\n98\\n100\\n1\\n3\\n5\\n7\\n9\\n11\\n13\\n15\\n17\\n19\\n21\\n23\\n25\\n27\\n29\\n31\\n33\\n35\\n37\\n39\\n41\\n43\\n45\\n47\\n49\\n51\\n53\\n55\\n57\\n59\\n61\\n63\\n65\\n67\\n69\\n71\\n73\\n75\\n77\\n79\\n81\\n83\\n85\\n87\\n89\\n91\\n93\\n95\\n97\\n99\\n101'", "assert apps_run1(1, 101) == 'YES\\n2 4 6 8 10 12 14 16 18 20 22 24 26 28 30 32 34 36 38 40 42 44 46 48 50 52 54 56 58 60 62 64 66 68 70 72 74 76 78 80 82 84 86 88 90 92 94 96 98 100 1 3 5 7 9 11 13 15 17 19 21 23 25 27 29 31 33 35 37 39 41 43 45 47 49 51 53 55 57 59 61 63 65 67 69 71 73 75 77 79 81 83 85 87 89 91 93 95 97 99 101'", "assert apps_run1(2, 20) == 'YES\\n1 22 3 24 5 26 7 28 9 30 11 32 13 34 15 36 17 38 19 40\\n23 4 25 6 27 8 29 10 31 12 33 14 35 16 37 18 39 20 21 2'"], "new_problem": "In a classroom, students are seated in a grid represented by a matrix with n rows and m columns. Each student has a unique ID. The teacher wants to rearrange the students such that no two students who were originally neighbors remain neighbors. However, the teacher also wants to ensure that students with IDs that are prime numbers are seated in the first half of the matrix, and non-prime IDs in the second half. The matrix should be represented using a dictionary where keys are tuples representing coordinates (i, j) and values are student IDs. You need to find such a rearrangement or determine that it is not possible.", "new_solution": "from typing import Dict, Tuple\n\ndef is_prime(num: int) -> bool:\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\n\ndef apps_run2(n: int, m: int, initial_seating: Dict[Tuple[int, int], int]) -> str:\n    if n == 1 and m == 1:\n        return 'YES\\n1'\n    elif n < 4 and m < 4:\n        return 'NO'\n\n    total_students = n * m\n    prime_ids = [i for i in range(1, total_students + 1) if is_prime(i)]\n    non_prime_ids = [i for i in range(1, total_students + 1) if not is_prime(i)]\n\n    if len(prime_ids) > total_students // 2 or len(non_prime_ids) > total_students // 2:\n        return 'NO'\n\n    prime_ids.sort()\n    non_prime_ids.sort()\n\n    new_seating = {}\n    idx = 0\n    for i in range(n):\n        for j in range(m):\n            if idx < len(prime_ids):\n                new_seating[(i, j)] = prime_ids[idx]\n            else:\n                new_seating[(i, j)] = non_prime_ids[idx - len(prime_ids)]\n            idx += 1\n\n    return 'YES\\n' + '\\n'.join(' '.join(str(new_seating[(i, j)]) for j in range(m)) for i in range(n))", "input_format": "The first line contains two integers n and m (1 \u2264 n, m \u2264 10^5; n\u00b7m \u2264 10^5) \u2014 the number of rows and the number of columns in the required matrix. The next n lines contain m integers each, representing the initial seating arrangement.", "output_format": "If there is no such matrix, output \"NO\" (without quotes). Otherwise, in the first line output \"YES\" (without quotes), and in the next n lines output m integers which form the required matrix.", "test_input": ["assert apps_run2(2, 4, {(0, 0): 1, (0, 1): 2, (0, 2): 3, (0, 3): 4, (1, 0): 5, (1, 1): 6, (1, 2): 7, (1, 3): 8}) == 'YES\\n2 3 5 7\\n1 4 6 8'", "assert apps_run2(2, 1, {(0, 0): 1, (1, 0): 2}) == 'NO'", "assert apps_run2(3, 3, {(0, 0): 1, (0, 1): 2, (0, 2): 3, (1, 0): 4, (1, 1): 5, (1, 2): 6, (2, 0): 7, (2, 1): 8, (2, 2): 9}) == 'NO'", "assert apps_run2(1, 1, {(0, 0): 1}) == 'YES\\n1'", "assert apps_run2(4, 4, {(i, j): i * 4 + j + 1 for i in range(4) for j in range(4)}) == 'NO'"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "APPS/2022-4", "raw_problem": "Students went into a class to write a test and sat in some way. The teacher thought: \"Probably they sat in this order to copy works of each other. I need to rearrange them in such a way that students that were neighbors are not neighbors in a new seating.\"\n\nThe class can be represented as a matrix with n rows and m columns with a student in each cell. Two students are neighbors if cells in which they sit have a common side.\n\nLet's enumerate students from 1 to n\u00b7m in order of rows. So a student who initially sits in the cell in row i and column j has a number (i - 1)\u00b7m + j. You have to find a matrix with n rows and m columns in which all numbers from 1 to n\u00b7m appear exactly once and adjacent numbers in the original matrix are not adjacent in it, or determine that there is no such matrix.\n\n\n-----Input-----\n\nThe only line contains two integers n and m (1 \u2264 n, m \u2264 10^5; n\u00b7m \u2264 10^5)\u00a0\u2014 the number of rows and the number of columns in the required matrix.\n\n\n-----Output-----\n\nIf there is no such matrix, output \"NO\" (without quotes). \n\nOtherwise in the first line output \"YES\" (without quotes), and in the next n lines output m integers which form the required matrix.\n\n\n-----Examples-----\nInput\n2 4\n\nOutput\nYES\n5 4 7 2 \n3 6 1 8 \n\nInput\n2 1\n\nOutput\nNO\n\n\n\n-----Note-----\n\nIn the first test case the matrix initially looks like this:\n\n1 2 3 4\n\n5 6 7 8\n\n\n\nIt's easy to see that there are no two students that are adjacent in both matrices.\n\nIn the second test case there are only two possible seatings and in both of them students with numbers 1 and 2 are neighbors.", "raw_solution": "def apps_run1(n, m):\n    if n == 1 and m == 1:\n        return 'YES\\n1'\n    elif n == 3 and m == 3:\n        return 'YES\\n6 1 8\\n7 5 3\\n2 9 4'\n    elif n < 4 and m < 4:\n        return 'NO'\n    elif n == 1 or m == 1:\n        t = max(n, m)\n        a = [i for i in range(2, t + 1, 2)]\n        a += [i for i in range(1, t + 1, 2)]\n        result = 'YES\\n'\n        for i in a:\n            result += str(i) + [' ', '\\n'][m == 1]\n        return result.strip()\n    else:\n        a = []\n        for j in range(n):\n            a.append([int(i) + int(m * j) for i in range(1, m + 1)])\n        if n <= m:\n            for j in range(1, m, 2):\n                t = a[0][j]\n                for i in range(1, n):\n                    a[i - 1][j] = a[i][j]\n                a[n - 1][j] = t\n            for i in range(1, n, 2):\n                r, s = a[i][0], a[i][1]\n                for j in range(2, m):\n                    a[i][j - 2] = a[i][j]\n                a[i][m - 2], a[i][m - 1] = r, s\n        else:\n            for j in range(1, m, 2):\n                r, s = a[0][j], a[1][j]\n                for i in range(2, n):\n                    a[i - 2][j] = a[i][j]\n                a[n - 2][j], a[n - 1][j] = r, s\n            for i in range(1, n, 2):\n                t = a[i][0]\n                for j in range(1, m):\n                    a[i][j - 1] = a[i][j]\n                a[i][m - 1] = t\n        result = 'YES\\n'\n        for i in range(n):\n            result += ' '.join(map(str, a[i])) + '\\n'\n        return result.strip()", "raw_test_input": ["assert apps_run1(2, 4) == 'YES\\n1 6 3 8\\n7 4 5 2'", "assert apps_run1(2, 1) == 'NO'", "assert apps_run1(1, 1) == 'YES\\n1'", "assert apps_run1(1, 2) == 'NO'", "assert apps_run1(1, 3) == 'NO'", "assert apps_run1(2, 2) == 'NO'", "assert apps_run1(2, 3) == 'NO'", "assert apps_run1(3, 1) == 'NO'", "assert apps_run1(3, 2) == 'NO'", "assert apps_run1(3, 3) == 'YES\\n6 1 8\\n7 5 3\\n2 9 4'", "assert apps_run1(1, 4) == 'YES\\n2 4 1 3'", "assert apps_run1(4, 1) == 'YES\\n2\\n4\\n1\\n3'", "assert apps_run1(4, 2) == 'YES\\n1 6\\n8 3\\n5 2\\n4 7'", "assert apps_run1(100, 1) == 'YES\\n2\\n4\\n6\\n8\\n10\\n12\\n14\\n16\\n18\\n20\\n22\\n24\\n26\\n28\\n30\\n32\\n34\\n36\\n38\\n40\\n42\\n44\\n46\\n48\\n50\\n52\\n54\\n56\\n58\\n60\\n62\\n64\\n66\\n68\\n70\\n72\\n74\\n76\\n78\\n80\\n82\\n84\\n86\\n88\\n90\\n92\\n94\\n96\\n98\\n100\\n1\\n3\\n5\\n7\\n9\\n11\\n13\\n15\\n17\\n19\\n21\\n23\\n25\\n27\\n29\\n31\\n33\\n35\\n37\\n39\\n41\\n43\\n45\\n47\\n49\\n51\\n53\\n55\\n57\\n59\\n61\\n63\\n65\\n67\\n69\\n71\\n73\\n75\\n77\\n79\\n81\\n83\\n85\\n87\\n89\\n91\\n93\\n95\\n97\\n99'", "assert apps_run1(1, 100) == 'YES\\n2 4 6 8 10 12 14 16 18 20 22 24 26 28 30 32 34 36 38 40 42 44 46 48 50 52 54 56 58 60 62 64 66 68 70 72 74 76 78 80 82 84 86 88 90 92 94 96 98 100 1 3 5 7 9 11 13 15 17 19 21 23 25 27 29 31 33 35 37 39 41 43 45 47 49 51 53 55 57 59 61 63 65 67 69 71 73 75 77 79 81 83 85 87 89 91 93 95 97 99'", "assert apps_run1(101, 1) == 'YES\\n2\\n4\\n6\\n8\\n10\\n12\\n14\\n16\\n18\\n20\\n22\\n24\\n26\\n28\\n30\\n32\\n34\\n36\\n38\\n40\\n42\\n44\\n46\\n48\\n50\\n52\\n54\\n56\\n58\\n60\\n62\\n64\\n66\\n68\\n70\\n72\\n74\\n76\\n78\\n80\\n82\\n84\\n86\\n88\\n90\\n92\\n94\\n96\\n98\\n100\\n1\\n3\\n5\\n7\\n9\\n11\\n13\\n15\\n17\\n19\\n21\\n23\\n25\\n27\\n29\\n31\\n33\\n35\\n37\\n39\\n41\\n43\\n45\\n47\\n49\\n51\\n53\\n55\\n57\\n59\\n61\\n63\\n65\\n67\\n69\\n71\\n73\\n75\\n77\\n79\\n81\\n83\\n85\\n87\\n89\\n91\\n93\\n95\\n97\\n99\\n101'", "assert apps_run1(1, 101) == 'YES\\n2 4 6 8 10 12 14 16 18 20 22 24 26 28 30 32 34 36 38 40 42 44 46 48 50 52 54 56 58 60 62 64 66 68 70 72 74 76 78 80 82 84 86 88 90 92 94 96 98 100 1 3 5 7 9 11 13 15 17 19 21 23 25 27 29 31 33 35 37 39 41 43 45 47 49 51 53 55 57 59 61 63 65 67 69 71 73 75 77 79 81 83 85 87 89 91 93 95 97 99 101'", "assert apps_run1(2, 20) == 'YES\\n1 22 3 24 5 26 7 28 9 30 11 32 13 34 15 36 17 38 19 40\\n23 4 25 6 27 8 29 10 31 12 33 14 35 16 37 18 39 20 21 2'"], "new_problem": "In a classroom setting, a teacher wants to rearrange students to prevent cheating. The classroom is represented as a matrix with n rows and m columns. Each cell contains a student. Two students are neighbors if their cells share a side. The task is to rearrange the students such that no two students who were neighbors in the original matrix are neighbors in the new matrix. However, the system must handle errors such as invalid input dimensions, exceeding maximum allowed students, and non-integer inputs. Implement error handling to manage these scenarios and provide meaningful error messages.", "new_solution": "def apps_run2(n: int, m: int) -> str:\n    class SeatingError(Exception):\n        pass\n\n    class InvalidDimensionsError(SeatingError):\n        pass\n\n    class ExceedsMaxStudentsError(SeatingError):\n        pass\n\n    MAX_STUDENTS = 100000\n\n    try:\n        if not isinstance(n, int) or not isinstance(m, int):\n            raise ValueError(\"Dimensions must be integers.\")\n        if n < 1 or m < 1:\n            raise InvalidDimensionsError(\"Dimensions must be at least 1.\")\n        if n * m > MAX_STUDENTS:\n            raise ExceedsMaxStudentsError(\"Number of students exceeds the maximum allowed.\")\n\n        if n == 1 and m == 1:\n            return 'YES\\n1'\n        elif n == 3 and m == 3:\n            return 'YES\\n6 1 8\\n7 5 3\\n2 9 4'\n        elif n < 4 and m < 4:\n            return 'NO'\n        elif n == 1 or m == 1:\n            t = max(n, m)\n            a = [i for i in range(2, t + 1, 2)]\n            a += [i for i in range(1, t + 1, 2)]\n            result = 'YES\\n' + (' '.join(map(str, a)) if m > 1 else '\\n'.join(map(str, a)))\n            return result\n        else:\n            a = []\n            for j in range(n):\n                a.append([int(i) + int(m * j) for i in range(1, m + 1)])\n            if n <= m:\n                for j in range(1, m, 2):\n                    t = a[0][j]\n                    for i in range(1, n):\n                        a[i - 1][j] = a[i][j]\n                    a[n - 1][j] = t\n                for i in range(1, n, 2):\n                    r, s = a[i][0], a[i][1]\n                    for j in range(2, m):\n                        a[i][j - 2] = a[i][j]\n                    a[i][m - 2], a[i][m - 1] = r, s\n            else:\n                for j in range(1, m, 2):\n                    r, s = a[0][j], a[1][j]\n                    for i in range(2, n):\n                        a[i - 2][j] = a[i][j]\n                    a[n - 2][j], a[n - 1][j] = r, s\n                for i in range(1, n, 2):\n                    t = a[i][0]\n                    for j in range(1, m):\n                        a[i][j - 1] = a[i][j]\n                    a[i][m - 1] = t\n            result = 'YES\\n' + '\\n'.join(' '.join(map(str, row)) for row in a)\n            return result\n    except SeatingError as e:\n        return f'Error: {str(e)}'\n    except ValueError as e:\n        return f'Error: {str(e)}'\n", "input_format": "The only line contains two integers n and m (1 \u2264 n, m \u2264 10^5; n\u00b7m \u2264 10^5) \u2014 the number of rows and the number of columns in the required matrix.", "output_format": "If there is no such matrix, output 'NO'. Otherwise, output 'YES' followed by the n x m matrix.", "test_input": ["assert apps_run2(2, 4) == 'YES\\n1 6 3 8\\n7 4 5 2'", "assert apps_run2(2, 1) == 'NO'", "assert apps_run2(1, 1) == 'YES\\n1'", "assert apps_run2(3, 3) == 'YES\\n6 1 8\\n7 5 3\\n2 9 4'", "assert apps_run2(100001, 1) == 'Error: Number of students exceeds the maximum allowed.'", "assert apps_run2(0, 5) == 'Error: Dimensions must be at least 1.'", "assert apps_run2('a', 5) == 'Error: Dimensions must be integers.'"], "requirement_type": "PROMPT_ERROR_HANDLING"}
{"task_id": "APPS/2024-1", "raw_problem": "You're playing a game called Osu! Here's a simplified version of it. There are n clicks in a game. For each click there are two outcomes: correct or bad. Let us denote correct as \"O\", bad as \"X\", then the whole play can be encoded as a sequence of n characters \"O\" and \"X\".\n\nUsing the play sequence you can calculate the score for the play as follows: for every maximal consecutive \"O\"s block, add the square of its length (the number of characters \"O\") to the score. For example, if your play can be encoded as \"OOXOOOXXOO\", then there's three maximal consecutive \"O\"s block \"OO\", \"OOO\", \"OO\", so your score will be 2^2 + 3^2 + 2^2 = 17. If there are no correct clicks in a play then the score for the play equals to 0.\n\nYou know that the probability to click the i-th (1 \u2264 i \u2264 n) click correctly is p_{i}. In other words, the i-th character in the play sequence has p_{i} probability to be \"O\", 1 - p_{i} to be \"X\". You task is to calculate the expected score for your play.\n\n\n-----Input-----\n\nThe first line contains an integer n (1 \u2264 n \u2264 10^5) \u2014 the number of clicks. The second line contains n space-separated real numbers p_1, p_2, ..., p_{n} (0 \u2264 p_{i} \u2264 1).\n\nThere will be at most six digits after the decimal point in the given p_{i}.\n\n\n-----Output-----\n\nPrint a single real number \u2014 the expected score for your play. Your answer will be considered correct if its absolute or relative error does not exceed 10^{ - 6}.\n\n\n-----Examples-----\nInput\n3\n0.5 0.5 0.5\n\nOutput\n2.750000000000000\n\nInput\n4\n0.7 0.2 0.1 0.9\n\nOutput\n2.489200000000000\n\nInput\n5\n1 1 1 1 1\n\nOutput\n25.000000000000000\n\n\n\n-----Note-----\n\nFor the first example. There are 8 possible outcomes. Each has a probability of 0.125.  \"OOO\"  \u2192  3^2 = 9;  \"OOX\"  \u2192  2^2 = 4;  \"OXO\"  \u2192  1^2 + 1^2 = 2;  \"OXX\"  \u2192  1^2 = 1;  \"XOO\"  \u2192  2^2 = 4;  \"XOX\"  \u2192  1^2 = 1;  \"XXO\"  \u2192  1^2 = 1;  \"XXX\"  \u2192  0. \n\nSo the expected score is $\\frac{9 + 4 + 2 + 1 + 4 + 1 + 1}{8} = 2.75$.", "raw_solution": "def apps_run1(n, read):\n    p = []\n    for x in read.split():\n        p.append((float)(x))\n    v = 0.0\n    l = 0.0\n    for item in p:\n        v = v*(1-item) + item*(v + 2*l + 1)\n        l = (l + 1)*item\n    return v", "raw_test_input": ["assert apps_run1('3', '0.5 0.5 0.5') == 2.750000000000000", "assert apps_run1('4', '0.7 0.2 0.1 0.9') == 2.489200000000000", "assert apps_run1('5', '1 1 1 1 1') == 25.000000000000000", "assert apps_run1('10', '0.684846 0.156794 0.153696 0.714526 0.281868 0.628256 0.745339 0.123854 0.748936 0.856333') == 10.72177881447123", "assert apps_run1('10', '0.684488 0.834971 0.834886 0.643646 0.162710 0.119851 0.659401 0.743950 0.220986 0.839665') == 15.401334613504346", "assert apps_run1('10', '0.684416 0.170607 0.491124 0.469470 0.458879 0.658170 0.322214 0.707969 0.275396 0.836331') == 11.404416796704295", "assert apps_run1('10', '0.684631 0.563700 0.722410 0.191998 0.370373 0.643213 0.533776 0.815911 0.112166 0.846332') == 12.88892900895716", "assert apps_run1('10', '0.684559 0.699336 0.378648 0.817822 0.666542 0.381532 0.196589 0.779930 0.166576 0.842998') == 14.036752909261953", "assert apps_run1('10', '0.999453 0.999188 0.998398 0.999609 0.999113 0.999426 0.998026 0.999244 0.998842 0.999807') == 99.59073862289468", "assert apps_run1('10', '0.000733 0.000769 0.000772 0.000595 0.000930 0.000395 0.000596 0.000584 0.000496 0.000905') == 0.006782723279202994", "assert apps_run1('30', '0.684344 0.306242 0.147362 0.295294 0.755047 0.396489 0.785026 0.671988 0.329806 0.832998 0.106621 0.452498 0.125067 0.838169 0.869683 0.740625 0.449522 0.751800 0.272185 0.865612 0.272859 0.416162 0.339155 0.478441 0.401937 0.626148 0.305498 0.716523 0.734322 0.751335') == 44.57674504741172", "assert apps_run1('30', '0.684273 0.441878 0.603600 0.121118 0.251216 0.134808 0.447839 0.636007 0.384215 0.829664 0.204397 0.627395 0.243031 0.424765 0.525065 0.585464 0.893844 0.377080 0.246110 0.356372 0.836239 0.670558 0.546182 0.310427 0.343287 0.868653 0.269521 0.432699 0.288850 0.848816') == 36.47816270616331", "assert apps_run1('30', '0.683914 0.320055 0.484789 0.850238 0.132058 0.426403 0.361901 0.456102 0.656265 0.812996 0.693279 0.701878 0.832853 0.757747 0.401974 0.609660 0.715452 0.103482 0.115733 0.210174 0.453140 0.342538 0.781317 0.270359 0.850037 0.481183 0.889637 0.613578 0.461492 0.536221') == 53.227679791398110", "assert apps_run1('30', '0.683843 0.455691 0.141027 0.676062 0.428227 0.164722 0.824714 0.420121 0.710675 0.809662 0.791055 0.876775 0.150817 0.344344 0.857356 0.454499 0.359774 0.528762 0.889658 0.500934 0.216520 0.596934 0.188344 0.102346 0.791387 0.723689 0.853660 0.329754 0.816020 0.633702') == 49.05487257530848", "assert apps_run1('30', '0.684058 0.848784 0.372313 0.398590 0.339721 0.149765 0.236276 0.528064 0.547445 0.819663 0.497726 0.352085 0.596924 0.784554 0.291210 0.119982 0.626809 0.852921 0.167884 0.428653 0.126380 0.633746 0.367263 0.606386 0.167337 0.796171 0.161591 0.381226 0.552435 0.341259') == 33.12561538331047", "assert apps_run1('30', '0.999453 0.998210 0.999812 0.998309 0.999333 0.999463 0.999490 0.998975 0.999248 0.999782 0.999233 0.999062 0.999530 0.998674 0.999608 0.999654 0.998426 0.998941 0.998104 0.999541 0.999467 0.999961 0.999180 0.998842 0.998022 0.998345 0.998064 0.999984 0.998017 0.998843') == 891.2190529525873", "assert apps_run1('30', '0.000735 0.000533 0.000518 0.000044 0.000677 0.000571 0.000138 0.000707 0.000793 0.000018 0.000326 0.000635 0.000789 0.000298 0.000445 0.000077 0.000226 0.000128 0.000933 0.000961 0.000726 0.000405 0.000610 0.000102 0.000990 0.000989 0.000254 0.000580 0.000053 0.000142') == 0.014416714297574856"], "new_problem": "In a competitive gaming tournament, players participate in multiple rounds of a game similar to Osu! Each round is represented by a sequence of clicks, where each click can be correct ('O') or incorrect ('X'). The probability of each click being correct is given. The score for each round is calculated as the sum of the squares of the lengths of consecutive 'O' blocks. Your task is to calculate the expected total score for all rounds in the tournament. This requires calculating the expected score for each round and summing them up.", "new_solution": "def expected_score_for_play(n, probabilities):\n    v = 0.0\n    l = 0.0\n    for item in probabilities:\n        v = v * (1 - item) + item * (v + 2 * l + 1)\n        l = (l + 1) * item\n    return v\n\n\ndef apps_run2(m, games):\n    total_score = 0.0\n    for game in games:\n        n, probabilities = game[0], game[1]\n        total_score += expected_score_for_play(n, probabilities)\n    return total_score\n", "input_format": "The first line contains an integer m (1 \u2264 m \u2264 100) \u2014 the number of games. Each of the next m lines contains an integer n (1 \u2264 n \u2264 10^5) followed by n space-separated real numbers p_1, p_2, ..., p_{n} (0 \u2264 p_{i} \u2264 1) representing the number of clicks and the probability of each click being correct for that game.", "output_format": "Print a single real number \u2014 the expected total score for all games. Your answer will be considered correct if its absolute or relative error does not exceed 10^{ - 6}.", "test_input": ["assert abs(apps_run2(2, [(3, [0.5, 0.5, 0.5]), (4, [0.7, 0.2, 0.1, 0.9])]) - 5.2392) < 1e-6", "assert abs(apps_run2(1, [(5, [1, 1, 1, 1, 1])]) - 25.0) < 1e-6", "assert abs(apps_run2(3, [(3, [0.5, 0.5, 0.5]), (4, [0.7, 0.2, 0.1, 0.9]), (5, [0.1, 0.2, 0.3, 0.4, 0.5])]) - 7.7504000) < 1e-6", "assert abs(apps_run2(2, [(2, [0.9, 0.9]), (3, [0.1, 0.1, 0.1])]) - 3.762) < 1e-6", "assert abs(apps_run2(1, [(6, [0.5, 0.5, 0.5, 0.5, 0.5, 0.5])]) - 7.03125) < 1e-6"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "APPS/2024-2", "raw_problem": "You're playing a game called Osu! Here's a simplified version of it. There are n clicks in a game. For each click there are two outcomes: correct or bad. Let us denote correct as \"O\", bad as \"X\", then the whole play can be encoded as a sequence of n characters \"O\" and \"X\".\n\nUsing the play sequence you can calculate the score for the play as follows: for every maximal consecutive \"O\"s block, add the square of its length (the number of characters \"O\") to the score. For example, if your play can be encoded as \"OOXOOOXXOO\", then there's three maximal consecutive \"O\"s block \"OO\", \"OOO\", \"OO\", so your score will be 2^2 + 3^2 + 2^2 = 17. If there are no correct clicks in a play then the score for the play equals to 0.\n\nYou know that the probability to click the i-th (1 \u2264 i \u2264 n) click correctly is p_{i}. In other words, the i-th character in the play sequence has p_{i} probability to be \"O\", 1 - p_{i} to be \"X\". You task is to calculate the expected score for your play.\n\n\n-----Input-----\n\nThe first line contains an integer n (1 \u2264 n \u2264 10^5) \u2014 the number of clicks. The second line contains n space-separated real numbers p_1, p_2, ..., p_{n} (0 \u2264 p_{i} \u2264 1).\n\nThere will be at most six digits after the decimal point in the given p_{i}.\n\n\n-----Output-----\n\nPrint a single real number \u2014 the expected score for your play. Your answer will be considered correct if its absolute or relative error does not exceed 10^{ - 6}.\n\n\n-----Examples-----\nInput\n3\n0.5 0.5 0.5\n\nOutput\n2.750000000000000\n\nInput\n4\n0.7 0.2 0.1 0.9\n\nOutput\n2.489200000000000\n\nInput\n5\n1 1 1 1 1\n\nOutput\n25.000000000000000\n\n\n\n-----Note-----\n\nFor the first example. There are 8 possible outcomes. Each has a probability of 0.125.  \"OOO\"  \u2192  3^2 = 9;  \"OOX\"  \u2192  2^2 = 4;  \"OXO\"  \u2192  1^2 + 1^2 = 2;  \"OXX\"  \u2192  1^2 = 1;  \"XOO\"  \u2192  2^2 = 4;  \"XOX\"  \u2192  1^2 = 1;  \"XXO\"  \u2192  1^2 = 1;  \"XXX\"  \u2192  0. \n\nSo the expected score is $\\frac{9 + 4 + 2 + 1 + 4 + 1 + 1}{8} = 2.75$.", "raw_solution": "def apps_run1(n, read):\n    p = []\n    for x in read.split():\n        p.append((float)(x))\n    v = 0.0\n    l = 0.0\n    for item in p:\n        v = v*(1-item) + item*(v + 2*l + 1)\n        l = (l + 1)*item\n    return v", "raw_test_input": ["assert apps_run1('3', '0.5 0.5 0.5') == 2.750000000000000", "assert apps_run1('4', '0.7 0.2 0.1 0.9') == 2.489200000000000", "assert apps_run1('5', '1 1 1 1 1') == 25.000000000000000", "assert apps_run1('10', '0.684846 0.156794 0.153696 0.714526 0.281868 0.628256 0.745339 0.123854 0.748936 0.856333') == 10.72177881447123", "assert apps_run1('10', '0.684488 0.834971 0.834886 0.643646 0.162710 0.119851 0.659401 0.743950 0.220986 0.839665') == 15.401334613504346", "assert apps_run1('10', '0.684416 0.170607 0.491124 0.469470 0.458879 0.658170 0.322214 0.707969 0.275396 0.836331') == 11.404416796704295", "assert apps_run1('10', '0.684631 0.563700 0.722410 0.191998 0.370373 0.643213 0.533776 0.815911 0.112166 0.846332') == 12.88892900895716", "assert apps_run1('10', '0.684559 0.699336 0.378648 0.817822 0.666542 0.381532 0.196589 0.779930 0.166576 0.842998') == 14.036752909261953", "assert apps_run1('10', '0.999453 0.999188 0.998398 0.999609 0.999113 0.999426 0.998026 0.999244 0.998842 0.999807') == 99.59073862289468", "assert apps_run1('10', '0.000733 0.000769 0.000772 0.000595 0.000930 0.000395 0.000596 0.000584 0.000496 0.000905') == 0.006782723279202994", "assert apps_run1('30', '0.684344 0.306242 0.147362 0.295294 0.755047 0.396489 0.785026 0.671988 0.329806 0.832998 0.106621 0.452498 0.125067 0.838169 0.869683 0.740625 0.449522 0.751800 0.272185 0.865612 0.272859 0.416162 0.339155 0.478441 0.401937 0.626148 0.305498 0.716523 0.734322 0.751335') == 44.57674504741172", "assert apps_run1('30', '0.684273 0.441878 0.603600 0.121118 0.251216 0.134808 0.447839 0.636007 0.384215 0.829664 0.204397 0.627395 0.243031 0.424765 0.525065 0.585464 0.893844 0.377080 0.246110 0.356372 0.836239 0.670558 0.546182 0.310427 0.343287 0.868653 0.269521 0.432699 0.288850 0.848816') == 36.47816270616331", "assert apps_run1('30', '0.683914 0.320055 0.484789 0.850238 0.132058 0.426403 0.361901 0.456102 0.656265 0.812996 0.693279 0.701878 0.832853 0.757747 0.401974 0.609660 0.715452 0.103482 0.115733 0.210174 0.453140 0.342538 0.781317 0.270359 0.850037 0.481183 0.889637 0.613578 0.461492 0.536221') == 53.227679791398110", "assert apps_run1('30', '0.683843 0.455691 0.141027 0.676062 0.428227 0.164722 0.824714 0.420121 0.710675 0.809662 0.791055 0.876775 0.150817 0.344344 0.857356 0.454499 0.359774 0.528762 0.889658 0.500934 0.216520 0.596934 0.188344 0.102346 0.791387 0.723689 0.853660 0.329754 0.816020 0.633702') == 49.05487257530848", "assert apps_run1('30', '0.684058 0.848784 0.372313 0.398590 0.339721 0.149765 0.236276 0.528064 0.547445 0.819663 0.497726 0.352085 0.596924 0.784554 0.291210 0.119982 0.626809 0.852921 0.167884 0.428653 0.126380 0.633746 0.367263 0.606386 0.167337 0.796171 0.161591 0.381226 0.552435 0.341259') == 33.12561538331047", "assert apps_run1('30', '0.999453 0.998210 0.999812 0.998309 0.999333 0.999463 0.999490 0.998975 0.999248 0.999782 0.999233 0.999062 0.999530 0.998674 0.999608 0.999654 0.998426 0.998941 0.998104 0.999541 0.999467 0.999961 0.999180 0.998842 0.998022 0.998345 0.998064 0.999984 0.998017 0.998843') == 891.2190529525873", "assert apps_run1('30', '0.000735 0.000533 0.000518 0.000044 0.000677 0.000571 0.000138 0.000707 0.000793 0.000018 0.000326 0.000635 0.000789 0.000298 0.000445 0.000077 0.000226 0.000128 0.000933 0.000961 0.000726 0.000405 0.000610 0.000102 0.000990 0.000989 0.000254 0.000580 0.000053 0.000142') == 0.014416714297574856"], "new_problem": "You're playing a game called Osu! Here's a simplified version of it. There are n clicks in a game. For each click, there are two outcomes: correct or bad. Let us denote correct as 'O', bad as 'X', then the whole play can be encoded as a sequence of n characters 'O' and 'X'. Using the play sequence, you can calculate the score for the play as follows: for every maximal consecutive 'O's block, add the square of its length (the number of characters 'O') to the score. You know that the probability to click the i-th (1 \u2264 i \u2264 n) click correctly is p_{i}. Your task is to calculate the expected score for your play. Additionally, you can request a detailed output that provides the expected score for each maximal consecutive 'O's block.", "new_solution": "def apps_run2(n: int, probabilities: list[float], mode: str = None) -> float:\n    v = 0.0\n    l = 0.0\n    detailed_scores = []\n    for item in probabilities:\n        v = v * (1 - item) + item * (v + 2 * l + 1)\n        l = (l + 1) * item\n        if mode == 'detailed':\n            detailed_scores.append(l)\n    if mode == 'detailed':\n        print('Detailed scores for each block:', detailed_scores)\n    return v\n\n# Original function for backward compatibility\napps_run2.__annotations__ = {'n': int, 'probabilities': list, 'mode': str, 'return': float}", "input_format": "The first line contains an integer n (1 \u2264 n \u2264 10^5) \u2014 the number of clicks. The second line contains n space-separated real numbers p_1, p_2, ..., p_{n} (0 \u2264 p_{i} \u2264 1). Optionally, a third line can contain a string 'detailed' to request detailed output.", "output_format": "Print a single real number \u2014 the expected score for your play. If 'detailed' is specified, also print the expected score for each maximal consecutive 'O's block.", "test_input": ["assert abs(apps_run2(3, [0.5, 0.5, 0.5]) - 2.75) < 1e-6", "assert abs(apps_run2(4, [0.7, 0.2, 0.1, 0.9]) - 2.4892) < 1e-6", "assert abs(apps_run2(5, [1, 1, 1, 1, 1]) - 25.0) < 1e-6", "assert abs(apps_run2(3, [0.5, 0.5, 0.5], 'detailed') - 2.75) < 1e-6", "assert abs(apps_run2(4, [0.7, 0.2, 0.1, 0.9], 'detailed') - 2.4892) < 1e-6"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "APPS/2024-3", "raw_problem": "You're playing a game called Osu! Here's a simplified version of it. There are n clicks in a game. For each click there are two outcomes: correct or bad. Let us denote correct as \"O\", bad as \"X\", then the whole play can be encoded as a sequence of n characters \"O\" and \"X\".\n\nUsing the play sequence you can calculate the score for the play as follows: for every maximal consecutive \"O\"s block, add the square of its length (the number of characters \"O\") to the score. For example, if your play can be encoded as \"OOXOOOXXOO\", then there's three maximal consecutive \"O\"s block \"OO\", \"OOO\", \"OO\", so your score will be 2^2 + 3^2 + 2^2 = 17. If there are no correct clicks in a play then the score for the play equals to 0.\n\nYou know that the probability to click the i-th (1 \u2264 i \u2264 n) click correctly is p_{i}. In other words, the i-th character in the play sequence has p_{i} probability to be \"O\", 1 - p_{i} to be \"X\". You task is to calculate the expected score for your play.\n\n\n-----Input-----\n\nThe first line contains an integer n (1 \u2264 n \u2264 10^5) \u2014 the number of clicks. The second line contains n space-separated real numbers p_1, p_2, ..., p_{n} (0 \u2264 p_{i} \u2264 1).\n\nThere will be at most six digits after the decimal point in the given p_{i}.\n\n\n-----Output-----\n\nPrint a single real number \u2014 the expected score for your play. Your answer will be considered correct if its absolute or relative error does not exceed 10^{ - 6}.\n\n\n-----Examples-----\nInput\n3\n0.5 0.5 0.5\n\nOutput\n2.750000000000000\n\nInput\n4\n0.7 0.2 0.1 0.9\n\nOutput\n2.489200000000000\n\nInput\n5\n1 1 1 1 1\n\nOutput\n25.000000000000000\n\n\n\n-----Note-----\n\nFor the first example. There are 8 possible outcomes. Each has a probability of 0.125.  \"OOO\"  \u2192  3^2 = 9;  \"OOX\"  \u2192  2^2 = 4;  \"OXO\"  \u2192  1^2 + 1^2 = 2;  \"OXX\"  \u2192  1^2 = 1;  \"XOO\"  \u2192  2^2 = 4;  \"XOX\"  \u2192  1^2 = 1;  \"XXO\"  \u2192  1^2 = 1;  \"XXX\"  \u2192  0. \n\nSo the expected score is $\\frac{9 + 4 + 2 + 1 + 4 + 1 + 1}{8} = 2.75$.", "raw_solution": "def apps_run1(n, read):\n    p = []\n    for x in read.split():\n        p.append((float)(x))\n    \n    v = 0.0\n    l = 0.0\n    for item in p:\n        v = v*(1-item) + item*(v + 2*l + 1)\n        l = (l + 1)*item\n    return v", "raw_test_input": ["assert apps_run1('3', '0.5 0.5 0.5') == 2.750000000000000", "assert apps_run1('4', '0.7 0.2 0.1 0.9') == 2.489200000000000", "assert apps_run1('5', '1 1 1 1 1') == 25.000000000000000", "assert apps_run1('10', '0.684846 0.156794 0.153696 0.714526 0.281868 0.628256 0.745339 0.123854 0.748936 0.856333') == 10.72177881447123", "assert apps_run1('10', '0.684488 0.834971 0.834886 0.643646 0.162710 0.119851 0.659401 0.743950 0.220986 0.839665') == 15.401334613504346", "assert apps_run1('10', '0.684416 0.170607 0.491124 0.469470 0.458879 0.658170 0.322214 0.707969 0.275396 0.836331') == 11.404416796704295", "assert apps_run1('10', '0.684631 0.563700 0.722410 0.191998 0.370373 0.643213 0.533776 0.815911 0.112166 0.846332') == 12.88892900895716", "assert apps_run1('10', '0.684559 0.699336 0.378648 0.817822 0.666542 0.381532 0.196589 0.779930 0.166576 0.842998') == 14.036752909261953", "assert apps_run1('10', '0.999453 0.999188 0.998398 0.999609 0.999113 0.999426 0.998026 0.999244 0.998842 0.999807') == 99.59073862289468", "assert apps_run1('10', '0.000733 0.000769 0.000772 0.000595 0.000930 0.000395 0.000596 0.000584 0.000496 0.000905') == 0.006782723279202994", "assert apps_run1('30', '0.684344 0.306242 0.147362 0.295294 0.755047 0.396489 0.785026 0.671988 0.329806 0.832998 0.106621 0.452498 0.125067 0.838169 0.869683 0.740625 0.449522 0.751800 0.272185 0.865612 0.272859 0.416162 0.339155 0.478441 0.401937 0.626148 0.305498 0.716523 0.734322 0.751335') == 44.57674504741172", "assert apps_run1('30', '0.684273 0.441878 0.603600 0.121118 0.251216 0.134808 0.447839 0.636007 0.384215 0.829664 0.204397 0.627395 0.243031 0.424765 0.525065 0.585464 0.893844 0.377080 0.246110 0.356372 0.836239 0.670558 0.546182 0.310427 0.343287 0.868653 0.269521 0.432699 0.288850 0.848816') == 36.47816270616331", "assert apps_run1('30', '0.683914 0.320055 0.484789 0.850238 0.132058 0.426403 0.361901 0.456102 0.656265 0.812996 0.693279 0.701878 0.832853 0.757747 0.401974 0.609660 0.715452 0.103482 0.115733 0.210174 0.453140 0.342538 0.781317 0.270359 0.850037 0.481183 0.889637 0.613578 0.461492 0.536221') == 53.227679791398110", "assert apps_run1('30', '0.683843 0.455691 0.141027 0.676062 0.428227 0.164722 0.824714 0.420121 0.710675 0.809662 0.791055 0.876775 0.150817 0.344344 0.857356 0.454499 0.359774 0.528762 0.889658 0.500934 0.216520 0.596934 0.188344 0.102346 0.791387 0.723689 0.853660 0.329754 0.816020 0.633702') == 49.05487257530848", "assert apps_run1('30', '0.684058 0.848784 0.372313 0.398590 0.339721 0.149765 0.236276 0.528064 0.547445 0.819663 0.497726 0.352085 0.596924 0.784554 0.291210 0.119982 0.626809 0.852921 0.167884 0.428653 0.126380 0.633746 0.367263 0.606386 0.167337 0.796171 0.161591 0.381226 0.552435 0.341259') == 33.12561538331047", "assert apps_run1('30', '0.999453 0.998210 0.999812 0.998309 0.999333 0.999463 0.999490 0.998975 0.999248 0.999782 0.999233 0.999062 0.999530 0.998674 0.999608 0.999654 0.998426 0.998941 0.998104 0.999541 0.999467 0.999961 0.999180 0.998842 0.998022 0.998345 0.998064 0.999984 0.998017 0.998843') == 891.2190529525873", "assert apps_run1('30', '0.000735 0.000533 0.000518 0.000044 0.000677 0.000571 0.000138 0.000707 0.000793 0.000018 0.000326 0.000635 0.000789 0.000298 0.000445 0.000077 0.000226 0.000128 0.000933 0.000961 0.000726 0.000405 0.000610 0.000102 0.000990 0.000989 0.000254 0.000580 0.000053 0.000142') == 0.014416714297574856"], "new_problem": "You are playing a more complex version of the game Osu! where you need to calculate the expected score for specific ranges of clicks. The game is still encoded as a sequence of 'O' and 'X', but now you are given multiple queries, each asking for the expected score of a subrange of the play sequence. You need to efficiently handle these queries using a suitable data structure. The probability to click the i-th click correctly is p_{i}. Your task is to calculate the expected score for each query range.", "new_solution": "from typing import List, Tuple\n\ndef apps_run2(n: int, probabilities: List[float], queries: List[Tuple[int, int]]) -> List[float]:\n    prefix_v = [0.0] * (n + 1)\n    prefix_l = [0.0] * (n + 1)\n    \n    for i in range(1, n + 1):\n        item = probabilities[i - 1]\n        prefix_v[i] = prefix_v[i - 1] * (1 - item) + item * (prefix_v[i - 1] + 2 * prefix_l[i - 1] + 1)\n        prefix_l[i] = (prefix_l[i - 1] + 1) * item\n    \n    results = []\n    for l, r in queries:\n        v_r = prefix_v[r]\n        v_l = prefix_v[l - 1]\n        l_r = prefix_l[r]\n        l_l = prefix_l[l - 1]\n        expected_score = v_r - v_l * (1 - probabilities[l - 1]) - probabilities[l - 1] * (v_l + 2 * l_l + 1)\n        results.append(expected_score)\n    \n    return results", "input_format": "The first line contains an integer n (1 \u2264 n \u2264 10^5) \u2014 the number of clicks. The second line contains n space-separated real numbers p_1, p_2, ..., p_{n} (0 \u2264 p_{i} \u2264 1). The third line contains an integer m (1 \u2264 m \u2264 10^5) \u2014 the number of queries. Each of the next m lines contains two integers l and r (1 \u2264 l \u2264 r \u2264 n) representing a range of clicks.", "output_format": "Print m lines, each containing a single real number \u2014 the expected score for the play in the range [l, r]. Your answer will be considered correct if its absolute or relative error does not exceed 10^{-6}.", "test_input": ["assert apps_run2(3, [0.5, 0.5, 0.5], [(1, 3), (2, 3)]) == [2.25, 1.25]", "assert apps_run2(4, [0.7, 0.2, 0.1, 0.9], [(1, 4), (2, 4)]) == [1.7892, 1.3091999999999997]", "assert apps_run2(5, [1, 1, 1, 1, 1], [(1, 5), (3, 5)]) == [24.0, 16.0]", "assert apps_run2(5, [0.1, 0.2, 0.3, 0.4, 0.5], [(1, 5), (1, 3)]) == [2.4112, 0.672]", "assert apps_run2(6, [0.6, 0.7, 0.8, 0.9, 0.5, 0.4], [(1, 6), (3, 6)]) ==[12.78176, 8.64976]"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "APPS/2024-4", "raw_problem": "You're playing a game called Osu! Here's a simplified version of it. There are n clicks in a game. For each click there are two outcomes: correct or bad. Let us denote correct as \"O\", bad as \"X\", then the whole play can be encoded as a sequence of n characters \"O\" and \"X\".\n\nUsing the play sequence you can calculate the score for the play as follows: for every maximal consecutive \"O\"s block, add the square of its length (the number of characters \"O\") to the score. For example, if your play can be encoded as \"OOXOOOXXOO\", then there's three maximal consecutive \"O\"s block \"OO\", \"OOO\", \"OO\", so your score will be 2^2 + 3^2 + 2^2 = 17. If there are no correct clicks in a play then the score for the play equals to 0.\n\nYou know that the probability to click the i-th (1 \u2264 i \u2264 n) click correctly is p_{i}. In other words, the i-th character in the play sequence has p_{i} probability to be \"O\", 1 - p_{i} to be \"X\". You task is to calculate the expected score for your play.\n\n\n-----Input-----\n\nThe first line contains an integer n (1 \u2264 n \u2264 10^5) \u2014 the number of clicks. The second line contains n space-separated real numbers p_1, p_2, ..., p_{n} (0 \u2264 p_{i} \u2264 1).\n\nThere will be at most six digits after the decimal point in the given p_{i}.\n\n\n-----Output-----\n\nPrint a single real number \u2014 the expected score for your play. Your answer will be considered correct if its absolute or relative error does not exceed 10^{ - 6}.\n\n\n-----Examples-----\nInput\n3\n0.5 0.5 0.5\n\nOutput\n2.750000000000000\n\nInput\n4\n0.7 0.2 0.1 0.9\n\nOutput\n2.489200000000000\n\nInput\n5\n1 1 1 1 1\n\nOutput\n25.000000000000000\n\n\n\n-----Note-----\n\nFor the first example. There are 8 possible outcomes. Each has a probability of 0.125.  \"OOO\"  \u2192  3^2 = 9;  \"OOX\"  \u2192  2^2 = 4;  \"OXO\"  \u2192  1^2 + 1^2 = 2;  \"OXX\"  \u2192  1^2 = 1;  \"XOO\"  \u2192  2^2 = 4;  \"XOX\"  \u2192  1^2 = 1;  \"XXO\"  \u2192  1^2 = 1;  \"XXX\"  \u2192  0. \n\nSo the expected score is $\\frac{9 + 4 + 2 + 1 + 4 + 1 + 1}{8} = 2.75$.", "raw_solution": "def apps_run1(n, read):\n    p = []\n    for x in read.split():\n        p.append((float)(x))\n    v = 0.0\n    l = 0.0\n    for item in p:\n        v = v*(1-item) + item*(v + 2*l + 1)\n        l = (l + 1)*item\n    return v", "raw_test_input": ["assert apps_run1('3', '0.5 0.5 0.5') == 2.750000000000000", "assert apps_run1('4', '0.7 0.2 0.1 0.9') == 2.489200000000000", "assert apps_run1('5', '1 1 1 1 1') == 25.000000000000000"], "new_problem": "You are developing a game analytics tool for a game similar to Osu! where players' performance is recorded as a sequence of clicks. Each click can be correct ('O') or incorrect ('X'). The probability of a correct click is given for each click. Your task is to calculate the expected score for a sequence of clicks. However, you must handle the following errors: 1. InputError: Raised if the number of probabilities does not match the number of clicks. 2. ProbabilityValueError: Raised if any probability is not between 0 and 1 inclusive. 3. CalculationError: Raised if any unexpected error occurs during the score calculation. Implement error handling to manage these scenarios and ensure the program provides meaningful error messages.", "new_solution": "class InputError(Exception):\n    pass\n\nclass ProbabilityValueError(Exception):\n    pass\n\nclass CalculationError(Exception):\n    pass\n\ndef apps_run2(n: int, probabilities: list[float]) -> float:\n    if len(probabilities) != n:\n        raise InputError(\"The number of probabilities does not match the number of clicks.\")\n    \n    for p in probabilities:\n        if not (0 <= p <= 1):\n            raise ProbabilityValueError(f\"Probability {p} is out of bounds. Must be between 0 and 1.\")\n\n    try:\n        v = 0.0\n        l = 0.0\n        for item in probabilities:\n            v = v * (1 - item) + item * (v + 2 * l + 1)\n            l = (l + 1) * item\n        return v\n    except Exception as e:\n        raise CalculationError(\"An error occurred during score calculation.\") from e", "input_format": "The first line contains an integer n (1 \u2264 n \u2264 10^5) \u2014 the number of clicks. The second line contains n space-separated real numbers p_1, p_2, ..., p_{n} (0 \u2264 p_{i} \u2264 1).", "output_format": "Print a single real number \u2014 the expected score for your play. Your answer will be considered correct if its absolute or relative error does not exceed 10^{ - 6}.", "test_input": ["assert apps_run2(3, [0.5, 0.5, 0.5]) == 2.75", "assert apps_run2(4, [0.7, 0.2, 0.1, 0.9]) == 2.4892", "assert apps_run2(5, [1, 1, 1, 1, 1]) == 25.0", "try:\n    apps_run2(3, [0.5, 0.5])\nexcept InputError as e:\n    assert str(e) == \"The number of probabilities does not match the number of clicks.\"", "try:\n    apps_run2(3, [0.5, 1.2, 0.5])\nexcept ProbabilityValueError as e:\n    assert str(e) == \"Probability 1.2 is out of bounds. Must be between 0 and 1.\""], "requirement_type": "PROMPT_ERROR_HANDLING"}
{"task_id": "APPS/2025-1", "raw_problem": "Vasya and Petya are playing a simple game. Vasya thought of number x between 1 and n, and Petya tries to guess the number.\n\nPetya can ask questions like: \"Is the unknown number divisible by number y?\".\n\nThe game is played by the following rules: first Petya asks all the questions that interest him (also, he can ask no questions), and then Vasya responds to each question with a 'yes' or a 'no'. After receiving all the answers Petya should determine the number that Vasya thought of.\n\nUnfortunately, Petya is not familiar with the number theory. Help him find the minimum number of questions he should ask to make a guaranteed guess of Vasya's number, and the numbers y_{i}, he should ask the questions about.\n\n\n-----Input-----\n\nA single line contains number n (1 \u2264 n \u2264 10^3).\n\n\n-----Output-----\n\nPrint the length of the sequence of questions k (0 \u2264 k \u2264 n), followed by k numbers \u2014 the questions y_{i} (1 \u2264 y_{i} \u2264 n).\n\nIf there are several correct sequences of questions of the minimum length, you are allowed to print any of them.\n\n\n-----Examples-----\nInput\n4\n\nOutput\n3\n2 4 3 \n\nInput\n6\n\nOutput\n4\n2 4 3 5 \n\n\n\n-----Note-----\n\nThe sequence from the answer to the first sample test is actually correct.\n\nIf the unknown number is not divisible by one of the sequence numbers, it is equal to 1.\n\nIf the unknown number is divisible by 4, it is 4.\n\nIf the unknown number is divisible by 3, then the unknown number is 3.\n\nOtherwise, it is equal to 2. Therefore, the sequence of questions allows you to guess the unknown number. It can be shown that there is no correct sequence of questions of length 2 or shorter.", "raw_solution": "def apps_run1(n):\n    result = []\n    for i in range(2, n + 1):\n        j = 2\n        while j * j <= i:\n            if i % j == 0:\n                break\n            j += 1\n        else:\n            j = i\n            while j <= n:\n                result.append(j)\n                j *= i\n    return len(result), result\n", "raw_test_input": ["assert apps_run1(4) == (3, [2, 4, 3])", "assert apps_run1(6) == (4, [2, 4, 3, 5])", "assert apps_run1(1) == (0, [])", "assert apps_run1(15) == (9, [2, 4, 8, 3, 9, 5, 7, 11, 13])", "assert apps_run1(19) == (12, [2, 4, 8, 16, 3, 9, 5, 7, 11, 13, 17, 19])", "assert apps_run1(20) == (12, [2, 4, 8, 16, 3, 9, 5, 7, 11, 13, 17, 19])", "assert apps_run1(37) == (19, [2, 4, 8, 16, 32, 3, 9, 27, 5, 25, 7, 11, 13, 17, 19, 23, 29, 31, 37])", "assert apps_run1(211) == (61, [2, 4, 8, 16, 32, 64, 128, 3, 9, 27, 81, 5, 25, 125, 7, 49, 11, 121, 13, 169, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211])", "assert apps_run1(557) == (123, [2, 4, 8, 16, 32, 64, 128, 256, 512, 3, 9, 27, 81, 243, 5, 25, 125, 7, 49, 343, 11, 121, 13, 169, 17, 289, 19, 361, 23, 529, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557])", "assert apps_run1(289) == (78, [2, 4, 8, 16, 32, 64, 128, 256, 3, 9, 27, 81, 243, 5, 25, 125, 7, 49, 11, 121, 13, 169, 17, 289, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283])", "assert apps_run1(400) == (97, [2, 4, 8, 16, 32, 64, 128, 256, 3, 9, 27, 81, 243, 5, 25, 125, 7, 49, 343, 11, 121, 13, 169, 17, 289, 19, 361, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397])", "assert apps_run1(625) == (136, [2, 4, 8, 16, 32, 64, 128, 256, 512, 3, 9, 27, 81, 243, 5, 25, 125, 625, 7, 49, 343, 11, 121, 13, 169, 17, 289, 19, 361, 23, 529, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619])", "assert apps_run1(31) == (17, [2, 4, 8, 16, 3, 9, 27, 5, 25, 7, 11, 13, 17, 19, 23, 29, 31])", "assert apps_run1(44) == (21, [2, 4, 8, 16, 32, 3, 9, 27, 5, 25, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43])", "assert apps_run1(160) == (50, [2, 4, 8, 16, 32, 64, 128, 3, 9, 27, 81, 5, 25, 125, 7, 49, 11, 121, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157])", "assert apps_run1(322) == (83, [2, 4, 8, 16, 32, 64, 128, 256, 3, 9, 27, 81, 243, 5, 25, 125, 7, 49, 11, 121, 13, 169, 17, 289, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317])", "assert apps_run1(30) == (16, [2, 4, 8, 16, 3, 9, 27, 5, 25, 7, 11, 13, 17, 19, 23, 29])"], "new_problem": "Vasya and Petya are playing an extended version of their number guessing game. Vasya thinks of a number x between 1 and n, and Petya tries to guess the number. Petya can ask questions like: 'Is the unknown number divisible by number y?'. The game is played by the following rules: first Petya asks all the questions that interest him (also, he can ask no questions), and then Vasya responds to each question with a 'yes' or a 'no'. After receiving all the answers, Petya should determine the number that Vasya thought of. However, this time, Petya wants to play m different games, each with a different range of numbers. Help Petya find the minimum number of questions he should ask for each game to make a guaranteed guess of Vasya's number, and the numbers y_{i}, he should ask the questions about.", "new_solution": "def apps_run2(n):\n    result = []\n    for i in range(2, n + 1):\n        j = 2\n        while j * j <= i:\n            if i % j == 0:\n                break\n            j += 1\n        else:\n            j = i\n            while j <= n:\n                result.append(j)\n                j *= i\n    return result\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split()\n    n = int(data[0])\n    m = int(data[1])\n    results = []\n    for _ in range(m):\n        questions = apps_run2(n)\n        results.append((len(questions), questions))\n    for result in results:\n        print(result[0])\n        print(' '.join(map(str, result[1])))", "input_format": "A single line containing two integers n (1 \u2264 n \u2264 10^3) and m (1 \u2264 m \u2264 10^3), where n is the range of numbers Vasya can think of, and m is the number of different games Petya wants to play.", "output_format": "For each game, print the length of the sequence of questions k (0 \u2264 k \u2264 n), followed by k numbers \u2014 the questions y_{i} (1 \u2264 y_{i} \u2264 n).", "test_input": ["assert apps_run2(4) == [2, 4, 3]", "assert apps_run2(6) == [2, 4, 3, 5]", "assert apps_run2(10) == [2, 4, 8, 3, 9, 5, 7]", "assert apps_run2(1) == []", "assert apps_run2(15) == [2, 4, 8, 3, 9, 5, 7, 11, 13]"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "APPS/2025-2", "raw_problem": "Vasya and Petya are playing a simple game. Vasya thought of number x between 1 and n, and Petya tries to guess the number.\n\nPetya can ask questions like: \"Is the unknown number divisible by number y?\".\n\nThe game is played by the following rules: first Petya asks all the questions that interest him (also, he can ask no questions), and then Vasya responds to each question with a 'yes' or a 'no'. After receiving all the answers Petya should determine the number that Vasya thought of.\n\nUnfortunately, Petya is not familiar with the number theory. Help him find the minimum number of questions he should ask to make a guaranteed guess of Vasya's number, and the numbers y_{i}, he should ask the questions about.\n\n\n-----Input-----\n\nA single line contains number n (1 \u2264 n \u2264 10^3).\n\n\n-----Output-----\n\nPrint the length of the sequence of questions k (0 \u2264 k \u2264 n), followed by k numbers \u2014 the questions y_{i} (1 \u2264 y_{i} \u2264 n).\n\nIf there are several correct sequences of questions of the minimum length, you are allowed to print any of them.\n\n\n-----Examples-----\nInput\n4\n\nOutput\n3\n2 4 3 \n\nInput\n6\n\nOutput\n4\n2 4 3 5 \n\n\n\n-----Note-----\n\nThe sequence from the answer to the first sample test is actually correct.\n\nIf the unknown number is not divisible by one of the sequence numbers, it is equal to 1.\n\nIf the unknown number is divisible by 4, it is 4.\n\nIf the unknown number is divisible by 3, then the unknown number is 3.\n\nOtherwise, it is equal to 2. Therefore, the sequence of questions allows you to guess the unknown number. It can be shown that there is no correct sequence of questions of length 2 or shorter.", "raw_solution": "def apps_run1(n):\n    result = []\n    for i in range(2, n + 1):\n        j = 2\n        while j * j <= i:\n            if i % j == 0:\n                break\n            j += 1\n        else:\n            j = i\n            while j <= n:\n                result.append(j)\n                j *= i\n    return len(result), ' '.join(str(i) for i in result)\n", "raw_test_input": ["assert apps_run1(4) == (3, '2 4 3')", "assert apps_run1(6) == (4, '2 4 3 5')", "assert apps_run1(1) == (0, '')", "assert apps_run1(15) == (9, '2 4 8 3 9 5 7 11 13')", "assert apps_run1(19) == (12, '2 4 8 16 3 9 5 7 11 13 17 19')", "assert apps_run1(20) == (12, '2 4 8 16 3 9 5 7 11 13 17 19')", "assert apps_run1(37) == (19, '2 4 8 16 32 3 9 27 5 25 7 11 13 17 19 23 29 31 37')", "assert apps_run1(211) == (61, '2 4 8 16 32 64 128 3 9 27 81 5 25 125 7 49 11 121 13 169 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 101 103 107 109 113 127 131 137 139 149 151 157 163 167 173 179 181 191 193 197 199 211')", "assert apps_run1(557) == (123, '2 4 8 16 32 64 128 256 512 3 9 27 81 243 5 25 125 7 49 343 11 121 13 169 17 289 19 361 23 529 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 101 103 107 109 113 127 131 137 139 149 151 157 163 167 173 179 181 191 193 197 199 211 223 227 229 233 239 241 251 257 263 269 271 277 281 283 293 307 311 313 317 331 337 347 349 353 359 367 373 379 383 389 397 401 409 419 421 431 433 439 443 449 457 461 463 467 479 487 491 499 503 509 521 523 541 547 557')", "assert apps_run1(289) == (78, '2 4 8 16 32 64 128 256 3 9 27 81 243 5 25 125 7 49 11 121 13 169 17 289 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 101 103 107 109 113 127 131 137 139 149 151 157 163 167 173 179 181 191 193 197 199 211 223 227 229 233 239 241 251 257 263 269 271 277 281 283')", "assert apps_run1(400) == (97, '2 4 8 16 32 64 128 256 3 9 27 81 243 5 25 125 7 49 343 11 121 13 169 17 289 19 361 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 101 103 107 109 113 127 131 137 139 149 151 157 163 167 173 179 181 191 193 197 199 211 223 227 229 233 239 241 251 257 263 269 271 277 281 283 293 307 311 313 317 331 337 347 349 353 359 367 373 379 383 389 397')", "assert apps_run1(625) == (136, '2 4 8 16 32 64 128 256 512 3 9 27 81 243 5 25 125 625 7 49 343 11 121 13 169 17 289 19 361 23 529 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 101 103 107 109 113 127 131 137 139 149 151 157 163 167 173 179 181 191 193 197 199 211 223 227 229 233 239 241 251 257 263 269 271 277 281 283 293 307 311 313 317 331 337 347 349 353 359 367 373 379 383 389 397 401 409 419 421 431 433 439 443 449 457 461 463 467 479 487 491 499 503 509 521 523 541 547 557 563 569 571 577 587 593 599 601 607 613 617 619')", "assert apps_run1(31) == (17, '2 4 8 16 3 9 27 5 25 7 11 13 17 19 23 29 31')", "assert apps_run1(44) == (21, '2 4 8 16 32 3 9 27 5 25 7 11 13 17 19 23 29 31 37 41 43')", "assert apps_run1(160) == (50, '2 4 8 16 32 64 128 3 9 27 81 5 25 125 7 49 11 121 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 101 103 107 109 113 127 131 137 139 149 151 157')", "assert apps_run1(322) == (83, '2 4 8 16 32 64 128 256 3 9 27 81 243 5 25 125 7 49 11 121 13 169 17 289 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 101 103 107 109 113 127 131 137 139 149 151 157 163 167 173 179 181 191 193 197 199 211 223 227 229 233 239 241 251 257 263 269 271 277 281 283 293 307 311 313 317')", "assert apps_run1(30) == (16, '2 4 8 16 3 9 27 5 25 7 11 13 17 19 23 29')"], "new_problem": "Vasya and Petya are playing a simple game. Vasya thought of number x between 1 and n, and Petya tries to guess the number. Petya can ask questions like: 'Is the unknown number divisible by number y?'. The game is played by the following rules: first Petya asks all the questions that interest him (also, he can ask no questions), and then Vasya responds to each question with a 'yes' or a 'no'. After receiving all the answers Petya should determine the number that Vasya thought of. Unfortunately, Petya is not familiar with the number theory. Help him find the minimum number of questions he should ask to make a guaranteed guess of Vasya's number, and the numbers y_{i}, he should ask the questions about. Additionally, if a detailed flag is set to True, provide a mapping of each number from 1 to n to the questions it is divisible by.", "new_solution": "def apps_run2(n: int, detailed: bool = False) -> None:\n    result = []\n    divisibility_map = {i: [] for i in range(1, n + 1)}\n    for i in range(2, n + 1):\n        j = 2\n        while j * j <= i:\n            if i % j == 0:\n                break\n            j += 1\n        else:\n            j = i\n            while j <= n:\n                result.append(j)\n                for k in range(j, n + 1, j):\n                    divisibility_map[k].append(j)\n                j *= i\n    print(len(result))\n    print(' '.join(str(i) for i in result))\n    if detailed:\n        print(divisibility_map)\n\n# Example usage\n# apps_run2(6, detailed=True)", "input_format": "A single line contains number n (1 \u2264 n \u2264 10^3) and an optional boolean flag detailed (default is False).", "output_format": "Print the length of the sequence of questions k (0 \u2264 k \u2264 n), followed by k numbers \u2014 the questions y_{i} (1 \u2264 y_{i} \u2264 n). If detailed is True, also print a dictionary mapping each number from 1 to n to the questions it is divisible by.", "test_input": ["assert apps_run2(4) == None", "assert apps_run2(6) == None", "assert apps_run2(4, detailed=True) == None", "assert apps_run2(6, detailed=True) == None", "assert apps_run2(10, detailed=False) == None"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "APPS/2025-3", "raw_problem": "Vasya and Petya are playing a simple game. Vasya thought of number x between 1 and n, and Petya tries to guess the number.\n\nPetya can ask questions like: \"Is the unknown number divisible by number y?\".\n\nThe game is played by the following rules: first Petya asks all the questions that interest him (also, he can ask no questions), and then Vasya responds to each question with a 'yes' or a 'no'. After receiving all the answers Petya should determine the number that Vasya thought of.\n\nUnfortunately, Petya is not familiar with the number theory. Help him find the minimum number of questions he should ask to make a guaranteed guess of Vasya's number, and the numbers y_{i}, he should ask the questions about.\n\n\n-----Input-----\n\nA single line contains number n (1 \u2264 n \u2264 10^3).\n\n\n-----Output-----\n\nPrint the length of the sequence of questions k (0 \u2264 k \u2264 n), followed by k numbers \u2014 the questions y_{i} (1 \u2264 y_{i} \u2264 n).\n\nIf there are several correct sequences of questions of the minimum length, you are allowed to print any of them.\n\n\n-----Examples-----\nInput\n4\n\nOutput\n3\n2 4 3 \n\nInput\n6\n\nOutput\n4\n2 4 3 5 \n\n\n\n-----Note-----\n\nThe sequence from the answer to the first sample test is actually correct.\n\nIf the unknown number is not divisible by one of the sequence numbers, it is equal to 1.\n\nIf the unknown number is divisible by 4, it is 4.\n\nIf the unknown number is divisible by 3, then the unknown number is 3.\n\nOtherwise, it is equal to 2. Therefore, the sequence of questions allows you to guess the unknown number. It can be shown that there is no correct sequence of questions of length 2 or shorter.", "raw_solution": "def apps_run1(n):\n    result = []\n    for i in range(2, n + 1):\n        j = 2\n        while j * j <= i:\n            if i % j == 0:\n                break\n            j += 1\n        else:\n            j = i\n            while j <= n:\n                result.append(j)\n                j *= i\n    return len(result), result\n", "raw_test_input": ["assert apps_run1(4) == (3, [2, 4, 3])", "assert apps_run1(6) == (4, [2, 4, 3, 5])", "assert apps_run1(1) == (0, [])", "assert apps_run1(15) == (9, [2, 4, 8, 3, 9, 5, 7, 11, 13])", "assert apps_run1(19) == (12, [2, 4, 8, 16, 3, 9, 5, 7, 11, 13, 17, 19])", "assert apps_run1(20) == (12, [2, 4, 8, 16, 3, 9, 5, 7, 11, 13, 17, 19])", "assert apps_run1(37) == (19, [2, 4, 8, 16, 32, 3, 9, 27, 5, 25, 7, 11, 13, 17, 19, 23, 29, 31, 37])", "assert apps_run1(211) == (61, [2, 4, 8, 16, 32, 64, 128, 3, 9, 27, 81, 5, 25, 125, 7, 49, 11, 121, 13, 169, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211])", "assert apps_run1(557) == (123, [2, 4, 8, 16, 32, 64, 128, 256, 512, 3, 9, 27, 81, 243, 5, 25, 125, 7, 49, 343, 11, 121, 13, 169, 17, 289, 19, 361, 23, 529, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557])", "assert apps_run1(289) == (78, [2, 4, 8, 16, 32, 64, 128, 256, 3, 9, 27, 81, 243, 5, 25, 125, 7, 49, 11, 121, 13, 169, 17, 289, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283])", "assert apps_run1(400) == (97, [2, 4, 8, 16, 32, 64, 128, 256, 3, 9, 27, 81, 243, 5, 25, 125, 7, 49, 343, 11, 121, 13, 169, 17, 289, 19, 361, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397])", "assert apps_run1(625) == (136, [2, 4, 8, 16, 32, 64, 128, 256, 512, 3, 9, 27, 81, 243, 5, 25, 125, 625, 7, 49, 343, 11, 121, 13, 169, 17, 289, 19, 361, 23, 529, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619])", "assert apps_run1(31) == (17, [2, 4, 8, 16, 3, 9, 27, 5, 25, 7, 11, 13, 17, 19, 23, 29, 31])", "assert apps_run1(44) == (21, [2, 4, 8, 16, 32, 3, 9, 27, 5, 25, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43])", "assert apps_run1(160) == (50, [2, 4, 8, 16, 32, 64, 128, 3, 9, 27, 81, 5, 25, 125, 7, 49, 11, 121, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157])", "assert apps_run1(322) == (83, [2, 4, 8, 16, 32, 64, 128, 256, 3, 9, 27, 81, 243, 5, 25, 125, 7, 49, 11, 121, 13, 169, 17, 289, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317])", "assert apps_run1(30) == (16, [2, 4, 8, 16, 3, 9, 27, 5, 25, 7, 11, 13, 17, 19, 23, 29])"], "new_problem": "Vasya and Petya are playing an advanced version of their game. Vasya thought of a number x between 1 and n, and Petya tries to guess the number. Petya can ask questions like: 'Is the unknown number divisible by number y?'. Additionally, there are m constraints given as pairs (a_i, b_i) which mean that if the number is divisible by a_i, it must also be divisible by b_i. Help Petya find the minimum number of questions he should ask to make a guaranteed guess of Vasya's number, considering these constraints. Use a dictionary to store the constraints and optimize the question sequence.", "new_solution": "from typing import List, Tuple, Dict\n\ndef apps_run2(n: int, constraints: List[Tuple[int, int]]) -> Tuple[int, List[int]]:\n    constraint_dict: Dict[int, List[int]] = {}\n    for a, b in constraints:\n        if a in constraint_dict:\n            constraint_dict[a].append(b)\n        else:\n            constraint_dict[a] = [b]\n\n    result = []\n    for i in range(2, n + 1):\n        j = 2\n        while j * j <= i:\n            if i % j == 0:\n                break\n            j += 1\n        else:\n            j = i\n            while j <= n:\n                if all(j % b != 0 for b in constraint_dict.get(j, [])):\n                    result.append(j)\n                j *= i\n\n    return len(result), result", "input_format": "A single line contains number n (1 \u2264 n \u2264 10^3) and a list of m pairs of integers (a_i, b_i) representing additional constraints.", "output_format": "Print the length of the sequence of questions k (0 \u2264 k \u2264 n), followed by k numbers \u2014 the questions y_{i} (1 \u2264 y_{i} \u2264 n).", "test_input": ["assert apps_run2(4, [(2, 3)]) == (3, [2, 4, 3])", "assert apps_run2(6, [(2, 3), (3, 5)]) == (4, [2, 4, 3, 5])", "assert apps_run2(10, [(2, 5), (3, 7)]) == (7, [2, 4, 8, 3, 9, 5, 7])", "assert apps_run2(8, [(2, 4), (3, 6)]) ==(6, [2, 4, 8, 3, 5, 7])", "assert apps_run2(12, [(2, 6), (3, 9)]) == (8, [2, 4, 8, 3, 9, 5, 7, 11])"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "APPS/2025-4", "raw_problem": "Vasya and Petya are playing a simple game. Vasya thought of number x between 1 and n, and Petya tries to guess the number.\n\nPetya can ask questions like: \"Is the unknown number divisible by number y?\".\n\nThe game is played by the following rules: first Petya asks all the questions that interest him (also, he can ask no questions), and then Vasya responds to each question with a 'yes' or a 'no'. After receiving all the answers Petya should determine the number that Vasya thought of.\n\nUnfortunately, Petya is not familiar with the number theory. Help him find the minimum number of questions he should ask to make a guaranteed guess of Vasya's number, and the numbers y_{i}, he should ask the questions about.\n\n\n-----Input-----\n\nA single line contains number n (1 \u2264 n \u2264 10^3).\n\n\n-----Output-----\n\nPrint the length of the sequence of questions k (0 \u2264 k \u2264 n), followed by k numbers \u2014 the questions y_{i} (1 \u2264 y_{i} \u2264 n).\n\nIf there are several correct sequences of questions of the minimum length, you are allowed to print any of them.\n\n\n-----Examples-----\nInput\n4\n\nOutput\n3\n2 4 3 \n\nInput\n6\n\nOutput\n4\n2 4 3 5 \n\n\n\n-----Note-----\n\nThe sequence from the answer to the first sample test is actually correct.\n\nIf the unknown number is not divisible by one of the sequence numbers, it is equal to 1.\n\nIf the unknown number is divisible by 4, it is 4.\n\nIf the unknown number is divisible by 3, then the unknown number is 3.\n\nOtherwise, it is equal to 2. Therefore, the sequence of questions allows you to guess the unknown number. It can be shown that there is no correct sequence of questions of length 2 or shorter.", "raw_solution": "def apps_run1(n):\n    result = []\n    for i in range(2, n + 1):\n        j = 2\n        while j * j <= i:\n            if i % j == 0:\n                break\n            j += 1\n        else:\n            j = i\n            while j <= n:\n                result.append(j)\n                j *= i\n    return len(result), result\n", "raw_test_input": ["assert apps_run1(4) == (3, [2, 4, 3])", "assert apps_run1(6) == (4, [2, 4, 3, 5])", "assert apps_run1(1) == (0, [])", "assert apps_run1(15) == (9, [2, 4, 8, 3, 9, 5, 7, 11, 13])", "assert apps_run1(19) == (12, [2, 4, 8, 16, 3, 9, 5, 7, 11, 13, 17, 19])", "assert apps_run1(20) == (12, [2, 4, 8, 16, 3, 9, 5, 7, 11, 13, 17, 19])", "assert apps_run1(37) == (19, [2, 4, 8, 16, 32, 3, 9, 27, 5, 25, 7, 11, 13, 17, 19, 23, 29, 31, 37])", "assert apps_run1(211) == (61, [2, 4, 8, 16, 32, 64, 128, 3, 9, 27, 81, 5, 25, 125, 7, 49, 11, 121, 13, 169, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211])", "assert apps_run1(557) == (123, [2, 4, 8, 16, 32, 64, 128, 256, 512, 3, 9, 27, 81, 243, 5, 25, 125, 7, 49, 343, 11, 121, 13, 169, 17, 289, 19, 361, 23, 529, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557])", "assert apps_run1(289) == (78, [2, 4, 8, 16, 32, 64, 128, 256, 3, 9, 27, 81, 243, 5, 25, 125, 7, 49, 11, 121, 13, 169, 17, 289, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283])", "assert apps_run1(400) == (97, [2, 4, 8, 16, 32, 64, 128, 256, 3, 9, 27, 81, 243, 5, 25, 125, 7, 49, 343, 11, 121, 13, 169, 17, 289, 19, 361, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397])", "assert apps_run1(625) == (136, [2, 4, 8, 16, 32, 64, 128, 256, 512, 3, 9, 27, 81, 243, 5, 25, 125, 625, 7, 49, 343, 11, 121, 13, 169, 17, 289, 19, 361, 23, 529, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619])", "assert apps_run1(31) == (17, [2, 4, 8, 16, 3, 9, 27, 5, 25, 7, 11, 13, 17, 19, 23, 29, 31])", "assert apps_run1(44) == (21, [2, 4, 8, 16, 32, 3, 9, 27, 5, 25, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43])", "assert apps_run1(160) == (50, [2, 4, 8, 16, 32, 64, 128, 3, 9, 27, 81, 5, 25, 125, 7, 49, 11, 121, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157])", "assert apps_run1(322) == (83, [2, 4, 8, 16, 32, 64, 128, 256, 3, 9, 27, 81, 243, 5, 25, 125, 7, 49, 11, 121, 13, 169, 17, 289, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317])", "assert apps_run1(30) == (16, [2, 4, 8, 16, 3, 9, 27, 5, 25, 7, 11, 13, 17, 19, 23, 29])"], "new_problem": "Vasya and Petya are playing a game similar to the one described earlier. However, this time, the input may contain errors or invalid data. Your task is to implement error handling to manage the following scenarios: \n1. The input is not an integer.\n2. The input integer is out of the specified range (1 \u2264 n \u2264 10^3).\n3. The input is missing or empty.\n\nDefine specific error types for these scenarios and ensure that meaningful error messages are provided. Handle error propagation appropriately and maintain type hints in your solution.", "new_solution": "# \u81ea\u5b9a\u4e49\u5f02\u5e38\u7c7b\uff0c\u7528\u4e8e\u5904\u7406\u8f93\u5165\u65e0\u6548\u7684\u60c5\u51b5\nclass InvalidInputError(Exception):\n    pass\n\n\n# \u81ea\u5b9a\u4e49\u5f02\u5e38\u7c7b\uff0c\u7528\u4e8e\u5904\u7406\u8f93\u5165\u8d85\u51fa\u8303\u56f4\u7684\u60c5\u51b5\nclass OutOfRangeError(Exception):\n    pass\n\n\ndef apps_run2(n: int | None = None) -> tuple[int, list[int]]:\n    # \u68c0\u67e5\u8f93\u5165\u662f\u5426\u7f3a\u5931\u6216\u4e3a\u7a7a\n    if n is None:\n        raise InvalidInputError(\"Input is missing or empty.\")\n\n    # \u68c0\u67e5\u8f93\u5165\u662f\u5426\u4e3a\u6709\u6548\u7684\u6574\u6570\n    if not isinstance(n, int):\n        raise InvalidInputError(\"Input is not a valid integer.\")\n\n    # \u68c0\u67e5\u8f93\u5165\u662f\u5426\u5728\u5141\u8bb8\u7684\u8303\u56f4\u5185\n    if not (1 <= n <= 1000):\n        raise OutOfRangeError(\"Input is out of the allowed range (1 \u2264 n \u2264 10^3).\")\n\n    result = []  # \u521d\u59cb\u5316\u4e00\u4e2a\u7a7a\u5217\u8868\uff0c\u7528\u4e8e\u5b58\u50a8\u6700\u7ec8\u8981\u63d0\u95ee\u7684\u6570\u5b57\n    for i in range(2, n + 1):  # \u904d\u5386\u4ece 2 \u5230 n \u7684\u6bcf\u4e2a\u6570\u5b57 i\n        j = 2  # \u521d\u59cb\u5316 j \u4e3a 2\uff0c\u7528\u4e8e\u68c0\u67e5 i \u662f\u5426\u4e3a\u8d28\u6570\n        while j * j <= i:  # \u5f53 j \u7684\u5e73\u65b9\u5c0f\u4e8e\u7b49\u4e8e i \u65f6\n            if i % j == 0:  # \u5982\u679c i \u80fd\u88ab j \u6574\u9664\uff0c\u8bf4\u660e i \u4e0d\u662f\u8d28\u6570\n                break  # \u8df3\u51fa\u5faa\u73af\n            j += 1  # j \u81ea\u589e 1 \u7ee7\u7eed\u68c0\u67e5\n        else:  # \u5982\u679c\u5faa\u73af\u6b63\u5e38\u7ed3\u675f\uff0c\u8bf4\u660e i \u662f\u8d28\u6570\n            j = i  # \u5c06 j \u8d4b\u503c\u4e3a i\n            while j <= n:  # \u5f53 j \u5c0f\u4e8e\u7b49\u4e8e n \u65f6\n                result.append(j)  # \u5c06 j \u6dfb\u52a0\u5230\u7ed3\u679c\u5217\u8868\u4e2d\n                j *= i  # j \u4e58\u4ee5 i\uff0c\u5f97\u5230 i \u7684\u5e42\u6b21\n    return len(result), result  # \u8fd4\u56de\u7ed3\u679c\u5217\u8868\u7684\u957f\u5ea6\uff08\u95ee\u9898\u6570\u91cf\uff09\u548c\u7ed3\u679c\u5217\u8868\uff08\u63d0\u95ee\u7684\u6570\u5b57\uff09", "input_format": "A single line contains number n (1 \u2264 n \u2264 10^3).", "output_format": "Print the length of the sequence of questions k (0 \u2264 k \u2264 n), followed by k numbers \u2014 the questions y_{i} (1 \u2264 y_{i} \u2264 n).", "test_input": ["try:\n    apps_run2('a')\nexcept InvalidInputError as e:\n    assert str(e) == \"Input is not a valid integer.\"\nelse:\n    assert False, \"Expected InvalidInputError\"", "try:\n    apps_run2(10000000)\nexcept OutOfRangeError as e:\n    assert str(e) == \"Input is out of the allowed range (1 \u2264 n \u2264 10^3).\"\nelse:\n    assert False, \"Expected OutOfRangeError\"", "try:\n    apps_run2()\nexcept InvalidInputError as e:\n    assert str(e) == \"Input is missing or empty.\"\nelse:\n    assert False, \"Expected InvalidInputError\"", "try:\n    apps_run2(\"b\")\nexcept InvalidInputError as e:\n    assert str(e) == \"Input is not a valid integer.\"\nelse:\n    assert False, \"Expected InvalidInputError\"", "try:\n    apps_run2(999999999999)\nexcept OutOfRangeError as e:\n    assert str(e) == \"Input is out of the allowed range (1 \u2264 n \u2264 10^3).\"\nelse:\n    assert False, \"Expected OutOfRangeError\""], "requirement_type": null}
{"task_id": "APPS/2504-1", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nGiven an array of positive integers\u00a0arr, calculate the sum of all possible odd-length subarrays.\nA subarray is a contiguous\u00a0subsequence of the array.\nReturn\u00a0the sum of all odd-length subarrays of\u00a0arr.\n\u00a0\nExample 1:\nInput: arr = [1,4,2,5,3]\nOutput: 58\nExplanation: The odd-length subarrays of arr and their sums are:\n[1] = 1\n[4] = 4\n[2] = 2\n[5] = 5\n[3] = 3\n[1,4,2] = 7\n[4,2,5] = 11\n[2,5,3] = 10\n[1,4,2,5,3] = 15\nIf we add all these together we get 1 + 4 + 2 + 5 + 3 + 7 + 11 + 10 + 15 = 58\nExample 2:\nInput: arr = [1,2]\nOutput: 3\nExplanation: There are only 2 subarrays of odd length, [1] and [2]. Their sum is 3.\nExample 3:\nInput: arr = [10,11,12]\nOutput: 66\n\n\u00a0\nConstraints:\n\n1 <= arr.length <= 100\n1 <= arr[i] <= 1000.", "raw_solution": "def apps_run1(arr):\n    total = 0\n    for i in range(len(arr)):\n        totalisubarrays = (len(arr) - i) * (i+1)\n        if totalisubarrays % 2 == 1:\n            totalisubarrays += 1\n        oddisubarrays = totalisubarrays//2\n        total += arr[i]*oddisubarrays\n    return total", "raw_test_input": ["assert apps_run1([1, 4, 2, 5, 3]) == 58", "assert apps_run1([1, 2]) == 3", "assert apps_run1([10, 11, 12]) == 66", "assert apps_run1([7, 8, 9, 10]) == 85", "assert apps_run1([1, 2, 3, 4, 5, 6]) == 98"], "new_problem": "In a retail business, you are given weekly sales data for multiple weeks. Each week's sales data is represented as a list of positive integers, where each integer represents the sales for a day. Your task is to calculate the sum of all possible odd-length subarrays of sales data for each week. Return a list of sums, where each sum corresponds to a week.", "new_solution": "from typing import List\n\nclass apps_run2:\n    def sumOddLengthSubarrays(self, arr: List[int]) -> int:\n        total = 0\n        for i in range(len(arr)):\n            totalisubarrays = (len(arr) - i) * (i+1)\n            if totalisubarrays % 2 == 1:\n                totalisubarrays += 1\n            oddisubarrays = totalisubarrays // 2\n            total += arr[i] * oddisubarrays\n        return total\n\n    def weeklyOddLengthSubarraySums(self, sales_data: List[List[int]]) -> List[int]:\n        results = []\n        for week_data in sales_data:\n            week_sum = self.sumOddLengthSubarrays(week_data)\n            results.append(week_sum)\n        return results", "input_format": "A list of lists, where each sublist contains positive integers representing daily sales data for a week.", "output_format": "A list of integers, where each integer represents the sum of all odd-length subarrays of sales data for each week.", "test_input": ["assert apps_run2().weeklyOddLengthSubarraySums([[1,4,2,5,3], [1,2], [10,11,12]]) == [58, 3, 66]", "assert apps_run2().weeklyOddLengthSubarraySums([[1,1,1], [2,2,2,2], [3,3,3,3,3]]) == [6, 20, 57]", "assert apps_run2().weeklyOddLengthSubarraySums([[5], [6,7,8], [9,10,11,12,13]]) == [5, 42, 209]", "assert apps_run2().weeklyOddLengthSubarraySums([[100,200,300], [400,500], [600]]) == [1200, 900, 600]", "assert apps_run2().weeklyOddLengthSubarraySums([[1,2,3,4,5,6,7], [8,9,10,11,12,13,14]]) == [176, 484]"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "APPS/2504-2", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nGiven an array of positive integers\u00a0arr, calculate the sum of all possible odd-length subarrays.\nA subarray is a contiguous\u00a0subsequence of the array.\nReturn\u00a0the sum of all odd-length subarrays of\u00a0arr.\n\u00a0\nExample 1:\nInput: arr = [1,4,2,5,3]\nOutput: 58\nExplanation: The odd-length subarrays of arr and their sums are:\n[1] = 1\n[4] = 4\n[2] = 2\n[5] = 5\n[3] = 3\n[1,4,2] = 7\n[4,2,5] = 11\n[2,5,3] = 10\n[1,4,2,5,3] = 15\nIf we add all these together we get 1 + 4 + 2 + 5 + 3 + 7 + 11 + 10 + 15 = 58\nExample 2:\nInput: arr = [1,2]\nOutput: 3\nExplanation: There are only 2 subarrays of odd length, [1] and [2]. Their sum is 3.\nExample 3:\nInput: arr = [10,11,12]\nOutput: 66\n\n\u00a0\nConstraints:\n\n1 <= arr.length <= 100\n1 <= arr[i] <= 1000.", "raw_solution": "def apps_run1(arr):\n    total = 0\n    for i in range(len(arr)):\n        totalisubarrays = (len(arr) - i) * (i+1)\n        if totalisubarrays % 2 == 1:\n            totalisubarrays += 1\n        oddisubarrays = totalisubarrays//2\n        total += arr[i]*oddisubarrays\n    return total", "raw_test_input": ["assert apps_run1([1, 4, 2, 5, 3]) == 58", "assert apps_run1([1, 2]) == 3", "assert apps_run1([10, 11, 12]) == 66", "assert apps_run1([1, 2, 3, 4, 5, 6]) == 98", "assert apps_run1([7, 8, 9, 10]) == 85"], "new_problem": "Given an array of positive integers arr, calculate the sum of all possible odd-length subarrays. Additionally, provide an option to include even-length subarrays in the sum calculation. The function should maintain backward compatibility, meaning it should still work as originally intended if the new parameter is not used. Return the sum of all odd-length subarrays of arr, and if the optional parameter include_even is set to True, include the sum of all even-length subarrays as well.", "new_solution": "from typing import List, Optional\n\nclass apps_run2:\n    def sumOddLengthSubarrays(self, arr: List[int], include_even: Optional[bool] = False) -> int:\n        total = 0\n        n = len(arr)\n        for i in range(n):\n            totalisubarrays = (n - i) * (i + 1)\n            oddisubarrays = totalisubarrays // 2\n            if totalisubarrays % 2 == 1:\n                oddisubarrays += 1\n            total += arr[i] * oddisubarrays\n            if include_even:\n                evenisubarrays = totalisubarrays // 2\n                total += arr[i] * evenisubarrays\n        return total", "input_format": "arr: List[int], include_even: Optional[bool] = False", "output_format": "int", "test_input": ["assert apps_run2().sumOddLengthSubarrays([1, 4, 2, 5, 3]) == 58", "assert apps_run2().sumOddLengthSubarrays([1, 4, 2, 5, 3], include_even=True) == 110", "assert apps_run2().sumOddLengthSubarrays([1, 2]) == 3", "assert apps_run2().sumOddLengthSubarrays([1, 2], include_even=True) == 6", "assert apps_run2().sumOddLengthSubarrays([10, 11, 12]) == 66", "assert apps_run2().sumOddLengthSubarrays([10, 11, 12], include_even=True) == 110"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "APPS/2504-3", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nGiven an array of positive integers\u00a0arr, calculate the sum of all possible odd-length subarrays.\nA subarray is a contiguous\u00a0subsequence of the array.\nReturn\u00a0the sum of all odd-length subarrays of\u00a0arr.\n\u00a0\nExample 1:\nInput: arr = [1,4,2,5,3]\nOutput: 58\nExplanation: The odd-length subarrays of arr and their sums are:\n[1] = 1\n[4] = 4\n[2] = 2\n[5] = 5\n[3] = 3\n[1,4,2] = 7\n[4,2,5] = 11\n[2,5,3] = 10\n[1,4,2,5,3] = 15\nIf we add all these together we get 1 + 4 + 2 + 5 + 3 + 7 + 11 + 10 + 15 = 58\nExample 2:\nInput: arr = [1,2]\nOutput: 3\nExplanation: There are only 2 subarrays of odd length, [1] and [2]. Their sum is 3.\nExample 3:\nInput: arr = [10,11,12]\nOutput: 66\n\n\u00a0\nConstraints:\n\n1 <= arr.length <= 100\n1 <= arr[i] <= 1000.", "raw_solution": "def apps_run1(arr):\n    total = 0\n    for i in range(len(arr)):\n        totalisubarrays = (len(arr) - i) * (i+1)\n        if totalisubarrays % 2 == 1:\n            totalisubarrays += 1\n        oddisubarrays = totalisubarrays//2\n        total += arr[i]*oddisubarrays\n    return total", "raw_test_input": ["assert apps_run1([1, 4, 2, 5, 3]) == 58", "assert apps_run1([1, 2]) == 3", "assert apps_run1([10, 11, 12]) == 66", "assert apps_run1([1, 2, 3, 4, 5, 6]) == 98", "assert apps_run1([7, 8, 9, 10]) == 85"], "new_problem": "Given a dictionary where keys are indices and values are positive integers representing the array elements, calculate the sum of all possible odd-length subarrays. A subarray is a contiguous subsequence of the array. Return the sum of all odd-length subarrays of the array represented by the dictionary. The dictionary keys are guaranteed to be consecutive integers starting from 0. Additionally, the dictionary may contain up to 1000 elements, and each value is between 1 and 1000.", "new_solution": "from typing import Dict\n\nclass apps_run2:\n    def sumOddLengthSubarrays(self, arr_dict: Dict[int, int]) -> int:\n        arr = [arr_dict[i] for i in sorted(arr_dict.keys())]\n        total = 0\n        for i in range(len(arr)):\n            totalisubarrays = (len(arr) - i) * (i + 1)\n            if totalisubarrays % 2 == 1:\n                totalisubarrays += 1\n            oddisubarrays = totalisubarrays // 2\n            total += arr[i] * oddisubarrays\n        return total", "input_format": "A dictionary where keys are indices and values are positive integers representing the array elements.", "output_format": "An integer representing the sum of all odd-length subarrays.", "test_input": ["assert apps_run2().sumOddLengthSubarrays({0: 1, 1: 4, 2: 2, 3: 5, 4: 3}) == 58", "assert apps_run2().sumOddLengthSubarrays({0: 1, 1: 2}) == 3", "assert apps_run2().sumOddLengthSubarrays({0: 10, 1: 11, 2: 12}) == 66", "assert apps_run2().sumOddLengthSubarrays({0: 5, 1: 5, 2: 5, 3: 5, 4: 5}) == 95", "assert apps_run2().sumOddLengthSubarrays({0: 100, 1: 200, 2: 300, 3: 400, 4: 500}) == 5700"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "APPS/2504-4", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nGiven an array of positive integers\u00a0arr, calculate the sum of all possible odd-length subarrays.\nA subarray is a contiguous\u00a0subsequence of the array.\nReturn\u00a0the sum of all odd-length subarrays of\u00a0arr.\n\u00a0\nExample 1:\nInput: arr = [1,4,2,5,3]\nOutput: 58\nExplanation: The odd-length subarrays of arr and their sums are:\n[1] = 1\n[4] = 4\n[2] = 2\n[5] = 5\n[3] = 3\n[1,4,2] = 7\n[4,2,5] = 11\n[2,5,3] = 10\n[1,4,2,5,3] = 15\nIf we add all these together we get 1 + 4 + 2 + 5 + 3 + 7 + 11 + 10 + 15 = 58\nExample 2:\nInput: arr = [1,2]\nOutput: 3\nExplanation: There are only 2 subarrays of odd length, [1] and [2]. Their sum is 3.\nExample 3:\nInput: arr = [10,11,12]\nOutput: 66\n\n\u00a0\nConstraints:\n\n1 <= arr.length <= 100\n1 <= arr[i] <= 1000.", "raw_solution": "def apps_run1(arr):\n    total = 0\n    for i in range(len(arr)):\n        totalisubarrays = (len(arr) - i) * (i+1)\n        if totalisubarrays % 2 == 1:\n            totalisubarrays += 1\n        oddisubarrays = totalisubarrays//2\n        total += arr[i]*oddisubarrays\n    return total", "raw_test_input": ["assert apps_run1([1, 4, 2, 5, 3]) == 58", "assert apps_run1([1, 2]) == 3", "assert apps_run1([10, 11, 12]) == 66", "assert apps_run1([1, 2, 3, 4, 5, 6]) == 98", "assert apps_run1([7, 8, 9, 10]) == 85"], "new_problem": "Write a function that calculates the sum of all possible odd-length subarrays of a given array of positive integers. The function should handle the following errors: 1) If the input is not a list, raise a TypeError with a meaningful message. 2) If any element in the list is not an integer, raise a ValueError. 3) If any integer in the list is not positive, raise a ValueError. 4) If the list is empty, raise a ValueError. The function should propagate these errors appropriately and maintain type hints.", "new_solution": "from typing import List\n\nclass InvalidInputError(Exception):\n    pass\n\nclass apps_run2:\n    def sumOddLengthSubarrays(self, arr: List[int]) -> int:\n        if not isinstance(arr, list):\n            raise TypeError('Input must be a list of integers.')\n        if not arr:\n            raise ValueError('Input list cannot be empty.')\n        for num in arr:\n            if not isinstance(num, int):\n                raise ValueError('All elements in the list must be integers.')\n            if num <= 0:\n                raise ValueError('All integers in the list must be positive.')\n\n        total = 0\n        for i in range(len(arr)):\n            totalisubarrays = (len(arr) - i) * (i + 1)\n            if totalisubarrays % 2 == 1:\n                totalisubarrays += 1\n            oddisubarrays = totalisubarrays // 2\n            total += arr[i] * oddisubarrays\n        return total", "input_format": "List[int]", "output_format": "int", "test_input": ["assert apps_run2().sumOddLengthSubarrays([1, 4, 2, 5, 3]) == 58", "assert apps_run2().sumOddLengthSubarrays([1, 2]) == 3", "assert apps_run2().sumOddLengthSubarrays([10, 11, 12]) == 66", "try:\n    apps_run2().sumOddLengthSubarrays('not a list')\nexcept TypeError as e:\n    assert str(e) == 'Input must be a list of integers.'", "try:\n    apps_run2().sumOddLengthSubarrays([])\nexcept ValueError as e:\n    assert str(e) == 'Input list cannot be empty.'", "try:\n    apps_run2().sumOddLengthSubarrays([1, 'a', 3])\nexcept ValueError as e:\n    assert str(e) == 'All elements in the list must be integers.'", "try:\n    apps_run2().sumOddLengthSubarrays([1, -2, 3])\nexcept ValueError as e:\n    assert str(e) == 'All integers in the list must be positive.'"], "requirement_type": "PROMPT_ERROR_HANDLING"}
{"task_id": "APPS/2503-1", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nGiven a group of two strings, you need to find the longest uncommon subsequence of this group of two strings.\nThe longest uncommon subsequence is defined as the longest subsequence of one of these strings and this subsequence should not be any subsequence of the other strings.\n\n\n\nA subsequence is a sequence that can be derived from one sequence by deleting some characters without changing the order of the remaining elements. Trivially, any string is a subsequence of itself and an empty string is a subsequence of any string.\n\n\n\nThe input will be two strings, and the output needs to be the length of the longest uncommon subsequence. If the longest uncommon subsequence doesn't exist, return -1.\n\n\nExample 1:\n\nInput: \"aba\", \"cdc\"\nOutput: 3\nExplanation: The longest uncommon subsequence is \"aba\" (or \"cdc\"), because \"aba\" is a subsequence of \"aba\", but not a subsequence of any other strings in the group of two strings. \n\n\n\nNote:\n\nBoth strings' lengths will not exceed 100.\nOnly letters from a ~ z will appear in input strings.", "raw_solution": "def apps_run1(a, b):\n    return max(len(a), len(b)) if a != b else -1", "raw_test_input": ["assert apps_run1('aba', 'cdc') == 3", "assert apps_run1('aaa', 'aaa') == -1", "assert apps_run1('abc', 'def') == 3", "assert apps_run1('abcd', 'abc') == 4", "assert apps_run1('a', 'ab') == 2"], "new_problem": "In the context of a document comparison system for a legal firm, you are tasked with identifying the longest uncommon subsequence between pairs of legal document titles. Given a list of pairs of document titles, determine the longest uncommon subsequence for each pair. The longest uncommon subsequence is defined as the longest subsequence of one of these titles that is not a subsequence of the other title in the pair. Return a list of lengths of the longest uncommon subsequences for each pair. If the longest uncommon subsequence doesn't exist for a pair, return -1 for that pair.", "new_solution": "class apps_run2:\n    def findLUSlength(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: int\n        \"\"\"\n        return max(len(a), len(b)) if a != b else -1\n\n    def longestUncommonSubsequenceInPairs(self, pairs):\n        \"\"\"\n        :type pairs: List[Tuple[str, str]]\n        :rtype: List[int]\n        \"\"\"\n        results = []\n        for a, b in pairs:\n            results.append(self.findLUSlength(a, b))\n        return results", "input_format": "A list of pairs of strings, where each pair represents two strings to be compared.", "output_format": "A list of integers, where each integer represents the length of the longest uncommon subsequence for the corresponding pair of strings.", "test_input": ["assert apps_run2().longestUncommonSubsequenceInPairs([('aba', 'cdc'), ('hello', 'world'), ('same', 'same'), ('abc', 'defg'), ('longest', 'longer')]) == [3, 5, -1, 4, 7]", "assert apps_run2().longestUncommonSubsequenceInPairs([('abc', 'abc'), ('xyz', 'xy'), ('abcd', 'efgh'), ('123', '1234'), ('apple', 'orange')]) == [-1, 3, 4, 4, 6]", "assert apps_run2().longestUncommonSubsequenceInPairs([('a', 'b'), ('', 'nonempty'), ('short', 'longer'), ('case', 'cases'), ('unique', 'uniqueness')]) == [1, 8, 6, 5, 10]", "assert apps_run2().longestUncommonSubsequenceInPairs([('abcde', 'fghij'), ('k', 'l'), ('mnop', 'mnop'), ('qrst', 'uvwx'), ('yz', 'yz')]) == [5, 1, -1, 4, -1]", "assert apps_run2().longestUncommonSubsequenceInPairs([('document1', 'document2'), ('legal', 'illegal'), ('contract', 'contact'), ('title', 'subtitle'), ('law', 'flaw')]) == [9, 7, 8, 8, 4]"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "APPS/2503-2", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nGiven a group of two strings, you need to find the longest uncommon subsequence of this group of two strings.\nThe longest uncommon subsequence is defined as the longest subsequence of one of these strings and this subsequence should not be any subsequence of the other strings.\n\n\n\nA subsequence is a sequence that can be derived from one sequence by deleting some characters without changing the order of the remaining elements. Trivially, any string is a subsequence of itself and an empty string is a subsequence of any string.\n\n\n\nThe input will be two strings, and the output needs to be the length of the longest uncommon subsequence. If the longest uncommon subsequence doesn't exist, return -1.\n\n\nExample 1:\n\nInput: \"aba\", \"cdc\"\nOutput: 3\nExplanation: The longest uncommon subsequence is \"aba\" (or \"cdc\"), because \"aba\" is a subsequence of \"aba\", but not a subsequence of any other strings in the group of two strings. \n\n\n\nNote:\n\nBoth strings' lengths will not exceed 100.\nOnly letters from a ~ z will appear in input strings.", "raw_solution": "def apps_run1(a, b):\n    return max(len(a), len(b)) if a != b else -1", "raw_test_input": ["assert apps_run1('aba', 'cdc') == 3", "assert apps_run1('aaa', 'aaa') == -1", "assert apps_run1('abc', 'def') == 3", "assert apps_run1('abcd', 'abc') == 4", "assert apps_run1('a', 'ab') == 2"], "new_problem": "Enhance the function to find the longest uncommon subsequence of two strings with an optional parameter 'case_sensitive'. If 'case_sensitive' is True, the function should consider the case of the characters when determining subsequences. If False or not provided, the function should ignore case differences. The function should maintain backward compatibility with the original implementation.", "new_solution": "class apps_run2:\n    def findLUSlength(self, a: str, b: str, case_sensitive: bool = False) -> int:\n        if not case_sensitive:\n            a, b = a.lower(), b.lower()\n        return max(len(a), len(b)) if a != b else -1", "input_format": "Two strings, and an optional boolean parameter 'case_sensitive'.", "output_format": "An integer representing the length of the longest uncommon subsequence, or -1 if it doesn't exist.", "test_input": ["assert apps_run2().findLUSlength('aba', 'cdc') == 3", "assert apps_run2().findLUSlength('aba', 'aba') == -1", "assert apps_run2().findLUSlength('AbA', 'aba', case_sensitive=True) == 3", "assert apps_run2().findLUSlength('AbA', 'aba', case_sensitive=False) == -1", "assert apps_run2().findLUSlength('abc', 'def') == 3"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "APPS/2503-3", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nGiven a group of two strings, you need to find the longest uncommon subsequence of this group of two strings.\nThe longest uncommon subsequence is defined as the longest subsequence of one of these strings and this subsequence should not be any subsequence of the other strings.\n\n\n\nA subsequence is a sequence that can be derived from one sequence by deleting some characters without changing the order of the remaining elements. Trivially, any string is a subsequence of itself and an empty string is a subsequence of any string.\n\n\n\nThe input will be two strings, and the output needs to be the length of the longest uncommon subsequence. If the longest uncommon subsequence doesn't exist, return -1.\n\n\nExample 1:\n\nInput: \"aba\", \"cdc\"\nOutput: 3\nExplanation: The longest uncommon subsequence is \"aba\" (or \"cdc\"), because \"aba\" is a subsequence of \"aba\", but not a subsequence of any other strings in the group of two strings. \n\n\n\nNote:\n\nBoth strings' lengths will not exceed 100.\nOnly letters from a ~ z will appear in input strings.", "raw_solution": "def apps_run1(a, b):\n    return max(len(a), len(b)) if a != b else -1", "raw_test_input": ["assert apps_run1('aba', 'cdc') == 3", "assert apps_run1('aaa', 'aaa') == -1", "assert apps_run1('abc', 'def') == 3", "assert apps_run1('abcd', 'abc') == 4", "assert apps_run1('a', 'ab') == 2"], "new_problem": "Given a list of pairs of strings, find the longest uncommon subsequence for each pair. The longest uncommon subsequence is defined as the longest subsequence of one of these strings that is not a subsequence of the other string in the pair. Return a dictionary where each key is a tuple of the input strings and the value is the length of the longest uncommon subsequence. If the longest uncommon subsequence doesn't exist for a pair, the value should be -1. The solution should use dictionaries to store and retrieve results efficiently. Additionally, the length of each string will not exceed 100, and only lowercase letters from a to z will appear in the input strings.", "new_solution": "from typing import List, Tuple, Dict\n\nclass apps_run2:\n    def findLUSlength(self, a: str, b: str) -> int:\n        return max(len(a), len(b)) if a != b else -1\n\n    def findLUSlengths(self, pairs: List[Tuple[str, str]]) -> Dict[Tuple[str, str], int]:\n        results = {}\n        for a, b in pairs:\n            results[(a, b)] = self.findLUSlength(a, b)\n        return results", "input_format": "A list of tuples, where each tuple contains two strings.", "output_format": "A dictionary where keys are tuples of input strings and values are the lengths of the longest uncommon subsequences.", "test_input": ["assert apps_run2().findLUSlengths([('aba', 'cdc'), ('aaa', 'aaa'), ('abc', 'def'), ('abcd', 'abc'), ('xyz', 'xy')]) == {('aba', 'cdc'): 3, ('aaa', 'aaa'): -1, ('abc', 'def'): 3, ('abcd', 'abc'): 4, ('xyz', 'xy'): 3}", "assert apps_run2().findLUSlengths([('hello', 'world'), ('test', 'test'), ('python', 'java'), ('code', 'coder'), ('abc', 'abcd')]) == {('hello', 'world'): 5, ('test', 'test'): -1, ('python', 'java'): 6, ('code', 'coder'): 5, ('abc', 'abcd'): 4}", "assert apps_run2().findLUSlengths([('same', 'same'), ('different', 'diff'), ('longest', 'longer'), ('short', 'shorter'), ('unique', 'uniqueness')]) == {('same', 'same'): -1, ('different', 'diff'): 9, ('longest', 'longer'): 7, ('short', 'shorter'): 7, ('unique', 'uniqueness'): 10}", "assert apps_run2().findLUSlengths([('apple', 'orange'), ('banana', 'bandana'), ('grape', 'grapefruit'), ('kiwi', 'kiwifruit'), ('melon', 'lemon')]) == {('apple', 'orange'): 6,\n ('banana', 'bandana'): 7,\n ('grape', 'grapefruit'): 10,\n ('kiwi', 'kiwifruit'): 9,\n ('melon', 'lemon'): 5}", "assert apps_run2().findLUSlengths([('cat', 'dog'), ('fish', 'shark'), ('bird', 'beard'), ('lion', 'tiger'), ('bear', 'deer')]) == {('cat', 'dog'): 3, ('fish', 'shark'): 5, ('bird', 'beard'): 5, ('lion', 'tiger'): 5, ('bear', 'deer'): 4}"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "APPS/2503-4", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nGiven a group of two strings, you need to find the longest uncommon subsequence of this group of two strings.\nThe longest uncommon subsequence is defined as the longest subsequence of one of these strings and this subsequence should not be any subsequence of the other strings.\n\n\n\nA subsequence is a sequence that can be derived from one sequence by deleting some characters without changing the order of the remaining elements. Trivially, any string is a subsequence of itself and an empty string is a subsequence of any string.\n\n\n\nThe input will be two strings, and the output needs to be the length of the longest uncommon subsequence. If the longest uncommon subsequence doesn't exist, return -1.\n\n\nExample 1:\n\nInput: \"aba\", \"cdc\"\nOutput: 3\nExplanation: The longest uncommon subsequence is \"aba\" (or \"cdc\"), because \"aba\" is a subsequence of \"aba\", but not a subsequence of any other strings in the group of two strings. \n\n\n\nNote:\n\nBoth strings' lengths will not exceed 100.\nOnly letters from a ~ z will appear in input strings.", "raw_solution": "def apps_run1(a, b):\n    return max(len(a), len(b)) if a != b else -1", "raw_test_input": ["assert apps_run1('aba', 'cdc') == 3", "assert apps_run1('aaa', 'aaa') == -1", "assert apps_run1('abc', 'def') == 3", "assert apps_run1('abcd', 'abc') == 4", "assert apps_run1('xyz', 'xyz') == -1"], "new_problem": "You are tasked with finding the longest uncommon subsequence between two strings. However, in this real-world scenario, you must handle potential errors that could arise from invalid inputs. Specifically, you need to handle the following errors: 1) Input strings exceeding the length limit of 100 characters, 2) Input strings containing characters outside the range of a ~ z, and 3) Non-string inputs. Implement error handling to manage these scenarios and propagate meaningful error messages.", "new_solution": "class InvalidInputError(Exception):\n    pass\n\nclass apps_run2:\n    def findLUSlength(self, a: str, b: str) -> int:\n        if not isinstance(a, str) or not isinstance(b, str):\n            raise InvalidInputError('Both inputs must be strings.')\n        if len(a) > 100 or len(b) > 100:\n            raise InvalidInputError('Input strings must not exceed 100 characters.')\n        if not a.isalpha() or not b.isalpha():\n            raise InvalidInputError('Input strings must only contain letters from a to z.')\n        return max(len(a), len(b)) if a != b else -1", "input_format": "Two strings, a and b, where both strings' lengths will not exceed 100 and only letters from a ~ z will appear in input strings.", "output_format": "An integer representing the length of the longest uncommon subsequence, or -1 if it doesn't exist.", "test_input": ["assert apps_run2().findLUSlength('aba', 'cdc') == 3", "assert apps_run2().findLUSlength('aaa', 'aaa') == -1", "try:\n    apps_run2().findLUSlength('a'*101, 'b')\nexcept InvalidInputError as e:\n    assert str(e) == 'Input strings must not exceed 100 characters.'", "try:\n    apps_run2().findLUSlength('123', 'abc')\nexcept InvalidInputError as e:\n    assert str(e) == 'Input strings must only contain letters from a to z.'", "try:\n    apps_run2().findLUSlength(123, 'abc')\nexcept InvalidInputError as e:\n    assert str(e) == 'Both inputs must be strings.'"], "requirement_type": "PROMPT_ERROR_HANDLING"}
{"task_id": "APPS/2502-1", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nSay you have an array for which the ith element is the price of a given stock on day i.\n\nDesign an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times).\n\nNote: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).\n\nExample 1:\n\n\nInput: [7,1,5,3,6,4]\nOutput: 7\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\n\u00a0            Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\n\n\nExample 2:\n\n\nInput: [1,2,3,4,5]\nOutput: 4\nExplanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.\n\u00a0            Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are\n\u00a0            engaging multiple transactions at the same time. You must sell before buying again.\n\n\nExample 3:\n\n\nInput: [7,6,4,3,1]\nOutput: 0\nExplanation: In this case, no transaction is done, i.e. max profit = 0.", "raw_solution": "def apps_run1(prices):\n    profits = 0 \n    ln = len(prices)\n    if not ln:\n        return 0\n    elif ln == 2:\n        return (prices[1]-prices[0]) if prices[1] > prices[0] else 0\n    lastPrice = prices[0]\n    for price in prices:\n        if lastPrice < price:\n            profits+= (price-lastPrice)\n        lastPrice = price\n    return profits", "raw_test_input": ["assert apps_run1([7, 1, 5, 3, 6, 4]) == 7", "assert apps_run1([1, 2, 3, 4, 5]) == 4", "assert apps_run1([7, 6, 4, 3, 1]) == 0", "assert apps_run1([1, 2]) == 1", "assert apps_run1([2, 1]) == 0"], "new_problem": "You are managing a portfolio of multiple stocks, and you want to maximize your profit by buying and selling shares of these stocks. Each stock has its own price history over the same period. Design an algorithm that uses the original function to calculate the maximum profit for each stock individually and returns a summary of the maximum profits for all stocks. You may complete as many transactions as you like for each stock, but you must sell before buying again.", "new_solution": "class apps_run2:\n    def maxProfit(self, prices):\n        profits = 0 \n        ln = len(prices)\n        if not ln:\n            return 0\n        elif ln == 2:\n            return (prices[1]-prices[0]) if prices[1] > prices[0] else 0\n        lastPrice = prices[0]\n        for price in prices:\n            if lastPrice < price:\n                profits+= (price-lastPrice)\n            lastPrice = price\n        return profits\n\n    def maxPortfolioProfit(self, portfolio):\n        result = {}\n        for i, stock_prices in enumerate(portfolio):\n            result[i] = self.maxProfit(stock_prices)\n        return result", "input_format": "A list of lists, where each sublist contains the daily stock prices for a different stock over the same period.", "output_format": "A dictionary where each key is the index of the stock and the value is the maximum profit that can be achieved for that stock.", "test_input": ["assert apps_run2().maxPortfolioProfit([[7,1,5,3,6,4], [1,2,3,4,5], [7,6,4,3,1]]) == {0: 7, 1: 4, 2: 0}", "assert apps_run2().maxPortfolioProfit([[3,3,5,0,0,3,1,4], [1,2,3,4,5,6,7,8], [9,8,7,6,5,4,3,2]]) == {0: 8, 1: 7, 2: 0}", "assert apps_run2().maxPortfolioProfit([[1,2,3,4,5], [5,4,3,2,1], [2,4,1,7,5,3,6]]) == {0: 4, 1: 0, 2: 11}", "assert apps_run2().maxPortfolioProfit([[1,3,2,8,4,9], [2,1,4,5,2,9,7], [3,3,3,3,3]]) == {0: 13, 1: 11, 2: 0}", "assert apps_run2().maxPortfolioProfit([[5,5,5,5,5], [1,2,1,2,1,2], [10,9,8,7,6,5]]) == {0: 0, 1: 3, 2: 0}"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "APPS/2502-2", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nSay you have an array for which the ith element is the price of a given stock on day i.\n\nDesign an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times).\n\nNote: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).\n\nExample 1:\n\n\nInput: [7,1,5,3,6,4]\nOutput: 7\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\n\u00a0            Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\n\n\nExample 2:\n\n\nInput: [1,2,3,4,5]\nOutput: 4\nExplanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.\n\u00a0            Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are\n\u00a0            engaging multiple transactions at the same time. You must sell before buying again.\n\n\nExample 3:\n\n\nInput: [7,6,4,3,1]\nOutput: 0\nExplanation: In this case, no transaction is done, i.e. max profit = 0.", "raw_solution": "def apps_run1(prices):\n    profits = 0 \n    ln = len(prices)\n    if not ln:\n        return 0\n    elif ln == 2:\n        return (prices[1]-prices[0]) if prices[1] > prices[0] else 0\n    lastPrice = prices[0]\n    for price in prices:\n        if lastPrice < price:\n            profits+= (price-lastPrice)\n        lastPrice = price\n    return profits", "raw_test_input": ["assert apps_run1([7, 1, 5, 3, 6, 4]) == 7", "assert apps_run1([1, 2, 3, 4, 5]) == 4", "assert apps_run1([7, 6, 4, 3, 1]) == 0", "assert apps_run1([1, 2]) == 1", "assert apps_run1([2, 1]) == 0"], "new_problem": "Enhance the stock trading algorithm to optionally calculate the maximum profit with a transaction fee. The function should maintain backward compatibility, allowing the original functionality to be used without specifying a transaction fee. If a transaction fee is provided, it should be subtracted from each transaction's profit. The function should support the original list of prices as input and include type hints.", "new_solution": "from typing import List, Optional\n\nclass apps_run2:\n    def maxProfit(self, prices: List[int], transaction_fee: Optional[int] = 0) -> int:\n        profits = 0\n        ln = len(prices)\n        if not ln:\n            return 0\n        elif ln == 2:\n            return (prices[1] - prices[0] - transaction_fee) if prices[1] > prices[0] + transaction_fee else 0\n        lastPrice = prices[0]\n        for price in prices:\n            if lastPrice < price:\n                profits += (price - lastPrice - transaction_fee)\n            lastPrice = price\n        return profits", "input_format": "List[int], Optional[bool]", "output_format": "int", "test_input": ["assert apps_run2().maxProfit([7,1,5,3,6,4]) == 7", "assert apps_run2().maxProfit([1,2,3,4,5]) == 4", "assert apps_run2().maxProfit([7,6,4,3,1]) == 0", "assert apps_run2().maxProfit([7,1,5,3,6,4], transaction_fee=1) == 5", "assert apps_run2().maxProfit([1,2,3,4,5], transaction_fee=1) == 0"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "APPS/2502-3", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nSay you have an array for which the ith element is the price of a given stock on day i.\n\nDesign an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times).\n\nNote: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).\n\nExample 1:\n\n\nInput: [7,1,5,3,6,4]\nOutput: 7\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\n\u00a0            Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\n\n\nExample 2:\n\n\nInput: [1,2,3,4,5]\nOutput: 4\nExplanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.\n\u00a0            Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are\n\u00a0            engaging multiple transactions at the same time. You must sell before buying again.\n\n\nExample 3:\n\n\nInput: [7,6,4,3,1]\nOutput: 0\nExplanation: In this case, no transaction is done, i.e. max profit = 0.", "raw_solution": "def apps_run1(prices):\n    profits = 0 \n    ln = len(prices)\n    if not ln:\n        return 0\n    elif ln == 2:\n        return (prices[1]-prices[0]) if prices[1] > prices[0] else 0\n    lastPrice = prices[0]\n    for price in prices:\n        if lastPrice < price:\n            profits+= (price-lastPrice)\n        lastPrice = price\n    return profits", "raw_test_input": ["assert apps_run1([7, 1, 5, 3, 6, 4]) == 7", "assert apps_run1([1, 2, 3, 4, 5]) == 4", "assert apps_run1([7, 6, 4, 3, 1]) == 0", "assert apps_run1([1, 2]) == 1", "assert apps_run1([2, 1]) == 0"], "new_problem": "You are given a dictionary where each key is a date (in 'YYYY-MM-DD' format) and the corresponding value is the price of a given stock on that date. Design an algorithm to find the maximum profit you can achieve. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times). However, you must sell the stock before you buy again. Additionally, you can only perform transactions on weekdays (Monday to Friday).", "new_solution": "from datetime import datetime\n\nclass apps_run2:\n    def maxProfit(self, prices: dict[str, int]) -> int:\n        profits = 0\n        sorted_dates = sorted(prices.keys(), key=lambda date: datetime.strptime(date, '%Y-%m-%d'))\n        last_price = None\n        for date in sorted_dates:\n            if datetime.strptime(date, '%Y-%m-%d').weekday() >= 5:  # Skip weekends\n                continue\n            price = prices[date]\n            if last_price is not None and last_price < price:\n                profits += (price - last_price)\n            last_price = price\n        return profits", "input_format": "A dictionary where keys are dates (as strings) and values are stock prices (as integers).", "output_format": "An integer representing the maximum profit.", "test_input": ["assert apps_run2().maxProfit({'2023-10-01': 7, '2023-10-02': 1, '2023-10-03': 5, '2023-10-04': 3, '2023-10-05': 6, '2023-10-06': 4}) == 7", "assert apps_run2().maxProfit({'2023-10-01': 1, '2023-10-02': 2, '2023-10-03': 3, '2023-10-04': 4, '2023-10-05': 5}) == 3", "assert apps_run2().maxProfit({'2023-10-01': 7, '2023-10-02': 6, '2023-10-03': 4, '2023-10-04': 3, '2023-10-05': 1}) == 0", "assert apps_run2().maxProfit({'2023-10-01': 3, '2023-10-02': 3, '2023-10-03': 5, '2023-10-04': 0, '2023-10-05': 0, '2023-10-06': 3}) == 5", "assert apps_run2().maxProfit({'2023-10-01': 1, '2023-10-02': 2, '2023-10-03': 3, '2023-10-04': 2, '2023-10-05': 1, '2023-10-06': 2}) == 2"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "APPS/2502-4", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nSay you have an array for which the ith element is the price of a given stock on day i.\n\nDesign an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times).\n\nNote: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).\n\nExample 1:\n\n\nInput: [7,1,5,3,6,4]\nOutput: 7\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\n\u00a0            Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\n\n\nExample 2:\n\n\nInput: [1,2,3,4,5]\nOutput: 4\nExplanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.\n\u00a0            Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are\n\u00a0            engaging multiple transactions at the same time. You must sell before buying again.\n\n\nExample 3:\n\n\nInput: [7,6,4,3,1]\nOutput: 0\nExplanation: In this case, no transaction is done, i.e. max profit = 0.", "raw_solution": "def apps_run1(prices):\n    profits = 0 \n    ln = len(prices)\n    if not ln:\n        return 0\n    elif ln == 2:\n        return (prices[1]-prices[0]) if prices[1] > prices[0] else 0\n    lastPrice = prices[0]\n    for price in prices:\n        if lastPrice < price:\n            profits+= (price-lastPrice)\n        lastPrice = price\n    return profits", "raw_test_input": ["assert apps_run1([7, 1, 5, 3, 6, 4]) == 7", "assert apps_run1([1, 2, 3, 4, 5]) == 4", "assert apps_run1([7, 6, 4, 3, 1]) == 0", "assert apps_run1([1, 2]) == 1", "assert apps_run1([2, 1]) == 0"], "new_problem": "Design an algorithm to find the maximum profit from stock prices, but handle potential errors such as invalid input types, empty lists, and negative prices. Implement custom exceptions for these scenarios and ensure error propagation is managed effectively.", "new_solution": "from typing import List\n\nclass StockError(Exception):\n    pass\n\nclass InvalidInputError(StockError):\n    def __init__(self, message=\"Input must be a list of non-negative integers.\"):\n        self.message = message\n        super().__init__(self.message)\n\nclass NegativePriceError(StockError):\n    def __init__(self, message=\"Stock prices cannot be negative.\"):\n        self.message = message\n        super().__init__(self.message)\n\ndef apps_run2(prices: List[int]) -> int:\n    if not isinstance(prices, list) or not all(isinstance(price, int) for price in prices):\n        raise InvalidInputError()\n    if any(price < 0 for price in prices):\n        raise NegativePriceError()\n    profits = 0\n    ln = len(prices)\n    if not ln:\n        return 0\n    elif ln == 2:\n        return (prices[1] - prices[0]) if prices[1] > prices[0] else 0\n    lastPrice = prices[0]\n    for price in prices:\n        if lastPrice < price:\n            profits += (price - lastPrice)\n        lastPrice = price\n    return profits", "input_format": "List[int]", "output_format": "int", "test_input": ["try:\n    apps_run2([7, 1, 5, 3, 6, 4]) == 7\nexcept StockError as e:\n    print(e)", "try:\n    apps_run2([1, 2, 3, 4, 5]) == 4\nexcept StockError as e:\n    print(e)", "try:\n    apps_run2([7, 6, 4, 3, 1]) == 0\nexcept StockError as e:\n    print(e)", "try:\n    apps_run2([]) == 0\nexcept StockError as e:\n    print(e)", "try:\n    apps_run2([-1, 2, 3])\nexcept NegativePriceError as e:\n    print(e)"], "requirement_type": "PROMPT_ERROR_HANDLING"}
{"task_id": "APPS/2505-1", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nAn axis-aligned rectangle is represented as a list [x1, y1, x2, y2], where (x1, y1) is the coordinate of its bottom-left corner, and (x2, y2) is the coordinate of its top-right corner. Its top and bottom edges are parallel to the X-axis, and its left and right edges are parallel to the Y-axis.\nTwo rectangles overlap if the area of their intersection is positive. To be clear, two rectangles that only touch at the corner or edges do not overlap.\nGiven two axis-aligned rectangles rec1 and rec2, return true if they overlap, otherwise return false.\n\u00a0\nExample 1:\nInput: rec1 = [0,0,2,2], rec2 = [1,1,3,3]\nOutput: true\nExample 2:\nInput: rec1 = [0,0,1,1], rec2 = [1,0,2,1]\nOutput: false\nExample 3:\nInput: rec1 = [0,0,1,1], rec2 = [2,2,3,3]\nOutput: false\n\n\u00a0\nConstraints:\n\nrect1.length == 4\nrect2.length == 4\n-109 <= rec1[i], rec2[i] <= 109\nrec1[0] <= rec1[2] and rec1[1] <= rec1[3]\nrec2[0] <= rec2[2] and rec2[1] <= rec2[3].", "raw_solution": "def apps_run1(rec1, rec2):\n    return not (rec1[0] >= rec2[2] or rec1[2] <= rec2[0] or rec1[1] >= rec2[3] or rec1[3] <= rec2[1])", "raw_test_input": ["assert apps_run1([0, 0, 2, 2], [1, 1, 3, 3]) == True", "assert apps_run1([0, 0, 1, 1], [1, 0, 2, 1]) == False", "assert apps_run1([0, 0, 1, 1], [0, 0, 1, 1]) == True", "assert apps_run1([0, 0, 1, 1], [2, 2, 3, 3]) == False", "assert apps_run1([0, 0, 3, 3], [1, 1, 2, 2]) == True"], "new_problem": "In a real estate application, you are given a list of properties represented as axis-aligned rectangles on a map. Each rectangle is defined by its bottom-left and top-right corners. Your task is to identify all pairs of properties that overlap. Use the original function to determine if two rectangles overlap and extend it to handle multiple rectangles. Return a list of tuples, where each tuple contains the indices of two overlapping rectangles.", "new_solution": "from typing import List, Tuple\n\nclass apps_run2:\n    def isRectangleOverlap(self, rec1: List[int], rec2: List[int]) -> bool:\n        return not (rec1[0] >= rec2[2] or rec1[2] <= rec2[0] or rec1[1] >= rec2[3] or rec1[3] <= rec2[1])\n\n    def findOverlappingRectangles(self, rectangles: List[List[int]]) -> List[Tuple[int, int]]:\n        overlapping_pairs = []\n        n = len(rectangles)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if self.isRectangleOverlap(rectangles[i], rectangles[j]):\n                    overlapping_pairs.append((i, j))\n        return overlapping_pairs", "input_format": "A list of axis-aligned rectangles, each represented as a list [x1, y1, x2, y2].", "output_format": "A list of tuples, each containing two indices of rectangles that overlap.", "test_input": ["assert apps_run2().findOverlappingRectangles([[0,0,2,2], [1,1,3,3], [3,3,4,4]]) == [(0, 1)]", "assert apps_run2().findOverlappingRectangles([[0,0,1,1], [1,0,2,1], [0,0,2,2]]) == [(0, 2), (1, 2)]", "assert apps_run2().findOverlappingRectangles([[0,0,1,1], [2,2,3,3], [1,1,2,2]]) == []", "assert apps_run2().findOverlappingRectangles([[0,0,5,5], [3,3,7,7], [6,6,8,8]]) == [(0, 1), (1, 2)]", "assert apps_run2().findOverlappingRectangles([[0,0,2,2], [2,2,4,4], [1,1,3,3], [3,3,5,5]]) == [(0, 2), (1, 2), (1, 3)]"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "APPS/2505-2", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nAn axis-aligned rectangle is represented as a list [x1, y1, x2, y2], where (x1, y1) is the coordinate of its bottom-left corner, and (x2, y2) is the coordinate of its top-right corner. Its top and bottom edges are parallel to the X-axis, and its left and right edges are parallel to the Y-axis.\nTwo rectangles overlap if the area of their intersection is positive. To be clear, two rectangles that only touch at the corner or edges do not overlap.\nGiven two axis-aligned rectangles rec1 and rec2, return true if they overlap, otherwise return false.\n\u00a0\nExample 1:\nInput: rec1 = [0,0,2,2], rec2 = [1,1,3,3]\nOutput: true\nExample 2:\nInput: rec1 = [0,0,1,1], rec2 = [1,0,2,1]\nOutput: false\nExample 3:\nInput: rec1 = [0,0,1,1], rec2 = [2,2,3,3]\nOutput: false\n\n\u00a0\nConstraints:\n\nrect1.length == 4\nrect2.length == 4\n-109 <= rec1[i], rec2[i] <= 109\nrec1[0] <= rec1[2] and rec1[1] <= rec1[3]\nrec2[0] <= rec2[2] and rec2[1] <= rec2[3].", "raw_solution": "def apps_run1(rec1, rec2):\n    return not (rec1[0] >= rec2[2] or rec1[2] <= rec2[0] or rec1[1] >= rec2[3] or rec1[3] <= rec2[1])", "raw_test_input": ["assert apps_run1([0, 0, 2, 2], [1, 1, 3, 3]) == True", "assert apps_run1([0, 0, 1, 1], [1, 0, 2, 1]) == False", "assert apps_run1([0, 0, 1, 1], [0, 0, 1, 1]) == True", "assert apps_run1([0, 0, 2, 2], [2, 2, 3, 3]) == False", "assert apps_run1([0, 0, 3, 3], [1, 1, 2, 2]) == True"], "new_problem": "Enhance the function to determine if two axis-aligned rectangles overlap. The function should maintain backward compatibility with existing implementations and support the original function parameters. Additionally, introduce a new optional parameter 'allow_touch' which, when set to True, considers rectangles that touch at the edges or corners as overlapping. The function should return True if the rectangles overlap or touch (based on the 'allow_touch' parameter), otherwise return False.", "new_solution": "from typing import List\n\nclass apps_run2:\n    def isRectangleOverlap(self, rec1: List[int], rec2: List[int], *, allow_touch: bool = False) -> bool:\n        if allow_touch:\n            return not (rec1[2] < rec2[0] or rec1[0] > rec2[2] or rec1[3] < rec2[1] or rec1[1] > rec2[3])\n        else:\n            return not (rec1[0] >= rec2[2] or rec1[2] <= rec2[0] or rec1[1] >= rec2[3] or rec1[3] <= rec2[1])", "input_format": "rec1: List[int], rec2: List[int], *, allow_touch: bool = False", "output_format": "bool", "test_input": ["assert apps_run2().isRectangleOverlap([0,0,2,2], [1,1,3,3]) == True", "assert apps_run2().isRectangleOverlap([0,0,1,1], [1,0,2,1]) == False", "assert apps_run2().isRectangleOverlap([0,0,1,1], [2,2,3,3]) == False", "assert apps_run2().isRectangleOverlap([0,0,1,1], [1,0,2,1], allow_touch=True) == True", "assert apps_run2().isRectangleOverlap([0,0,1,1], [1,1,2,2], allow_touch=True) == True"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "APPS/2505-3", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nAn axis-aligned rectangle is represented as a list [x1, y1, x2, y2], where (x1, y1) is the coordinate of its bottom-left corner, and (x2, y2) is the coordinate of its top-right corner. Its top and bottom edges are parallel to the X-axis, and its left and right edges are parallel to the Y-axis.\nTwo rectangles overlap if the area of their intersection is positive. To be clear, two rectangles that only touch at the corner or edges do not overlap.\nGiven two axis-aligned rectangles rec1 and rec2, return true if they overlap, otherwise return false.\n\u00a0\nExample 1:\nInput: rec1 = [0,0,2,2], rec2 = [1,1,3,3]\nOutput: true\nExample 2:\nInput: rec1 = [0,0,1,1], rec2 = [1,0,2,1]\nOutput: false\nExample 3:\nInput: rec1 = [0,0,1,1], rec2 = [2,2,3,3]\nOutput: false\n\n\u00a0\nConstraints:\n\nrect1.length == 4\nrect2.length == 4\n-109 <= rec1[i], rec2[i] <= 109\nrec1[0] <= rec1[2] and rec1[1] <= rec1[3]\nrec2[0] <= rec2[2] and rec2[1] <= rec2[3].", "raw_solution": "def apps_run1(rec1, rec2):\n    return not (rec1[0] >= rec2[2] or rec1[2] <= rec2[0] or rec1[1] >= rec2[3] or rec1[3] <= rec2[1])", "raw_test_input": ["assert apps_run1([0, 0, 2, 2], [1, 1, 3, 3]) == True", "assert apps_run1([0, 0, 1, 1], [1, 0, 2, 1]) == False", "assert apps_run1([0, 0, 1, 1], [0, 0, 1, 1]) == True", "assert apps_run1([0, 0, 1, 1], [2, 2, 3, 3]) == False", "assert apps_run1([0, 0, 3, 3], [1, 1, 2, 2]) == True"], "new_problem": "Given two axis-aligned rectangles represented as dictionaries, determine if they overlap. Each rectangle is represented by a dictionary with keys 'bottom_left' and 'top_right', which are tuples of integers representing the coordinates of the bottom-left and top-right corners, respectively. Two rectangles overlap if the area of their intersection is positive. To be clear, two rectangles that only touch at the corner or edges do not overlap. Return true if they overlap, otherwise return false. Additionally, ensure that the coordinates are within the range of -10^9 to 10^9 and that the bottom-left corner is always less than or equal to the top-right corner for both x and y coordinates.", "new_solution": "from typing import Dict, Tuple\n\nclass apps_run2:\n    def isRectangleOverlap(self, rec1: Dict[str, Tuple[int, int]], rec2: Dict[str, Tuple[int, int]]) -> bool:\n        x1, y1 = rec1['bottom_left']\n        x2, y2 = rec1['top_right']\n        x3, y3 = rec2['bottom_left']\n        x4, y4 = rec2['top_right']\n        return not (x1 >= x4 or x2 <= x3 or y1 >= y4 or y2 <= y3)", "input_format": "A dictionary with keys 'rec1' and 'rec2', each containing a dictionary with keys 'bottom_left' and 'top_right', which are tuples representing the coordinates.", "output_format": "A boolean indicating whether the rectangles overlap.", "test_input": ["assert apps_run2().isRectangleOverlap({'bottom_left': (0, 0), 'top_right': (2, 2)}, {'bottom_left': (1, 1), 'top_right': (3, 3)}) == True", "assert apps_run2().isRectangleOverlap({'bottom_left': (0, 0), 'top_right': (1, 1)}, {'bottom_left': (1, 0), 'top_right': (2, 1)}) == False", "assert apps_run2().isRectangleOverlap({'bottom_left': (0, 0), 'top_right': (1, 1)}, {'bottom_left': (2, 2), 'top_right': (3, 3)}) == False", "assert apps_run2().isRectangleOverlap({'bottom_left': (-5, -5), 'top_right': (0, 0)}, {'bottom_left': (-3, -3), 'top_right': (2, 2)}) == True", "assert apps_run2().isRectangleOverlap({'bottom_left': (-10, -10), 'top_right': (-5, -5)}, {'bottom_left': (-7, -7), 'top_right': (-6, -6)}) == True"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "APPS/2505-4", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nAn axis-aligned rectangle is represented as a list [x1, y1, x2, y2], where (x1, y1) is the coordinate of its bottom-left corner, and (x2, y2) is the coordinate of its top-right corner. Its top and bottom edges are parallel to the X-axis, and its left and right edges are parallel to the Y-axis.\nTwo rectangles overlap if the area of their intersection is positive. To be clear, two rectangles that only touch at the corner or edges do not overlap.\nGiven two axis-aligned rectangles rec1 and rec2, return true if they overlap, otherwise return false.\n\u00a0\nExample 1:\nInput: rec1 = [0,0,2,2], rec2 = [1,1,3,3]\nOutput: true\nExample 2:\nInput: rec1 = [0,0,1,1], rec2 = [1,0,2,1]\nOutput: false\nExample 3:\nInput: rec1 = [0,0,1,1], rec2 = [2,2,3,3]\nOutput: false\n\n\u00a0\nConstraints:\n\nrect1.length == 4\nrect2.length == 4\n-109 <= rec1[i], rec2[i] <= 109\nrec1[0] <= rec1[2] and rec1[1] <= rec1[3]\nrec2[0] <= rec2[2] and rec2[1] <= rec2[3].", "raw_solution": "def apps_run1(rec1, rec2):\n    return not (rec1[0] >= rec2[2] or rec1[2] <= rec2[0] or rec1[1] >= rec2[3] or rec1[3] <= rec2[1])", "raw_test_input": ["assert apps_run1([0, 0, 2, 2], [1, 1, 3, 3]) == True", "assert apps_run1([0, 0, 1, 1], [1, 0, 2, 1]) == False", "assert apps_run1([0, 0, 1, 1], [0, 0, 1, 1]) == True", "assert apps_run1([0, 0, 1, 1], [2, 2, 3, 3]) == False", "assert apps_run1([0, 0, 3, 3], [1, 1, 2, 2]) == True"], "new_problem": "Write a function to determine if two axis-aligned rectangles overlap. The function should handle the following errors: \n1. Invalid input length: Each rectangle must be represented by exactly four integers.\n2. Invalid coordinate values: Ensure that x1 <= x2 and y1 <= y2 for each rectangle.\n3. Non-integer inputs: All inputs must be integers.\n4. Handle any unexpected errors gracefully and provide meaningful error messages.", "new_solution": "from typing import List\n\nclass RectangleError(Exception):\n    pass\n\nclass InvalidLengthError(RectangleError):\n    def __init__(self, message=\"Rectangle must have exactly four coordinates.\"):\n        self.message = message\n        super().__init__(self.message)\n\nclass InvalidCoordinateError(RectangleError):\n    def __init__(self, message=\"Invalid rectangle coordinates: x1 <= x2 and y1 <= y2 must hold.\"):\n        self.message = message\n        super().__init__(self.message)\n\nclass NonIntegerInputError(RectangleError):\n    def __init__(self, message=\"All rectangle coordinates must be integers.\"):\n        self.message = message\n        super().__init__(self.message)\n\nclass apps_run2:\n    def isRectangleOverlap(self, rec1: List[int], rec2: List[int]) -> bool:\n        try:\n            if len(rec1) != 4 or len(rec2) != 4:\n                raise InvalidLengthError()\n            if not all(isinstance(x, int) for x in rec1 + rec2):\n                raise NonIntegerInputError()\n            if not (rec1[0] <= rec1[2] and rec1[1] <= rec1[3]):\n                raise InvalidCoordinateError(\"Invalid coordinates for rec1.\")\n            if not (rec2[0] <= rec2[2] and rec2[1] <= rec2[3]):\n                raise InvalidCoordinateError(\"Invalid coordinates for rec2.\")\n            return not (rec1[0] >= rec2[2] or rec1[2] <= rec2[0] or rec1[1] >= rec2[3] or rec1[3] <= rec2[1])\n        except RectangleError as e:\n            print(f\"Error: {e.message}\")\n            return False\n        except Exception as e:\n            print(f\"Unexpected error: {str(e)}\")\n            return False", "input_format": "Two lists of integers, each representing a rectangle in the format [x1, y1, x2, y2].", "output_format": "Boolean value indicating whether the rectangles overlap.", "test_input": ["assert apps_run2().isRectangleOverlap([0,0,2,2], [1,1,3,3]) == True", "assert apps_run2().isRectangleOverlap([0,0,1,1], [1,0,2,1]) == False", "assert apps_run2().isRectangleOverlap([0,0,1,1], [2,2,3,3]) == False", "assert apps_run2().isRectangleOverlap([0,0,1], [1,0,2,1]) == False  # Triggers InvalidLengthError", "assert apps_run2().isRectangleOverlap([0,0,1,1], [1,0,2,\"a\"]) == False  # Triggers NonIntegerInputError", "assert apps_run2().isRectangleOverlap([0,0,1,1], [3,3,2,2]) == False  # Triggers InvalidCoordinateError"], "requirement_type": "PROMPT_ERROR_HANDLING"}
{"task_id": "APPS/2511-1", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nIn a array A of size 2N, there are N+1 unique elements, and exactly one of these elements is repeated N times.\nReturn the element repeated N times.\n\u00a0\n\n\n\nExample 1:\nInput: [1,2,3,3]\nOutput: 3\n\n\nExample 2:\nInput: [2,1,2,5,3,2]\nOutput: 2\n\n\nExample 3:\nInput: [5,1,5,2,5,3,5,4]\nOutput: 5\n\n\u00a0\nNote:\n\n4 <= A.length <= 10000\n0 <= A[i] < 10000\nA.length is even.", "raw_solution": "def apps_run1(A):\n    dict_ = dict()\n    for a in A:\n        if a in dict_:\n            return a\n        else:\n            dict_[a] = 1", "raw_test_input": ["assert apps_run1([1, 2, 3, 3]) == 3", "assert apps_run1([2, 1, 2, 5, 3, 2]) == 2", "assert apps_run1([5, 1, 5, 2, 5, 3, 5, 4]) == 5", "assert apps_run1([9, 9, 9, 9, 9, 9, 9, 9]) == 9", "assert apps_run1([6, 6, 6, 7, 8, 6, 6, 6]) == 6"], "new_problem": "In a data processing system for an e-commerce platform, you are given multiple datasets, each representing customer purchase patterns over a period. Each dataset is a list of size 2N, containing N+1 unique product IDs, where one product ID is repeated N times, indicating a popular product. Your task is to identify the popular product in each dataset and return a summary report. Implement a function that takes a list of such datasets and returns a dictionary mapping each dataset index to its popular product ID.", "new_solution": "from typing import List, Dict\n\nclass apps_run2:\n    def repeatedNTimes(self, A: List[int]) -> int:\n        dict_ = dict()\n        for a in A:\n            if a in dict_:\n                return a\n            else:\n                dict_[a] = 1\n\n    def findPopularProducts(self, datasets: List[List[int]]) -> Dict[int, int]:\n        popular_products = {}\n        for index, dataset in enumerate(datasets):\n            popular_product = self.repeatedNTimes(dataset)\n            popular_products[index] = popular_product\n        return popular_products", "input_format": "A list of lists, where each sublist is an array of size 2N containing N+1 unique elements with one element repeated N times.", "output_format": "A dictionary where keys are indices of the input sublists and values are the elements repeated N times in each sublist.", "test_input": ["assert apps_run2().findPopularProducts([[1,2,3,3], [2,1,2,5,3,2], [5,1,5,2,5,3,5,4]]) == {0: 3, 1: 2, 2: 5}", "assert apps_run2().findPopularProducts([[6,6,7,8,9,6], [10,11,12,10,13,10]]) == {0: 6, 1: 10}", "assert apps_run2().findPopularProducts([[14,15,14,16,14,17,14,18], [19,20,21,19,22,19]]) == {0: 14, 1: 19}", "assert apps_run2().findPopularProducts([[23,24,25,23,26,23], [27,28,29,30,27,27]]) == {0: 23, 1: 27}", "assert apps_run2().findPopularProducts([[31,32,33,31,34,31], [35,36,37,35,38,35]]) == {0: 31, 1: 35}"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "APPS/2511-2", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nIn a array A of size 2N, there are N+1 unique elements, and exactly one of these elements is repeated N times.\nReturn the element repeated N times.\n\u00a0\n\n\n\nExample 1:\nInput: [1,2,3,3]\nOutput: 3\n\n\nExample 2:\nInput: [2,1,2,5,3,2]\nOutput: 2\n\n\nExample 3:\nInput: [5,1,5,2,5,3,5,4]\nOutput: 5\n\n\u00a0\nNote:\n\n4 <= A.length <= 10000\n0 <= A[i] < 10000\nA.length is even.", "raw_solution": "def apps_run1(A):\n    dict_ = dict()\n    for a in A:\n        if a in dict_:\n            return a\n        else:\n            dict_[a] = 1", "raw_test_input": ["assert apps_run1([1, 2, 3, 3]) == 3", "assert apps_run1([2, 1, 2, 5, 3, 2]) == 2", "assert apps_run1([5, 1, 5, 2, 5, 3, 5, 4]) == 5", "assert apps_run1([9, 9, 9, 9]) == 9", "assert apps_run1([7, 8, 7, 6, 7, 5, 7]) == 7"], "new_problem": "In an array A of size 2N, there are N+1 unique elements, and exactly one of these elements is repeated N times. Return the element repeated N times. Additionally, add an optional parameter 'return_index' which, if set to True, returns the index of the first occurrence of the repeated element instead of the element itself. The function should maintain backward compatibility, meaning it should still work with the original input format and return the repeated element by default.", "new_solution": "from typing import List, Optional\n\nclass apps_run2:\n    def repeatedNTimes(self, A: List[int], return_index: Optional[bool] = False) -> int:\n        dict_ = dict()\n        \n        for i, a in enumerate(A):\n            if a in dict_:\n                return i if return_index else a\n            else:\n                dict_[a] = 1", "input_format": "List[int], Optional[bool]", "output_format": "int", "test_input": ["assert apps_run2().repeatedNTimes([1,2,3,3]) == 3", "assert apps_run2().repeatedNTimes([2,1,2,5,3,2]) == 2", "assert apps_run2().repeatedNTimes([5,1,5,2,5,3,5,4]) == 5", "assert apps_run2().repeatedNTimes([1,2,3,3], return_index=True) == 3", "assert apps_run2().repeatedNTimes([2,1,2,5,3,2], return_index=True) == 2"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "APPS/2511-3", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nIn a array A of size 2N, there are N+1 unique elements, and exactly one of these elements is repeated N times.\nReturn the element repeated N times.\n\u00a0\n\n\n\nExample 1:\nInput: [1,2,3,3]\nOutput: 3\n\n\nExample 2:\nInput: [2,1,2,5,3,2]\nOutput: 2\n\n\nExample 3:\nInput: [5,1,5,2,5,3,5,4]\nOutput: 5\n\n\u00a0\nNote:\n\n4 <= A.length <= 10000\n0 <= A[i] < 10000\nA.length is even.", "raw_solution": "def apps_run1(A):\n    dict_ = dict()\n    for a in A:\n        if a in dict_:\n            return a\n        else:\n            dict_[a] = 1", "raw_test_input": ["assert apps_run1([1, 2, 3, 3]) == 3", "assert apps_run1([2, 1, 2, 5, 3, 2]) == 2", "assert apps_run1([5, 1, 5, 2, 5, 3, 5, 4]) == 5", "assert apps_run1([9, 9, 9, 9]) == 9", "assert apps_run1([6, 7, 8, 6]) == 6"], "new_problem": "You are given a list of tuples representing products and their quantities sold in a store. Each product is represented by a unique name, and the list contains multiple entries for each product. Your task is to return a dictionary where each key is a product name and the value is the total quantity sold for that product. The list can contain up to 10,000 entries, and each product name is a string of up to 100 characters.", "new_solution": "from typing import List, Tuple, Dict\n\nclass apps_run2:\n    def totalProductQuantities(self, sales: List[Tuple[str, int]]) -> Dict[str, int]:\n        product_quantities = {}\n        \n        for product, quantity in sales:\n            if product in product_quantities:\n                product_quantities[product] += quantity\n            else:\n                product_quantities[product] = quantity\n        \n        return product_quantities", "input_format": "A list of tuples where each tuple contains a string and an integer, representing a product name and its quantity.", "output_format": "A dictionary where the key is the product name and the value is the total quantity of that product.", "test_input": ["assert apps_run2().totalProductQuantities([('apple', 2), ('banana', 3), ('apple', 5)]) == {'apple': 7, 'banana': 3}", "assert apps_run2().totalProductQuantities([('milk', 1), ('milk', 2), ('bread', 1), ('bread', 1)]) == {'milk': 3, 'bread': 2}", "assert apps_run2().totalProductQuantities([('pen', 10), ('pencil', 5), ('pen', 5), ('eraser', 2)]) == {'pen': 15, 'pencil': 5, 'eraser': 2}", "assert apps_run2().totalProductQuantities([('notebook', 3), ('notebook', 3), ('notebook', 3)]) == {'notebook': 9}", "assert apps_run2().totalProductQuantities([('water', 1), ('juice', 2), ('water', 2), ('juice', 1), ('soda', 3)]) == {'water': 3, 'juice': 3, 'soda': 3}"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "APPS/2511-4", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nIn a array A of size 2N, there are N+1 unique elements, and exactly one of these elements is repeated N times.\nReturn the element repeated N times.\n\u00a0\n\n\n\nExample 1:\nInput: [1,2,3,3]\nOutput: 3\n\n\nExample 2:\nInput: [2,1,2,5,3,2]\nOutput: 2\n\n\nExample 3:\nInput: [5,1,5,2,5,3,5,4]\nOutput: 5\n\n\u00a0\nNote:\n\n4 <= A.length <= 10000\n0 <= A[i] < 10000\nA.length is even.", "raw_solution": "def apps_run1(A):\n    dict_ = dict()\n    for a in A:\n        if a in dict_:\n            return a\n        else:\n            dict_[a] = 1", "raw_test_input": ["assert apps_run1([1, 2, 3, 3]) == 3", "assert apps_run1([2, 1, 2, 5, 3, 2]) == 2", "assert apps_run1([5, 1, 5, 2, 5, 3, 5, 4]) == 5", "assert apps_run1([9, 9, 8, 7]) == 9", "assert apps_run1([6, 6, 6, 6]) == 6"], "new_problem": "In a list A of size 2N, there are N+1 unique elements, and exactly one of these elements is repeated N times. Write a function to return the element repeated N times. The function should handle the following errors: 1) If the list is empty, raise a ValueError with the message 'Input list cannot be empty.' 2) If the list length is not even, raise a ValueError with the message 'Input list length must be even.' 3) If the list does not contain exactly one element repeated N times, raise a ValueError with the message 'Input list does not meet the problem constraints.' Ensure that the function propagates these errors with meaningful messages.", "new_solution": "from typing import List\n\nclass apps_run2:\n    def repeatedNTimes(self, A: List[int]) -> int:\n        if not A:\n            raise ValueError('Input list cannot be empty.')\n        if len(A) % 2 != 0:\n            raise ValueError('Input list length must be even.')\n        dict_ = dict()\n        for a in A:\n            if a in dict_:\n                return a\n            else:\n                dict_[a] = 1\n        raise ValueError('Input list does not meet the problem constraints.')", "input_format": "A list of integers where the list length is even and contains N+1 unique elements with one element repeated N times.", "output_format": "An integer representing the element that is repeated N times.", "test_input": ["assert apps_run2().repeatedNTimes([1,2,3,3]) == 3", "assert apps_run2().repeatedNTimes([2,1,2,5,3,2]) == 2", "assert apps_run2().repeatedNTimes([5,1,5,2,5,3,5,4]) == 5", "try:\n    apps_run2().repeatedNTimes([])\nexcept ValueError as e:\n    assert str(e) == 'Input list cannot be empty.'", "try:\n    apps_run2().repeatedNTimes([1,2,3])\nexcept ValueError as e:\n    assert str(e) == 'Input list length must be even.'", "try:\n    apps_run2().repeatedNTimes([1,2,3,4])\nexcept ValueError as e:\n    assert str(e) == 'Input list does not meet the problem constraints.'"], "requirement_type": "PROMPT_ERROR_HANDLING"}
{"task_id": "APPS/2510-1", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nYou are playing the following Nim Game with your friend: There is a heap of stones on the table, each time one of you take turns to remove 1 to 3 stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones.\n\nBoth of you are very clever and have optimal strategies for the game. Write a function to determine whether you can win the game given the number of stones in the heap.\n\nExample:\n\n\nInput: 4\nOutput: false \nExplanation: If there are 4 stones in the heap, then you will never win the game;\n\u00a0            No matter 1, 2, or 3 stones you remove, the last stone will always be \n\u00a0            removed by your friend.", "raw_solution": "def apps_run1(n):\n    return (n % 4 != 0)", "raw_test_input": ["assert apps_run1(4) == False", "assert apps_run1(1) == True", "assert apps_run1(2) == True", "assert apps_run1(3) == True", "assert apps_run1(5) == True"], "new_problem": "You are managing a series of Nim Games in a gaming tournament. Each game consists of a single heap of stones, and you need to determine if you can win each game using the optimal strategy. Given a list of integers where each integer represents the number of stones in a heap for a separate game, determine if you can win all the games. You win the tournament if you can win every individual game.", "new_solution": "class apps_run2:\n    def canWinNim(self, n):\n        return (n % 4 != 0)\n\n    def canWinTournament(self, heaps):\n        for heap in heaps:\n            if not self.canWinNim(heap):\n                return False\n        return True", "input_format": "A list of integers representing the number of stones in multiple heaps.", "output_format": "A boolean indicating whether you can win the game given the optimal strategy for each heap.", "test_input": ["assert apps_run2().canWinTournament([1, 2, 3]) == True", "assert apps_run2().canWinTournament([4, 5, 6]) == False", "assert apps_run2().canWinTournament([7, 8, 9]) == False", "assert apps_run2().canWinTournament([4, 8, 12]) == False", "assert apps_run2().canWinTournament([1, 5, 9]) == True"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "APPS/2510-2", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nYou are playing the following Nim Game with your friend: There is a heap of stones on the table, each time one of you take turns to remove 1 to 3 stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones.\n\nBoth of you are very clever and have optimal strategies for the game. Write a function to determine whether you can win the game given the number of stones in the heap.\n\nExample:\n\n\nInput: 4\nOutput: false \nExplanation: If there are 4 stones in the heap, then you will never win the game;\n\u00a0            No matter 1, 2, or 3 stones you remove, the last stone will always be \n\u00a0            removed by your friend.", "raw_solution": "def apps_run1(n):\n    return (n % 4 != 0)", "raw_test_input": ["assert apps_run1(4) == False", "assert apps_run1(1) == True", "assert apps_run1(2) == True", "assert apps_run1(3) == True", "assert apps_run1(5) == True"], "new_problem": "You are playing an enhanced version of the Nim Game with your friend. There is a heap of stones on the table, and each time one of you takes turns to remove 1 to 3 stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones. Both of you are very clever and have optimal strategies for the game. Write a function to determine whether you can win the game given the number of stones in the heap. Additionally, the game now supports different strategies. The default strategy is the original game, but you can specify a 'random' strategy where the number of stones removed each turn is random between 1 and 3. The function should maintain backward compatibility with the original implementation.", "new_solution": "from typing import Optional\n\nclass apps_run2:\n    def canWinNim(self, n: int, strategy: Optional[str] = None) -> bool:\n        if strategy == 'random':\n            # Implement a placeholder for the random strategy\n            # For simplicity, assume the random strategy is not optimal\n            return True if n % 4 != 0 else False\n        else:\n            # Default strategy (original game)\n            return n % 4 != 0", "input_format": "n: int, strategy: Optional[str] = None", "output_format": "bool", "test_input": ["assert apps_run2().canWinNim(4) == False", "assert apps_run2().canWinNim(5) == True", "assert apps_run2().canWinNim(8) == False", "assert apps_run2().canWinNim(7, 'random') == True", "assert apps_run2().canWinNim(12, 'random') == False"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "APPS/2510-3", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nYou are playing the following Nim Game with your friend: There is a heap of stones on the table, each time one of you take turns to remove 1 to 3 stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones.\n\nBoth of you are very clever and have optimal strategies for the game. Write a function to determine whether you can win the game given the number of stones in the heap.\n\nExample:\n\n\nInput: 4\nOutput: false \nExplanation: If there are 4 stones in the heap, then you will never win the game;\n\u00a0            No matter 1, 2, or 3 stones you remove, the last stone will always be \n\u00a0            removed by your friend.", "raw_solution": "def apps_run1(n):\n    return (n % 4 != 0)", "raw_test_input": ["assert apps_run1(4) == False", "assert apps_run1(1) == True", "assert apps_run1(2) == True", "assert apps_run1(3) == True", "assert apps_run1(5) == True"], "new_problem": "You are playing a modified version of the Nim Game with your friend. There are multiple heaps of stones on the table, each represented as a tuple (heap_id, number_of_stones). Each time, one of you takes turns to remove 1 to 3 stones from any one heap. The one who removes the last stone from any heap will be the winner. You will take the first turn to remove the stones. Both of you are very clever and have optimal strategies for the game. Write a function to determine for each heap whether you can win the game given the number of stones in that heap. Return a dictionary where the keys are heap_ids and the values are booleans indicating whether you can win for that heap.", "new_solution": "from typing import List, Tuple, Dict\n\nclass apps_run2:\n    def canWinNim(self, n: int) -> bool:\n        return (n % 4 != 0)\n\n    def canWinMultipleNim(self, heaps: List[Tuple[int, int]]) -> Dict[int, bool]:\n        results = {}\n        for heap_id, stones in heaps:\n            results[heap_id] = self.canWinNim(stones)\n        return results", "input_format": "List[Tuple[int, int]]", "output_format": "Dict[int, bool]", "test_input": ["assert apps_run2().canWinMultipleNim([(1, 4), (2, 5), (3, 7), (4, 8), (5, 10)]) == {1: False, 2: True, 3: True, 4: False, 5: True}", "assert apps_run2().canWinMultipleNim([(1, 1), (2, 2), (3, 3), (4, 4), (5, 6)]) == {1: True, 2: True, 3: True, 4: False, 5: True}", "assert apps_run2().canWinMultipleNim([(1, 9), (2, 12), (3, 15), (4, 16), (5, 20)]) == {1: True, 2: False, 3: True, 4: False, 5: False}", "assert apps_run2().canWinMultipleNim([(1, 0), (2, 13), (3, 14), (4, 17), (5, 18)]) == {1: False, 2: True, 3: True, 4: True, 5: True}", "assert apps_run2().canWinMultipleNim([(1, 21), (2, 22), (3, 23), (4, 24), (5, 25)]) == {1: True, 2: True, 3: True, 4: False, 5: True}"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "APPS/2510-4", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nYou are playing the following Nim Game with your friend: There is a heap of stones on the table, each time one of you take turns to remove 1 to 3 stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones.\n\nBoth of you are very clever and have optimal strategies for the game. Write a function to determine whether you can win the game given the number of stones in the heap.\n\nExample:\n\n\nInput: 4\nOutput: false \nExplanation: If there are 4 stones in the heap, then you will never win the game;\n\u00a0            No matter 1, 2, or 3 stones you remove, the last stone will always be \n\u00a0            removed by your friend.", "raw_solution": "def apps_run1(n):\n    return (n % 4 != 0)", "raw_test_input": ["assert apps_run1(4) == False", "assert apps_run1(1) == True", "assert apps_run1(2) == True", "assert apps_run1(3) == True", "assert apps_run1(5) == True"], "new_problem": "You are playing the Nim Game with your friend. There is a heap of stones on the table, and each time one of you takes turns to remove 1 to 3 stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones. Both of you are very clever and have optimal strategies for the game. Write a function to determine whether you can win the game given the number of stones in the heap. However, you must handle the following errors: 1) The input must be a positive integer. If the input is not a positive integer, raise a ValueError with a message 'Number of stones must be a positive integer.' 2) If the input is not an integer, raise a TypeError with a message 'Input must be an integer.' Ensure that these errors are propagated correctly.", "new_solution": "class apps_run2:\n    def canWinNim(self, n: int) -> bool:\n        if not isinstance(n, int):\n            raise TypeError('Input must be an integer.')\n        if n <= 0:\n            raise ValueError('Number of stones must be a positive integer.')\n        return (n % 4 != 0)", "input_format": "An integer representing the number of stones in the heap.", "output_format": "A boolean indicating whether you can win the game.", "test_input": ["assert apps_run2().canWinNim(4) == False", "assert apps_run2().canWinNim(1) == True", "assert apps_run2().canWinNim(2) == True", "assert apps_run2().canWinNim(7) == True", "try:\n    apps_run2().canWinNim(-1)\nexcept ValueError as e:\n    assert str(e) == 'Number of stones must be a positive integer.'", "try:\n    apps_run2().canWinNim('three')\nexcept TypeError as e:\n    assert str(e) == 'Input must be an integer.'"], "requirement_type": "PROMPT_ERROR_HANDLING"}
{"task_id": "APPS/2500-1", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nGiven a string s, the power of the string is the maximum length of a non-empty substring that\u00a0contains only one unique character.\nReturn the power\u00a0of the string.\n\u00a0\nExample 1:\nInput: s = \"leetcode\"\nOutput: 2\nExplanation: The substring \"ee\" is of length 2 with the character 'e' only.\n\nExample 2:\nInput: s = \"abbcccddddeeeeedcba\"\nOutput: 5\nExplanation: The substring \"eeeee\" is of length 5 with the character 'e' only.\n\nExample 3:\nInput: s = \"triplepillooooow\"\nOutput: 5\n\nExample 4:\nInput: s = \"hooraaaaaaaaaaay\"\nOutput: 11\n\nExample 5:\nInput: s = \"tourist\"\nOutput: 1\n\n\u00a0\nConstraints:\n\n1 <= s.length <= 500\ns contains only lowercase English letters.", "raw_solution": "def apps_run1(s: str) -> int:\n    n = len(s) \n    count = 0\n    res = s[0] \n    cur_count = 1\n\n    for i in range(n): \n        if (i < n - 1 and \n            s[i] == s[i + 1]): \n            cur_count += 1\n        else: \n            if cur_count > count: \n                count = cur_count \n                res = s[i] \n            cur_count = 1\n    return count", "raw_test_input": ["assert apps_run1('leetcode') == 2", "assert apps_run1('abbcccddddeeeeedcba') == 5", "assert apps_run1('triplepillooooow') == 5", "assert apps_run1('hooraaaaaaaaaaay') == 11", "assert apps_run1('tourist') == 1"], "new_problem": "In an e-commerce platform, customer reviews are analyzed to determine the consistency of sentiment. A review with a high power of a string might indicate strong sentiment (positive or negative) about a particular aspect. Given a list of customer reviews, determine the power of each review. The power of a review is defined as the maximum length of a non-empty substring that contains only one unique character. Return a dictionary where each key is the index of the review in the list, and the value is the power of that review.", "new_solution": "class apps_run2:\n    def maxPower(self, s: str) -> int:\n        n = len(s) \n        count = 0\n        res = s[0] \n        cur_count = 1\n  \n        for i in range(n): \n            if (i < n - 1 and s[i] == s[i + 1]): \n                cur_count += 1\n            else: \n                if cur_count > count: \n                    count = cur_count \n                    res = s[i] \n                cur_count = 1\n        return count \n\n    def analyzeReviewPowers(self, reviews: list) -> dict:\n        result = {}\n        for index, review in enumerate(reviews):\n            result[index] = self.maxPower(review)\n        return result", "input_format": "A list of strings representing customer reviews.", "output_format": "A dictionary where keys are review indices and values are the power of the string in each review.", "test_input": ["assert apps_run2().analyzeReviewPowers(['greaFt product', 'sooooo good', 'bad', 'excellent', 'noooooo']) == {0: 1, 1: 5, 2: 1, 3: 2, 4: 6}", "assert apps_run2().analyzeReviewPowers(['aaaa', 'bbbb', 'cccc', 'dddd', 'eeee']) == {0: 4, 1: 4, 2: 4, 3: 4, 4: 4}", "assert apps_run2().analyzeReviewPowers(['a', 'b', 'c', 'd', 'e']) == {0: 1, 1: 1, 2: 1, 3: 1, 4: 1}", "assert apps_run2().analyzeReviewPowers(['a', 'aa', 'aaa', 'aaaa']) == {0: 1, 1: 2, 2: 3, 3: 4}", "assert apps_run2().analyzeReviewPowers(['zzzzzz', 'yyyy', 'xxxx', 'wwww', 'vvvv']) == {0: 6, 1: 4, 2: 4, 3: 4, 4: 4}"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "APPS/2500-2", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nGiven a string s, the power of the string is the maximum length of a non-empty substring that\u00a0contains only one unique character.\nReturn the power\u00a0of the string.\n\u00a0\nExample 1:\nInput: s = \"leetcode\"\nOutput: 2\nExplanation: The substring \"ee\" is of length 2 with the character 'e' only.\n\nExample 2:\nInput: s = \"abbcccddddeeeeedcba\"\nOutput: 5\nExplanation: The substring \"eeeee\" is of length 5 with the character 'e' only.\n\nExample 3:\nInput: s = \"triplepillooooow\"\nOutput: 5\n\nExample 4:\nInput: s = \"hooraaaaaaaaaaay\"\nOutput: 11\n\nExample 5:\nInput: s = \"tourist\"\nOutput: 1\n\n\u00a0\nConstraints:\n\n1 <= s.length <= 500\ns contains only lowercase English letters.", "raw_solution": "def apps_run1(s: str) -> int:\n    n = len(s) \n    count = 0\n    res = s[0] \n    cur_count = 1\n\n    for i in range(n): \n        if (i < n - 1 and \n            s[i] == s[i + 1]): \n            cur_count += 1\n        else: \n            if cur_count > count: \n                count = cur_count \n                res = s[i] \n            cur_count = 1\n    return count", "raw_test_input": ["assert apps_run1('leetcode') == 2", "assert apps_run1('abbcccddddeeeeedcba') == 5", "assert apps_run1('triplepillooooow') == 5", "assert apps_run1('hooraaaaaaaaaaay') == 11", "assert apps_run1('tourist') == 1"], "new_problem": "Enhance the function to not only return the power of the string but also optionally return the character that forms the longest substring when requested. The function should maintain backward compatibility, meaning it should still return just the power of the string by default. Add an optional parameter 'detailed' which, when set to True, returns a tuple containing both the power and the character.", "new_solution": "class apps_run2:\n    def maxPower(self, s: str, detailed: bool = False) -> int:\n        n = len(s)\n        count = 0\n        res = s[0]\n        cur_count = 1\n\n        for i in range(n):\n            if (i < n - 1 and s[i] == s[i + 1]):\n                cur_count += 1\n            else:\n                if cur_count > count:\n                    count = cur_count\n                    res = s[i]\n                cur_count = 1\n\n        if detailed:\n            return (count, res)\n        return count", "input_format": "A string s and an optional boolean parameter detailed.", "output_format": "An integer representing the power of the string. If detailed is True, return a tuple with the power and the character.", "test_input": ["assert apps_run2().maxPower('leetcode') == 2", "assert apps_run2().maxPower('abbcccddddeeeeedcba') == 5", "assert apps_run2().maxPower('triplepillooooow') == 5", "assert apps_run2().maxPower('hooraaaaaaaaaaay') == 11", "assert apps_run2().maxPower('tourist') == 1", "assert apps_run2().maxPower('leetcode', detailed=True) == (2, 'e')", "assert apps_run2().maxPower('abbcccddddeeeeedcba', detailed=True) == (5, 'e')", "assert apps_run2().maxPower('triplepillooooow', detailed=True) == (5, 'o')", "assert apps_run2().maxPower('hooraaaaaaaaaaay', detailed=True) == (11, 'a')", "assert apps_run2().maxPower('tourist', detailed=True) == (1, 't')"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "APPS/2500-3", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nGiven a string s, the power of the string is the maximum length of a non-empty substring that\u00a0contains only one unique character.\nReturn the power\u00a0of the string.\n\u00a0\nExample 1:\nInput: s = \"leetcode\"\nOutput: 2\nExplanation: The substring \"ee\" is of length 2 with the character 'e' only.\n\nExample 2:\nInput: s = \"abbcccddddeeeeedcba\"\nOutput: 5\nExplanation: The substring \"eeeee\" is of length 5 with the character 'e' only.\n\nExample 3:\nInput: s = \"triplepillooooow\"\nOutput: 5\n\nExample 4:\nInput: s = \"hooraaaaaaaaaaay\"\nOutput: 11\n\nExample 5:\nInput: s = \"tourist\"\nOutput: 1\n\n\u00a0\nConstraints:\n\n1 <= s.length <= 500\ns contains only lowercase English letters.", "raw_solution": "def apps_run1(s: str) -> int:\n    n = len(s) \n    count = 0\n    res = s[0] \n    cur_count = 1\n\n    for i in range(n): \n        if (i < n - 1 and \n            s[i] == s[i + 1]): \n            cur_count += 1\n        else: \n            if cur_count > count: \n                count = cur_count \n                res = s[i] \n            cur_count = 1\n    return count", "raw_test_input": ["assert apps_run1('leetcode') == 2", "assert apps_run1('abbcccddddeeeeedcba') == 5", "assert apps_run1('triplepillooooow') == 5", "assert apps_run1('hooraaaaaaaaaaay') == 11", "assert apps_run1('tourist') == 1"], "new_problem": "Given a list of strings, determine the power of each string, where the power is defined as the maximum length of a non-empty substring that contains only one unique character. Return the results in a dictionary where each key is the original string and the value is its power. Use a dictionary to store intermediate results for each character's maximum power in each string. Additionally, ensure that the solution can handle strings with a length of up to 1000 characters and that the list can contain up to 100 strings.", "new_solution": "from typing import List, Dict\n\nclass apps_run2:\n    def maxPower(self, s: str) -> int:\n        n = len(s)\n        count = 0\n        cur_count = 1\n\n        for i in range(n):\n            if i < n - 1 and s[i] == s[i + 1]:\n                cur_count += 1\n            else:\n                if cur_count > count:\n                    count = cur_count\n                cur_count = 1\n        return count\n\n    def maxPowerForStrings(self, strings: List[str]) -> Dict[str, int]:\n        result = {}\n        for s in strings:\n            result[s] = self.maxPower(s)\n        return result", "input_format": "A list of strings, where each string represents a sequence of characters.", "output_format": "A dictionary where keys are the input strings and values are the power of each string.", "test_input": ["assert apps_run2().maxPowerForStrings(['leetcode', 'abbcccddddeeeeedcba', 'triplepillooooow', 'hooraaaaaaaaaaay', 'tourist']) == {'leetcode': 2, 'abbcccddddeeeeedcba': 5, 'triplepillooooow': 5, 'hooraaaaaaaaaaay': 11, 'tourist': 1}", "assert apps_run2().maxPowerForStrings(['a', 'bb', 'ccc', 'dddd', 'eeeee']) == {'a': 1, 'bb': 2, 'ccc': 3, 'dddd': 4, 'eeeee': 5}", "assert apps_run2().maxPowerForStrings(['', 'a', 'ab', 'abc', 'abcd']) == {'': 0, 'a': 1, 'ab': 1, 'abc': 1, 'abcd': 1}", "assert apps_run2().maxPowerForStrings(['zzzzzzzzzz', 'yyyyyyyyyy', 'xxxxxxxxxx']) == {'zzzzzzzzzz': 10, 'yyyyyyyyyy': 10, 'xxxxxxxxxx': 10}", "assert apps_run2().maxPowerForStrings(['aabbcc', 'ddeeff', 'gghhii', 'jjkkll', 'mmnnoo']) == {'aabbcc': 2, 'ddeeff': 2, 'gghhii': 2, 'jjkkll': 2, 'mmnnoo': 2}"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "APPS/2500-4", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nGiven a string s, the power of the string is the maximum length of a non-empty substring that\u00a0contains only one unique character.\nReturn the power\u00a0of the string.\n\u00a0\nExample 1:\nInput: s = \"leetcode\"\nOutput: 2\nExplanation: The substring \"ee\" is of length 2 with the character 'e' only.\n\nExample 2:\nInput: s = \"abbcccddddeeeeedcba\"\nOutput: 5\nExplanation: The substring \"eeeee\" is of length 5 with the character 'e' only.\n\nExample 3:\nInput: s = \"triplepillooooow\"\nOutput: 5\n\nExample 4:\nInput: s = \"hooraaaaaaaaaaay\"\nOutput: 11\n\nExample 5:\nInput: s = \"tourist\"\nOutput: 1\n\n\u00a0\nConstraints:\n\n1 <= s.length <= 500\ns contains only lowercase English letters.", "raw_solution": "def apps_run1(s: str) -> int:\n    n = len(s) \n    count = 0\n    res = s[0] \n    cur_count = 1\n\n    for i in range(n): \n        if (i < n - 1 and \n            s[i] == s[i + 1]): \n            cur_count += 1\n        else: \n            if cur_count > count: \n                count = cur_count \n                res = s[i] \n            cur_count = 1\n    return count", "raw_test_input": ["assert apps_run1(\"leetcode\") == 2", "assert apps_run1(\"abbcccddddeeeeedcba\") == 5", "assert apps_run1(\"triplepillooooow\") == 5", "assert apps_run1(\"hooraaaaaaaaaaay\") == 11", "assert apps_run1(\"tourist\") == 1"], "new_problem": "Write a function that calculates the power of a string, which is the maximum length of a non-empty substring that contains only one unique character. The function should handle the following errors: 1. If the input is not a string, raise a TypeError with a meaningful message. 2. If the string is empty, raise a ValueError. 3. If the string contains characters other than lowercase English letters, raise a ValueError. Ensure that the function propagates these errors appropriately and includes type hints.", "new_solution": "class apps_run2:\n    class InvalidCharacterError(ValueError):\n        pass\n\n    def maxPower(self, s: str) -> int:\n        if not isinstance(s, str):\n            raise TypeError('Input must be a string.')\n        if len(s) == 0:\n            raise ValueError('String cannot be empty.')\n        if not s.islower() or not s.isalpha():\n            raise self.InvalidCharacterError('String must contain only lowercase English letters.')\n\n        n = len(s)\n        count = 0\n        cur_count = 1\n\n        for i in range(n):\n            if i < n - 1 and s[i] == s[i + 1]:\n                cur_count += 1\n            else:\n                if cur_count > count:\n                    count = cur_count\n                cur_count = 1\n        return count", "input_format": "A string s", "output_format": "An integer representing the power of the string", "test_input": ["assert apps_run2().maxPower('leetcode') == 2", "assert apps_run2().maxPower('abbcccddddeeeeedcba') == 5", "assert apps_run2().maxPower('triplepillooooow') == 5", "assert apps_run2().maxPower('hooraaaaaaaaaaay') == 11", "assert apps_run2().maxPower('tourist') == 1", "try:\n    apps_run2().maxPower(123)\nexcept TypeError as e:\n    assert str(e) == 'Input must be a string.'", "try:\n    apps_run2().maxPower('')\nexcept ValueError as e:\n    assert str(e) == 'String cannot be empty.'", "try:\n    apps_run2().maxPower('abc123')\nexcept apps_run2.InvalidCharacterError as e:\n    assert str(e) == 'String must contain only lowercase English letters.'"], "requirement_type": "PROMPT_ERROR_HANDLING"}
{"task_id": "APPS/2507-1", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nYou are given an array of strings\u00a0words\u00a0and a string\u00a0chars.\nA string is good\u00a0if\u00a0it can be formed by\u00a0characters from chars\u00a0(each character\u00a0can only be used once).\nReturn the sum of lengths of all good strings in words.\n\u00a0\nExample 1:\nInput: words = [\"cat\",\"bt\",\"hat\",\"tree\"], chars = \"atach\"\nOutput: 6\nExplanation: \nThe strings that can be formed are \"cat\" and \"hat\" so the answer is 3 + 3 = 6.\n\nExample 2:\nInput: words = [\"hello\",\"world\",\"leetcode\"], chars = \"welldonehoneyr\"\nOutput: 10\nExplanation: \nThe strings that can be formed are \"hello\" and \"world\" so the answer is 5 + 5 = 10.\n\n\u00a0\nNote:\n\n1 <= words.length <= 1000\n1 <= words[i].length, chars.length\u00a0<= 100\nAll strings contain lowercase English letters only.", "raw_solution": "def apps_run1(words, chars):\n    d={}\n    for i in chars:\n        if i in d:\n            d[i]+=1\n        else:\n            d[i]=1\n    l=0\n    for i in words:\n        flag = True\n        for j in i:\n            if j in d:\n                if i.count(j)>d[j]:\n                    flag=False\n                    break\n            else:\n                flag = False\n                break\n        if flag:\n            l+=len(i)\n    return l", "raw_test_input": ["assert apps_run1(['cat', 'bt', 'hat', 'tree'], 'atach') == 6", "assert apps_run1(['hello', 'world', 'leetcode'], 'welldonehoneyr') == 10", "assert apps_run1(['apple', 'orange', 'banana'], 'aabbccddeeff') == 0", "assert apps_run1(['abc', 'def', 'ghi'], 'abcdefghi') == 9", "assert apps_run1(['a', 'b', 'c'], 'abc') == 3"], "new_problem": "In an e-commerce platform, you are tasked with filtering product names based on available characters and a minimum length requirement. You are given a list of dictionaries, each containing a list of product names ('words') and a string of available characters ('chars'). Additionally, you have a threshold integer 'min_length'. A product name is considered valid if it can be formed using the characters from 'chars' (each character can only be used once) and its length is greater than or equal to 'min_length'. Return a list of dictionaries where each dictionary contains the valid product names.", "new_solution": "from typing import List, Dict\n\nclass apps_run2:\n    def countCharacters(self, words: List[str], chars: str) -> int:\n        d = {}\n        for i in chars:\n            if i in d:\n                d[i] += 1\n            else:\n                d[i] = 1\n        l = 0\n        for i in words:\n            flag = True\n            for j in i:\n                if j in d:\n                    if i.count(j) > d[j]:\n                        flag = False\n                        break\n                else:\n                    flag = False\n                    break\n            if flag:\n                l += len(i)\n        return l\n\n    def filterProductNames(self, data: List[Dict[str, object]], min_length: int) -> List[Dict[str, List[str]]]:\n        def canForm(word: str, chars: str) -> bool:\n            d = {}\n            for i in chars:\n                if i in d:\n                    d[i] += 1\n                else:\n                    d[i] = 1\n            for j in word:\n                if j in d:\n                    if word.count(j) > d[j]:\n                        return False\n                else:\n                    return False\n            return True\n\n        result = []\n        for entry in data:\n            words = entry['words']\n            chars = entry['chars']\n            valid_words = [word for word in words if canForm(word, chars) and len(word) >= min_length]\n            result.append({'words': valid_words})\n        return result", "input_format": "A list of dictionaries where each dictionary contains 'words' (a list of strings) and 'chars' (a string), and a threshold integer 'min_length'.", "output_format": "A list of dictionaries where each dictionary contains 'words' (a list of strings) that are good and have a length greater than or equal to 'min_length'.", "test_input": ["assert apps_run2().filterProductNames([{'words': ['cat', 'bt', 'hat', 'tree'], 'chars': 'atach'}], 3) == [{'words': ['cat', 'hat']}]", "assert apps_run2().filterProductNames([{'words': ['hello', 'world', 'leetcode'], 'chars': 'welldonehoneyr'}], 5) == [{'words': ['hello', 'world']}]", "assert apps_run2().filterProductNames([{'words': ['apple', 'banana', 'cherry'], 'chars': 'aabbccnnee'}], 6) == [{'words': []}]", "assert apps_run2().filterProductNames([{'words': ['dog', 'god', 'good'], 'chars': 'doog'}], 4) == [{'words': ['good']}]", "assert apps_run2().filterProductNames([{'words': ['car', 'arc', 'race'], 'chars': 'carerac'}], 3) == [{'words': ['car', 'arc', 'race']}]"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "APPS/2507-2", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nYou are given an array of strings\u00a0words\u00a0and a string\u00a0chars.\nA string is good\u00a0if\u00a0it can be formed by\u00a0characters from chars\u00a0(each character\u00a0can only be used once).\nReturn the sum of lengths of all good strings in words.\n\u00a0\nExample 1:\nInput: words = [\"cat\",\"bt\",\"hat\",\"tree\"], chars = \"atach\"\nOutput: 6\nExplanation: \nThe strings that can be formed are \"cat\" and \"hat\" so the answer is 3 + 3 = 6.\n\nExample 2:\nInput: words = [\"hello\",\"world\",\"leetcode\"], chars = \"welldonehoneyr\"\nOutput: 10\nExplanation: \nThe strings that can be formed are \"hello\" and \"world\" so the answer is 5 + 5 = 10.\n\n\u00a0\nNote:\n\n1 <= words.length <= 1000\n1 <= words[i].length, chars.length\u00a0<= 100\nAll strings contain lowercase English letters only.", "raw_solution": "def apps_run1(words, chars):\n    d={}\n    for i in chars:\n        if i in d:\n            d[i]+=1\n        else:\n            d[i]=1\n    l=0\n    for i in words:\n        flag = True\n        for j in i:\n            if j in d:\n                if i.count(j)>d[j]:\n                    flag=False\n                    break\n            else:\n                flag = False\n                break\n        if flag:\n            l+=len(i)\n    return l", "raw_test_input": ["assert apps_run1(['cat', 'bt', 'hat', 'tree'], 'atach') == 6", "assert apps_run1(['hello', 'world', 'leetcode'], 'welldonehoneyr') == 10", "assert apps_run1(['apple', 'orange', 'banana'], 'aabbccddeeff') == 0", "assert apps_run1(['a', 'b', 'c'], 'abc') == 3", "assert apps_run1(['abcd', 'efgh'], 'abcdefgh') == 8"], "new_problem": "You are given an array of strings words and a string chars. A string is good if it can be formed by characters from chars (each character can only be used once). Return the sum of lengths of all good strings in words. Additionally, the function should support an optional parameter case_sensitive. If case_sensitive is True, the function should consider character case when forming good strings. If False or not provided, the function should treat characters as case-insensitive.", "new_solution": "from typing import List, Optional\n\nclass apps_run2:\n    def countCharacters(self, words: List[str], chars: str, case_sensitive: Optional[bool] = False) -> int:\n        if not case_sensitive:\n            words = [word.lower() for word in words]\n            chars = chars.lower()\n        \n        d = {}\n        for i in chars:\n            if i in d:\n                d[i] += 1\n            else:\n                d[i] = 1\n        l = 0\n        for i in words:\n            flag = True\n            for j in i:\n                if j in d:\n                    if i.count(j) > d[j]:\n                        flag = False\n                        break\n                else:\n                    flag = False\n                    break\n            if flag:\n                l += len(i)\n        return l", "input_format": "words: List[str], chars: str, case_sensitive: Optional[bool] = False", "output_format": "int", "test_input": ["assert apps_run2().countCharacters(['cat', 'bt', 'hat', 'tree'], 'atach') == 6", "assert apps_run2().countCharacters(['hello', 'world', 'leetcode'], 'welldonehoneyr') == 10", "assert apps_run2().countCharacters(['Cat', 'bt', 'Hat', 'tree'], 'atach', case_sensitive=True) == 0", "assert apps_run2().countCharacters(['Cat', 'bt', 'Hat', 'tree'], 'atach', case_sensitive=False) == 6", "assert apps_run2().countCharacters(['HELLO', 'world', 'leetcode'], 'WELLDONEHONEYR', case_sensitive=True) == 5"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "APPS/2507-3", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nYou are given an array of strings\u00a0words\u00a0and a string\u00a0chars.\nA string is good\u00a0if\u00a0it can be formed by\u00a0characters from chars\u00a0(each character\u00a0can only be used once).\nReturn the sum of lengths of all good strings in words.\n\u00a0\nExample 1:\nInput: words = [\"cat\",\"bt\",\"hat\",\"tree\"], chars = \"atach\"\nOutput: 6\nExplanation: \nThe strings that can be formed are \"cat\" and \"hat\" so the answer is 3 + 3 = 6.\n\nExample 2:\nInput: words = [\"hello\",\"world\",\"leetcode\"], chars = \"welldonehoneyr\"\nOutput: 10\nExplanation: \nThe strings that can be formed are \"hello\" and \"world\" so the answer is 5 + 5 = 10.\n\n\u00a0\nNote:\n\n1 <= words.length <= 1000\n1 <= words[i].length, chars.length\u00a0<= 100\nAll strings contain lowercase English letters only.", "raw_solution": "def apps_run1(words, chars):\n    d={}\n    for i in chars:\n        if i in d:\n            d[i]+=1\n        else:\n            d[i]=1\n    l=0\n    for i in words:\n        flag = True\n        for j in i:\n            if j in d:\n                if i.count(j)>d[j]:\n                    flag=False\n                    break\n            else:\n                flag = False\n                break\n        if flag:\n            l+=len(i)\n    return l", "raw_test_input": ["assert apps_run1(['cat', 'bt', 'hat', 'tree'], 'atach') == 6", "assert apps_run1(['hello', 'world', 'leetcode'], 'welldonehoneyr') == 10", "assert apps_run1(['apple', 'orange', 'banana'], 'aabbccddeeff') == 0", "assert apps_run1(['abcd', 'efgh', 'ijkl'], 'abcdefgh') == 8", "assert apps_run1(['a', 'b', 'c'], 'abc') == 3"], "new_problem": "You are given a dictionary where keys are strings representing words and values are integers representing the frequency of each word. You are also given a dictionary where keys are characters and values are integers representing the frequency of each character available. A string is considered good if it can be formed by characters from the available characters dictionary, considering their frequencies. Return the sum of lengths of all good strings in the words dictionary, each multiplied by its frequency.", "new_solution": "from typing import Dict\n\nclass apps_run2:\n    def countCharacters(self, words: Dict[str, int], chars: Dict[str, int]) -> int:\n        total_length = 0\n        for word, freq in words.items():\n            word_count = {}\n            for char in word:\n                if char in word_count:\n                    word_count[char] += 1\n                else:\n                    word_count[char] = 1\n            can_form = True\n            for char, count in word_count.items():\n                if chars.get(char, 0) < count:\n                    can_form = False\n                    break\n            if can_form:\n                total_length += len(word) * freq\n        return total_length", "input_format": "A dictionary of words with their frequencies and a dictionary of available characters with their frequencies.", "output_format": "An integer representing the sum of lengths of all good strings.", "test_input": ["assert apps_run2().countCharacters({'cat': 1, 'bt': 1, 'hat': 1, 'tree': 1}, {'a': 2, 't': 1, 'c': 1, 'h': 1}) == 6", "assert apps_run2().countCharacters({'hello': 1, 'world': 1, 'leetcode': 1}, {'w': 1, 'e': 2, 'l': 2, 'd': 1, 'o': 1, 'n': 1, 'h': 1, 'r': 1, 'y': 1}) == 10", "assert apps_run2().countCharacters({'apple': 2, 'banana': 1}, {'a': 3, 'p': 2, 'l': 1, 'e': 1, 'b': 1, 'n': 2}) == 16", "assert apps_run2().countCharacters({'abc': 1, 'def': 1}, {'a': 1, 'b': 1, 'c': 1, 'd': 1, 'e': 1, 'f': 1}) == 6", "assert apps_run2().countCharacters({'xyz': 1, 'xy': 2}, {'x': 2, 'y': 2, 'z': 1}) == 7"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "APPS/2507-4", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nYou are given an array of strings\u00a0words\u00a0and a string\u00a0chars.\nA string is good\u00a0if\u00a0it can be formed by\u00a0characters from chars\u00a0(each character\u00a0can only be used once).\nReturn the sum of lengths of all good strings in words.\n\u00a0\nExample 1:\nInput: words = [\"cat\",\"bt\",\"hat\",\"tree\"], chars = \"atach\"\nOutput: 6\nExplanation: \nThe strings that can be formed are \"cat\" and \"hat\" so the answer is 3 + 3 = 6.\n\nExample 2:\nInput: words = [\"hello\",\"world\",\"leetcode\"], chars = \"welldonehoneyr\"\nOutput: 10\nExplanation: \nThe strings that can be formed are \"hello\" and \"world\" so the answer is 5 + 5 = 10.\n\n\u00a0\nNote:\n\n1 <= words.length <= 1000\n1 <= words[i].length, chars.length\u00a0<= 100\nAll strings contain lowercase English letters only.", "raw_solution": "def apps_run1(words, chars):\n    d={}\n    for i in chars:\n        if i in d:\n            d[i]+=1\n        else:\n            d[i]=1\n    l=0\n    for i in words:\n        flag = True\n        for j in i:\n            if j in d:\n                if i.count(j)>d[j]:\n                    flag=False\n                    break\n            else:\n                flag = False\n                break\n        if flag:\n            l+=len(i)\n    return l", "raw_test_input": ["assert apps_run1(['cat', 'bt', 'hat', 'tree'], 'atach') == 6", "assert apps_run1(['hello', 'world', 'leetcode'], 'welldonehoneyr') == 10", "assert apps_run1(['apple', 'orange', 'banana'], 'aabbccddeeff') == 0", "assert apps_run1(['a', 'b', 'c'], 'abc') == 3", "assert apps_run1(['abcd', 'efgh'], 'abcdefgh') == 8"], "new_problem": "You are given an array of strings words and a string chars. A string is good if it can be formed by characters from chars (each character can only be used once). Return the sum of lengths of all good strings in words. However, you must handle the following errors: 1. If words is not a list of strings, raise a TypeError with a meaningful message. 2. If chars is not a string, raise a TypeError with a meaningful message. 3. If any string in words or chars contains non-lowercase English letters, raise a ValueError with a meaningful message. 4. Handle any unexpected errors gracefully and propagate them with a custom exception.", "new_solution": "from typing import List\n\nclass InvalidInputError(Exception):\n    pass\n\nclass apps_run2:\n    def countCharacters(self, words: List[str], chars: str) -> int:\n        if not isinstance(words, list) or not all(isinstance(word, str) for word in words):\n            raise TypeError('words must be a list of strings.')\n        if not isinstance(chars, str):\n            raise TypeError('chars must be a string.')\n        if not all(word.islower() for word in words) or not chars.islower():\n            raise ValueError('All strings must contain only lowercase English letters.')\n\n        try:\n            d = {}\n            for i in chars:\n                if i in d:\n                    d[i] += 1\n                else:\n                    d[i] = 1\n            l = 0\n            for i in words:\n                flag = True\n                for j in i:\n                    if j in d:\n                        if i.count(j) > d[j]:\n                            flag = False\n                            break\n                    else:\n                        flag = False\n                        break\n                if flag:\n                    l += len(i)\n            return l\n        except Exception as e:\n            raise InvalidInputError('An unexpected error occurred.') from e", "input_format": "words: List[str], chars: str", "output_format": "int", "test_input": ["assert apps_run2().countCharacters(['cat', 'bt', 'hat', 'tree'], 'atach') == 6", "assert apps_run2().countCharacters(['hello', 'world', 'leetcode'], 'welldonehoneyr') == 10", "try:\n    apps_run2().countCharacters('not a list', 'atach')\nexcept TypeError as e:\n    assert str(e) == 'words must be a list of strings.'", "try:\n    apps_run2().countCharacters(['cat', 'bt'], 123)\nexcept TypeError as e:\n    assert str(e) == 'chars must be a string.'", "try:\n    apps_run2().countCharacters(['Cat', 'bt'], 'atach')\nexcept ValueError as e:\n    assert str(e) == 'All strings must contain only lowercase English letters.'"], "requirement_type": "PROMPT_ERROR_HANDLING"}
{"task_id": "APPS/2509-1", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nGiven a non-empty integer array of size n, find the minimum number of moves required to make all array elements equal, where a move is incrementing n - 1 elements by 1.\n\nExample:\n\nInput:\n[1,2,3]\n\nOutput:\n3\n\nExplanation:\nOnly three moves are needed (remember each move increments two elements):\n\n[1,2,3]  =>  [2,3,3]  =>  [3,4,3]  =>  [4,4,4].", "raw_solution": "def apps_run1(nums):\n    minx = min(nums)\n    sums = sum(nums)\n    return sums - len(nums) * minx", "raw_test_input": ["assert apps_run1([1, 2, 3]) == 3", "assert apps_run1([5, 6, 8, 8]) == 7", "assert apps_run1([1, 1, 1]) == 0", "assert apps_run1([0, 0, 0, 0]) == 0", "assert apps_run1([10, 20, 30]) == 30"], "new_problem": "In a logistics company, there are multiple products stored in different warehouses. Each product is represented by a non-empty integer array where each element denotes the number of items in a specific warehouse. The company wants to equalize the number of items for each product across all warehouses to streamline inventory management. A move consists of incrementing the number of items in n - 1 warehouses by 1. Write a function that takes a list of such arrays and returns a list of integers, where each integer is the minimum number of moves required to equalize the items for each product.", "new_solution": "class apps_run2:\n    def minMoves(self, nums):\n        minx = min(nums)\n        sums = sum(nums)\n        return sums - len(nums) * minx\n\n    def equalizeWarehouses(self, products):\n        results = []\n        for product in products:\n            moves = self.minMoves(product)\n            results.append(moves)\n        return results", "input_format": "A list of non-empty integer arrays, each representing the number of items in different warehouses. Each array corresponds to a different product.", "output_format": "A list of integers where each integer represents the minimum number of moves required to equalize the items in all warehouses for each product.", "test_input": ["assert apps_run2().equalizeWarehouses([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == [3, 3, 3]", "assert apps_run2().equalizeWarehouses([[10, 10, 10], [1, 1, 1], [5, 5, 5]]) == [0, 0, 0]", "assert apps_run2().equalizeWarehouses([[1, 1, 1, 1], [2, 3, 4], [5, 5, 5, 5]]) == [0, 3, 0]", "assert apps_run2().equalizeWarehouses([[1, 2], [3, 4, 5], [6, 7, 8, 9]]) == [1, 3, 6]", "assert apps_run2().equalizeWarehouses([[1], [2], [3]]) == [0, 0, 0]"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "APPS/2509-2", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nGiven a non-empty integer array of size n, find the minimum number of moves required to make all array elements equal, where a move is incrementing n - 1 elements by 1.\n\nExample:\n\nInput:\n[1,2,3]\n\nOutput:\n3\n\nExplanation:\nOnly three moves are needed (remember each move increments two elements):\n\n[1,2,3]  =>  [2,3,3]  =>  [3,4,3]  =>  [4,4,4].", "raw_solution": "def apps_run1(nums):\n    minx = min(nums)\n    sums = sum(nums)\n    return sums - len(nums) * minx", "raw_test_input": ["assert apps_run1([1, 2, 3]) == 3", "assert apps_run1([5, 6, 8, 8]) == 7", "assert apps_run1([1, 1, 1]) == 0", "assert apps_run1([0, 0, 0, 0]) == 0", "assert apps_run1([10, 20, 30]) == 30"], "new_problem": "Given a non-empty integer array of size n, find the minimum number of moves required to make all array elements equal, where a move is incrementing n - 1 elements by 1. Additionally, provide an optional parameter 'increment_value' which specifies the value by which n - 1 elements should be incremented in each move (default is 1). Also, include an optional parameter 'verbose' which, if set to True, will print each step of the transformation process.", "new_solution": "from typing import List, Optional\n\nclass apps_run2:\n    def minMoves(self, nums: List[int], increment_value: Optional[int] = 1, verbose: Optional[bool] = False) -> int:\n        \"\"\"\n        :type nums: List[int]\n        :type increment_value: Optional[int]\n        :type verbose: Optional[bool]\n        :rtype: int\n        \"\"\"\n        minx = min(nums)\n        sums = sum(nums)\n        moves = (sums - len(nums) * minx) // increment_value\n        if verbose:\n            current_nums = nums[:]\n            for _ in range(moves):\n                min_index = current_nums.index(min(current_nums))\n                for i in range(len(current_nums)):\n                    if i != min_index:\n                        current_nums[i] += increment_value\n                print(current_nums)\n        return moves", "input_format": "List[int], Optional[int], Optional[bool]", "output_format": "int", "test_input": ["assert apps_run2().minMoves([1, 2, 3]) == 3", "assert apps_run2().minMoves([1, 2, 3], increment_value=2) == 1", "assert apps_run2().minMoves([1, 2, 3, 4], increment_value=1) == 6", "assert apps_run2().minMoves([5, 6, 8, 8], increment_value=1) == 7", "assert apps_run2().minMoves([1, 1, 1, 1], increment_value=1) == 0"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "APPS/2509-3", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nGiven a non-empty integer array of size n, find the minimum number of moves required to make all array elements equal, where a move is incrementing n - 1 elements by 1.\n\nExample:\n\nInput:\n[1,2,3]\n\nOutput:\n3\n\nExplanation:\nOnly three moves are needed (remember each move increments two elements):\n\n[1,2,3]  =>  [2,3,3]  =>  [3,4,3]  =>  [4,4,4].", "raw_solution": "def apps_run1(nums):\n    minx = min(nums)\n    sums = sum(nums)\n    return sums - len(nums) * minx", "raw_test_input": ["assert apps_run1([1, 2, 3]) == 3", "assert apps_run1([5, 6, 8, 8]) == 7", "assert apps_run1([1, 1, 1]) == 0", "assert apps_run1([0, 0, 0, 0]) == 0", "assert apps_run1([10, 20, 30]) == 30"], "new_problem": "Given a dictionary where each key is a unique identifier and each value is a non-empty list of integers, find the minimum number of moves required to make all elements in each list equal. A move is defined as incrementing n - 1 elements by 1. Return a dictionary with the same keys and the calculated minimum moves as values. Additionally, ensure that each list has at least 3 elements and no element exceeds 10^6.", "new_solution": "from typing import Dict, List\n\nclass apps_run2:\n    def minMoves(self, nums: List[int]) -> int:\n        minx = min(nums)\n        sums = sum(nums)\n        return sums - len(nums) * minx\n\n    def minMovesForDict(self, data: Dict[str, List[int]]) -> Dict[str, int]:\n        result = {}\n        for key, nums in data.items():\n            if len(nums) < 3:\n                raise ValueError('Each list must have at least 3 elements.')\n            if any(num > 10**6 for num in nums):\n                raise ValueError('Elements must not exceed 10^6.')\n            result[key] = self.minMoves(nums)\n        return result", "input_format": "A dictionary where keys are unique identifiers for arrays and values are lists of integers.", "output_format": "A dictionary where keys are the same unique identifiers and values are the minimum number of moves required to make all elements in the corresponding list equal.", "test_input": ["assert apps_run2().minMovesForDict({'a': [1, 2, 3], 'b': [4, 5, 6]}) == {'a': 3, 'b': 3}", "assert apps_run2().minMovesForDict({'x': [10, 10, 10], 'y': [1, 1, 1]}) == {'x': 0, 'y': 0}", "assert apps_run2().minMovesForDict({'p': [1, 2, 3, 4], 'q': [5, 5, 5, 5]}) == {'p': 6, 'q': 0}", "assert apps_run2().minMovesForDict({'m': [100, 200, 300], 'n': [1, 1000000, 1000000]}) == {'m': 300, 'n': 1999998}", "assert apps_run2().minMovesForDict({'u': [1, 1, 2, 2, 3, 3]}) == {'u': 6}"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "APPS/2509-4", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nGiven a non-empty integer array of size n, find the minimum number of moves required to make all array elements equal, where a move is incrementing n - 1 elements by 1.\n\nExample:\n\nInput:\n[1,2,3]\n\nOutput:\n3\n\nExplanation:\nOnly three moves are needed (remember each move increments two elements):\n\n[1,2,3]  =>  [2,3,3]  =>  [3,4,3]  =>  [4,4,4].", "raw_solution": "def apps_run1(nums):\n    minx = min(nums)\n    sums = sum(nums)\n    return sums - len(nums) * minx", "raw_test_input": ["assert apps_run1([1, 2, 3]) == 3", "assert apps_run1([5, 6, 8, 8]) == 7", "assert apps_run1([1, 1, 1]) == 0", "assert apps_run1([0, 0, 0, 0]) == 0", "assert apps_run1([10, 20, 30]) == 30"], "new_problem": "Write a function that calculates the minimum number of moves required to make all elements of a non-empty integer array equal, where a move is incrementing n - 1 elements by 1. The function should handle the following errors: \n1. The input is not a list. \n2. The list is empty. \n3. The list contains non-integer elements. \n4. The list contains negative integers. \nDefine specific error types for these scenarios and ensure meaningful error messages are provided. Handle error propagation appropriately.", "new_solution": "from typing import List\n\nclass InvalidInputError(Exception):\n    pass\n\nclass EmptyArrayError(Exception):\n    pass\n\nclass NonIntegerElementError(Exception):\n    pass\n\nclass NegativeIntegerError(Exception):\n    pass\n\nclass apps_run2:\n    def minMoves(self, nums: List[int]) -> int:\n        if not isinstance(nums, list):\n            raise InvalidInputError(\"Input must be a list.\")\n        if len(nums) == 0:\n            raise EmptyArrayError(\"Array cannot be empty.\")\n        if not all(isinstance(x, int) for x in nums):\n            raise NonIntegerElementError(\"All elements must be integers.\")\n        if any(x < 0 for x in nums):\n            raise NegativeIntegerError(\"All elements must be non-negative integers.\")\n        minx = min(nums)\n        sums = sum(nums)\n        return sums - len(nums) * minx", "input_format": "A list of integers representing the array.", "output_format": "An integer representing the minimum number of moves required to make all array elements equal.", "test_input": ["try:\n    apps_run2().minMoves(\"not a list\")\nexcept InvalidInputError as e:\n    assert str(e) == \"Input must be a list.\"", "try:\n    apps_run2().minMoves([])\nexcept EmptyArrayError as e:\n    assert str(e) == \"Array cannot be empty.\"", "try:\n    apps_run2().minMoves([1, 2, \"three\"])\nexcept NonIntegerElementError as e:\n    assert str(e) == \"All elements must be integers.\"", "try:\n    apps_run2().minMoves([1, -2, 3])\nexcept NegativeIntegerError as e:\n    assert str(e) == \"All elements must be non-negative integers.\"", "assert apps_run2().minMoves([1, 2, 3]) == 3"], "requirement_type": "PROMPT_ERROR_HANDLING"}
{"task_id": "APPS/2508-1", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nStudents are asked to stand in non-decreasing order of heights for an annual photo.\nReturn the minimum number of students that must move in order for all students to be standing in non-decreasing order of height.\nNotice that when a group of students is selected they can reorder in any possible way between themselves and the non selected students\u00a0remain on their seats.\n\u00a0\nExample 1:\nInput: heights = [1,1,4,2,1,3]\nOutput: 3\nExplanation: \nCurrent array : [1,1,4,2,1,3]\nTarget array  : [1,1,1,2,3,4]\nOn index 2 (0-based) we have 4 vs 1 so we have to move this student.\nOn index 4 (0-based) we have 1 vs 3 so we have to move this student.\nOn index 5 (0-based) we have 3 vs 4 so we have to move this student.\n\nExample 2:\nInput: heights = [5,1,2,3,4]\nOutput: 5\n\nExample 3:\nInput: heights = [1,2,3,4,5]\nOutput: 0\n\n\u00a0\nConstraints:\n\n1 <= heights.length <= 100\n1 <= heights[i] <= 100.", "raw_solution": "def apps_run1(heights):\n    max_val = max(heights)\n    freq = [0] * (max_val + 1)\n    for num in heights:\n        freq[num] += 1\n    for num in range(1,len(freq)):\n        freq[num] += freq[num-1]\n    places = [0] * len(heights)\n    for num in heights:\n        places[freq[num] - 1] = num\n        freq[num] -= 1\n    return sum(a != b for a , b in zip(places,heights))", "raw_test_input": ["assert apps_run1([1, 1, 4, 2, 1, 3]) == 3", "assert apps_run1([5, 1, 2, 3, 4]) == 5", "assert apps_run1([1, 2, 3, 4, 5]) == 0", "assert apps_run1([2, 1, 2, 1, 1, 2, 2, 1]) == 4", "assert apps_run1([10, 6, 6, 10, 10, 6]) == 2"], "new_problem": "In a school, multiple classes are preparing for their annual photo day. Each class has a list of student heights, and the students in each class need to be arranged in non-decreasing order of height. Your task is to determine the minimum number of students that must move in each class to achieve this order. Use the original function to solve this problem for each class and return the results as a list.", "new_solution": "from typing import List\n\nclass apps_run2:\n    def heightChecker(self, heights: List[int]) -> int:\n        max_val = max(heights)\n        \n        freq = [0] * (max_val + 1)\n        for num in heights:\n            freq[num] += 1\n        for num in range(1,len(freq)):\n            freq[num] += freq[num-1]\n        places = [0] * len(heights)\n        for num in heights:\n            places[freq[num] - 1] = num\n            freq[num] -= 1\n        return sum(a != b for a , b in zip(places,heights))\n\n    def minimumMovesForClasses(self, classes: List[List[int]]) -> List[int]:\n        return [self.heightChecker(class_heights) for class_heights in classes]", "input_format": "A list of lists where each sublist represents the heights of students in a different class.", "output_format": "A list of integers where each integer represents the minimum number of students that must move in each class to achieve non-decreasing order of heights.", "test_input": ["assert apps_run2().minimumMovesForClasses([[1,1,4,2,1,3], [5,1,2,3,4], [1,2,3,4,5]]) == [3, 5, 0]", "assert apps_run2().minimumMovesForClasses([[3,3,2,1], [4,4,4,4], [2,1,3,2]]) == [4, 0, 4]", "assert apps_run2().minimumMovesForClasses([[10,9,8,7], [1,1,1,1], [5,6,7,8]]) == [4, 0, 0]", "assert apps_run2().minimumMovesForClasses([[1,3,2,4,5], [2,2,2,1,1], [3,1,2,3,1]]) == [2, 4, 2]", "assert apps_run2().minimumMovesForClasses([[6,5,4,3,2,1], [1,2,3,4,5,6], [7,8,9,10,11,12]]) == [6, 0, 0]"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "APPS/2508-2", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nStudents are asked to stand in non-decreasing order of heights for an annual photo.\nReturn the minimum number of students that must move in order for all students to be standing in non-decreasing order of height.\nNotice that when a group of students is selected they can reorder in any possible way between themselves and the non selected students\u00a0remain on their seats.\n\u00a0\nExample 1:\nInput: heights = [1,1,4,2,1,3]\nOutput: 3\nExplanation: \nCurrent array : [1,1,4,2,1,3]\nTarget array  : [1,1,1,2,3,4]\nOn index 2 (0-based) we have 4 vs 1 so we have to move this student.\nOn index 4 (0-based) we have 1 vs 3 so we have to move this student.\nOn index 5 (0-based) we have 3 vs 4 so we have to move this student.\n\nExample 2:\nInput: heights = [5,1,2,3,4]\nOutput: 5\n\nExample 3:\nInput: heights = [1,2,3,4,5]\nOutput: 0\n\n\u00a0\nConstraints:\n\n1 <= heights.length <= 100\n1 <= heights[i] <= 100.", "raw_solution": "def apps_run1(heights):\n    max_val = max(heights)\n    freq = [0] * (max_val + 1)\n    for num in heights:\n        freq[num] += 1\n    for num in range(1,len(freq)):\n        freq[num] += freq[num-1]\n    places = [0] * len(heights)\n    for num in heights:\n        places[freq[num] - 1] = num\n        freq[num] -= 1\n    return sum(a != b for a , b in zip(places,heights))", "raw_test_input": ["assert apps_run1([1, 1, 4, 2, 1, 3]) == 3", "assert apps_run1([5, 1, 2, 3, 4]) == 5", "assert apps_run1([1, 2, 3, 4, 5]) == 0", "assert apps_run1([2, 1, 2, 1, 1, 2, 2, 1]) == 4", "assert apps_run1([10, 6, 6, 10, 10, 6]) == 2"], "new_problem": "Students are asked to stand in non-decreasing order of heights for an annual photo. Return the minimum number of students that must move in order for all students to be standing in non-decreasing order of height. Additionally, if the optional parameter 'allow_reorder' is set to True, the function should return the minimum number of students that must move if students are allowed to reorder themselves within the group that needs to be moved. Notice that when a group of students is selected, they can reorder in any possible way between themselves, and the non-selected students remain in their seats. The function should maintain backward compatibility with existing implementations.", "new_solution": "from typing import List\n\nclass apps_run2:\n    def heightChecker(self, heights: List[int], allow_reorder: bool = False) -> int:\n        max_val = max(heights)\n        freq = [0] * (max_val + 1)\n        for num in heights:\n            freq[num] += 1\n        for num in range(1, len(freq)):\n            freq[num] += freq[num - 1]\n        places = [0] * len(heights)\n        for num in heights:\n            places[freq[num] - 1] = num\n            freq[num] -= 1\n        if allow_reorder:\n            return len(heights) - sum(a == b for a, b in zip(places, heights))\n        else:\n            return sum(a != b for a, b in zip(places, heights))", "input_format": "heights: List[int], allow_reorder: bool = False", "output_format": "int", "test_input": ["assert apps_run2().heightChecker([1,1,4,2,1,3]) == 3", "assert apps_run2().heightChecker([5,1,2,3,4]) == 5", "assert apps_run2().heightChecker([1,2,3,4,5]) == 0", "assert apps_run2().heightChecker([1,1,4,2,1,3], allow_reorder=True) == 3", "assert apps_run2().heightChecker([5,1,2,3,4], allow_reorder=True) == 5"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "APPS/2508-3", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nStudents are asked to stand in non-decreasing order of heights for an annual photo.\nReturn the minimum number of students that must move in order for all students to be standing in non-decreasing order of height.\nNotice that when a group of students is selected they can reorder in any possible way between themselves and the non selected students\u00a0remain on their seats.\n\u00a0\nExample 1:\nInput: heights = [1,1,4,2,1,3]\nOutput: 3\nExplanation: \nCurrent array : [1,1,4,2,1,3]\nTarget array  : [1,1,1,2,3,4]\nOn index 2 (0-based) we have 4 vs 1 so we have to move this student.\nOn index 4 (0-based) we have 1 vs 3 so we have to move this student.\nOn index 5 (0-based) we have 3 vs 4 so we have to move this student.\n\nExample 2:\nInput: heights = [5,1,2,3,4]\nOutput: 5\n\nExample 3:\nInput: heights = [1,2,3,4,5]\nOutput: 0\n\n\u00a0\nConstraints:\n\n1 <= heights.length <= 100\n1 <= heights[i] <= 100.", "raw_solution": "def apps_run1(heights):\n    max_val = max(heights)\n    freq = [0] * (max_val + 1)\n    for num in heights:\n        freq[num] += 1\n    for num in range(1,len(freq)):\n        freq[num] += freq[num-1]\n    places = [0] * len(heights)\n    for num in heights:\n        places[freq[num] - 1] = num\n        freq[num] -= 1\n    return sum(a != b for a , b in zip(places,heights))", "raw_test_input": ["assert apps_run1([1, 1, 4, 2, 1, 3]) == 3", "assert apps_run1([5, 1, 2, 3, 4]) == 5", "assert apps_run1([1, 2, 3, 4, 5]) == 0", "assert apps_run1([10, 6, 6, 10, 10, 6]) == 2", "assert apps_run1([2, 1, 2, 1, 1, 2, 2, 1]) == 4"], "new_problem": "In a school, students are assigned to different classes based on their heights. Each student is represented as a tuple containing their name and height. The school wants to organize a photo session where students are grouped by their classes, and within each class, they should be arranged in non-decreasing order of heights. Return the minimum number of students that must move within their class to achieve this order. Use a dictionary to map class names to lists of student heights.", "new_solution": "from typing import List, Tuple, Dict\n\nclass apps_run2:\n    def heightChecker(self, heights: List[int]) -> int:\n        max_val = max(heights)\n        \n        freq = [0] * (max_val + 1)\n        for num in heights:\n            freq[num] += 1\n        for num in range(1,len(freq)):\n            freq[num] += freq[num-1]\n        places = [0] * len(heights)\n        for num in heights:\n            places[freq[num] - 1] = num\n            freq[num] -= 1\n        return sum(a != b for a , b in zip(places,heights))\n\n    def classHeightChecker(self, students: List[Tuple[str, int]]) -> int:\n        class_dict: Dict[str, List[int]] = {}\n        for name, height in students:\n            if name not in class_dict:\n                class_dict[name] = []\n            class_dict[name].append(height)\n        \n        total_moves = 0\n        for heights in class_dict.values():\n            total_moves += self.heightChecker(heights)\n        return total_moves", "input_format": "List[Tuple[str, int]]", "output_format": "int", "test_input": ["assert apps_run2().classHeightChecker([('A', 1), ('A', 1), ('A', 4), ('A', 2), ('A', 1), ('A', 3)]) == 3", "assert apps_run2().classHeightChecker([('B', 5), ('B', 1), ('B', 2), ('B', 3), ('B', 4)]) == 5", "assert apps_run2().classHeightChecker([('C', 1), ('C', 2), ('C', 3), ('C', 4), ('C', 5)]) == 0", "assert apps_run2().classHeightChecker([('D', 3), ('D', 3), ('D', 2), ('D', 1), ('D', 4)]) == 4", "assert apps_run2().classHeightChecker([('E', 2), ('E', 2), ('E', 2), ('E', 2), ('E', 2)]) == 0"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "APPS/2508-4", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nStudents are asked to stand in non-decreasing order of heights for an annual photo.\nReturn the minimum number of students that must move in order for all students to be standing in non-decreasing order of height.\nNotice that when a group of students is selected they can reorder in any possible way between themselves and the non selected students\u00a0remain on their seats.\n\u00a0\nExample 1:\nInput: heights = [1,1,4,2,1,3]\nOutput: 3\nExplanation: \nCurrent array : [1,1,4,2,1,3]\nTarget array  : [1,1,1,2,3,4]\nOn index 2 (0-based) we have 4 vs 1 so we have to move this student.\nOn index 4 (0-based) we have 1 vs 3 so we have to move this student.\nOn index 5 (0-based) we have 3 vs 4 so we have to move this student.\n\nExample 2:\nInput: heights = [5,1,2,3,4]\nOutput: 5\n\nExample 3:\nInput: heights = [1,2,3,4,5]\nOutput: 0\n\n\u00a0\nConstraints:\n\n1 <= heights.length <= 100\n1 <= heights[i] <= 100.", "raw_solution": "def apps_run1(heights):\n    max_val = max(heights)\n    freq = [0] * (max_val + 1)\n    for num in heights:\n        freq[num] += 1\n    for num in range(1,len(freq)):\n        freq[num] += freq[num-1]\n    places = [0] * len(heights)\n    for num in heights:\n        places[freq[num] - 1] = num\n        freq[num] -= 1\n    return sum(a != b for a , b in zip(places,heights))", "raw_test_input": ["assert apps_run1([1, 1, 4, 2, 1, 3]) == 3", "assert apps_run1([5, 1, 2, 3, 4]) == 5", "assert apps_run1([1, 2, 3, 4, 5]) == 0", "assert apps_run1([2, 1, 2, 1, 1, 2, 2, 1]) == 4", "assert apps_run1([10, 6, 6, 10, 10, 6]) == 2"], "new_problem": "You are tasked with organizing students for a photo in non-decreasing order of their heights. However, due to data entry errors, the list of heights may contain invalid values such as negative numbers or non-integer types. Write a function that returns the minimum number of students that must move to achieve the correct order, while handling the following errors: \n1. InvalidHeightError: Raised when a height is negative or not an integer. \n2. EmptyListError: Raised when the input list is empty. \n3. ListTooLongError: Raised when the list exceeds 100 elements. \nEnsure that the function propagates these errors with meaningful messages.", "new_solution": "from typing import List\n\nclass InvalidHeightError(Exception):\n    pass\n\nclass EmptyListError(Exception):\n    pass\n\nclass ListTooLongError(Exception):\n    pass\n\ndef apps_run2(heights: List[int]) -> int:\n    if not heights:\n        raise EmptyListError(\"The list of heights is empty.\")\n    if len(heights) > 100:\n        raise ListTooLongError(\"The list of heights exceeds the maximum allowed length of 100.\")\n    for height in heights:\n        if not isinstance(height, int) or height < 0:\n            raise InvalidHeightError(f\"Invalid height value: {height}. Heights must be non-negative integers.\")\n    max_val = max(heights)\n    freq = [0] * (max_val + 1)\n    for num in heights:\n        freq[num] += 1\n    for num in range(1, len(freq)):\n        freq[num] += freq[num - 1]\n    places = [0] * len(heights)\n    for num in heights:\n        places[freq[num] - 1] = num\n        freq[num] -= 1\n    return sum(a != b for a, b in zip(places, heights))", "input_format": "A list of integers representing the heights of students.", "output_format": "An integer representing the minimum number of students that must move.", "test_input": ["try:\n    apps_run2([1, 1, 4, 2, 1, 3]) == 3\nexcept Exception as e:\n    print(e)", "try:\n    apps_run2([5, 1, 2, 3, 4]) == 5\nexcept Exception as e:\n    print(e)", "try:\n    apps_run2([1, 2, 3, 4, 5]) == 0\nexcept Exception as e:\n    print(e)", "try:\n    apps_run2([]) == 0\nexcept EmptyListError as e:\n    print(e)", "try:\n    apps_run2([1, 2, 3, -4, 5]) == 0\nexcept InvalidHeightError as e:\n    print(e)", "try:\n    apps_run2([1] * 101) == 0\nexcept ListTooLongError as e:\n    print(e)"], "requirement_type": "PROMPT_ERROR_HANDLING"}
{"task_id": "APPS/2506-1", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nGiven two strings s and t, determine if they are isomorphic.\n\nTwo strings are isomorphic if the characters in s can be replaced to get t.\n\nAll occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself.\n\nExample 1:\n\n\nInput: s = \"egg\", t = \"add\"\nOutput: true\n\n\nExample 2:\n\n\nInput: s = \"foo\", t = \"bar\"\nOutput: false\n\nExample 3:\n\n\nInput: s = \"paper\", t = \"title\"\nOutput: true\n\nNote:\nYou may assume both s\u00a0and t\u00a0have the same length.", "raw_solution": "def apps_run1(s1, s2):\n    return len(set(zip(s1, s2))) == len(set(s1)) == len(set(s2))", "raw_test_input": ["assert apps_run1('egg', 'add') == True", "assert apps_run1('foo', 'bar') == False", "assert apps_run1('paper', 'title') == True", "assert apps_run1('abc', 'def') == True", "assert apps_run1('ab', 'aa') == False"], "new_problem": "In the context of e-commerce, different platforms may use different product codes for the same items. Given a list of tuples, where each tuple contains two product codes from two different platforms, determine if the product codes are isomorphic. Two product codes are isomorphic if the characters in one code can be replaced to get the other code, with the order of characters preserved and no two characters mapping to the same character unless they map to themselves. This can help in identifying equivalent products across platforms.", "new_solution": "class apps_run2:\n    def isIsomorphic(self, s1, s2):\n        return len(set(zip(s1, s2))) == len(set(s1)) == len(set(s2))\n\n    def checkIsomorphicProductCodes(self, product_code_pairs):\n        results = []\n        for s, t in product_code_pairs:\n            results.append(self.isIsomorphic(s, t))\n        return results", "input_format": "A list of tuples, where each tuple contains two strings representing product codes from two different e-commerce platforms.", "output_format": "A list of booleans indicating whether each pair of product codes is isomorphic.", "test_input": ["assert apps_run2().checkIsomorphicProductCodes([('egg', 'add'), ('foo', 'bar'), ('paper', 'title')]) == [True, False, True]", "assert apps_run2().checkIsomorphicProductCodes([('abc', 'def'), ('123', '321'), ('xyz', 'zyx')]) == [True, True, True]", "assert apps_run2().checkIsomorphicProductCodes([('abcd', 'efgh'), ('mnop', 'qrst'), ('ijkl', 'mnop')]) == [True, True, True]", "assert apps_run2().checkIsomorphicProductCodes([('aabb', 'xxyy'), ('abab', 'baba'), ('aaaa', 'bbbb')]) == [True, True, True]", "assert apps_run2().checkIsomorphicProductCodes([('abcd', 'abcd'), ('wxyz', 'wxyz'), ('mnop', 'mnop')]) == [True, True, True]"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "APPS/2506-2", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nGiven two strings s and t, determine if they are isomorphic.\n\nTwo strings are isomorphic if the characters in s can be replaced to get t.\n\nAll occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself.\n\nExample 1:\n\n\nInput: s = \"egg\", t = \"add\"\nOutput: true\n\n\nExample 2:\n\n\nInput: s = \"foo\", t = \"bar\"\nOutput: false\n\nExample 3:\n\n\nInput: s = \"paper\", t = \"title\"\nOutput: true\n\nNote:\nYou may assume both s\u00a0and t\u00a0have the same length.", "raw_solution": "def apps_run1(s1, s2):\n    return len(set(zip(s1, s2))) == len(set(s1)) == len(set(s2))", "raw_test_input": ["assert apps_run1('egg', 'add') == True", "assert apps_run1('foo', 'bar') == False", "assert apps_run1('paper', 'title') == True", "assert apps_run1('ab', 'aa') == False", "assert apps_run1('abc', 'def') == True"], "new_problem": "Enhance the function to determine if two strings are isomorphic with an additional optional parameter to handle case sensitivity. The function should maintain backward compatibility with existing implementations. The new parameter, 'case_sensitive', should default to True, meaning the function will consider case when determining isomorphism. If 'case_sensitive' is set to False, the function should treat uppercase and lowercase letters as equivalent.", "new_solution": "class apps_run2:\n    def isIsomorphic(self, s1: str, s2: str, case_sensitive: bool = True) -> bool:\n        if not case_sensitive:\n            s1 = s1.lower()\n            s2 = s2.lower()\n        return len(set(zip(s1, s2))) == len(set(s1)) == len(set(s2))", "input_format": "s: str, t: str, case_sensitive: bool = True", "output_format": "bool", "test_input": ["assert apps_run2().isIsomorphic('egg', 'add') == True", "assert apps_run2().isIsomorphic('foo', 'bar') == False", "assert apps_run2().isIsomorphic('paper', 'title') == True", "assert apps_run2().isIsomorphic('Egg', 'Add', case_sensitive=False) == True", "assert apps_run2().isIsomorphic('Egg', 'Add', case_sensitive=True) == True"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "APPS/2506-3", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nGiven two strings s and t, determine if they are isomorphic.\n\nTwo strings are isomorphic if the characters in s can be replaced to get t.\n\nAll occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself.\n\nExample 1:\n\n\nInput: s = \"egg\", t = \"add\"\nOutput: true\n\n\nExample 2:\n\n\nInput: s = \"foo\", t = \"bar\"\nOutput: false\n\nExample 3:\n\n\nInput: s = \"paper\", t = \"title\"\nOutput: true\n\nNote:\nYou may assume both s\u00a0and t\u00a0have the same length.", "raw_solution": "def apps_run1(s1, s2):\n    return len(set(zip(s1, s2))) == len(set(s1)) == len(set(s2))", "raw_test_input": ["assert apps_run1('egg', 'add') == True", "assert apps_run1('foo', 'bar') == False", "assert apps_run1('paper', 'title') == True", "assert apps_run1('abc', 'def') == True", "assert apps_run1('ab', 'aa') == False"], "new_problem": "Given a list of tuples, each containing two strings s and t, determine if each pair of strings is isomorphic. Return a dictionary where the keys are the indices of the input list and the values are booleans indicating if the strings at that index are isomorphic. Use dictionaries to map characters from s to t and vice versa. Ensure that the solution handles cases where the strings contain special characters and numbers. Additionally, the solution should handle up to 10,000 pairs of strings efficiently.", "new_solution": "from typing import List, Tuple, Dict\n\nclass apps_run2:\n    def isIsomorphic(self, s1: str, s2: str) -> bool:\n        mapping_s1_to_s2 = {}\n        mapping_s2_to_s1 = {}\n        for char_s1, char_s2 in zip(s1, s2):\n            if (char_s1 in mapping_s1_to_s2 and mapping_s1_to_s2[char_s1] != char_s2) or \\\n               (char_s2 in mapping_s2_to_s1 and mapping_s2_to_s1[char_s2] != char_s1):\n                return False\n            mapping_s1_to_s2[char_s1] = char_s2\n            mapping_s2_to_s1[char_s2] = char_s1\n        return True\n\n    def isIsomorphicPairs(self, pairs: List[Tuple[str, str]]) -> Dict[int, bool]:\n        result = {}\n        for index, (s, t) in enumerate(pairs):\n            result[index] = self.isIsomorphic(s, t)\n        return result", "input_format": "A list of tuples where each tuple contains two strings, s and t.", "output_format": "A dictionary where the keys are the indices of the input list and the values are booleans indicating if the strings at that index are isomorphic.", "test_input": ["assert apps_run2().isIsomorphicPairs([('egg', 'add'), ('foo', 'bar'), ('paper', 'title')]) == {0: True, 1: False, 2: True}", "assert apps_run2().isIsomorphicPairs([('123', '456'), ('abc', 'def'), ('aabb', 'bbaa')]) == {0: True, 1: True, 2: True}", "assert apps_run2().isIsomorphicPairs([('abcd', 'efgh'), ('abab', 'baba'), ('xyz', 'xyz')]) == {0: True, 1: True, 2: True}", "assert apps_run2().isIsomorphicPairs([('!@#', '$%^'), ('123', '321'), ('hello', 'world')]) == {0: True, 1: True, 2: False}", "assert apps_run2().isIsomorphicPairs([('a', 'a'), ('', ''), ('longstring', 'longstring')]) == {0: True, 1: True, 2: True}"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "APPS/2506-4", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nGiven two strings s and t, determine if they are isomorphic.\n\nTwo strings are isomorphic if the characters in s can be replaced to get t.\n\nAll occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself.\n\nExample 1:\n\n\nInput: s = \"egg\", t = \"add\"\nOutput: true\n\n\nExample 2:\n\n\nInput: s = \"foo\", t = \"bar\"\nOutput: false\n\nExample 3:\n\n\nInput: s = \"paper\", t = \"title\"\nOutput: true\n\nNote:\nYou may assume both s\u00a0and t\u00a0have the same length.", "raw_solution": "def apps_run1(s1, s2):\n    return len(set(zip(s1, s2))) == len(set(s1)) == len(set(s2))", "raw_test_input": ["assert apps_run1('egg', 'add') == True", "assert apps_run1('foo', 'bar') == False", "assert apps_run1('paper', 'title') == True", "assert apps_run1('ab', 'aa') == False", "assert apps_run1('abc', 'def') == True"], "new_problem": "Write a function to determine if two strings s and t are isomorphic. In addition to checking if they are isomorphic, handle the following errors: 1) If either string is None, raise a ValueError with the message 'Input strings cannot be None'. 2) If the strings are of different lengths, raise a ValueError with the message 'Strings must be of the same length'. 3) If the input is not a string, raise a TypeError with the message 'Inputs must be strings'. Ensure that the function propagates these errors appropriately.", "new_solution": "class apps_run2:\n    def isIsomorphic(self, s1: str, s2: str) -> bool:\n        if s1 is None or s2 is None:\n            raise ValueError('Input strings cannot be None')\n        if not isinstance(s1, str) or not isinstance(s2, str):\n            raise TypeError('Inputs must be strings')\n        if len(s1) != len(s2):\n            raise ValueError('Strings must be of the same length')\n        return len(set(zip(s1, s2))) == len(set(s1)) == len(set(s2))", "input_format": "Two strings s and t", "output_format": "Boolean indicating if the strings are isomorphic", "test_input": ["assert apps_run2().isIsomorphic('egg', 'add') == True", "assert apps_run2().isIsomorphic('foo', 'bar') == False", "assert apps_run2().isIsomorphic('paper', 'title') == True", "try:\n    apps_run2().isIsomorphic(None, 'title')\nexcept ValueError as e:\n    assert str(e) == 'Input strings cannot be None'", "try:\n    apps_run2().isIsomorphic('paper', None)\nexcept ValueError as e:\n    assert str(e) == 'Input strings cannot be None'", "try:\n    apps_run2().isIsomorphic('paper', 'tit')\nexcept ValueError as e:\n    assert str(e) == 'Strings must be of the same length'", "try:\n    apps_run2().isIsomorphic(123, 'title')\nexcept TypeError as e:\n    assert str(e) == 'Inputs must be strings'", "try:\n    apps_run2().isIsomorphic('paper', 456)\nexcept TypeError as e:\n    assert str(e) == 'Inputs must be strings'"], "requirement_type": "PROMPT_ERROR_HANDLING"}
{"task_id": "APPS/2501-1", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nGiven a string and an integer k, you need to reverse the first k characters for every 2k characters counting from the start of the string. If there are less than k characters left, reverse all of them. If there are less than 2k but greater than or equal to k characters, then reverse the first k characters and left the other as original.\n\n\nExample:\n\nInput: s = \"abcdefg\", k = 2\nOutput: \"bacdfeg\"\n\n\n\nRestrictions: \n\n The string consists of lower English letters only.\n Length of the given string and k will in the range [1, 10000].", "raw_solution": "def apps_run1(s, k):\n    for idx in range(0, len(s), 2*k):\n        s = s[:idx] + s[idx:idx+k][::-1] + s[idx+k:]\n    return s", "raw_test_input": ["assert apps_run1('abcdefg', 2) == 'bacdfeg'", "assert apps_run1('abcd', 2) == 'bacd'", "assert apps_run1('abcdef', 3) == 'cbadef'", "assert apps_run1('a', 2) == 'a'", "assert apps_run1('abcdefgh', 4) == 'dcbaefgh'"], "new_problem": "In an e-commerce platform, product descriptions are stored as strings. To enhance security and prevent unauthorized scraping, you need to obfuscate these descriptions by reversing the first k characters for every 2k characters in each description. Implement a function that takes a list of product descriptions and an integer k, and returns a new list where each description has been processed according to the specified rule.", "new_solution": "class apps_run2:\n    def reverseStr(self, s, k):\n        for idx in range(0, len(s), 2*k):\n            s = s[:idx] + s[idx:idx+k][::-1] + s[idx+k:]\n        return s\n\n    def obfuscateDescriptions(self, descriptions, k):\n        return [self.reverseStr(description, k) for description in descriptions]", "input_format": "A list of strings representing product descriptions and an integer k.", "output_format": "A list of strings where each product description has been processed by reversing the first k characters for every 2k characters.", "test_input": ["assert apps_run2().obfuscateDescriptions(['abcdefg', 'hijklmnop', 'qrstuv'], 2) == ['bacdfeg', 'ihjkmlnop', 'rqstvu']", "assert apps_run2().obfuscateDescriptions(['productone', 'producttwo'], 3) == ['orpducnote', 'orpducwtto']", "assert apps_run2().obfuscateDescriptions(['short', 'longerdescription'], 4) == ['rohst', 'gnolerdeircsption']", "assert apps_run2().obfuscateDescriptions(['example', 'testcase'], 1) == ['example', 'testcase']", "assert apps_run2().obfuscateDescriptions(['single'], 6) == ['elgnis']"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "APPS/2501-2", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nGiven a string and an integer k, you need to reverse the first k characters for every 2k characters counting from the start of the string. If there are less than k characters left, reverse all of them. If there are less than 2k but greater than or equal to k characters, then reverse the first k characters and left the other as original.\n\n\nExample:\n\nInput: s = \"abcdefg\", k = 2\nOutput: \"bacdfeg\"\n\n\n\nRestrictions: \n\n The string consists of lower English letters only.\n Length of the given string and k will in the range [1, 10000].", "raw_solution": "def apps_run1(s, k):\n    for idx in range(0, len(s), 2*k):\n        s = s[:idx] + s[idx:idx+k][::-1] + s[idx+k:]\n    return s", "raw_test_input": ["assert apps_run1('abcdefg', 2) == 'bacdfeg'", "assert apps_run1('abcd', 2) == 'bacd'", "assert apps_run1('abcdefgh', 3) == 'cbadefhg'", "assert apps_run1('a', 2) == 'a'", "assert apps_run1('abcdefg', 1) == 'abcdefg'"], "new_problem": "Enhance the function to reverse the first k characters for every 2k characters in a string. Additionally, add optional parameters to reverse the case of the characters and to reverse the entire string order. The function should maintain backward compatibility with the original implementation.", "new_solution": "class apps_run2:\n    def reverseStr(self, s: str, k: int, reverse_case: bool = False, reverse_order: bool = False) -> str:\n        def reverse_case_func(substring: str) -> str:\n            return ''.join([char.swapcase() for char in substring])\n\n        for idx in range(0, len(s), 2*k):\n            part = s[idx:idx+k][::-1]\n            if reverse_case:\n                part = reverse_case_func(part)\n            s = s[:idx] + part + s[idx+k:]\n\n        if reverse_order:\n            s = s[::-1]\n\n        return s", "input_format": "A string s and an integer k, with optional boolean parameters reverse_case and reverse_order.", "output_format": "A string with the first k characters reversed for every 2k characters, optionally with case reversed and/or order reversed.", "test_input": ["assert apps_run2().reverseStr('abcdefg', 2) == 'bacdfeg'", "assert apps_run2().reverseStr('abcdefg', 2, reverse_case=True) == 'BAcdFEg'", "assert apps_run2().reverseStr('abcdefg', 2, reverse_order=True) == 'gefdcab'", "assert apps_run2().reverseStr('abcdefg', 2, reverse_case=True, reverse_order=True) == 'gEFdcAB'", "assert apps_run2().reverseStr('abcdefghij', 3) == 'cbadefihgj'"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "APPS/2501-3", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nGiven a string and an integer k, you need to reverse the first k characters for every 2k characters counting from the start of the string. If there are less than k characters left, reverse all of them. If there are less than 2k but greater than or equal to k characters, then reverse the first k characters and left the other as original.\n\n\nExample:\n\nInput: s = \"abcdefg\", k = 2\nOutput: \"bacdfeg\"\n\n\n\nRestrictions: \n\n The string consists of lower English letters only.\n Length of the given string and k will in the range [1, 10000].", "raw_solution": "def apps_run1(s, k):\n    for idx in range(0, len(s), 2*k):\n        s = s[:idx] + s[idx:idx+k][::-1] + s[idx+k:]\n    return s", "raw_test_input": ["assert apps_run1('abcdefg', 2) == 'bacdfeg'", "assert apps_run1('abcd', 2) == 'bacd'", "assert apps_run1('a', 2) == 'a'", "assert apps_run1('abcdef', 3) == 'cbadef'", "assert apps_run1('abcdefgh', 4) == 'dcbaefgh'"], "new_problem": "Given a dictionary with a string and an integer k, reverse the first k characters for every 2k characters counting from the start of the string. If there are less than k characters left, reverse all of them. If there are less than 2k but greater than or equal to k characters, then reverse the first k characters and leave the other as original. The solution should use a dictionary to store intermediate results and handle the transformation. Additionally, the function should include type hints and handle strings of length up to 20,000.", "new_solution": "from typing import Dict\n\nclass apps_run2:\n    def reverseStr(self, s: str, k: int) -> str:\n        for idx in range(0, len(s), 2*k):\n            s = s[:idx] + s[idx:idx+k][::-1] + s[idx+k:]\n        return s\n\n    def reverseStrWithDict(self, data: Dict[str, str]) -> Dict[str, str]:\n        s = data['string']\n        k = data['k']\n        result = self.reverseStr(s, k)\n        return {'result': result}", "input_format": "A dictionary with keys 'string' and 'k', where 'string' is a string of lowercase English letters and 'k' is an integer.", "output_format": "A dictionary with a single key 'result' containing the transformed string.", "test_input": ["assert apps_run2().reverseStrWithDict({'string': 'abcdefg', 'k': 2}) == {'result': 'bacdfeg'}", "assert apps_run2().reverseStrWithDict({'string': 'abcdefghij', 'k': 3}) == {'result': 'cbadefihgj'}", "assert apps_run2().reverseStrWithDict({'string': 'a', 'k': 1}) == {'result': 'a'}", "assert apps_run2().reverseStrWithDict({'string': 'abcdefgh', 'k': 4}) == {'result': 'dcbaefgh'}", "assert apps_run2().reverseStrWithDict({'string': 'abcdefghijklmnop', 'k': 5}) == {'result': 'edcbafghijonmlkp'}"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "APPS/2501-4", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nGiven a string and an integer k, you need to reverse the first k characters for every 2k characters counting from the start of the string. If there are less than k characters left, reverse all of them. If there are less than 2k but greater than or equal to k characters, then reverse the first k characters and left the other as original.\n\n\nExample:\n\nInput: s = \"abcdefg\", k = 2\nOutput: \"bacdfeg\"\n\n\n\nRestrictions: \n\n The string consists of lower English letters only.\n Length of the given string and k will in the range [1, 10000].", "raw_solution": "def apps_run1(s, k):\n    for idx in range(0, len(s), 2*k):\n        s = s[:idx] + s[idx:idx+k][::-1] + s[idx+k:]\n    return s", "raw_test_input": ["assert apps_run1('abcdefg', 2) == 'bacdfeg'", "assert apps_run1('abcd', 2) == 'bacd'", "assert apps_run1('abcdefg', 3) == 'cbadefg'", "assert apps_run1('abcdefgh', 4) == 'dcbaefgh'", "assert apps_run1('a', 2) == 'a'"], "new_problem": "Write a function that reverses the first k characters for every 2k characters in a given string. The function should handle the following errors: 1) If the string contains non-lowercase English letters, raise a ValueError. 2) If k is not a positive integer, raise a ValueError. 3) If the string is empty, raise a ValueError. 4) If the string length exceeds 10000, raise a ValueError. Implement error propagation and provide meaningful error messages.", "new_solution": "class apps_run2:\n    class ReverseStringError(Exception):\n        pass\n\n    class InvalidCharacterError(ReverseStringError):\n        pass\n\n    class InvalidKValueError(ReverseStringError):\n        pass\n\n    class EmptyStringError(ReverseStringError):\n        pass\n\n    class StringLengthExceededError(ReverseStringError):\n        pass\n\n    def reverseStr(self, s: str, k: int) -> str:\n        if not s:\n            raise self.EmptyStringError(\"The input string is empty.\")\n        if len(s) > 10000:\n            raise self.StringLengthExceededError(\"The input string length exceeds 10000 characters.\")\n        if not all(c.islower() for c in s):\n            raise self.InvalidCharacterError(\"The string contains non-lowercase English letters.\")\n        if not isinstance(k, int) or k <= 0:\n            raise self.InvalidKValueError(\"The value of k must be a positive integer.\")\n\n        for idx in range(0, len(s), 2*k):\n            s = s[:idx] + s[idx:idx+k][::-1] + s[idx+k:]\n        return s", "input_format": "A string s and an integer k", "output_format": "A string with the first k characters reversed for every 2k characters", "test_input": ["assert apps_run2().reverseStr('abcdefg', 2) == 'bacdfeg'", "try:\n    apps_run2().reverseStr('abcDefg', 2)\nexcept apps_run2.InvalidCharacterError as e:\n    assert str(e) == 'The string contains non-lowercase English letters.'", "try:\n    apps_run2().reverseStr('abcdefg', -1)\nexcept apps_run2.InvalidKValueError as e:\n    assert str(e) == 'The value of k must be a positive integer.'", "try:\n    apps_run2().reverseStr('', 2)\nexcept apps_run2.EmptyStringError as e:\n    assert str(e) == 'The input string is empty.'", "try:\n    apps_run2().reverseStr('a' * 10001, 2)\nexcept apps_run2.StringLengthExceededError as e:\n    assert str(e) == 'The input string length exceeds 10000 characters.'"], "requirement_type": "PROMPT_ERROR_HANDLING"}
{"task_id": "APPS/2512-1", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nEvery email consists of a local name and a domain name, separated by the @ sign.\nFor example, in alice@leetcode.com,\u00a0alice is the local name, and leetcode.com is the domain name.\nBesides lowercase letters, these emails may contain '.'s or '+'s.\nIf you add periods ('.') between some characters in the local name part of an email address, mail sent there will be forwarded to the same address without dots in the local name.\u00a0 For example, \"alice.z@leetcode.com\" and \"alicez@leetcode.com\" forward to the same email address.\u00a0 (Note that this rule does not apply for domain names.)\nIf you add a plus ('+') in the local name, everything after the first plus sign will be\u00a0ignored. This allows certain emails to be filtered, for example\u00a0m.y+name@email.com\u00a0will be forwarded to\u00a0my@email.com.\u00a0 (Again, this rule does not apply for domain names.)\nIt is possible to use both of these rules at the same time.\nGiven a list of emails, we send one email to each address in the list.\u00a0\u00a0How many different addresses actually receive mails?\u00a0\n\u00a0\n\nExample 1:\nInput: [\"test.email+alex@leetcode.com\",\"test.e.mail+bob.cathy@leetcode.com\",\"testemail+david@lee.tcode.com\"]\nOutput: 2\nExplanation:\u00a0\"testemail@leetcode.com\" and \"testemail@lee.tcode.com\" actually receive mails\n\n\u00a0\nNote:\n\n1 <= emails[i].length\u00a0<= 100\n1 <= emails.length <= 100\nEach emails[i] contains exactly one '@' character.\nAll local and domain names are non-empty.\nLocal names do not start with a '+' character.", "raw_solution": "def apps_run1(emails):\n    s = []\n    for email in emails:\n        for i in range(len(email)):\n            if email[i] == '@':\n                localname = email[:i]\n                domainname = email[i:]\n                local = ''\n                for x in localname:\n                    if x == '+':\n                        break\n                    local += x\n                local = local.replace('.', '')\n                s.append(local + domainname)\n                break\n    return len(set(s))", "raw_test_input": ["assert apps_run1(['test.email+alex@leetcode.com', 'test.e.mail+bob.cathy@leetcode.com', 'testemail+david@lee.tcode.com']) == 2", "assert apps_run1(['a@leetcode.com', 'b@leetcode.com', 'c@leetcode.com']) == 3", "assert apps_run1(['test.email+alex@leetcode.com', 'test.email.leet+alex@code.com']) == 2", "assert apps_run1(['test.email+alex@leetcode.com', 'test.email@leetcode.com']) == 1", "assert apps_run1(['test.email+alex@leetcode.com', 'test.email.leet+alex@code.com', 'test.email@leetcode.com']) == 2"], "new_problem": "In an e-commerce platform, users register with their email addresses. The platform wants to send promotional emails only to users whose email addresses belong to specific domains. Given a list of email addresses and a list of target domains, determine how many unique email addresses belong to these domains after applying the email normalization rules (ignoring dots and characters after '+').", "new_solution": "from typing import List\n\nclass apps_run2:\n    def numUniqueEmails(self, emails: List[str]) -> int:\n        s = [];\n        for email in emails:\n            for i in range(len(email)):\n                if email[i]=='@':\n                    localname = email[:i];\n                    domainname = email[i:];\n                    local = '';\n                    for x in localname:\n                        if x=='+':\n                            break;\n                        local += x;\n                    local = local.replace('.','');\n                    s.append(local+domainname);\n                    break;\n        return len(set(s));\n\n    def numUniqueEmailsInDomains(self, emails: List[str], domains: List[str]) -> int:\n        in_domains_emails = []\n        for email in emails:\n            local, domain = email.split('@')\n            if domain in domains:\n                in_domains_emails.append(email)\n        return self.numUniqueEmails(in_domains_emails)\n", "input_format": "A dictionary with keys 'emails' (a list of email addresses) and 'domains' (a list of domain names to filter).", "output_format": "An integer representing the number of unique email addresses that belong to the specified domains.", "test_input": ["assert apps_run2().numUniqueEmailsInDomains(['test.email+alex@leetcode.com', 'test.e.mail+bob.cathy@leetcode.com', 'testemail+david@lee.tcode.com'], ['leetcode.com', 'lee.tcode.com']) == 2", "assert apps_run2().numUniqueEmailsInDomains(['user+name@domain.com', 'user.name@domain.com', 'user@other.com'], ['domain.com']) == 2", "assert apps_run2().numUniqueEmailsInDomains(['a@b.com', 'a+b@b.com', 'a.b@b.com'], ['b.com']) == 2", "assert apps_run2().numUniqueEmailsInDomains(['x@y.com', 'x+y@z.com', 'x@z.com'], ['y.com', 'z.com']) == 2", "assert apps_run2().numUniqueEmailsInDomains(['alice@wonderland.com', 'alice+test@wonderland.com', 'bob@builder.com'], ['wonderland.com']) == 1"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "APPS/2512-2", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nEvery email consists of a local name and a domain name, separated by the @ sign.\nFor example, in alice@leetcode.com,\u00a0alice is the local name, and leetcode.com is the domain name.\nBesides lowercase letters, these emails may contain '.'s or '+'s.\nIf you add periods ('.') between some characters in the local name part of an email address, mail sent there will be forwarded to the same address without dots in the local name.\u00a0 For example, \"alice.z@leetcode.com\" and \"alicez@leetcode.com\" forward to the same email address.\u00a0 (Note that this rule does not apply for domain names.)\nIf you add a plus ('+') in the local name, everything after the first plus sign will be\u00a0ignored. This allows certain emails to be filtered, for example\u00a0m.y+name@email.com\u00a0will be forwarded to\u00a0my@email.com.\u00a0 (Again, this rule does not apply for domain names.)\nIt is possible to use both of these rules at the same time.\nGiven a list of emails, we send one email to each address in the list.\u00a0\u00a0How many different addresses actually receive mails?\u00a0\n\u00a0\n\nExample 1:\nInput: [\"test.email+alex@leetcode.com\",\"test.e.mail+bob.cathy@leetcode.com\",\"testemail+david@lee.tcode.com\"]\nOutput: 2\nExplanation:\u00a0\"testemail@leetcode.com\" and \"testemail@lee.tcode.com\" actually receive mails\n\n\u00a0\nNote:\n\n1 <= emails[i].length\u00a0<= 100\n1 <= emails.length <= 100\nEach emails[i] contains exactly one '@' character.\nAll local and domain names are non-empty.\nLocal names do not start with a '+' character.", "raw_solution": "def apps_run1(emails):\n    s = []\n    for email in emails:\n        for i in range(len(email)):\n            if email[i] == '@':\n                localname = email[:i]\n                domainname = email[i:]\n                local = ''\n                for x in localname:\n                    if x == '+':\n                        break\n                    local += x\n                local = local.replace('.', '')\n                s.append(local + domainname)\n                break\n    return len(set(s))", "raw_test_input": ["assert apps_run1(['test.email+alex@leetcode.com', 'test.e.mail+bob.cathy@leetcode.com', 'testemail+david@lee.tcode.com']) == 2", "assert apps_run1(['a@leetcode.com', 'b@leetcode.com', 'c@leetcode.com']) == 3", "assert apps_run1(['test.email+alex@leetcode.com', 'test.email.leet+alex@code.com']) == 2", "assert apps_run1(['test.email@leetcode.com', 'test.email+spam@leetcode.com']) == 1", "assert apps_run1(['test.email+alex@leetcode.com', 'test.email@leetcode.com']) == 1"], "new_problem": "Enhance the email processing function to optionally ignore domain names when counting unique emails. The function should maintain backward compatibility with the original implementation. The new function should accept an optional boolean parameter 'ignore_domain'. If 'ignore_domain' is True, the function should count unique emails based only on the local name, ignoring the domain name. If 'ignore_domain' is False or not provided, the function should behave as originally specified, considering both local and domain names.", "new_solution": "from typing import List, Optional\n\nclass apps_run2:\n    def numUniqueEmails(self, emails: List[str], ignore_domain: Optional[bool] = False) -> int:\n        s = []\n        for email in emails:\n            for i in range(len(email)):\n                if email[i] == '@':\n                    localname = email[:i]\n                    domainname = email[i:]\n                    local = ''\n                    for x in localname:\n                        if x == '+':\n                            break\n                        local += x\n                    local = local.replace('.', '')\n                    if ignore_domain:\n                        s.append(local)\n                    else:\n                        s.append(local + domainname)\n                    break\n        return len(set(s))", "input_format": "List[str], Optional[bool]", "output_format": "int", "test_input": ["assert apps_run2().numUniqueEmails([\"test.email+alex@leetcode.com\",\"test.e.mail+bob.cathy@leetcode.com\",\"testemail+david@lee.tcode.com\"]) == 2", "assert apps_run2().numUniqueEmails([\"a@leetcode.com\",\"b@leetcode.com\",\"c@leetcode.com\"]) == 3", "assert apps_run2().numUniqueEmails([\"a@leetcode.com\",\"a@lee.tcode.com\"], ignore_domain=True) == 1", "assert apps_run2().numUniqueEmails([\"test.email+alex@leetcode.com\",\"test.email.leet+alex@code.com\"], ignore_domain=True) == 2", "assert apps_run2().numUniqueEmails([\"test.email+alex@leetcode.com\",\"test.email.leet+alex@code.com\"], ignore_domain=False) == 2"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "APPS/2512-3", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nEvery email consists of a local name and a domain name, separated by the @ sign.\nFor example, in alice@leetcode.com,\u00a0alice is the local name, and leetcode.com is the domain name.\nBesides lowercase letters, these emails may contain '.'s or '+'s.\nIf you add periods ('.') between some characters in the local name part of an email address, mail sent there will be forwarded to the same address without dots in the local name.\u00a0 For example, \"alice.z@leetcode.com\" and \"alicez@leetcode.com\" forward to the same email address.\u00a0 (Note that this rule does not apply for domain names.)\nIf you add a plus ('+') in the local name, everything after the first plus sign will be\u00a0ignored. This allows certain emails to be filtered, for example\u00a0m.y+name@email.com\u00a0will be forwarded to\u00a0my@email.com.\u00a0 (Again, this rule does not apply for domain names.)\nIt is possible to use both of these rules at the same time.\nGiven a list of emails, we send one email to each address in the list.\u00a0\u00a0How many different addresses actually receive mails?\u00a0\n\u00a0\n\nExample 1:\nInput: [\"test.email+alex@leetcode.com\",\"test.e.mail+bob.cathy@leetcode.com\",\"testemail+david@lee.tcode.com\"]\nOutput: 2\nExplanation:\u00a0\"testemail@leetcode.com\" and \"testemail@lee.tcode.com\" actually receive mails\n\n\u00a0\nNote:\n\n1 <= emails[i].length\u00a0<= 100\n1 <= emails.length <= 100\nEach emails[i] contains exactly one '@' character.\nAll local and domain names are non-empty.\nLocal names do not start with a '+' character.", "raw_solution": "def apps_run1(emails):\n    s = []\n    for email in emails:\n        for i in range(len(email)):\n            if email[i] == '@':\n                localname = email[:i]\n                domainname = email[i:]\n                local = ''\n                for x in localname:\n                    if x == '+':\n                        break\n                    local += x\n                local = local.replace('.', '')\n                s.append(local + domainname)\n                break\n    return len(set(s))", "raw_test_input": ["assert apps_run1(['test.email+alex@leetcode.com', 'test.e.mail+bob.cathy@leetcode.com', 'testemail+david@lee.tcode.com']) == 2", "assert apps_run1(['a@leetcode.com', 'b@leetcode.com', 'c@leetcode.com']) == 3", "assert apps_run1(['test.email+alex@leetcode.com', 'test.email.leet+alex@code.com']) == 2", "assert apps_run1(['test.email+alex@leetcode.com', 'test.email@leetcode.com']) == 1", "assert apps_run1(['test.email+alex@leetcode.com', 'test.email+alex@leetcode.com']) == 1"], "new_problem": "Given a dictionary where each key is a user ID and the value is a list of email addresses associated with that user, determine how many unique email addresses actually receive mails. Each email consists of a local name and a domain name, separated by the @ sign. The local name may contain '.'s or '+'s, which are ignored as per the rules described. The domain name remains unchanged. You must use a dictionary to store the processed email addresses and handle the relationships between user IDs and their email addresses. Additionally, ensure that the solution can handle up to 1000 users, each with up to 100 email addresses.", "new_solution": "from typing import Dict, List\n\nclass apps_run2:\n    def numUniqueEmails(self, user_emails: Dict[int, List[str]]) -> int:\n        unique_emails = set()\n        for user_id, emails in user_emails.items():\n            for email in emails:\n                local, domain = email.split('@')\n                local = local.split('+')[0].replace('.', '')\n                unique_emails.add(local + '@' + domain)\n        return len(unique_emails)", "input_format": "A dictionary where keys are user IDs and values are lists of email addresses associated with each user.", "output_format": "An integer representing the number of unique email addresses that actually receive mails.", "test_input": ["assert apps_run2().numUniqueEmails({1: [\"test.email+alex@leetcode.com\", \"test.e.mail+bob.cathy@leetcode.com\"], 2: [\"testemail+david@lee.tcode.com\"]}) == 2", "assert apps_run2().numUniqueEmails({1: [\"a@leetcode.com\", \"b@leetcode.com\"], 2: [\"c@leetcode.com\", \"a@leetcode.com\"]}) == 3", "assert apps_run2().numUniqueEmails({1: [\"a.b.c+d@leetcode.com\", \"abc@leetcode.com\"], 2: [\"a.b.c@leetcode.com\"]}) == 1", "assert apps_run2().numUniqueEmails({1: [\"x@domain.com\", \"x+spam@domain.com\"], 2: [\"x@domain.com\"]}) == 1", "assert apps_run2().numUniqueEmails({1: [\"unique@domain.com\"], 2: [\"unique@domain.com\"], 3: [\"unique@domain.com\"]}) == 1"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "APPS/2512-4", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nEvery email consists of a local name and a domain name, separated by the @ sign.\nFor example, in alice@leetcode.com,\u00a0alice is the local name, and leetcode.com is the domain name.\nBesides lowercase letters, these emails may contain '.'s or '+'s.\nIf you add periods ('.') between some characters in the local name part of an email address, mail sent there will be forwarded to the same address without dots in the local name.\u00a0 For example, \"alice.z@leetcode.com\" and \"alicez@leetcode.com\" forward to the same email address.\u00a0 (Note that this rule does not apply for domain names.)\nIf you add a plus ('+') in the local name, everything after the first plus sign will be\u00a0ignored. This allows certain emails to be filtered, for example\u00a0m.y+name@email.com\u00a0will be forwarded to\u00a0my@email.com.\u00a0 (Again, this rule does not apply for domain names.)\nIt is possible to use both of these rules at the same time.\nGiven a list of emails, we send one email to each address in the list.\u00a0\u00a0How many different addresses actually receive mails?\u00a0\n\u00a0\n\nExample 1:\nInput: [\"test.email+alex@leetcode.com\",\"test.e.mail+bob.cathy@leetcode.com\",\"testemail+david@lee.tcode.com\"]\nOutput: 2\nExplanation:\u00a0\"testemail@leetcode.com\" and \"testemail@lee.tcode.com\" actually receive mails\n\n\u00a0\nNote:\n\n1 <= emails[i].length\u00a0<= 100\n1 <= emails.length <= 100\nEach emails[i] contains exactly one '@' character.\nAll local and domain names are non-empty.\nLocal names do not start with a '+' character.", "raw_solution": "def apps_run1(emails):\n    s = []\n    for email in emails:\n        for i in range(len(email)):\n            if email[i] == '@':\n                localname = email[:i]\n                domainname = email[i:]\n                local = ''\n                for x in localname:\n                    if x == '+':\n                        break\n                    local += x\n                local = local.replace('.', '')\n                s.append(local + domainname)\n                break\n    return len(set(s))", "raw_test_input": ["assert apps_run1(['test.email+alex@leetcode.com', 'test.e.mail+bob.cathy@leetcode.com', 'testemail+david@lee.tcode.com']) == 2", "assert apps_run1(['a@leetcode.com', 'b@leetcode.com', 'c@leetcode.com']) == 3", "assert apps_run1(['test.email+alex@leetcode.com', 'test.email.leet+alex@code.com']) == 2", "assert apps_run1(['test.email+alex@leetcode.com', 'test.email@leetcode.com']) == 1", "assert apps_run1(['test.email+alex@leetcode.com', 'test.email.leet+alex@code.com', 'test.email+alex@leetcode.com']) == 2"], "new_problem": "Write a function that processes a list of email addresses and returns the number of unique addresses that actually receive emails. The function should handle the following errors: 1) Invalid email format (missing '@' or multiple '@' characters). 2) Local names starting with a '+' character. 3) Domain names containing invalid characters. Define specific error types for these scenarios and ensure meaningful error messages are provided. The function should propagate errors appropriately and maintain type hints.", "new_solution": "from typing import List\n\nclass InvalidEmailFormatError(Exception):\n    pass\n\nclass InvalidLocalNameError(Exception):\n    pass\n\nclass InvalidDomainNameError(Exception):\n    pass\n\nclass apps_run2:\n    def numUniqueEmails(self, emails: List[str]) -> int:\n        def validate_email(email: str) -> None:\n            if email.count('@') != 1:\n                raise InvalidEmailFormatError(f\"Invalid email format: {email}\")\n            localname, domainname = email.split('@')\n            if localname.startswith('+'):\n                raise InvalidLocalNameError(f\"Local name starts with '+': {email}\")\n            if not domainname.replace('.', '').isalnum():\n                raise InvalidDomainNameError(f\"Invalid characters in domain name: {email}\")\n\n        s = []\n        for email in emails:\n            try:\n                validate_email(email)\n                localname, domainname = email.split('@')\n                local = ''\n                for x in localname:\n                    if x == '+':\n                        break\n                    local += x\n                local = local.replace('.', '')\n                s.append(local + '@' + domainname)\n            except (InvalidEmailFormatError, InvalidLocalNameError, InvalidDomainNameError) as e:\n                print(f\"Error processing email '{email}': {e}\")\n        return len(set(s))", "input_format": "A list of email addresses as strings.", "output_format": "An integer representing the number of unique email addresses that actually receive emails.", "test_input": ["assert apps_run2().numUniqueEmails([\"test.email+alex@leetcode.com\",\"test.e.mail+bob.cathy@leetcode.com\",\"testemail+david@lee.tcode.com\"]) == 2", "assert apps_run2().numUniqueEmails([\"invalidemail.com\",\"test.email@leetcode.com\"]) == 1", "assert apps_run2().numUniqueEmails([\"+test@domain.com\",\"test@domain.com\"]) == 1", "assert apps_run2().numUniqueEmails([\"test@domain.com\",\"test@domain..com\"]) == 2", "assert apps_run2().numUniqueEmails([\"test.email+alex@leetcode.com\",\"test.email@leetcode.com\",\"test.email@leetcode.com\"]) == 1"], "requirement_type": "PROMPT_ERROR_HANDLING"}
{"task_id": "APPS/2514-1", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nGiven two integer arrays arr1 and arr2, and the integer d, return the distance value between the two\u00a0arrays.\nThe distance value is defined as the number of elements arr1[i] such that there is not any element arr2[j] where |arr1[i]-arr2[j]| <= d.\n\u00a0\nExample 1:\nInput: arr1 = [4,5,8], arr2 = [10,9,1,8], d = 2\nOutput: 2\nExplanation: \nFor arr1[0]=4 we have: \n|4-10|=6 > d=2 \n|4-9|=5 > d=2 \n|4-1|=3 > d=2 \n|4-8|=4 > d=2 \nFor arr1[1]=5 we have: \n|5-10|=5 > d=2 \n|5-9|=4 > d=2 \n|5-1|=4 > d=2 \n|5-8|=3 > d=2\nFor arr1[2]=8 we have:\n|8-10|=2 <= d=2\n|8-9|=1 <= d=2\n|8-1|=7 > d=2\n|8-8|=0 <= d=2\n\nExample 2:\nInput: arr1 = [1,4,2,3], arr2 = [-4,-3,6,10,20,30], d = 3\nOutput: 2\n\nExample 3:\nInput: arr1 = [2,1,100,3], arr2 = [-5,-2,10,-3,7], d = 6\nOutput: 1\n\n\u00a0\nConstraints:\n\n1 <= arr1.length, arr2.length <= 500\n-10^3 <= arr1[i], arr2[j] <= 10^3\n0 <= d <= 100.", "raw_solution": "def apps_run1(arr1, arr2, d):\n    count = 0\n    for i in arr1:\n        flag = 0\n        for j in arr2:\n            if abs(i - j) <= d:\n                flag = 1\n                break\n        if flag == 0:\n            count += 1\n    return count", "raw_test_input": ["assert apps_run1([4, 5, 8], [10, 9, 1, 8], 2) == 2", "assert apps_run1([1, 4, 2, 3], [-4, -3, 6, 10, 20, 30], 3) == 2", "assert apps_run1([2, 1, 100, 3], [-5, -2, 10, -3, 7], 6) == 1", "assert apps_run1([1, 2, 3, 4, 5], [10, 20, 30, 40, 50], 5) == 4", "assert apps_run1([10, 20, 30], [1, 2, 3, 4, 5], 10) == 2"], "new_problem": "In a logistics company, you are tasked with evaluating the compatibility of different sets of delivery routes based on their distance values. Each route is represented by an integer array, and you have multiple sets of routes to evaluate. For each set, you need to determine the distance value between two routes using a given threshold distance d. The distance value is defined as the number of elements in the first route that do not have any corresponding element in the second route within the threshold distance. Your task is to write a function that takes a list of tuples, where each tuple contains two integer arrays and an integer d, and returns a list of distance values for each tuple.", "new_solution": "from typing import List, Tuple\n\nclass apps_run2:\n    def findTheDistanceValue(self, arr1: List[int], arr2: List[int], d: int) -> int:\n        count = 0\n        for i in arr1:\n            flag = 0\n            for j in arr2:\n                if abs(i - j) <= d:\n                    flag = 1\n                    break\n            if flag == 0:\n                count += 1\n        return count\n\n    def evaluateRouteCompatibility(self, route_sets: List[Tuple[List[int], List[int], int]]) -> List[int]:\n        results = []\n        for arr1, arr2, d in route_sets:\n            distance_value = self.findTheDistanceValue(arr1, arr2, d)\n            results.append(distance_value)\n        return results", "input_format": "A list of tuples where each tuple contains two integer arrays and an integer d, representing multiple scenarios to evaluate.", "output_format": "A list of integers where each integer represents the distance value for the corresponding tuple of arrays and d.", "test_input": ["assert apps_run2().evaluateRouteCompatibility([([4,5,8], [10,9,1,8], 2), ([1,4,2,3], [-4,-3,6,10,20,30], 3)]) == [2, 2]", "assert apps_run2().evaluateRouteCompatibility([([2,1,100,3], [-5,-2,10,-3,7], 6), ([1,2,3], [4,5,6], 1)]) == [1, 2]", "assert apps_run2().evaluateRouteCompatibility([([10,20,30], [15,25,35], 5), ([0,0,0], [0,0,0], 0)]) == [0, 0]", "assert apps_run2().evaluateRouteCompatibility([([1,2,3,4,5], [10,9,8,7,6], 4), ([5,5,5], [5,5,5], 0)]) == [1, 0]", "assert apps_run2().evaluateRouteCompatibility([([100,200,300], [150,250,350], 50), ([1,1,1], [2,2,2], 1)]) == [0, 0]"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "APPS/2514-2", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nGiven two integer arrays arr1 and arr2, and the integer d, return the distance value between the two\u00a0arrays.\nThe distance value is defined as the number of elements arr1[i] such that there is not any element arr2[j] where |arr1[i]-arr2[j]| <= d.\n\u00a0\nExample 1:\nInput: arr1 = [4,5,8], arr2 = [10,9,1,8], d = 2\nOutput: 2\nExplanation: \nFor arr1[0]=4 we have: \n|4-10|=6 > d=2 \n|4-9|=5 > d=2 \n|4-1|=3 > d=2 \n|4-8|=4 > d=2 \nFor arr1[1]=5 we have: \n|5-10|=5 > d=2 \n|5-9|=4 > d=2 \n|5-1|=4 > d=2 \n|5-8|=3 > d=2\nFor arr1[2]=8 we have:\n|8-10|=2 <= d=2\n|8-9|=1 <= d=2\n|8-1|=7 > d=2\n|8-8|=0 <= d=2\n\nExample 2:\nInput: arr1 = [1,4,2,3], arr2 = [-4,-3,6,10,20,30], d = 3\nOutput: 2\n\nExample 3:\nInput: arr1 = [2,1,100,3], arr2 = [-5,-2,10,-3,7], d = 6\nOutput: 1\n\n\u00a0\nConstraints:\n\n1 <= arr1.length, arr2.length <= 500\n-10^3 <= arr1[i], arr2[j] <= 10^3\n0 <= d <= 100.", "raw_solution": "def apps_run1(arr1, arr2, d):\n    count = 0\n    for i in arr1:\n        flag = 0\n        for j in arr2:\n            if abs(i - j) <= d:\n                flag = 1\n                break\n        if flag == 0:\n            count += 1\n    return count", "raw_test_input": ["assert apps_run1([4, 5, 8], [10, 9, 1, 8], 2) == 2", "assert apps_run1([1, 4, 2, 3], [-4, -3, 6, 10, 20, 30], 3) == 2", "assert apps_run1([2, 1, 100, 3], [-5, -2, 10, -3, 7], 6) == 1", "assert apps_run1([1, 2, 3, 4, 5], [10, 20, 30, 40, 50], 5) == 4", "assert apps_run1([10, 20, 30], [1, 2, 3, 4, 5], 10) == 2"], "new_problem": "Enhance the function to calculate the distance value between two integer arrays arr1 and arr2, with an additional optional parameter ignore_negative. If ignore_negative is set to True, the function should ignore any negative values in arr1 and arr2 when calculating the distance value. The function should maintain backward compatibility, meaning it should work as originally intended when ignore_negative is not provided or set to False.", "new_solution": "from typing import List, Optional\n\nclass apps_run2:\n    def findTheDistanceValue(self, arr1: List[int], arr2: List[int], d: int, ignore_negative: Optional[bool] = False) -> int:\n        if ignore_negative:\n            arr1 = [x for x in arr1 if x >= 0]\n            arr2 = [x for x in arr2 if x >= 0]\n        count = 0\n        for i in arr1:\n            flag = 0\n            for j in arr2:\n                if abs(i - j) <= d:\n                    flag = 1\n                    break\n            if flag == 0:\n                count += 1\n        return count", "input_format": "arr1: List[int], arr2: List[int], d: int, ignore_negative: Optional[bool] = False", "output_format": "int", "test_input": ["assert apps_run2().findTheDistanceValue([4,5,8], [10,9,1,8], 2) == 2", "assert apps_run2().findTheDistanceValue([1,4,2,3], [-4,-3,6,10,20,30], 3) == 2", "assert apps_run2().findTheDistanceValue([2,1,100,3], [-5,-2,10,-3,7], 6) == 1", "assert apps_run2().findTheDistanceValue([4,5,8], [10,9,1,8], 2, ignore_negative=True) == 2", "assert apps_run2().findTheDistanceValue([-1,-4,-2,-3], [-4,-3,-6,-10,-20,-30], 3, ignore_negative=True) == 0"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "APPS/2514-3", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nGiven two integer arrays arr1 and arr2, and the integer d, return the distance value between the two\u00a0arrays.\nThe distance value is defined as the number of elements arr1[i] such that there is not any element arr2[j] where |arr1[i]-arr2[j]| <= d.\n\u00a0\nExample 1:\nInput: arr1 = [4,5,8], arr2 = [10,9,1,8], d = 2\nOutput: 2\nExplanation: \nFor arr1[0]=4 we have: \n|4-10|=6 > d=2 \n|4-9|=5 > d=2 \n|4-1|=3 > d=2 \n|4-8|=4 > d=2 \nFor arr1[1]=5 we have: \n|5-10|=5 > d=2 \n|5-9|=4 > d=2 \n|5-1|=4 > d=2 \n|5-8|=3 > d=2\nFor arr1[2]=8 we have:\n|8-10|=2 <= d=2\n|8-9|=1 <= d=2\n|8-1|=7 > d=2\n|8-8|=0 <= d=2\n\nExample 2:\nInput: arr1 = [1,4,2,3], arr2 = [-4,-3,6,10,20,30], d = 3\nOutput: 2\n\nExample 3:\nInput: arr1 = [2,1,100,3], arr2 = [-5,-2,10,-3,7], d = 6\nOutput: 1\n\n\u00a0\nConstraints:\n\n1 <= arr1.length, arr2.length <= 500\n-10^3 <= arr1[i], arr2[j] <= 10^3\n0 <= d <= 100.", "raw_solution": "def apps_run1(arr1, arr2, d):\n    count = 0\n    for i in arr1:\n        flag = 0\n        for j in arr2:\n            if abs(i - j) <= d:\n                flag = 1\n                break\n        if flag == 0:\n            count += 1\n    return count", "raw_test_input": ["assert apps_run1([4, 5, 8], [10, 9, 1, 8], 2) == 2", "assert apps_run1([1, 4, 2, 3], [-4, -3, 6, 10, 20, 30], 3) == 2", "assert apps_run1([2, 1, 100, 3], [-5, -2, 10, -3, 7], 6) == 1", "assert apps_run1([1, 2, 3, 4, 5], [10, 20, 30, 40, 50], 5) == 4", "assert apps_run1([10, 20, 30], [1, 2, 3, 4, 5], 10) == 2"], "new_problem": "Given two integer arrays arr1 and arr2, and an integer d, return the distance value between the two arrays. The distance value is defined as the number of elements arr1[i] such that there is not any element arr2[j] where |arr1[i]-arr2[j]| <= d. However, instead of using arrays, use dictionaries where the keys are the indices and the values are the integers from the arrays. Additionally, ensure that the solution can handle cases where the arrays have up to 1000 elements and the values can range from -10^4 to 10^4.", "new_solution": "from typing import Dict\n\nclass apps_run2:\n    def findTheDistanceValue(self, arr1: Dict[int, int], arr2: Dict[int, int], d: int) -> int:\n        count = 0\n        for i in arr1.values():\n            flag = 0\n            for j in arr2.values():\n                if abs(i - j) <= d:\n                    flag = 1\n                    break\n            if flag == 0:\n                count += 1\n        return count", "input_format": "A dictionary with keys 'arr1', 'arr2', and 'd', where 'arr1' and 'arr2' are lists of integers and 'd' is an integer.", "output_format": "An integer representing the distance value between the two arrays.", "test_input": ["assert apps_run2().findTheDistanceValue({0: 4, 1: 5, 2: 8}, {0: 10, 1: 9, 2: 1, 3: 8}, 2) == 2", "assert apps_run2().findTheDistanceValue({0: 1, 1: 4, 2: 2, 3: 3}, {0: -4, 1: -3, 2: 6, 3: 10, 4: 20, 5: 30}, 3) == 2", "assert apps_run2().findTheDistanceValue({0: 2, 1: 1, 2: 100, 3: 3}, {0: -5, 1: -2, 2: 10, 3: -3, 4: 7}, 6) == 1", "assert apps_run2().findTheDistanceValue({0: 0, 1: 0, 2: 0}, {0: 1, 1: 2, 2: 3}, 0) == 3", "assert apps_run2().findTheDistanceValue({0: 10, 1: 20, 2: 30}, {0: 5, 1: 15, 2: 25}, 5) == 0"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "APPS/2514-4", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nGiven two integer arrays arr1 and arr2, and the integer d, return the distance value between the two\u00a0arrays.\nThe distance value is defined as the number of elements arr1[i] such that there is not any element arr2[j] where |arr1[i]-arr2[j]| <= d.\n\u00a0\nExample 1:\nInput: arr1 = [4,5,8], arr2 = [10,9,1,8], d = 2\nOutput: 2\nExplanation: \nFor arr1[0]=4 we have: \n|4-10|=6 > d=2 \n|4-9|=5 > d=2 \n|4-1|=3 > d=2 \n|4-8|=4 > d=2 \nFor arr1[1]=5 we have: \n|5-10|=5 > d=2 \n|5-9|=4 > d=2 \n|5-1|=4 > d=2 \n|5-8|=3 > d=2\nFor arr1[2]=8 we have:\n|8-10|=2 <= d=2\n|8-9|=1 <= d=2\n|8-1|=7 > d=2\n|8-8|=0 <= d=2\n\nExample 2:\nInput: arr1 = [1,4,2,3], arr2 = [-4,-3,6,10,20,30], d = 3\nOutput: 2\n\nExample 3:\nInput: arr1 = [2,1,100,3], arr2 = [-5,-2,10,-3,7], d = 6\nOutput: 1\n\n\u00a0\nConstraints:\n\n1 <= arr1.length, arr2.length <= 500\n-10^3 <= arr1[i], arr2[j] <= 10^3\n0 <= d <= 100.", "raw_solution": "def apps_run1(arr1, arr2, d):\n    count = 0\n    for i in arr1:\n        flag = 0\n        for j in arr2:\n            if abs(i - j) <= d:\n                flag = 1\n                break\n        if flag == 0:\n            count += 1\n    return count", "raw_test_input": ["assert apps_run1([4, 5, 8], [10, 9, 1, 8], 2) == 2", "assert apps_run1([1, 4, 2, 3], [-4, -3, 6, 10, 20, 30], 3) == 2", "assert apps_run1([2, 1, 100, 3], [-5, -2, 10, -3, 7], 6) == 1", "assert apps_run1([1, 2, 3, 4, 5], [10, 20, 30, 40, 50], 5) == 4", "assert apps_run1([10, 20, 30], [1, 2, 3, 4, 5], 10) == 2"], "new_problem": "Write a function that calculates the distance value between two integer arrays arr1 and arr2, given an integer d. The function should handle the following errors: 1. If arr1 or arr2 is empty, raise a ValueError with a message 'Input arrays cannot be empty.' 2. If d is negative, raise a ValueError with a message 'Distance d cannot be negative.' 3. If any element in arr1 or arr2 is not an integer, raise a TypeError with a message 'All elements must be integers.' The function should propagate these errors appropriately and return the distance value if no errors occur.", "new_solution": "from typing import List\n\nclass apps_run2:\n    class DistanceValueError(Exception):\n        pass\n\n    class EmptyArrayError(DistanceValueError):\n        pass\n\n    class NegativeDistanceError(DistanceValueError):\n        pass\n\n    class NonIntegerElementError(DistanceValueError):\n        pass\n\n    def findTheDistanceValue(self, arr1: List[int], arr2: List[int], d: int) -> int:\n        if not arr1 or not arr2:\n            raise self.EmptyArrayError('Input arrays cannot be empty.')\n        if d < 0:\n            raise self.NegativeDistanceError('Distance d cannot be negative.')\n        if not all(isinstance(x, int) for x in arr1 + arr2):\n            raise self.NonIntegerElementError('All elements must be integers.')\n\n        count = 0\n        for i in arr1:\n            flag = 0\n            for j in arr2:\n                if abs(i - j) <= d:\n                    flag = 1\n                    break\n            if flag == 0:\n                count += 1\n        return count", "input_format": "arr1: List[int], arr2: List[int], d: int", "output_format": "int", "test_input": ["assert apps_run2().findTheDistanceValue([4,5,8], [10,9,1,8], 2) == 2", "assert apps_run2().findTheDistanceValue([1,4,2,3], [-4,-3,6,10,20,30], 3) == 2", "assert apps_run2().findTheDistanceValue([2,1,100,3], [-5,-2,10,-3,7], 6) == 1", "try:\n    apps_run2().findTheDistanceValue([], [10,9,1,8], 2)\nexcept apps_run2.EmptyArrayError as e:\n    assert str(e) == 'Input arrays cannot be empty.'", "try:\n    apps_run2().findTheDistanceValue([4,5,8], [10,9,1,8], -1)\nexcept apps_run2.NegativeDistanceError as e:\n    assert str(e) == 'Distance d cannot be negative.'", "try:\n    apps_run2().findTheDistanceValue([4,5,'a'], [10,9,1,8], 2)\nexcept apps_run2.NonIntegerElementError as e:\n    assert str(e) == 'All elements must be integers.'"], "requirement_type": "PROMPT_ERROR_HANDLING"}
{"task_id": "APPS/2513-1", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nFind the nth digit of the infinite integer sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ... \n\nNote:\nn is positive and will fit within the range of a 32-bit signed integer (n < 231).\n\n\nExample 1:\n\nInput:\n3\n\nOutput:\n3\n\n\n\nExample 2:\n\nInput:\n11\n\nOutput:\n0\n\nExplanation:\nThe 11th digit of the sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ... is a 0, which is part of the number 10.", "raw_solution": "def apps_run1(n):\n    i = count = 9\n    while count < n:\n        i *= 10\n        count += i * len(str(i))\n    div, mod = divmod(n - (count - i * len(str(i))), len(str(i)))\n    target = (i // 9 - 1) + div\n    if mod == 0:\n        return int(str(target)[-1])\n    else:\n        return int(str(target + 1)[mod - 1])", "raw_test_input": ["assert apps_run1(3) == 3", "assert apps_run1(11) == 0", "assert apps_run1(15) == 2", "assert apps_run1(19) == 4", "assert apps_run1(1000) == 3"], "new_problem": "In a financial application, you are given a list of positions in the infinite integer sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ... and a corresponding list of weights. Your task is to calculate the weighted sum of the digits at these positions. The weighted sum is calculated by multiplying each digit by its corresponding weight and summing the results. Implement a function that takes two lists as input: one for the positions and one for the weights, and returns the weighted sum of the digits at those positions.", "new_solution": "class apps_run2:\n    def findNthDigit(self, n):\n        i = count = 9\n        while count < n:\n            i *= 10\n            count += i * len(str(i))\n        div, mod = divmod(n - (count - i * len(str(i))), len(str(i)))\n        target = (i // 9 - 1) + div\n        if mod == 0:\n            return int(str(target)[-1])\n        else:\n            return int(str(target + 1)[mod - 1])\n\n    def weightedSumOfDigits(self, positions, weights):\n        total_sum = 0\n        for pos, weight in zip(positions, weights):\n            digit = self.findNthDigit(pos)\n            total_sum += digit * weight\n        return total_sum", "input_format": "A list of positive integers representing positions in the infinite sequence and a list of weights for each position.", "output_format": "A single integer representing the weighted sum of the digits at the specified positions.", "test_input": ["assert apps_run2().weightedSumOfDigits([3, 11, 15], [1, 2, 3]) == 9", "assert apps_run2().weightedSumOfDigits([1, 2, 3], [1, 1, 1]) == 6", "assert apps_run2().weightedSumOfDigits([10, 20, 30], [1, 1, 1]) == 4", "assert apps_run2().weightedSumOfDigits([5, 9, 12], [2, 3, 4]) == 41", "assert apps_run2().weightedSumOfDigits([100, 200, 300], [1, 2, 3]) == 23"], "requirement_type": "PROMPT_SELF_INVOKING"}
{"task_id": "APPS/2513-2", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nFind the nth digit of the infinite integer sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ... \n\nNote:\nn is positive and will fit within the range of a 32-bit signed integer (n < 231).\n\n\nExample 1:\n\nInput:\n3\n\nOutput:\n3\n\n\n\nExample 2:\n\nInput:\n11\n\nOutput:\n0\n\nExplanation:\nThe 11th digit of the sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ... is a 0, which is part of the number 10.", "raw_solution": "def apps_run1(n):\n    i = count = 9\n    while count < n:\n        i *= 10\n        count += i * len(str(i))\n    div, mod = divmod(n - (count - i * len(str(i))), len(str(i)))\n    target = (i // 9 - 1) + div\n    if mod == 0:\n        return int(str(target)[-1])\n    else:\n        return int(str(target + 1)[mod - 1])", "raw_test_input": ["assert apps_run1(3) == 3", "assert apps_run1(11) == 0", "assert apps_run1(15) == 2", "assert apps_run1(19) == 4", "assert apps_run1(1000) == 3"], "new_problem": "Enhance the function to find the nth digit of an infinite integer sequence in any given base, while maintaining backward compatibility with the original base 10 sequence. The function should accept an optional parameter 'base' which defaults to 10. The sequence should be interpreted in the specified base, and the nth digit should be returned in base 10.", "new_solution": "class apps_run2:\n    def findNthDigit(self, n: int, base: int = 10) -> int:\n        i = count = base - 1\n        while count < n:\n            i *= base\n            count += i * len(str(i))\n        div, mod = divmod(n - (count - i * len(str(i))), len(str(i)))\n        target = (i // (base - 1) - 1) + div\n        if mod == 0:\n            return int(str(target)[-1], base)\n        else:\n            return int(str(target + 1)[mod - 1], base)", "input_format": "findNthDigit(n: int, base: int = 10) -> int", "output_format": "int", "test_input": ["assert apps_run2().findNthDigit(3) == 3", "assert apps_run2().findNthDigit(11) == 0", "assert apps_run2().findNthDigit(3) == 3", "assert apps_run2().findNthDigit(11, 16) == 3", "assert apps_run2().findNthDigit(15, 8) == 1"], "requirement_type": "PROMPT_INTERFACE"}
{"task_id": "APPS/2513-3", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nFind the nth digit of the infinite integer sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ... \n\nNote:\nn is positive and will fit within the range of a 32-bit signed integer (n < 231).\n\n\nExample 1:\n\nInput:\n3\n\nOutput:\n3\n\n\n\nExample 2:\n\nInput:\n11\n\nOutput:\n0\n\nExplanation:\nThe 11th digit of the sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ... is a 0, which is part of the number 10.", "raw_solution": "def apps_run1(n):\n    i = count = 9\n    while count < n:\n        i *= 10\n        count += i * len(str(i))\n    div, mod = divmod(n - (count - i * len(str(i))), len(str(i)))\n    target = (i // 9 - 1) + div\n    if mod == 0:\n        return int(str(target)[-1])\n    else:\n        return int(str(target + 1)[mod - 1])", "raw_test_input": ["assert apps_run1(3) == 3", "assert apps_run1(11) == 0", "assert apps_run1(15) == 2", "assert apps_run1(19) == 4", "assert apps_run1(1000) == 3"], "new_problem": "Given a list of positions, find the corresponding digits in the infinite integer sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ... Use a dictionary to store the results for each position. The function should handle up to 1000 positions in a single call and return a dictionary with the results. Each position is a positive integer and will fit within the range of a 32-bit signed integer (n < 2^31).", "new_solution": "from typing import List, Dict\n\nclass apps_run2:\n    def findNthDigit(self, n: int) -> int:\n        i = count = 9\n        while count < n:\n            i *= 10\n            count += i * len(str(i))\n        div, mod = divmod(n - (count - i * len(str(i))), len(str(i)))\n        target = (i // 9 - 1) + div\n        if mod == 0:\n            return int(str(target)[-1])\n        else:\n            return int(str(target + 1)[mod - 1])\n\n    def findDigitsAtPositions(self, positions: List[int]) -> Dict[int, int]:\n        result = {}\n        for pos in positions:\n            result[pos] = self.findNthDigit(pos)\n        return result", "input_format": "A list of integers representing the positions of digits in the infinite sequence.", "output_format": "A dictionary where keys are the input positions and values are the corresponding digits.", "test_input": ["assert apps_run2().findDigitsAtPositions([3, 11, 15, 20, 25]) == {3: 3, 11: 0, 15: 2, 20: 1, 25: 7}", "assert apps_run2().findDigitsAtPositions([1, 2, 10, 100, 1000]) == {1: 1, 2: 2, 10: 1, 100: 5, 1000: 3}", "assert apps_run2().findDigitsAtPositions([5, 50, 500, 5000, 50000]) == {5: 5, 50: 3, 500: 0, 5000: 2, 50000: 1}", "assert apps_run2().findDigitsAtPositions([9, 19, 29, 39, 49]) == {9: 9, 19: 4, 29: 9, 39: 4, 49: 9}", "assert apps_run2().findDigitsAtPositions([100, 200, 300, 400, 500]) == {100: 5, 200: 0, 300: 6, 400: 1, 500: 0}"], "requirement_type": "PROMPT_DATA_STRUCTURE"}
{"task_id": "APPS/2513-4", "raw_problem": "Please write a function to solve the following problem and and no need to receive input from the keyboard.\n\nFind the nth digit of the infinite integer sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ... \n\nNote:\nn is positive and will fit within the range of a 32-bit signed integer (n < 231).\n\n\nExample 1:\n\nInput:\n3\n\nOutput:\n3\n\n\n\nExample 2:\n\nInput:\n11\n\nOutput:\n0\n\nExplanation:\nThe 11th digit of the sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ... is a 0, which is part of the number 10.", "raw_solution": "def apps_run1(n):\n    i = count = 9\n    while count < n:\n        i *= 10\n        count += i * len(str(i))\n    div, mod = divmod(n - (count - i * len(str(i))), len(str(i)))\n    target = (i // 9 - 1) + div\n    if mod == 0:\n        return int(str(target)[-1])\n    else:\n        return int(str(target + 1)[mod - 1])", "raw_test_input": ["assert apps_run1(3) == 3", "assert apps_run1(11) == 0", "assert apps_run1(15) == 2", "assert apps_run1(19) == 4", "assert apps_run1(1000) == 3"], "new_problem": "Write a function to find the nth digit of the infinite integer sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ... with error handling. The function should handle the following errors: 1) Invalid input type: If the input is not an integer, raise a TypeError with a meaningful message. 2) Out of range: If the input is not a positive integer or exceeds the maximum allowed value (2^31 - 1), raise a ValueError with a meaningful message. 3) Internal calculation errors: If any unexpected error occurs during the calculation, raise a RuntimeError with a message indicating an internal error. Ensure that the function propagates these errors appropriately.", "new_solution": "class apps_run2:\n    def findNthDigit(self, n: int) -> int:\n        if not isinstance(n, int):\n            raise TypeError('Input must be an integer.')\n        if n <= 0 or n >= 2**31:\n            raise ValueError('Input must be a positive integer less than 2^31.')\n        try:\n            i = count = 9\n            while count < n:\n                i *= 10\n                count += i * len(str(i))\n            div, mod = divmod(n - (count - i * len(str(i))), len(str(i)))\n            target = (i // 9 - 1) + div\n            if mod == 0:\n                return int(str(target)[-1])\n            else:\n                return int(str(target + 1)[mod - 1])\n        except Exception as e:\n            raise RuntimeError('An internal error occurred during calculation.') from e", "input_format": "An integer n representing the position in the infinite sequence.", "output_format": "An integer representing the nth digit in the sequence.", "test_input": ["assert apps_run2().findNthDigit(3) == 3", "assert apps_run2().findNthDigit(11) == 0", "try:\n    apps_run2().findNthDigit('a')\nexcept TypeError as e:\n    assert str(e) == 'Input must be an integer.'", "try:\n    apps_run2().findNthDigit(-1)\nexcept ValueError as e:\n    assert str(e) == 'Input must be a positive integer less than 2^31.'", "try:\n    apps_run2().findNthDigit(2**31)\nexcept ValueError as e:\n    assert str(e) == 'Input must be a positive integer less than 2^31.'"], "requirement_type": "PROMPT_ERROR_HANDLING"}
